#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: EditableMesh

#include "Basic.hpp"

#include "EditableMesh_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class EditableMesh.EditableMeshAdapter
// 0x0000 (0x0028 - 0x0028)
class UEditableMeshAdapter : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditableMeshAdapter">();
	}
	static class UEditableMeshAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditableMeshAdapter>();
	}
};
static_assert(alignof(UEditableMeshAdapter) == 0x000008, "Wrong alignment on UEditableMeshAdapter");
static_assert(sizeof(UEditableMeshAdapter) == 0x000028, "Wrong size on UEditableMeshAdapter");

// Class EditableMesh.EditableGeometryCollectionAdapter
// 0x00B0 (0x00D8 - 0x0028)
class UEditableGeometryCollectionAdapter final  : public UEditableMeshAdapter
{
public:
	class UGeometryCollection*                    GeometryCollection;                                // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGeometryCollection*                    OriginalGeometryCollection;                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GeometryCollectionLODIndex;                        // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1282[0x9C];                                    // 0x003C(0x009C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditableGeometryCollectionAdapter">();
	}
	static class UEditableGeometryCollectionAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditableGeometryCollectionAdapter>();
	}
};
static_assert(alignof(UEditableGeometryCollectionAdapter) == 0x000008, "Wrong alignment on UEditableGeometryCollectionAdapter");
static_assert(sizeof(UEditableGeometryCollectionAdapter) == 0x0000D8, "Wrong size on UEditableGeometryCollectionAdapter");
static_assert(offsetof(UEditableGeometryCollectionAdapter, GeometryCollection) == 0x000028, "Member 'UEditableGeometryCollectionAdapter::GeometryCollection' has a wrong offset!");
static_assert(offsetof(UEditableGeometryCollectionAdapter, OriginalGeometryCollection) == 0x000030, "Member 'UEditableGeometryCollectionAdapter::OriginalGeometryCollection' has a wrong offset!");
static_assert(offsetof(UEditableGeometryCollectionAdapter, GeometryCollectionLODIndex) == 0x000038, "Member 'UEditableGeometryCollectionAdapter::GeometryCollectionLODIndex' has a wrong offset!");

// Class EditableMesh.EditableMesh
// 0x06E0 (0x0708 - 0x0028)
class UEditableMesh final  : public UObject
{
public:
	uint8                                         Pad_1283[0x390];                                   // 0x0028(0x0390)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEditableMeshAdapter*>           Adapters;                                          // 0x03B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1284[0x8];                                     // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TextureCoordinateCount;                            // 0x03D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1285[0x148];                                   // 0x03D4(0x0148)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PendingCompactCounter;                             // 0x051C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubdivisionCount;                                  // 0x0520(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1286[0x1E4];                                   // 0x0524(0x01E4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FEdgeID InvalidEdgeID();
	static struct FPolygonGroupID InvalidPolygonGroupID();
	static struct FPolygonID InvalidPolygonID();
	static struct FVertexID InvalidVertexID();
	static struct FEdgeID MakeEdgeID(int32 EdgeIndex);
	static struct FPolygonGroupID MakePolygonGroupID(int32 PolygonGroupIndex);
	static struct FPolygonID MakePolygonID(int32 PolygonIndex);
	static struct FVertexID MakeVertexID(int32 VertexIndex);

	void AssignPolygonsToPolygonGroups(TArray<struct FPolygonGroupForPolygon>& PolygonGroupForPolygons, bool bDeleteOrphanedPolygonGroups);
	void BevelPolygons(TArray<struct FPolygonID>& PolygonIDs, float BevelFixedDistance, float BevelProgressTowardCenter, TArray<struct FPolygonID>* OutNewCenterPolygonIDs, TArray<struct FPolygonID>* OutNewSidePolygonIDs);
	void ChangePolygonsVertexInstances(TArray<struct FChangeVertexInstancesForPolygon>& VertexInstancesForPolygons);
	void Commit();
	class UEditableMesh* CommitInstance(class UPrimitiveComponent* ComponentToInstanceTo);
	void CreateEdges(TArray<struct FEdgeToCreate>& EdgesToCreate, TArray<struct FEdgeID>* OutNewEdgeIDs);
	void CreateEmptyVertexRange(int32 NumVerticesToCreate, TArray<struct FVertexID>* OutNewVertexIDs);
	void CreateMissingPolygonPerimeterEdges(struct FPolygonID& PolygonID, TArray<struct FEdgeID>* OutNewEdgeIDs);
	void CreatePolygonGroups(TArray<struct FPolygonGroupToCreate>& PolygonGroupsToCreate, TArray<struct FPolygonGroupID>* OutNewPolygonGroupIDs);
	void CreatePolygons(TArray<struct FPolygonToCreate>& PolygonsToCreate, TArray<struct FPolygonID>* OutNewPolygonIDs, TArray<struct FEdgeID>* OutNewEdgeIDs);
	void CreateVertexInstances(TArray<struct FVertexInstanceToCreate>& VertexInstancesToCreate, TArray<struct FVertexInstanceID>* OutNewVertexInstanceIDs);
	void CreateVertices(TArray<struct FVertexToCreate>& VerticesToCreate, TArray<struct FVertexID>* OutNewVertexIDs);
	void DeleteEdgeAndConnectedPolygons(struct FEdgeID& EdgeID, bool bDeleteOrphanedEdges, bool bDeleteOrphanedVertices, bool bDeleteOrphanedVertexInstances, bool bDeleteEmptyPolygonGroups);
	void DeleteEdges(TArray<struct FEdgeID>& EdgeIDsToDelete, bool bDeleteOrphanedVertices);
	void DeleteOrphanVertices(TArray<struct FVertexID>& VertexIDsToDelete);
	void DeletePolygonGroups(TArray<struct FPolygonGroupID>& PolygonGroupIDs);
	void DeletePolygons(TArray<struct FPolygonID>& PolygonIDsToDelete, bool bDeleteOrphanedEdges, bool bDeleteOrphanedVertices, bool bDeleteOrphanedVertexInstances, bool bDeleteEmptyPolygonGroups);
	void DeleteVertexAndConnectedEdgesAndPolygons(struct FVertexID& VertexID, bool bDeleteOrphanedEdges, bool bDeleteOrphanedVertices, bool bDeleteOrphanedVertexInstances, bool bDeleteEmptyPolygonGroups);
	void DeleteVertexInstances(TArray<struct FVertexInstanceID>& VertexInstanceIDsToDelete, bool bDeleteOrphanedVertices);
	void EndModification(bool bFromUndo);
	void ExtendEdges(TArray<struct FEdgeID>& EdgeIDs, bool bWeldNeighbors, TArray<struct FEdgeID>* OutNewExtendedEdgeIDs);
	void ExtendVertices(TArray<struct FVertexID>& VertexIDs, bool bOnlyExtendClosestEdge, struct FVector& ReferencePosition, TArray<struct FVertexID>* OutNewExtendedVertexIDs);
	void ExtrudePolygons(TArray<struct FPolygonID>& Polygons, float ExtrudeDistance, bool bKeepNeighborsTogether, TArray<struct FPolygonID>* OutNewExtrudedFrontPolygons);
	void FlipPolygons(TArray<struct FPolygonID>& PolygonIDs);
	void GeneratePolygonTangentsAndNormals(TArray<struct FPolygonID>& PolygonIDs);
	void InitializeAdapters();
	void InsertEdgeLoop(struct FEdgeID& EdgeID, TArray<float>& Splits, TArray<struct FEdgeID>* OutNewEdgeIDs);
	void InsetPolygons(TArray<struct FPolygonID>& PolygonIDs, float InsetFixedDistance, float InsetProgressTowardCenter, EInsetPolygonsMode Mode, TArray<struct FPolygonID>* OutNewCenterPolygonIDs, TArray<struct FPolygonID>* OutNewSidePolygonIDs);
	void MoveVertices(TArray<struct FVertexToMove>& VerticesToMove);
	void PropagateInstanceChanges();
	void QuadrangulateMesh(TArray<struct FPolygonID>* OutNewPolygonIDs);
	void RebuildRenderMesh();
	void Revert();
	class UEditableMesh* RevertInstance();
	void SetAllowCompact(bool bInAllowCompact);
	void SetAllowSpatialDatabase(bool bInAllowSpatialDatabase);
	void SetAllowUndo(bool bInAllowUndo);
	void SetEdgesAttributes(TArray<struct FAttributesForEdge>& AttributesForEdges);
	void SetEdgesCreaseSharpness(TArray<struct FEdgeID>& EdgeIDs, TArray<float>& EdgesNewCreaseSharpness);
	void SetEdgesHardness(TArray<struct FEdgeID>& EdgeIDs, TArray<bool>& EdgesNewIsHard);
	void SetEdgesHardnessAutomatically(TArray<struct FEdgeID>& EdgeIDs, float MaxDotProductForSoftEdge);
	void SetPolygonsVertexAttributes(TArray<struct FVertexAttributesForPolygon>& VertexAttributesForPolygons);
	void SetSubdivisionCount(int32 NewSubdivisionCount);
	void SetTextureCoordinateCount(int32 NumTexCoords);
	void SetVertexInstancesAttributes(TArray<struct FAttributesForVertexInstance>& AttributesForVertexInstances);
	void SetVerticesAttributes(TArray<struct FAttributesForVertex>& AttributesForVertices);
	void SetVerticesCornerSharpness(TArray<struct FVertexID>& VertexIDs, TArray<float>& VerticesNewCornerSharpness);
	void SplitEdge(struct FEdgeID& EdgeID, TArray<float>& Splits, TArray<struct FVertexID>* OutNewVertexIDs);
	void SplitPolygonalMesh(struct FPlane& InPlane, TArray<struct FPolygonID>* PolygonIDs1, TArray<struct FPolygonID>* PolygonIDs2, TArray<struct FEdgeID>* BoundaryIDs);
	void SplitPolygons(TArray<struct FPolygonToSplit>& PolygonsToSplit, TArray<struct FEdgeID>* OutNewEdgeIDs);
	void StartModification(EMeshModificationType MeshModificationType, EMeshTopologyChange MeshTopologyChange);
	void TessellatePolygons(TArray<struct FPolygonID>& PolygonIDs, ETriangleTessellationMode TriangleTessellationMode, TArray<struct FPolygonID>* OutNewPolygonIDs);
	void TriangulatePolygons(TArray<struct FPolygonID>& PolygonIDs, TArray<struct FPolygonID>* OutNewTrianglePolygons);
	void TryToRemovePolygonEdge(struct FEdgeID& EdgeID, bool* bOutWasEdgeRemoved, struct FPolygonID* OutNewPolygonID);
	void TryToRemoveVertex(struct FVertexID& VertexID, bool* bOutWasVertexRemoved, struct FEdgeID* OutNewEdgeID);
	void WeldVertices(TArray<struct FVertexID>& VertexIDs, struct FVertexID* OutNewVertexID);

	bool AnyChangesToUndo() const;
	struct FBox ComputeBoundingBox() const;
	struct FBoxSphereBounds ComputeBoundingBoxAndSphere() const;
	struct FVector ComputePolygonCenter(struct FPolygonID& PolygonID) const;
	struct FVector ComputePolygonNormal(struct FPolygonID& PolygonID) const;
	struct FPlane ComputePolygonPlane(struct FPolygonID& PolygonID) const;
	void ComputePolygonsSharedEdges(TArray<struct FPolygonID>& PolygonIDs, TArray<struct FEdgeID>* OutSharedEdgeIDs) const;
	void FindPolygonLoop(struct FEdgeID& EdgeID, TArray<struct FEdgeID>* OutEdgeLoopEdgeIDs, TArray<struct FEdgeID>* OutFlippedEdgeIDs, TArray<struct FEdgeID>* OutReversedEdgeIDPathToTake, TArray<struct FPolygonID>* OutPolygonIDsToSplit) const;
	int32 FindPolygonPerimeterEdgeNumberForVertices(struct FPolygonID& PolygonID, struct FVertexID& EdgeVertexID0, struct FVertexID& EdgeVertexID1) const;
	int32 FindPolygonPerimeterVertexNumberForVertex(struct FPolygonID& PolygonID, struct FVertexID& VertexID) const;
	struct FPolygonID GetEdgeConnectedPolygon(struct FEdgeID& EdgeID, int32 ConnectedPolygonNumber) const;
	int32 GetEdgeConnectedPolygonCount(struct FEdgeID& EdgeID) const;
	void GetEdgeConnectedPolygons(struct FEdgeID& EdgeID, TArray<struct FPolygonID>* OutConnectedPolygonIDs) const;
	int32 GetEdgeCount() const;
	void GetEdgeLoopElements(struct FEdgeID& EdgeID, TArray<struct FEdgeID>* EdgeLoopIDs) const;
	struct FEdgeID GetEdgeThatConnectsVertices(struct FVertexID& VertexID0, struct FVertexID& VertexID1) const;
	struct FVertexID GetEdgeVertex(struct FEdgeID& EdgeID, int32 EdgeVertexNumber) const;
	void GetEdgeVertices(struct FEdgeID& EdgeID, struct FVertexID* OutEdgeVertexID0, struct FVertexID* OutEdgeVertexID1) const;
	struct FPolygonGroupID GetFirstValidPolygonGroup() const;
	struct FPolygonGroupID GetGroupForPolygon(struct FPolygonID& PolygonID) const;
	void GetPolygonAdjacentPolygons(struct FPolygonID& PolygonID, TArray<struct FPolygonID>* OutAdjacentPolygons) const;
	int32 GetPolygonCount() const;
	int32 GetPolygonCountInGroup(struct FPolygonGroupID& PolygonGroupID) const;
	int32 GetPolygonGroupCount() const;
	struct FPolygonID GetPolygonInGroup(struct FPolygonGroupID& PolygonGroupID, int32 PolygonNumber) const;
	struct FEdgeID GetPolygonPerimeterEdge(struct FPolygonID& PolygonID, int32 PerimeterEdgeNumber, bool* bOutEdgeWindingIsReversedForPolygon) const;
	int32 GetPolygonPerimeterEdgeCount(struct FPolygonID& PolygonID) const;
	void GetPolygonPerimeterEdges(struct FPolygonID& PolygonID, TArray<struct FEdgeID>* OutPolygonPerimeterEdgeIDs) const;
	struct FVertexID GetPolygonPerimeterVertex(struct FPolygonID& PolygonID, int32 PolygonVertexNumber) const;
	int32 GetPolygonPerimeterVertexCount(struct FPolygonID& PolygonID) const;
	struct FVertexInstanceID GetPolygonPerimeterVertexInstance(struct FPolygonID& PolygonID, int32 PolygonVertexNumber) const;
	void GetPolygonPerimeterVertexInstances(struct FPolygonID& PolygonID, TArray<struct FVertexInstanceID>* OutPolygonPerimeterVertexInstanceIDs) const;
	void GetPolygonPerimeterVertices(struct FPolygonID& PolygonID, TArray<struct FVertexID>* OutPolygonPerimeterVertexIDs) const;
	struct FTriangleID GetPolygonTriangulatedTriangle(struct FPolygonID& PolygonID, int32 PolygonTriangleNumber) const;
	int32 GetPolygonTriangulatedTriangleCount(struct FPolygonID& PolygonID) const;
	int32 GetSubdivisionCount() const;
	const struct FSubdivisionLimitData GetSubdivisionLimitData() const;
	int32 GetTextureCoordinateCount() const;
	void GetVertexAdjacentVertices(struct FVertexID& VertexID, TArray<struct FVertexID>* OutAdjacentVertexIDs) const;
	struct FEdgeID GetVertexConnectedEdge(struct FVertexID& VertexID, int32 ConnectedEdgeNumber) const;
	int32 GetVertexConnectedEdgeCount(struct FVertexID& VertexID) const;
	void GetVertexConnectedEdges(struct FVertexID& VertexID, TArray<struct FEdgeID>* OutConnectedEdgeIDs) const;
	void GetVertexConnectedPolygons(struct FVertexID& VertexID, TArray<struct FPolygonID>* OutConnectedPolygonIDs) const;
	int32 GetVertexCount() const;
	struct FPolygonID GetVertexInstanceConnectedPolygon(struct FVertexInstanceID& VertexInstanceID, int32 ConnectedPolygonNumber) const;
	int32 GetVertexInstanceConnectedPolygonCount(struct FVertexInstanceID& VertexInstanceID) const;
	void GetVertexInstanceConnectedPolygons(struct FVertexInstanceID& VertexInstanceID, TArray<struct FPolygonID>* OutConnectedPolygonIDs) const;
	int32 GetVertexInstanceCount() const;
	struct FVertexID GetVertexInstanceVertex(struct FVertexInstanceID& VertexInstanceID) const;
	struct FEdgeID GetVertexPairEdge(struct FVertexID& VertexID, struct FVertexID& NextVertexID, bool* bOutEdgeWindingIsReversed) const;
	bool IsBeingModified() const;
	bool IsCommitted() const;
	bool IsCommittedAsInstance() const;
	bool IsCompactAllowed() const;
	bool IsOrphanedVertex(struct FVertexID& VertexID) const;
	bool IsPreviewingSubdivisions() const;
	bool IsSpatialDatabaseAllowed() const;
	bool IsUndoAllowed() const;
	bool IsValidEdge(struct FEdgeID& EdgeID) const;
	bool IsValidPolygon(struct FPolygonID& PolygonID) const;
	bool IsValidPolygonGroup(struct FPolygonGroupID& PolygonGroupID) const;
	bool IsValidVertex(struct FVertexID& VertexID) const;
	void SearchSpatialDatabaseForPolygonsInVolume(TArray<struct FPlane>& Planes, TArray<struct FPolygonID>* OutPolygons) const;
	void SearchSpatialDatabaseForPolygonsPotentiallyIntersectingLineSegment(struct FVector& LineSegmentStart, struct FVector& LineSegmentEnd, TArray<struct FPolygonID>* OutPolygons) const;
	void SearchSpatialDatabaseForPolygonsPotentiallyIntersectingPlane(struct FPlane& InPlane, TArray<struct FPolygonID>* OutPolygons) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditableMesh">();
	}
	static class UEditableMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditableMesh>();
	}
};
static_assert(alignof(UEditableMesh) == 0x000008, "Wrong alignment on UEditableMesh");
static_assert(sizeof(UEditableMesh) == 0x000708, "Wrong size on UEditableMesh");
static_assert(offsetof(UEditableMesh, Adapters) == 0x0003B8, "Member 'UEditableMesh::Adapters' has a wrong offset!");
static_assert(offsetof(UEditableMesh, TextureCoordinateCount) == 0x0003D0, "Member 'UEditableMesh::TextureCoordinateCount' has a wrong offset!");
static_assert(offsetof(UEditableMesh, PendingCompactCounter) == 0x00051C, "Member 'UEditableMesh::PendingCompactCounter' has a wrong offset!");
static_assert(offsetof(UEditableMesh, SubdivisionCount) == 0x000520, "Member 'UEditableMesh::SubdivisionCount' has a wrong offset!");

// Class EditableMesh.EditableMeshFactory
// 0x0000 (0x0028 - 0x0028)
class UEditableMeshFactory final  : public UObject
{
public:
	static class UEditableMesh* MakeEditableMesh(class UPrimitiveComponent* PrimitiveComponent, int32 LODIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditableMeshFactory">();
	}
	static class UEditableMeshFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditableMeshFactory>();
	}
};
static_assert(alignof(UEditableMeshFactory) == 0x000008, "Wrong alignment on UEditableMeshFactory");
static_assert(sizeof(UEditableMeshFactory) == 0x000028, "Wrong size on UEditableMeshFactory");

// Class EditableMesh.EditableStaticMeshAdapter
// 0x00B8 (0x00E0 - 0x0028)
class UEditableStaticMeshAdapter final  : public UEditableMeshAdapter
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            OriginalStaticMesh;                                // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         StaticMeshLODIndex;                                // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12AC[0xA4];                                    // 0x003C(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditableStaticMeshAdapter">();
	}
	static class UEditableStaticMeshAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditableStaticMeshAdapter>();
	}
};
static_assert(alignof(UEditableStaticMeshAdapter) == 0x000008, "Wrong alignment on UEditableStaticMeshAdapter");
static_assert(sizeof(UEditableStaticMeshAdapter) == 0x0000E0, "Wrong size on UEditableStaticMeshAdapter");
static_assert(offsetof(UEditableStaticMeshAdapter, StaticMesh) == 0x000028, "Member 'UEditableStaticMeshAdapter::StaticMesh' has a wrong offset!");
static_assert(offsetof(UEditableStaticMeshAdapter, OriginalStaticMesh) == 0x000030, "Member 'UEditableStaticMeshAdapter::OriginalStaticMesh' has a wrong offset!");
static_assert(offsetof(UEditableStaticMeshAdapter, StaticMeshLODIndex) == 0x000038, "Member 'UEditableStaticMeshAdapter::StaticMeshLODIndex' has a wrong offset!");

}

