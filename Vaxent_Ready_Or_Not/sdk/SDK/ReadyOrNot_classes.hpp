#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ReadyOrNot

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "ReadyOrNot_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_classes.hpp"
#include "CommonUI_classes.hpp"
#include "AdvancedSessions_classes.hpp"
#include "LevelSequence_classes.hpp"
#include "ObjectPooler_classes.hpp"
#include "SlateCore_structs.hpp"
#include "InputCore_structs.hpp"
#include "DynamicCoverSystem_structs.hpp"
#include "DynamicCoverSystem_classes.hpp"
#include "FMODStudio_structs.hpp"
#include "FMODStudio_classes.hpp"
#include "CommonInput_structs.hpp"
#include "InputRemapping_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "PhysicsCore_structs.hpp"
#include "PhysicsCore_classes.hpp"
#include "VivoxCore_structs.hpp"
#include "Gauntlet_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "Zeuzsdk_structs.hpp"


namespace SDK
{

// Class ReadyOrNot.AnimNotify_DoorKickBreak
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_DoorKickBreak final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DoorKickBreak">();
	}
	static class UAnimNotify_DoorKickBreak* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DoorKickBreak>();
	}
};
static_assert(alignof(UAnimNotify_DoorKickBreak) == 0x000008, "Wrong alignment on UAnimNotify_DoorKickBreak");
static_assert(sizeof(UAnimNotify_DoorKickBreak) == 0x000038, "Wrong size on UAnimNotify_DoorKickBreak");

// Class ReadyOrNot.ReadyOrNotGameMode
// 0x04B0 (0x0770 - 0x02C0)
class alignas(0x10) AReadyOrNotGameMode : public AGameModeBase
{
public:
	uint8                                         Pad_2012[0x58];                                    // 0x02C0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    GameModeSettings;                                  // 0x0318(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2013[0x60];                                    // 0x0328(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AReadyOrNotCharacter*, int32>      AbuseCountMap;                                     // 0x0388(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsCampaignTransitioning;                          // 0x03D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2014[0x7];                                     // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           Reinforcement_Handle;                              // 0x03E0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunWarmup;                                        // 0x03E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArrestSpectator;                                  // 0x03E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowLoadouts;                                    // 0x03EA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2015[0x1];                                     // 0x03EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPlayersAllowed;                                 // 0x03EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabledForPlay;                                   // 0x03F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2016[0x7];                                     // 0x03F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UrlShortName;                                      // 0x03F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Password;                                          // 0x0408(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     PlayerStartClass;                                  // 0x0418(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASpectatePawn>              DeadSpectatorClass;                                // 0x0420(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LobbyStartTag;                                     // 0x0428(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RedCustomizationStartTag;                          // 0x0430(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BlueCustomizationStartTag;                         // 0x0438(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SWATBlueStartTag;                                  // 0x0440(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SWATRedStartTag;                                   // 0x0448(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SuspectStartTag;                                   // 0x0450(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpectateKillerOnDeath;                            // 0x0458(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialPlayerRespawn;                             // 0x0459(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDrawPlayerCameraSphere : 1;                       // 0x045A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2017[0x5];                                     // 0x045B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMatchStarted;                                    // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ERespawnMode                                  RespawnMode;                                       // 0x0470(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2018[0x1];                                     // 0x0471(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTimelimitUsedInMode;                              // 0x0472(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchState                                   CurrentMatchState;                                 // 0x0473(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2019[0x4];                                     // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMatchStateChanged;                               // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_201A[0x8];                                     // 0x0488(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedLoadout                          DefaultLoadoutIfNothingLoaded;                     // 0x0490(0x0188)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_201B[0x8];                                     // 0x0618(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ModeName;                                          // 0x0620(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ModeDescription;                                   // 0x0638(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bCanRespawn;                                       // 0x0650(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201C[0x3];                                     // 0x0651(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumPlayersToStart;                             // 0x0654(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumPlayersForTimer;                            // 0x0658(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201D[0x4];                                     // 0x065C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   BlueCharacterClass;                                // 0x0660(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   RedCharacterClass;                                 // 0x0688(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201E[0x40];                                    // 0x06B0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerController*>              DeadPlayers;                                       // 0x06F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class APlayerController*>              RespawnableDeadPlayers;                            // 0x0700(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 PlayerSpawnTag;                                    // 0x0710(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerRespawned;                                 // 0x0720(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                CharacterHUD;                                      // 0x0730(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASpectatorPawn>             NormalSpectatorPawn;                               // 0x0738(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMissionPlanManager*                    MissionPlanManager;                                // 0x0740(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMissionExfiltrated;                               // 0x0748(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExfilEnabled;                                   // 0x0749(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201F[0x26];                                    // 0x074A(0x0026)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AddAbuse(class AReadyOrNotCharacter* Abuser, class ACyberneticCharacter* Abused);

	bool AreAllPlayersDead();
	void CheckToAnnounceTeamkill(class ACharacter* InstigatorCharacter, class ACharacter* KilledCharacter);
	bool DoesLevelRequireGeneration();
	void ExfiltrateMission(const TArray<class ASWATCharacter*>& ExfilCharacters);
	bool GetIsExfilEnabled();
	EMatchState GetMatchState();
	class AReadyOrNotGameSession* GetReadyOrNotGameSession();
	class AReadyOrNotGameState* GetReadyOrNotGameState();
	class AActor* GetThisPlayersStartPointByTag(class APlayerController* Player, const class FString& IncomingName);
	bool IsTeamDead(ETeamType Team, bool bIncludeArrestedAsDead);
	bool KickPlayer(class APlayerController* KickedPlayer, class FText& KickReason);
	void NextGame();
	void OnBanStatusChecked(const class FString& SteamId, bool bIsBanned, const class FString& BanReason, bool bIsMySteamId);
	void OnExfilEnabledChange__DelegateSignature(bool bEnabled);
	void OnExfiltrateMission__DelegateSignature();
	void OnMatchStarted__DelegateSignature();
	void OnMatchStateChanged__DelegateSignature(EMatchState NewMatchState);
	void OnOutOfBoundsTimeLimitEnded();
	void OnPlayerRespawned__DelegateSignature(class APawn* Pawn, class APlayerController* Controller);
	void PlayerArrested(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void PlayerDowned(class AReadyOrNotCharacter* DownedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void PlayerFreed(class ACharacter* Freed, class ACharacter* Freer);
	void PlayerKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void PlayerTakenDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void ProcessServerTravel(const class FString& URL, bool bAbsolute);
	void RefreshSession();
	bool RemoveDeadPlayer(class APlayerController* InPlayerController);
	bool RemoveDeadPlayerAt(int32 Param_Index);
	void RespawnAllPlayers();
	void RespawnAllPlayersOnTeam(ETeamType Team);
	void RespawnDeadPlayers();
	void RespawnDeadPlayersOnTeam(ETeamType Team);
	void RespawnPlayer(class APlayerController* Player, bool bForceSpectator);
	void RestartGame();
	void SetExfilEnabled(bool bEnabled);
	void SetMatchState(EMatchState NewMatchState);
	void SetPassword(const class FString& NewPassword);
	bool ShouldCountDownTimelimitNow();
	class APlayerCharacter* SpawnPlayerCharacter(class APlayerController* Controller, TSubclassOf<class APlayerCharacter> Param_Class, const struct FTransform& SpawnTransform);
	class ASpectatorPawn* SpawnSpectator(class APlayerController* Controller, TSubclassOf<class ASpectatorPawn> Param_Class, const struct FTransform& SpawnTransform);
	void StartMatch();
	void SwapPlayerTeams();

	TArray<class APlayerCharacter*> GetAllPlayerCharactersInWorld() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotGameMode">();
	}
	static class AReadyOrNotGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotGameMode>();
	}
};
static_assert(alignof(AReadyOrNotGameMode) == 0x000010, "Wrong alignment on AReadyOrNotGameMode");
static_assert(sizeof(AReadyOrNotGameMode) == 0x000770, "Wrong size on AReadyOrNotGameMode");
static_assert(offsetof(AReadyOrNotGameMode, GameModeSettings) == 0x000318, "Member 'AReadyOrNotGameMode::GameModeSettings' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, AbuseCountMap) == 0x000388, "Member 'AReadyOrNotGameMode::AbuseCountMap' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bIsCampaignTransitioning) == 0x0003D8, "Member 'AReadyOrNotGameMode::bIsCampaignTransitioning' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, Reinforcement_Handle) == 0x0003E0, "Member 'AReadyOrNotGameMode::Reinforcement_Handle' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bRunWarmup) == 0x0003E8, "Member 'AReadyOrNotGameMode::bRunWarmup' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bArrestSpectator) == 0x0003E9, "Member 'AReadyOrNotGameMode::bArrestSpectator' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bAllowLoadouts) == 0x0003EA, "Member 'AReadyOrNotGameMode::bAllowLoadouts' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, MaxPlayersAllowed) == 0x0003EC, "Member 'AReadyOrNotGameMode::MaxPlayersAllowed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bEnabledForPlay) == 0x0003F0, "Member 'AReadyOrNotGameMode::bEnabledForPlay' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, UrlShortName) == 0x0003F8, "Member 'AReadyOrNotGameMode::UrlShortName' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, Password) == 0x000408, "Member 'AReadyOrNotGameMode::Password' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, PlayerStartClass) == 0x000418, "Member 'AReadyOrNotGameMode::PlayerStartClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, DeadSpectatorClass) == 0x000420, "Member 'AReadyOrNotGameMode::DeadSpectatorClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, LobbyStartTag) == 0x000428, "Member 'AReadyOrNotGameMode::LobbyStartTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, RedCustomizationStartTag) == 0x000430, "Member 'AReadyOrNotGameMode::RedCustomizationStartTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, BlueCustomizationStartTag) == 0x000438, "Member 'AReadyOrNotGameMode::BlueCustomizationStartTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, SWATBlueStartTag) == 0x000440, "Member 'AReadyOrNotGameMode::SWATBlueStartTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, SWATRedStartTag) == 0x000448, "Member 'AReadyOrNotGameMode::SWATRedStartTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, SuspectStartTag) == 0x000450, "Member 'AReadyOrNotGameMode::SuspectStartTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bSpectateKillerOnDeath) == 0x000458, "Member 'AReadyOrNotGameMode::bSpectateKillerOnDeath' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bInitialPlayerRespawn) == 0x000459, "Member 'AReadyOrNotGameMode::bInitialPlayerRespawn' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, OnMatchStarted) == 0x000460, "Member 'AReadyOrNotGameMode::OnMatchStarted' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, RespawnMode) == 0x000470, "Member 'AReadyOrNotGameMode::RespawnMode' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bTimelimitUsedInMode) == 0x000472, "Member 'AReadyOrNotGameMode::bTimelimitUsedInMode' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, CurrentMatchState) == 0x000473, "Member 'AReadyOrNotGameMode::CurrentMatchState' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, OnMatchStateChanged) == 0x000478, "Member 'AReadyOrNotGameMode::OnMatchStateChanged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, DefaultLoadoutIfNothingLoaded) == 0x000490, "Member 'AReadyOrNotGameMode::DefaultLoadoutIfNothingLoaded' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, ModeName) == 0x000620, "Member 'AReadyOrNotGameMode::ModeName' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, ModeDescription) == 0x000638, "Member 'AReadyOrNotGameMode::ModeDescription' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bCanRespawn) == 0x000650, "Member 'AReadyOrNotGameMode::bCanRespawn' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, MinimumPlayersToStart) == 0x000654, "Member 'AReadyOrNotGameMode::MinimumPlayersToStart' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, MinimumPlayersForTimer) == 0x000658, "Member 'AReadyOrNotGameMode::MinimumPlayersForTimer' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, BlueCharacterClass) == 0x000660, "Member 'AReadyOrNotGameMode::BlueCharacterClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, RedCharacterClass) == 0x000688, "Member 'AReadyOrNotGameMode::RedCharacterClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, DeadPlayers) == 0x0006F0, "Member 'AReadyOrNotGameMode::DeadPlayers' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, RespawnableDeadPlayers) == 0x000700, "Member 'AReadyOrNotGameMode::RespawnableDeadPlayers' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, PlayerSpawnTag) == 0x000710, "Member 'AReadyOrNotGameMode::PlayerSpawnTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, OnPlayerRespawned) == 0x000720, "Member 'AReadyOrNotGameMode::OnPlayerRespawned' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, CharacterHUD) == 0x000730, "Member 'AReadyOrNotGameMode::CharacterHUD' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, NormalSpectatorPawn) == 0x000738, "Member 'AReadyOrNotGameMode::NormalSpectatorPawn' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, MissionPlanManager) == 0x000740, "Member 'AReadyOrNotGameMode::MissionPlanManager' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bMissionExfiltrated) == 0x000748, "Member 'AReadyOrNotGameMode::bMissionExfiltrated' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bIsExfilEnabled) == 0x000749, "Member 'AReadyOrNotGameMode::bIsExfilEnabled' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotGameMode_PVP
// 0x0060 (0x07D0 - 0x0770)
class AReadyOrNotGameMode_PVP : public AReadyOrNotGameMode
{
public:
	FMulticastInlineDelegateProperty_             OnMatchStart;                                      // 0x0770(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRoundWon;                                        // 0x0780(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRoundStart;                                      // 0x0790(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRoundEnd;                                        // 0x07A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         RoundEndResetDelay;                                // 0x07B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MatchEndResetDelay;                                // 0x07B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URoundEndWidget_PVP>        RoundEndWidgetClass;                               // 0x07B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIncrementedRoundCounterThisRound : 1;             // 0x07C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2029[0xF];                                     // 0x07C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AnyDeathsOnWinningTeam();
	void CheckRoundEnd(float DeltaSeconds);
	void MatchEnd();
	void Multicast_SetWinningTeam(ETeamType WinningTeam);
	void NextRound();
	void OnMatchStart__DelegateSignature();
	void OnRoundEnd__DelegateSignature();
	void OnRoundEnded();
	void OnRoundStart__DelegateSignature();
	void OnRoundStarted();
	void OnRoundWon__DelegateSignature(ETeamType WinningTeam);
	void RoundEnd();
	void RoundWon(const TArray<class AReadyOrNotPlayerState*>& WinningPlayers);
	void RoundWonTeam(ETeamType WinningTeam);
	void TimelimitReached();
	void TimeLimitVictoryConditions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotGameMode_PVP">();
	}
	static class AReadyOrNotGameMode_PVP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotGameMode_PVP>();
	}
};
static_assert(alignof(AReadyOrNotGameMode_PVP) == 0x000010, "Wrong alignment on AReadyOrNotGameMode_PVP");
static_assert(sizeof(AReadyOrNotGameMode_PVP) == 0x0007D0, "Wrong size on AReadyOrNotGameMode_PVP");
static_assert(offsetof(AReadyOrNotGameMode_PVP, OnMatchStart) == 0x000770, "Member 'AReadyOrNotGameMode_PVP::OnMatchStart' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode_PVP, OnRoundWon) == 0x000780, "Member 'AReadyOrNotGameMode_PVP::OnRoundWon' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode_PVP, OnRoundStart) == 0x000790, "Member 'AReadyOrNotGameMode_PVP::OnRoundStart' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode_PVP, OnRoundEnd) == 0x0007A0, "Member 'AReadyOrNotGameMode_PVP::OnRoundEnd' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode_PVP, RoundEndResetDelay) == 0x0007B0, "Member 'AReadyOrNotGameMode_PVP::RoundEndResetDelay' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode_PVP, MatchEndResetDelay) == 0x0007B4, "Member 'AReadyOrNotGameMode_PVP::MatchEndResetDelay' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode_PVP, RoundEndWidgetClass) == 0x0007B8, "Member 'AReadyOrNotGameMode_PVP::RoundEndWidgetClass' has a wrong offset!");

// Class ReadyOrNot.TeamDeathmatchGM
// 0x0020 (0x07F0 - 0x07D0)
class ATeamDeathmatchGM final  : public AReadyOrNotGameMode_PVP
{
public:
	bool                                          bSuddenDeath;                                      // 0x07D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_202A[0x7];                                     // 0x07D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             MatchLoopMusic;                                    // 0x07D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchStartMusic;                                   // 0x07E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchEndMusic;                                     // 0x07E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamDeathmatchGM">();
	}
	static class ATeamDeathmatchGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeamDeathmatchGM>();
	}
};
static_assert(alignof(ATeamDeathmatchGM) == 0x000010, "Wrong alignment on ATeamDeathmatchGM");
static_assert(sizeof(ATeamDeathmatchGM) == 0x0007F0, "Wrong size on ATeamDeathmatchGM");
static_assert(offsetof(ATeamDeathmatchGM, bSuddenDeath) == 0x0007D0, "Member 'ATeamDeathmatchGM::bSuddenDeath' has a wrong offset!");
static_assert(offsetof(ATeamDeathmatchGM, MatchLoopMusic) == 0x0007D8, "Member 'ATeamDeathmatchGM::MatchLoopMusic' has a wrong offset!");
static_assert(offsetof(ATeamDeathmatchGM, MatchStartMusic) == 0x0007E0, "Member 'ATeamDeathmatchGM::MatchStartMusic' has a wrong offset!");
static_assert(offsetof(ATeamDeathmatchGM, MatchEndMusic) == 0x0007E8, "Member 'ATeamDeathmatchGM::MatchEndMusic' has a wrong offset!");

// Class ReadyOrNot.AchievementSubsystem
// 0x0128 (0x0158 - 0x0030)
class UAchievementSubsystem final  : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_202B[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAchievementStats, struct FUniversalStat> AchievementStats;                                  // 0x0038(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_202C[0x10];                                    // 0x0088(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ABaseItem*>                        UsedItemsInCurrentMission;                         // 0x0098(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_202D[0x50];                                    // 0x00E8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalAchievements*                     LocalAchievements;                                 // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URequestStatsAndAchievements*           RequestStatAndAchievements;                        // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStoreStatsAndAchievements*             StoreStatsAndAchievements;                         // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UIndicateAchievementProgress*           UserAchievementProgress;                           // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BeginMission();
	void EndMission(class UObject* WorldContextObject);
	bool HasOnlyUsedItems(const TArray<EItemCategory>& Categories);
	void IndicateUserAchievementProgress(EAchievement Achievement, int32 Progress, int32 MaxProgress);
	void QueryAchievementsAndStatsFailure(int32 SteamErrorOutput);
	void QueryAchievementsAndStatsSuccess(int32 SteamErrorOutput);
	void StoreStatsAndAchievementsFailure(int32 SteamErrorOutput);
	void StoreStatsAndAchievementsSuccess(int32 SteamErrorOutput);
	void UsedItem(class ABaseItem* Item);
	void UserAchievementProgressFailure(int32 SteamErrorOutput);
	void UserAchievementProgressSuccess(int32 SteamErrorOutput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementSubsystem">();
	}
	static class UAchievementSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementSubsystem>();
	}
};
static_assert(alignof(UAchievementSubsystem) == 0x000008, "Wrong alignment on UAchievementSubsystem");
static_assert(sizeof(UAchievementSubsystem) == 0x000158, "Wrong size on UAchievementSubsystem");
static_assert(offsetof(UAchievementSubsystem, AchievementStats) == 0x000038, "Member 'UAchievementSubsystem::AchievementStats' has a wrong offset!");
static_assert(offsetof(UAchievementSubsystem, UsedItemsInCurrentMission) == 0x000098, "Member 'UAchievementSubsystem::UsedItemsInCurrentMission' has a wrong offset!");
static_assert(offsetof(UAchievementSubsystem, LocalAchievements) == 0x000138, "Member 'UAchievementSubsystem::LocalAchievements' has a wrong offset!");
static_assert(offsetof(UAchievementSubsystem, RequestStatAndAchievements) == 0x000140, "Member 'UAchievementSubsystem::RequestStatAndAchievements' has a wrong offset!");
static_assert(offsetof(UAchievementSubsystem, StoreStatsAndAchievements) == 0x000148, "Member 'UAchievementSubsystem::StoreStatsAndAchievements' has a wrong offset!");
static_assert(offsetof(UAchievementSubsystem, UserAchievementProgress) == 0x000150, "Member 'UAchievementSubsystem::UserAchievementProgress' has a wrong offset!");

// Class ReadyOrNot.MenuWidget
// 0x0000 (0x0320 - 0x0320)
class UMenuWidget : public UCommonActivatableWidget
{
public:
	void PlayWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation, bool bRestartIfAlreadyPlaying);

	void BP_OnShow() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuWidget">();
	}
	static class UMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuWidget>();
	}
};
static_assert(alignof(UMenuWidget) == 0x000008, "Wrong alignment on UMenuWidget");
static_assert(sizeof(UMenuWidget) == 0x000320, "Wrong size on UMenuWidget");

// Class ReadyOrNot.MainMenu
// 0x00E8 (0x0408 - 0x0320)
class UMainMenu final  : public UMenuWidget
{
public:
	TMap<ReadyOrNot::ELoginState, class FText>    BackendConnectionStatus;                           // 0x0320(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<ReadyOrNot::ELoginState, struct FSlateColor> BackendConnectionStatusColor;                      // 0x0370(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           BackgroundCanvas;                                  // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            PlayBtn;                                           // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            FindCOOPSessionBtn;                                // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            FindPVPSessionBtn;                                 // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            PlayPublicLobbyBtn;                                // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            PlayFriendsOnlyBtn;                                // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_BackEndConnection;                             // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_PublicLobbyCooldown;                           // 0x03F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnableFindSessionCOOPButton : 1;                  // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnableFindSessionPVPButton : 1;                   // 0x0400(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2031[0x7];                                     // 0x0401(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseModMenu();
	void OpenModMenu();

	bool CanFindSession(bool bCOOP) const;
	bool CanPlayPublicLobby() const;
	class FText GetBackEndConnectionStatus(ReadyOrNot::ELoginState LoginState) const;
	class FText GetPublicLobbyCooldown() const;
	class FText GetVersion() const;
	bool IsLoggedIn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenu">();
	}
	static class UMainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenu>();
	}
};
static_assert(alignof(UMainMenu) == 0x000008, "Wrong alignment on UMainMenu");
static_assert(sizeof(UMainMenu) == 0x000408, "Wrong size on UMainMenu");
static_assert(offsetof(UMainMenu, BackendConnectionStatus) == 0x000320, "Member 'UMainMenu::BackendConnectionStatus' has a wrong offset!");
static_assert(offsetof(UMainMenu, BackendConnectionStatusColor) == 0x000370, "Member 'UMainMenu::BackendConnectionStatusColor' has a wrong offset!");
static_assert(offsetof(UMainMenu, BackgroundCanvas) == 0x0003C0, "Member 'UMainMenu::BackgroundCanvas' has a wrong offset!");
static_assert(offsetof(UMainMenu, PlayBtn) == 0x0003C8, "Member 'UMainMenu::PlayBtn' has a wrong offset!");
static_assert(offsetof(UMainMenu, FindCOOPSessionBtn) == 0x0003D0, "Member 'UMainMenu::FindCOOPSessionBtn' has a wrong offset!");
static_assert(offsetof(UMainMenu, FindPVPSessionBtn) == 0x0003D8, "Member 'UMainMenu::FindPVPSessionBtn' has a wrong offset!");
static_assert(offsetof(UMainMenu, PlayPublicLobbyBtn) == 0x0003E0, "Member 'UMainMenu::PlayPublicLobbyBtn' has a wrong offset!");
static_assert(offsetof(UMainMenu, PlayFriendsOnlyBtn) == 0x0003E8, "Member 'UMainMenu::PlayFriendsOnlyBtn' has a wrong offset!");
static_assert(offsetof(UMainMenu, Txt_BackEndConnection) == 0x0003F0, "Member 'UMainMenu::Txt_BackEndConnection' has a wrong offset!");
static_assert(offsetof(UMainMenu, Txt_PublicLobbyCooldown) == 0x0003F8, "Member 'UMainMenu::Txt_PublicLobbyCooldown' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_DoorKickFailure
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_DoorKickFailure final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DoorKickFailure">();
	}
	static class UAnimNotify_DoorKickFailure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DoorKickFailure>();
	}
};
static_assert(alignof(UAnimNotify_DoorKickFailure) == 0x000008, "Wrong alignment on UAnimNotify_DoorKickFailure");
static_assert(sizeof(UAnimNotify_DoorKickFailure) == 0x000038, "Wrong size on UAnimNotify_DoorKickFailure");

// Class ReadyOrNot.AchievementStatics
// 0x0000 (0x0028 - 0x0028)
class UAchievementStatics final  : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementStatics">();
	}
	static class UAchievementStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementStatics>();
	}
};
static_assert(alignof(UAchievementStatics) == 0x000008, "Wrong alignment on UAchievementStatics");
static_assert(sizeof(UAchievementStatics) == 0x000028, "Wrong size on UAchievementStatics");

// Class ReadyOrNot.LocalAchievements
// 0x0060 (0x0088 - 0x0028)
class ULocalAchievements final  : public USaveGame
{
public:
	TMap<EAchievementStats, struct FUniversalStat> Stats;                                             // 0x0028(0x0050)(NativeAccessSpecifierPrivate)
	TArray<EAchievement>                          Achievements;                                      // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalAchievements">();
	}
	static class ULocalAchievements* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalAchievements>();
	}
};
static_assert(alignof(ULocalAchievements) == 0x000008, "Wrong alignment on ULocalAchievements");
static_assert(sizeof(ULocalAchievements) == 0x000088, "Wrong size on ULocalAchievements");
static_assert(offsetof(ULocalAchievements, Stats) == 0x000028, "Member 'ULocalAchievements::Stats' has a wrong offset!");
static_assert(offsetof(ULocalAchievements, Achievements) == 0x000078, "Member 'ULocalAchievements::Achievements' has a wrong offset!");

// Class ReadyOrNot.ActorSpawnPoint
// 0x0018 (0x0238 - 0x0220)
class AActorSpawnPoint : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBillboardComponent*                    BillboardComponent;                                // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasVisited : 1;                                   // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2033[0x7];                                     // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorSpawnPoint">();
	}
	static class AActorSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActorSpawnPoint>();
	}
};
static_assert(alignof(AActorSpawnPoint) == 0x000008, "Wrong alignment on AActorSpawnPoint");
static_assert(sizeof(AActorSpawnPoint) == 0x000238, "Wrong size on AActorSpawnPoint");
static_assert(offsetof(AActorSpawnPoint, SceneComponent) == 0x000220, "Member 'AActorSpawnPoint::SceneComponent' has a wrong offset!");
static_assert(offsetof(AActorSpawnPoint, BillboardComponent) == 0x000228, "Member 'AActorSpawnPoint::BillboardComponent' has a wrong offset!");

// Class ReadyOrNot.IncriminationClueSpawnPoint
// 0x0058 (0x0290 - 0x0238)
class AIncriminationClueSpawnPoint final  : public AActorSpawnPoint
{
public:
	TSubclassOf<class AIncriminationClue>         IncriminationClueClass;                            // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ClueFlareClass;                                    // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClueNumber;                                        // 0x0248(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2034[0x3];                                     // 0x0249(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShowObjectiveMarkerIn;                             // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ClueName;                                          // 0x0250(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ClueFoundMessage;                                  // 0x0268(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_2035[0x10];                                    // 0x0280(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncriminationClueSpawnPoint">();
	}
	static class AIncriminationClueSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIncriminationClueSpawnPoint>();
	}
};
static_assert(alignof(AIncriminationClueSpawnPoint) == 0x000008, "Wrong alignment on AIncriminationClueSpawnPoint");
static_assert(sizeof(AIncriminationClueSpawnPoint) == 0x000290, "Wrong size on AIncriminationClueSpawnPoint");
static_assert(offsetof(AIncriminationClueSpawnPoint, IncriminationClueClass) == 0x000238, "Member 'AIncriminationClueSpawnPoint::IncriminationClueClass' has a wrong offset!");
static_assert(offsetof(AIncriminationClueSpawnPoint, ClueFlareClass) == 0x000240, "Member 'AIncriminationClueSpawnPoint::ClueFlareClass' has a wrong offset!");
static_assert(offsetof(AIncriminationClueSpawnPoint, ClueNumber) == 0x000248, "Member 'AIncriminationClueSpawnPoint::ClueNumber' has a wrong offset!");
static_assert(offsetof(AIncriminationClueSpawnPoint, ShowObjectiveMarkerIn) == 0x00024C, "Member 'AIncriminationClueSpawnPoint::ShowObjectiveMarkerIn' has a wrong offset!");
static_assert(offsetof(AIncriminationClueSpawnPoint, ClueName) == 0x000250, "Member 'AIncriminationClueSpawnPoint::ClueName' has a wrong offset!");
static_assert(offsetof(AIncriminationClueSpawnPoint, ClueFoundMessage) == 0x000268, "Member 'AIncriminationClueSpawnPoint::ClueFoundMessage' has a wrong offset!");

// Class ReadyOrNot.ActivatableBaseWidget
// 0x0018 (0x0338 - 0x0320)
class UActivatableBaseWidget : public UCommonActivatableWidget
{
public:
	struct FVector2D                              MouseAxisDeltaThreshold;                           // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              GamepadAxisDeltaThreshold;                         // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotGameState*                   RONGS;                                             // 0x0330(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FVector2D GetCenterScreenPosition();
	void HideWidget();
	bool IsBlockingAnimationPlaying();
	bool IsGamepadAxisBeyondThreshold(struct FVector2D& InGamepadAxis);
	bool IsMouseAxisBeyondThreshold(struct FVector2D& InMouseDelta);
	void PauseWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation);
	void PlaySoundEffect(class UFMODEvent* SoundEffectToPlay);
	void PlayWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation, bool bRestartIfAlreadyPlaying);
	void ShowWidget(bool bNotHitTestable);
	void StopWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation);
	void ToggleWidgetVisibility(bool bNotHitTestable);
	bool UpdateDebugInfo();

	struct FVector2D GetMouseDelta() const;
	struct FVector2D GetMousePosition() const;
	bool HasMouseMoved() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivatableBaseWidget">();
	}
	static class UActivatableBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivatableBaseWidget>();
	}
};
static_assert(alignof(UActivatableBaseWidget) == 0x000008, "Wrong alignment on UActivatableBaseWidget");
static_assert(sizeof(UActivatableBaseWidget) == 0x000338, "Wrong size on UActivatableBaseWidget");
static_assert(offsetof(UActivatableBaseWidget, MouseAxisDeltaThreshold) == 0x000320, "Member 'UActivatableBaseWidget::MouseAxisDeltaThreshold' has a wrong offset!");
static_assert(offsetof(UActivatableBaseWidget, GamepadAxisDeltaThreshold) == 0x000328, "Member 'UActivatableBaseWidget::GamepadAxisDeltaThreshold' has a wrong offset!");
static_assert(offsetof(UActivatableBaseWidget, RONGS) == 0x000330, "Member 'UActivatableBaseWidget::RONGS' has a wrong offset!");

// Class ReadyOrNot.VOIPTalkerEntryWidget
// 0x0070 (0x02D0 - 0x0260)
class UVOIPTalkerEntryWidget : public UUserWidget
{
public:
	TMap<ETeamType, struct FSlateColor>           VoiceTypeColorMap;                                 // 0x0260(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerName;                                        // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerChannel;                                     // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 VoiceImage;                                        // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotPlayerState*                 PlayerState;                                       // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FSlateColor GetVoiceTypeColor() const;
	class FText GetVoiceTypeText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOIPTalkerEntryWidget">();
	}
	static class UVOIPTalkerEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOIPTalkerEntryWidget>();
	}
};
static_assert(alignof(UVOIPTalkerEntryWidget) == 0x000008, "Wrong alignment on UVOIPTalkerEntryWidget");
static_assert(sizeof(UVOIPTalkerEntryWidget) == 0x0002D0, "Wrong size on UVOIPTalkerEntryWidget");
static_assert(offsetof(UVOIPTalkerEntryWidget, VoiceTypeColorMap) == 0x000260, "Member 'UVOIPTalkerEntryWidget::VoiceTypeColorMap' has a wrong offset!");
static_assert(offsetof(UVOIPTalkerEntryWidget, PlayerName) == 0x0002B0, "Member 'UVOIPTalkerEntryWidget::PlayerName' has a wrong offset!");
static_assert(offsetof(UVOIPTalkerEntryWidget, PlayerChannel) == 0x0002B8, "Member 'UVOIPTalkerEntryWidget::PlayerChannel' has a wrong offset!");
static_assert(offsetof(UVOIPTalkerEntryWidget, VoiceImage) == 0x0002C0, "Member 'UVOIPTalkerEntryWidget::VoiceImage' has a wrong offset!");
static_assert(offsetof(UVOIPTalkerEntryWidget, PlayerState) == 0x0002C8, "Member 'UVOIPTalkerEntryWidget::PlayerState' has a wrong offset!");

// Class ReadyOrNot.ActivityData
// 0x00F8 (0x0128 - 0x0030)
class UActivityData final  : public UDataAsset
{
public:
	EActivity                                     Activity;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2039[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSwatCommandData                       SwatCommandData;                                   // 0x0038(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTutorialWidgetData                    WidgetData;                                        // 0x0070(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         ActionsRequired;                                   // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRequired;                                      // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnComplete;                                        // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_203A[0x10];                                    // 0x0108(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotCharacter*>           CharactersKilled;                                  // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void CompleteActivity();
	void OnAttachmentLightToggled();
	void OnCantedSightToggled(bool bUsingCantedSight);
	void OnCharacterArrested(class AReadyOrNotCharacter* Character, class AReadyOrNotCharacter* ArrestedBy);
	void OnCharacterKilled(class AReadyOrNotCharacter* Character, class AReadyOrNotCharacter* KilledBy);
	void OnCharacterMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity);
	void OnChemlightThrown(class APlayerCharacter* DelegatePlayerCharacter);
	void OnDoorKicked(class ADoor* Door, class AReadyOrNotCharacter* InstigatorCharacter, bool bSuccess);
	void OnEvidenceCollected(class AActor* Evidence);
	void OnExfiltrateMission();
	void OnInteract(class UInteractableComponent* InteractableComponent);
	void OnItemEquipped(class ABaseItem* Item);
	void OnItemUseCompleted(class ABaseItem* Item);
	void OnItemUseStart(class ABaseItem* Item);
	void OnNightVisionGogglesToggled(class AReadyOrNotCharacter* Character, bool bOn);
	void OnSwatCommandIssued(ESwatCommand SwatCommand, ETeamType TeamType, class AActor* ContextActor);
	void OnSwatCommandQueued(struct FQueuedSwatCommand& QueuedSwatCommand, ETeamType TeamType);
	void OnSwatElementChanged(ETeamType TeamType);
	void OnTargetHit(class ATrainingTarget* Target);
	void OnTeamViewSet(class AReadyOrNotCharacter* NewViewCharacter);
	void OnWeaponFire(class AReadyOrNotCharacter* Character, class ABaseMagazineWeapon* Weapon, const struct FVector& FireDirection);
	void OnWeaponFireModeChanged(class APlayerCharacter* DelegatePlayerCharacter, EFireMode NewFireMode, EFireMode LastFireMode);
	void OnWeaponReload(class APlayerCharacter* DelegatePlayerCharacter);
	void OnWeaponSwitchAmmoType(class APlayerCharacter* DelegatePlayerCharacter);
	void OnWeaponTacticalReload(class APlayerCharacter* DelegatePlayerCharacter);

	bool IsComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityData">();
	}
	static class UActivityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivityData>();
	}
};
static_assert(alignof(UActivityData) == 0x000008, "Wrong alignment on UActivityData");
static_assert(sizeof(UActivityData) == 0x000128, "Wrong size on UActivityData");
static_assert(offsetof(UActivityData, Activity) == 0x000030, "Member 'UActivityData::Activity' has a wrong offset!");
static_assert(offsetof(UActivityData, SwatCommandData) == 0x000038, "Member 'UActivityData::SwatCommandData' has a wrong offset!");
static_assert(offsetof(UActivityData, WidgetData) == 0x000070, "Member 'UActivityData::WidgetData' has a wrong offset!");
static_assert(offsetof(UActivityData, ActionsRequired) == 0x0000E8, "Member 'UActivityData::ActionsRequired' has a wrong offset!");
static_assert(offsetof(UActivityData, TimeRequired) == 0x0000EC, "Member 'UActivityData::TimeRequired' has a wrong offset!");
static_assert(offsetof(UActivityData, OnComplete) == 0x0000F0, "Member 'UActivityData::OnComplete' has a wrong offset!");
static_assert(offsetof(UActivityData, PlayerCharacter) == 0x000100, "Member 'UActivityData::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UActivityData, CharactersKilled) == 0x000118, "Member 'UActivityData::CharactersKilled' has a wrong offset!");

// Class ReadyOrNot.IconWidget
// 0x0010 (0x0270 - 0x0260)
class UIconWidget final  : public UUserWidget
{
public:
	class UImage*                                 MainImage;                                         // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 ParentComponent;                                   // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UTexture2D* GetAttachedObjectIcon() const;
	class FString GetAttachedObjectName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IconWidget">();
	}
	static class UIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIconWidget>();
	}
};
static_assert(alignof(UIconWidget) == 0x000008, "Wrong alignment on UIconWidget");
static_assert(sizeof(UIconWidget) == 0x000270, "Wrong size on UIconWidget");
static_assert(offsetof(UIconWidget, MainImage) == 0x000260, "Member 'UIconWidget::MainImage' has a wrong offset!");
static_assert(offsetof(UIconWidget, ParentComponent) == 0x000268, "Member 'UIconWidget::ParentComponent' has a wrong offset!");

// Class ReadyOrNot.ActivityState
// 0x0070 (0x0098 - 0x0028)
class UActivityState final  : public UObject
{
public:
	uint8                                         Pad_2041[0x30];                                    // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name_ActivityState;                                // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Uptime;                                            // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActivityFiniteStateMachine*            StateMachineOwner;                                 // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActivityStateTransition>       StateTransitions;                                  // 0x0078(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2042[0x10];                                    // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UActivityState* CreateTransition(struct FActivityStateTransition& InStateTransition);
	class UActivityState* RemoveTransitionByID(int32 InID);
	class UActivityState* RemoveTransitionByName(class FString& InName);

	TArray<struct FActivityStateTransition> GetTransitions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityState">();
	}
	static class UActivityState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivityState>();
	}
};
static_assert(alignof(UActivityState) == 0x000008, "Wrong alignment on UActivityState");
static_assert(sizeof(UActivityState) == 0x000098, "Wrong size on UActivityState");
static_assert(offsetof(UActivityState, Name_ActivityState) == 0x000058, "Member 'UActivityState::Name_ActivityState' has a wrong offset!");
static_assert(offsetof(UActivityState, ID) == 0x000068, "Member 'UActivityState::ID' has a wrong offset!");
static_assert(offsetof(UActivityState, Uptime) == 0x00006C, "Member 'UActivityState::Uptime' has a wrong offset!");
static_assert(offsetof(UActivityState, StateMachineOwner) == 0x000070, "Member 'UActivityState::StateMachineOwner' has a wrong offset!");
static_assert(offsetof(UActivityState, StateTransitions) == 0x000078, "Member 'UActivityState::StateTransitions' has a wrong offset!");

// Class ReadyOrNot.ActivityFiniteStateMachine
// 0x0020 (0x0048 - 0x0028)
class UActivityFiniteStateMachine final  : public UObject
{
public:
	TArray<class UActivityState*>                 States;                                            // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	class UActivityState*                         ActiveState;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bMachineInitialized : 1;                           // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_2044[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UActivityState* AddState(const class FString& NewStateName, const TArray<struct FActivityStateTransition>& Transitions);
	class UActivityState* GetActiveState();

	class UActivityState* GetStateByID(int32 InStateID) const;
	class UActivityState* GetStateByName(const class FString& InStateName) const;
	bool IsMachineInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityFiniteStateMachine">();
	}
	static class UActivityFiniteStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivityFiniteStateMachine>();
	}
};
static_assert(alignof(UActivityFiniteStateMachine) == 0x000008, "Wrong alignment on UActivityFiniteStateMachine");
static_assert(sizeof(UActivityFiniteStateMachine) == 0x000048, "Wrong size on UActivityFiniteStateMachine");
static_assert(offsetof(UActivityFiniteStateMachine, States) == 0x000028, "Member 'UActivityFiniteStateMachine::States' has a wrong offset!");
static_assert(offsetof(UActivityFiniteStateMachine, ActiveState) == 0x000038, "Member 'UActivityFiniteStateMachine::ActiveState' has a wrong offset!");

// Class ReadyOrNot.PVPTriggerBox
// 0x0068 (0x0290 - 0x0228)
class APVPTriggerBox : public ATriggerBox
{
public:
	class UTextRenderComponent*                   TextRender;                                        // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectiveMarkerComponent*              ObjectiveMarkerComponent;                          // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class APlayerCharacter*>               CharactersInTriggerBox;                            // 0x0238(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	float                                         TimeElapsed;                                       // 0x0248(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviousTimeElapsed;                               // 0x024C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEntered : 1;                                      // 0x0250(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2046[0x3];                                     // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeNeededToStay_Editor;                           // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeNeededToStay;                                  // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeNeededToStay_Active;                           // 0x025C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ETeamType>                             OnlyAcceptTeams;                                   // 0x0260(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           OnlyAcceptActorsWithTags;                          // 0x0270(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bLogDebugInfo : 1;                                 // 0x0280(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2047[0x7];                                     // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TH_TimerEventExpiry;                               // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CancelTimerEvent();
	void HideObjectiveMarker();
	void OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnRep_CharactersInTriggerBoxUpdated();
	void OnTimerExpired();
	void PauseTimerEvent();
	void ResumeTimerEvent();
	void ShowObjectiveMarker();
	void StartTimerEvent();
	void ToggleObjectiveMarker();

	bool DoesActorHaveAnyAcceptedTags(class AActor* OtherActor) const;
	float GetCurrentElapsedTime() const;
	float GetLastElapsedTime() const;
	bool IsActorInTriggerBox(class AActor* InActor) const;
	bool IsPlayerOnAcceptedTeam(class APlayerCharacter* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PVPTriggerBox">();
	}
	static class APVPTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<APVPTriggerBox>();
	}
};
static_assert(alignof(APVPTriggerBox) == 0x000008, "Wrong alignment on APVPTriggerBox");
static_assert(sizeof(APVPTriggerBox) == 0x000290, "Wrong size on APVPTriggerBox");
static_assert(offsetof(APVPTriggerBox, TextRender) == 0x000228, "Member 'APVPTriggerBox::TextRender' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, ObjectiveMarkerComponent) == 0x000230, "Member 'APVPTriggerBox::ObjectiveMarkerComponent' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, CharactersInTriggerBox) == 0x000238, "Member 'APVPTriggerBox::CharactersInTriggerBox' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, TimeElapsed) == 0x000248, "Member 'APVPTriggerBox::TimeElapsed' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, PreviousTimeElapsed) == 0x00024C, "Member 'APVPTriggerBox::PreviousTimeElapsed' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, TimeNeededToStay_Editor) == 0x000254, "Member 'APVPTriggerBox::TimeNeededToStay_Editor' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, TimeNeededToStay) == 0x000258, "Member 'APVPTriggerBox::TimeNeededToStay' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, TimeNeededToStay_Active) == 0x00025C, "Member 'APVPTriggerBox::TimeNeededToStay_Active' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, OnlyAcceptTeams) == 0x000260, "Member 'APVPTriggerBox::OnlyAcceptTeams' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, OnlyAcceptActorsWithTags) == 0x000270, "Member 'APVPTriggerBox::OnlyAcceptActorsWithTags' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, TH_TimerEventExpiry) == 0x000288, "Member 'APVPTriggerBox::TH_TimerEventExpiry' has a wrong offset!");

// Class ReadyOrNot.IncriminationTriggerBox
// 0x0000 (0x0290 - 0x0290)
class AIncriminationTriggerBox final  : public APVPTriggerBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncriminationTriggerBox">();
	}
	static class AIncriminationTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIncriminationTriggerBox>();
	}
};
static_assert(alignof(AIncriminationTriggerBox) == 0x000008, "Wrong alignment on AIncriminationTriggerBox");
static_assert(sizeof(AIncriminationTriggerBox) == 0x000290, "Wrong size on AIncriminationTriggerBox");

// Class ReadyOrNot.ReplaySpringArm
// 0x0000 (0x0280 - 0x0280)
class UReplaySpringArm final  : public USpringArmComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplaySpringArm">();
	}
	static class UReplaySpringArm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReplaySpringArm>();
	}
};
static_assert(alignof(UReplaySpringArm) == 0x000010, "Wrong alignment on UReplaySpringArm");
static_assert(sizeof(UReplaySpringArm) == 0x000280, "Wrong size on UReplaySpringArm");

// Class ReadyOrNot.ActivityManager
// 0x0070 (0x00B0 - 0x0040)
class UActivityManager final  : public UTickableWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnStartActivity;                                   // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UBaseActivity*>                  AllActivities;                                     // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UBaseActivity>, float> ActivityClassGlobalCooldownMap;                    // 0x0060(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UBaseActivity* CreateActivity(class UObject* ContextObject, TSubclassOf<class UBaseActivity> InActivityClass, class FText& InActivityName, float InActivityStartDelay);
	static bool GiveActivityTo(class UBaseActivity* InActivity, class ACyberneticCharacter* InCharacter, bool bOverrideCurrentActivity, bool bClearActivityList);

	void OnStartActivity__DelegateSignature(class UBaseActivity* Activity, class ACyberneticController* Controller);

	bool IsActivityClassOnCooldown(TSubclassOf<class UBaseActivity> Param_Class) const;
	bool IsActivityClassOnCooldown_WithTimeRemaining(TSubclassOf<class UBaseActivity> Param_Class, float* TimeRemaining) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityManager">();
	}
	static class UActivityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivityManager>();
	}
};
static_assert(alignof(UActivityManager) == 0x000008, "Wrong alignment on UActivityManager");
static_assert(sizeof(UActivityManager) == 0x0000B0, "Wrong size on UActivityManager");
static_assert(offsetof(UActivityManager, OnStartActivity) == 0x000040, "Member 'UActivityManager::OnStartActivity' has a wrong offset!");
static_assert(offsetof(UActivityManager, AllActivities) == 0x000050, "Member 'UActivityManager::AllActivities' has a wrong offset!");
static_assert(offsetof(UActivityManager, ActivityClassGlobalCooldownMap) == 0x000060, "Member 'UActivityManager::ActivityClassGlobalCooldownMap' has a wrong offset!");

// Class ReadyOrNot.ActivityTriggerVolume
// 0x00B0 (0x02D8 - 0x0228)
class AActivityTriggerVolume : public ATriggerBox
{
public:
	TArray<struct FActivityEvent>                 ActivationEvents;                                  // 0x0228(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FActivityEvent>                 OnEnterEvents;                                     // 0x0238(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UActivityData*>                  Activities;                                        // 0x0248(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FActivityEvent>                 OnLeaveEvents;                                     // 0x0258(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FActivityEvent>                 CompletionEvents;                                  // 0x0268(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class AActivityTriggerVolume>  NextTransitionVolume;                              // 0x0278(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TransitionDelay;                                   // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStartActive;                                      // 0x02A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_204F[0x3];                                     // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActivityDelay;                                     // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTriggerEventsWhileInactive;                       // 0x02AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawDebug;                                        // 0x02AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2050[0x2];                                     // 0x02AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           ActivateDelayTimerHandle;                          // 0x02B8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2051[0x8];                                     // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAllActivitiesComplete;                           // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Activate();
	void Deactivate();
	void OnActivityComplete(class UActivityData* Activity);
	void OnPlayerBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnPlayerEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnSpawnedAiKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void Reactivate(float ReactivateDelay);
	void ResetAllProgress();

	bool AllActivitiesComplete() const;
	TArray<class UActivityData*> GetActivities() const;
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityTriggerVolume">();
	}
	static class AActivityTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActivityTriggerVolume>();
	}
};
static_assert(alignof(AActivityTriggerVolume) == 0x000008, "Wrong alignment on AActivityTriggerVolume");
static_assert(sizeof(AActivityTriggerVolume) == 0x0002D8, "Wrong size on AActivityTriggerVolume");
static_assert(offsetof(AActivityTriggerVolume, ActivationEvents) == 0x000228, "Member 'AActivityTriggerVolume::ActivationEvents' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, OnEnterEvents) == 0x000238, "Member 'AActivityTriggerVolume::OnEnterEvents' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, Activities) == 0x000248, "Member 'AActivityTriggerVolume::Activities' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, OnLeaveEvents) == 0x000258, "Member 'AActivityTriggerVolume::OnLeaveEvents' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, CompletionEvents) == 0x000268, "Member 'AActivityTriggerVolume::CompletionEvents' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, NextTransitionVolume) == 0x000278, "Member 'AActivityTriggerVolume::NextTransitionVolume' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, TransitionDelay) == 0x0002A0, "Member 'AActivityTriggerVolume::TransitionDelay' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, bStartActive) == 0x0002A4, "Member 'AActivityTriggerVolume::bStartActive' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, ActivityDelay) == 0x0002A8, "Member 'AActivityTriggerVolume::ActivityDelay' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, bTriggerEventsWhileInactive) == 0x0002AC, "Member 'AActivityTriggerVolume::bTriggerEventsWhileInactive' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, bDrawDebug) == 0x0002AD, "Member 'AActivityTriggerVolume::bDrawDebug' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, PlayerCharacter) == 0x0002B0, "Member 'AActivityTriggerVolume::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, ActivateDelayTimerHandle) == 0x0002B8, "Member 'AActivityTriggerVolume::ActivateDelayTimerHandle' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, OnAllActivitiesComplete) == 0x0002C8, "Member 'AActivityTriggerVolume::OnAllActivitiesComplete' has a wrong offset!");

// Class ReadyOrNot.InteractionActor
// 0x0058 (0x0278 - 0x0220)
class AInteractionActor : public AActor
{
public:
	uint8                                         Pad_2052[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneRoot;                                         // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       UseIconRadius;                                     // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mesh_Static;                                       // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Mesh_Skeletal;                                     // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseNow;                                        // 0x0248(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailableForUse;                                  // 0x0249(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompleteIcon;                                     // 0x024A(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bButtonPushAnimation;                              // 0x024B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldButtonPrompt;                                 // 0x024C(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideButtonPrompt;                             // 0x024D(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2053[0x2];                                     // 0x024E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   OverrideButtonPromptText;                          // 0x0250(0x0018)(Edit, BlueprintVisible, Net, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                CachedUseComponents;                               // 0x0268(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	bool CanBeUsedNow(class AActor* PotentialUser);
	void OnActorUsed(class AActor* User);
	void OnActorUsedEnd(class AActor* User);
	void Server_EndUse(class AActor* User);
	void Server_TryUse(class AActor* User);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionActor">();
	}
	static class AInteractionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractionActor>();
	}
};
static_assert(alignof(AInteractionActor) == 0x000008, "Wrong alignment on AInteractionActor");
static_assert(sizeof(AInteractionActor) == 0x000278, "Wrong size on AInteractionActor");
static_assert(offsetof(AInteractionActor, SceneRoot) == 0x000228, "Member 'AInteractionActor::SceneRoot' has a wrong offset!");
static_assert(offsetof(AInteractionActor, UseIconRadius) == 0x000230, "Member 'AInteractionActor::UseIconRadius' has a wrong offset!");
static_assert(offsetof(AInteractionActor, Mesh_Static) == 0x000238, "Member 'AInteractionActor::Mesh_Static' has a wrong offset!");
static_assert(offsetof(AInteractionActor, Mesh_Skeletal) == 0x000240, "Member 'AInteractionActor::Mesh_Skeletal' has a wrong offset!");
static_assert(offsetof(AInteractionActor, bCanUseNow) == 0x000248, "Member 'AInteractionActor::bCanUseNow' has a wrong offset!");
static_assert(offsetof(AInteractionActor, bAvailableForUse) == 0x000249, "Member 'AInteractionActor::bAvailableForUse' has a wrong offset!");
static_assert(offsetof(AInteractionActor, bCompleteIcon) == 0x00024A, "Member 'AInteractionActor::bCompleteIcon' has a wrong offset!");
static_assert(offsetof(AInteractionActor, bButtonPushAnimation) == 0x00024B, "Member 'AInteractionActor::bButtonPushAnimation' has a wrong offset!");
static_assert(offsetof(AInteractionActor, bHoldButtonPrompt) == 0x00024C, "Member 'AInteractionActor::bHoldButtonPrompt' has a wrong offset!");
static_assert(offsetof(AInteractionActor, bOverrideButtonPrompt) == 0x00024D, "Member 'AInteractionActor::bOverrideButtonPrompt' has a wrong offset!");
static_assert(offsetof(AInteractionActor, OverrideButtonPromptText) == 0x000250, "Member 'AInteractionActor::OverrideButtonPromptText' has a wrong offset!");
static_assert(offsetof(AInteractionActor, CachedUseComponents) == 0x000268, "Member 'AInteractionActor::CachedUseComponents' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotPlayerController
// 0x04C8 (0x0A48 - 0x0580)
class AReadyOrNotPlayerController : public APlayerController
{
public:
	uint8                                         Pad_2055[0x8];                                     // 0x0580(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UProgressionComponent*                  ProgressionComp;                                   // 0x0588(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2056[0x4];                                     // 0x0590(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ServerSideChecksum;                                // 0x0594(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2057[0xC];                                     // 0x0598(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldShowMouseCursor;                            // 0x05A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2058[0x3];                                     // 0x05A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPawnPossessed;                                   // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExitSettingsMenu;                                // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOutOfBoundsChanged;                              // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPreClientTravel;                                 // 0x05D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2059[0x10];                                    // 0x05E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RespawnTimeLeft;                                   // 0x05F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_205A[0x4];                                     // 0x05FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            TabMenuWidget;                                     // 0x0600(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                TabMenuWidgetClass;                                // 0x0608(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            SubtitlesWidget;                                   // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_205B[0x8];                                     // 0x0618(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACameraActor*                           SpectateCamera;                                    // 0x0620(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULevelStreaming*>                StreamingLevels;                                   // 0x0628(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UJoinSessionCallbackProxyAdvanced*      JoinSession;                                       // 0x0638(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 StreamingLevel;                                    // 0x0640(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 StreamingOptions;                                  // 0x0650(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_205C[0x20];                                    // 0x0660(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReplicatedMapList;                                 // 0x0680(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMapListReplicated;                               // 0x0690(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         VoteAntiSpamDebouncer;                             // 0x06A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_205D[0x4];                                     // 0x06A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVoteData                              MyVoteData;                                        // 0x06A8(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	bool                                          bStatsProfiledQueued;                              // 0x06D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_205E[0x7];                                     // 0x06D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UUserWidget>>        ProtectedWidgetClasses;                            // 0x06E0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_205F[0x18];                                    // 0x06F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanOpenOptionsMenu;                               // 0x0708(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2060[0x7];                                     // 0x0709(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UUserWidget*>       CreatedWidgetMap;                                  // 0x0710(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2061[0x10];                                    // 0x0760(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FZeuzMatchMakingServerInfo             Rep_MatchmakingServerInfo;                         // 0x0770(0x0078)(Net, NativeAccessSpecifierPublic)
	struct FZeuzMatchMakingPartyInit              Rep_MatchmakingPartyInit;                          // 0x07E8(0x00B0)(Net, NativeAccessSpecifierPublic)
	class ASwatAutomationManager*                 SwatAutomationManager;                             // 0x0898(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, float>                    DebugActorList;                                    // 0x08A0(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_2062[0x30];                                    // 0x08F0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHudWidgetsClearedComplete;                       // 0x0920(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          TestCube;                                          // 0x0930(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TestMaterial;                                      // 0x0938(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2063[0x8];                                     // 0x0940(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bStartedCoopAsSpectator;                           // 0x0948(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2064[0x7];                                     // 0x0949(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             LastKilledCharacter;                               // 0x0950(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2065[0x8];                                     // 0x0958(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsReplaySpectator;                                // 0x0960(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2066[0x27];                                    // 0x0961(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRTXDMOChanged;                                   // 0x0988(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FRChatMessage>                  ChatMessages;                                      // 0x0998(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2067[0x18];                                    // 0x09A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FProjectileData>           ActiveProjectiles;                                 // 0x09C0(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_2068[0x8];                                     // 0x0A10(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayerReadyChange;                               // 0x0A18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2069[0x18];                                    // 0x0A28(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPauseMenu_Wrapper*                     PauseMenu;                                         // 0x0A40(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static float GetRespawnTimeRemaining();

	void AbortCover();
	void AcknowledgeVote(const struct FVoteData& CurrentVoteData);
	void AIEquipPrimary();
	void AIEquipSecondary();
	void AIHide();
	void AIStopHide();
	void ApplyCharacterSkin(const class FString& SkinName);
	void ApplyWeaponSkin(const class FString& SkinName);
	void ArrestAll(ETeamType TargetTeam);
	void ArrestAllCivilians();
	void ArrestAllSuspects();
	void ArrestOne();
	void BeginVote(const class FString& Reason, const class FString& Question, bool bCanVoteNo);
	void BP_ClientWasKicked(class FText& KickReason);
	void BP_HandleMessage(const struct FRChatMessage& ChatMessage);
	void BP_ReturnToMenu(class FText& ReturnReason);
	bool CanDisableDeployable(int32 DeployableNum);
	bool CanDisablePersonnel(int32 PersonnelNum);
	bool CanEnableDeployable(int32 DeployableNum);
	bool CanEnablePersonnel(int32 PersonnelNum, int32 MapPointNum);
	bool CanSetDepotTo(int32 NewDepot, bool bSameDepot);
	bool CanSetSpawn(ETeamType Team, ESelectedSpawn NewSpawnPoint, bool bSameSpawn);
	void ChangeInputMode(bool bGameMode, bool bMouseCursorEnabled, class UWidget* Widget);
	void Client_ClearHUDWidgets();
	void Client_CreateLoadingScreen(const class FString& Map, const class FString& Mode, const class FString& SessionName, bool bIsSeamlessTravel);
	void Client_CreateMessageDisplay(const class FString& MessageTxt, const class FString& ButtonTxt);
	void Client_CreateWidget(const class FString& WidgetName, bool bForceAddToWidgetStack, bool bIsEscapeKey);
	void Client_DisableUIMouse();
	void Client_GetStats();
	void Client_HideHUDWidgets();
	void Client_LocalReadyStateChanged(bool bReady);
	void Client_OnProjectileValidation(int32 ProjectileSeed, EServerValidationState Validation);
	void Client_PostLogin();
	void Client_RemoveWidget(TSubclassOf<class UUserWidget> Widget);
	void Client_SetControlRotation(const struct FRotator& NewControlRotation);
	void Client_SetViewTargetWithBlend(class APawn* NewViewTarget);
	void Client_UpdateWorldTime(float ServerTime, float SentClientTime);
	void ClientEndOnlineGame();
	void ClientJoinVoice(const class FString& OnlineSessionId, int32& TeamNum);
	void ClientSetNetSpeed(int32 NewNetSpeed);
	void ClientSetSpectatorCamera(const struct FVector& CameraLocation, const struct FRotator& CameraRotation);
	void ClientSpawned();
	void ClientStartOnlineGame();
	class UUserWidget* CreateWidgetForPlayer(const class FString& WidgetName, bool bForceAddToWidgetStack, bool bIsEscapeKey);
	void DebugClientStartHostMigration();
	void DebugMigrateHost();
	void DeleteAnyNonMeshComponents();
	void DestroyAllActorsOfName(const class FString& Param_Name);
	void DestroyAllAI();
	void DestroyAllDecals();
	void DestroyAllDynamicLights();
	void DestroyAllExceptClosestCharacter();
	void DestroyAllExceptClosestDoor();
	void DestroyAllItemMeshes();
	void DestroyAllItems();
	void DestroyAllLights();
	void DestroyAllSuspects();
	void DestroyAllWidgets();
	void DestroyAllWorldDynamicItems();
	void DestroyEverything();
	void DestroySwatAnimation();
	void DestroySwatControllers();
	void DestroySwatInventoryItems();
	void DestroySwatTeam();
	void DisableAllItemMaterials();
	void DisableAllItemTicks();
	void DisableAllMaterials();
	void DisableForceShowMouseCursor();
	void DisableSkeletalMeshShadowCasting();
	void DisableWeaponFovShader();
	void DisplayAllPlayingFMODEvents();
	void DownloadBlacklistHashes();
	void DropAllSuspectWeapons();
	void EnablePlayerInput();
	void EnableScopeAlignmentTool();
	void EnableWeaponFovShader();
	void EndVote();
	void Equip(const class FString& ItemName);
	void EquipAndDropEvidence();
	void EscapeMenu();
	void ExecuteLineTracePerfTest();
	void ExecuteSweepTraceMultiPerfTest();
	void ExecuteSweepTraceSinglePerfTest();
	void FlushDeadBodies();
	void FreeVIP();
	void GetNetworkConnectionStatus(float* AvgLag, int32* OutLostPackets, int32* InLostPackets, int32* OutLostPacketPrcnt, int32* InLostPacketPrcnt);
	class FString GetPasswordOnConnection();
	class FString GetPrefferredTeamUniqueNetIdOnConnection();
	TArray<class FString> GetReplicatedMapRotation();
	ETeamType GetTeamType();
	EVoteState GetVote();
	void GibAllComponents();
	void GiveSWATRam();
	void HideAllItemMeshes();
	void HideAllSmallItemMeshes();
	void HideAllWeaponAttachments();
	void InternalSaveStats();
	bool IsCameraFading();
	bool IsConsoleTarget();
	void Kill(float Time);
	void KillAll(ETeamType TargetTeam);
	void KillAllCivilians();
	void KillAllSuspects();
	void KillSWATTeam();
	void KnockoutAllEnemies();
	void MakeCrash();
	void Multicast_ForcePlanningRefresh();
	void Multicast_RemovePersonnelAtPoint(int32 PersonnelNum);
	void Multicast_SetPersonnelAtPoint(int32 PersonnelNum, int32 MapPointNum);
	void NotifyRespawnTime(float RespawnTime);
	void OnExitSettingsMenu__DelegateSignature();
	void OnHudWidgetsCleared__DelegateSignature();
	void OnLevelOpen();
	void OnLocallyFiredProjectile(class ABulletProjectile* Projectile, int32 ProjectileIdentifier);
	void OnlyCastLocalPlayerDynamicShadow();
	void OnMapListReplicated__DelegateSignature(TArray<class FString>& MapList);
	void OnOutOfBoundsChanged__DelegateSignature(bool bIsOutOfBounds);
	void OnPawnPossessed__DelegateSignature(class APawn* PossessedPawn);
	void OnPlayerReadyChange__DelegateSignature(class AReadyOrNotPlayerController* PlayerController, bool bReady);
	void OnPreClientTravel__DelegateSignature();
	void OnRep_Maplist();
	void OnRTXDMOChanged__DelegateSignature(bool bRTXOn);
	void OnSaveLoadout();
	void OnSessionJoinFailed();
	void OnSessionJoinSuccess();
	void OnStreamedLevelLoadedComplete();
	void OnStreamedLevelLoadedExecuteOpen();
	void OnStreamedLevelLoadedRemovingLoadingScreen();
	void OptimizeWorld();
	void PassMouseControlToValidWidget();
	void PlayAnimationFromLookupTable(const class FString& AnimationRowName);
	void PlayDeadAllEnemies();
	void PrintAllSceneComponentWhoseOriginIsZero();
	void PrintGPUBrand();
	void ReadyUp();
	void ReadyUp_Failsafe();
	void ReleaseVIP();
	void RemoveCharacterSkin();
	void RemoveHUD();
	void RemoveWeaponSkin();
	bool RemoveWidgetFromStack(const class FString& WidgetName);
	void ReplicateMapListIfAdmin();
	void ReportAllInstancedStaticMeshes();
	void RequestVoteInput(const struct FVoteData& CurrentVoteData);
	void ResetAI(float Range);
	void ResetDoorLockStateKnowledge();
	void ResetKeybinds();
	void RetrieveChatLog(TArray<struct FRChatMessage>* OutMessages);
	void RosterInstantFinishStatus();
	void SaveChatMessage(const struct FRChatMessage& Message);
	bool SaveFileToUserCloud(const class FString& FullPath);
	void SavePerformanceStats();
	void SendChatMessage(const struct FRChatMessage& ChatMessage);
	void Server_AddLine(struct FPlanningLine& Line);
	void Server_AddMarker(struct FPlanningMarker& Marker);
	void Server_AdminAddMapToRotation(const class FString& MapURL);
	void Server_AdminAddMapToRotationAtIndex(const class FString& MapURL, int32 Idx);
	void Server_AdminBanPlayer(class APlayerState* BanningPlayerState);
	void Server_AdminKickPlayer(class APlayerState* KickingPlayerState, class FText& ReasonOveride);
	void Server_AdminNextMap();
	void Server_AdminRemoveMapFromRotation(const class FString& MapURL);
	void Server_AdminRemoveMapFromRotationByIndex(int32 Idx);
	void Server_AdminRestartServer();
	void Server_BecomeVIP();
	void Server_DisableDeployable(int32 DeployableNum);
	void Server_DisablePersonnel(int32 PersonnelNum);
	void Server_EnableDeployable(int32 DeployableNum);
	void Server_EnablePersonnel(int32 PersonnelNum, int32 MapPointNum);
	void Server_Equip(const class FString& ItemName);
	void Server_LoginAsAdmin(const class FString& Password);
	void Server_ReferendumVoteNo();
	void Server_ReferendumVoteYes();
	void Server_ReleaseVIP();
	void Server_RemoveLine(int32 ID);
	void Server_RemoveMarker(int32 ID);
	void Server_RequestLoadoutChange(const struct FSavedLoadout& Loadout);
	void Server_RequestWorldTime(float ClientTime);
	void Server_RespawnAsLobby(TSubclassOf<class ASpectatorPawn> Param_Class, const struct FTransform& SpawnTransform);
	void Server_SendChatMessage(const struct FRChatMessage& ChatMessage);
	void Server_SetChecksum(int32 Checksum);
	void Server_SetDeployableDepot(int32 NewDepot);
	void Server_SetHasFinishedLoading();
	void Server_SetReadyState(bool bReady);
	void Server_SetSpawn(ETeamType SpawnTeam, ESelectedSpawn NewSpawnPoint);
	void Server_SetTeamType(ETeamType NewTeam);
	void Server_StartMapReferendum(TSubclassOf<class AMapReferendum> ReferendumClass, const class FString& MapURL);
	void Server_StartPlayerReferendum(TSubclassOf<class APlayerReferendum> ReferendumClass, class AReadyOrNotPlayerState* TargetPlayer);
	void Server_StartReferendum(TSubclassOf<class AReferendum> ReferendumClass);
	void Server_StartSpectating();
	void Server_StatFile(bool bStartStatFile);
	void Server_SwapPlayersTeam(class APlayerState* Ps);
	void ServerStatFileStart();
	void ServerStatFileStop();
	void SetAllComponentsUseParentsBounds();
	void SetClubMusicMasterVolume(float Volume);
	void SetHostMigrationComplete();
	void SetMousePosition(float LocationX, float LocationY);
	void SetPreferredTeamUniqueNetIdOnConnection(const class FString& UniqueId);
	void SetRosterStressValue(float Stress);
	void SetScorelimit(int32 Score);
	void SetServerPasswordOnConnection(const class FString& Password);
	void SetShouldShowMouseCursor(bool bShow);
	void SetTimelimit(float Time);
	void ShowCoopScoreChangeWidget(float ScoreChangeValue);
	void SkipTutorial();
	void SoftWinCoop();
	void SpawnAI(const class FString& TableName, int32 Count);
	void SpawnAIAtLocation(const class FString& TableName, const struct FVector& Location, const struct FVector& MoveLocation);
	void SpawnBotsForGame(int32 BotCount);
	void SpawnRandomAI(int32 Count);
	void StartBleeding();
	void StartMatchmaking();
	void StartSpeaking();
	void StartSwatAutomation();
	void StopSpeaking();
	void StopSwatAutomation();
	void StopVoteInput();
	bool StreamInLevel(const class FString& NewLevel, const class FString& Options, class ULevelStreaming** OutStreamedLevel, const struct FLevelStreamOptions& LevelStreamOptions);
	bool StreamInSession(const struct FBlueprintSessionResult& SessionResult, class ULevelStreaming** OutStreamedLevel, bool bShouldCreateLoadingScreen);
	void SwapAllItemSkeletalMeshesToCubes();
	void TakeDamageExec(float DamageAmount);
	void TeleportToNextRemainingAI();
	void TeleportUp();
	void TestMatchmakingServerCreateParty();
	void TestMatchmakingServerRefresh();
	void TestSendCrash();
	void ToggleDeployMenu();
	void ToggleGodModeOnEveryone();
	void ToggleRTXDMO();
	void UnhideAllItemMeshes();
	void UnhideAllSmallItemMeshes();
	void UnhideAllWeaponAttachments();
	void UpdateAchievementProgress(const class FString& ID, float Percent);
	void UpdateMouseCursorVisibility();
	void Vote(bool VoteYes);
	void WinCoop();

	bool IsOverlayHudVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotPlayerController">();
	}
	static class AReadyOrNotPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotPlayerController>();
	}
};
static_assert(alignof(AReadyOrNotPlayerController) == 0x000008, "Wrong alignment on AReadyOrNotPlayerController");
static_assert(sizeof(AReadyOrNotPlayerController) == 0x000A48, "Wrong size on AReadyOrNotPlayerController");
static_assert(offsetof(AReadyOrNotPlayerController, ProgressionComp) == 0x000588, "Member 'AReadyOrNotPlayerController::ProgressionComp' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, ServerSideChecksum) == 0x000594, "Member 'AReadyOrNotPlayerController::ServerSideChecksum' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, bShouldShowMouseCursor) == 0x0005A4, "Member 'AReadyOrNotPlayerController::bShouldShowMouseCursor' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnPawnPossessed) == 0x0005A8, "Member 'AReadyOrNotPlayerController::OnPawnPossessed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnExitSettingsMenu) == 0x0005B8, "Member 'AReadyOrNotPlayerController::OnExitSettingsMenu' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnOutOfBoundsChanged) == 0x0005C8, "Member 'AReadyOrNotPlayerController::OnOutOfBoundsChanged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnPreClientTravel) == 0x0005D8, "Member 'AReadyOrNotPlayerController::OnPreClientTravel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, RespawnTimeLeft) == 0x0005F8, "Member 'AReadyOrNotPlayerController::RespawnTimeLeft' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, TabMenuWidget) == 0x000600, "Member 'AReadyOrNotPlayerController::TabMenuWidget' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, TabMenuWidgetClass) == 0x000608, "Member 'AReadyOrNotPlayerController::TabMenuWidgetClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, SubtitlesWidget) == 0x000610, "Member 'AReadyOrNotPlayerController::SubtitlesWidget' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, SpectateCamera) == 0x000620, "Member 'AReadyOrNotPlayerController::SpectateCamera' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, StreamingLevels) == 0x000628, "Member 'AReadyOrNotPlayerController::StreamingLevels' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, JoinSession) == 0x000638, "Member 'AReadyOrNotPlayerController::JoinSession' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, StreamingLevel) == 0x000640, "Member 'AReadyOrNotPlayerController::StreamingLevel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, StreamingOptions) == 0x000650, "Member 'AReadyOrNotPlayerController::StreamingOptions' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, ReplicatedMapList) == 0x000680, "Member 'AReadyOrNotPlayerController::ReplicatedMapList' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnMapListReplicated) == 0x000690, "Member 'AReadyOrNotPlayerController::OnMapListReplicated' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, VoteAntiSpamDebouncer) == 0x0006A0, "Member 'AReadyOrNotPlayerController::VoteAntiSpamDebouncer' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, MyVoteData) == 0x0006A8, "Member 'AReadyOrNotPlayerController::MyVoteData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, bStatsProfiledQueued) == 0x0006D8, "Member 'AReadyOrNotPlayerController::bStatsProfiledQueued' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, ProtectedWidgetClasses) == 0x0006E0, "Member 'AReadyOrNotPlayerController::ProtectedWidgetClasses' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, bCanOpenOptionsMenu) == 0x000708, "Member 'AReadyOrNotPlayerController::bCanOpenOptionsMenu' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, CreatedWidgetMap) == 0x000710, "Member 'AReadyOrNotPlayerController::CreatedWidgetMap' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, Rep_MatchmakingServerInfo) == 0x000770, "Member 'AReadyOrNotPlayerController::Rep_MatchmakingServerInfo' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, Rep_MatchmakingPartyInit) == 0x0007E8, "Member 'AReadyOrNotPlayerController::Rep_MatchmakingPartyInit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, SwatAutomationManager) == 0x000898, "Member 'AReadyOrNotPlayerController::SwatAutomationManager' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, DebugActorList) == 0x0008A0, "Member 'AReadyOrNotPlayerController::DebugActorList' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnHudWidgetsClearedComplete) == 0x000920, "Member 'AReadyOrNotPlayerController::OnHudWidgetsClearedComplete' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, TestCube) == 0x000930, "Member 'AReadyOrNotPlayerController::TestCube' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, TestMaterial) == 0x000938, "Member 'AReadyOrNotPlayerController::TestMaterial' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, bStartedCoopAsSpectator) == 0x000948, "Member 'AReadyOrNotPlayerController::bStartedCoopAsSpectator' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, LastKilledCharacter) == 0x000950, "Member 'AReadyOrNotPlayerController::LastKilledCharacter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, bIsReplaySpectator) == 0x000960, "Member 'AReadyOrNotPlayerController::bIsReplaySpectator' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnRTXDMOChanged) == 0x000988, "Member 'AReadyOrNotPlayerController::OnRTXDMOChanged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, ChatMessages) == 0x000998, "Member 'AReadyOrNotPlayerController::ChatMessages' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, ActiveProjectiles) == 0x0009C0, "Member 'AReadyOrNotPlayerController::ActiveProjectiles' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnPlayerReadyChange) == 0x000A18, "Member 'AReadyOrNotPlayerController::OnPlayerReadyChange' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, PauseMenu) == 0x000A40, "Member 'AReadyOrNotPlayerController::PauseMenu' has a wrong offset!");

// Class ReadyOrNot.ReplayController
// 0x00D8 (0x0B20 - 0x0A48)
class AReplayController : public AReadyOrNotPlayerController
{
public:
	TArray<class AActor*>                         SelectableActors;                                  // 0x0A48(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class AActor*                                 SelectedActor;                                     // 0x0A58(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedActorIndex;                                // 0x0A60(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReplayMenuOpen;                                 // 0x0A64(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2080[0x3];                                     // 0x0A65(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AReplaySplineActor*                     ReplaySplineActor;                                 // 0x0A68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalSplineTime;                                   // 0x0A70(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFollowingSpline;                                // 0x0A74(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2081[0x3];                                     // 0x0A75(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaSplineTime;                                   // 0x0A78(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineRotation                               SplineRotationType;                                // 0x0A7C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2082[0x3];                                     // 0x0A7D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UReplayControls*                        ReplayControls;                                    // 0x0A80(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraState                                  CurrentCameraState;                                // 0x0A88(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2083[0x3];                                     // 0x0A89(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdjustableVerticalOffset;                          // 0x0A8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMountedTransformLock;                             // 0x0A90(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2084[0x7];                                     // 0x0A91(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 MountedMesh;                                       // 0x0A98(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MountedBoneName;                                   // 0x0AA0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FReplaySubMesh>                 MountedSubMeshes;                                  // 0x0AB0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                MountedLocationOffset;                             // 0x0AC0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MountedRotationOffset;                             // 0x0ACC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2085[0x18];                                    // 0x0AD8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            EscapeWidgetInstance;                              // 0x0AF0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2086[0x28];                                    // 0x0AF8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSplinePoint(const struct FVector& Location, const struct FRotator& Rotation);
	void ApplyCameraState();
	void ApplyNewCameraState();
	void BeginFollowingSpline();
	void ClearSplinePoints();
	void CreateMountData();
	class FString GetActorName(class AActor* Actor);
	TArray<class ACivilianCharacter*> GetAllCivilianAI();
	TArray<class APlayerCharacter*> GetAllPlayers();
	TArray<class ASuspectCharacter*> GetAllSuspectAI();
	TArray<class ASWATCharacter*> GetAllSwatAI();
	TArray<struct FSplinePoint> GetSplinePoints();
	void NextActor();
	void NextSelectableActor();
	void OnChangeSelectedActor();
	void OnDynamicLoad();
	void OnFirstDynamicLoad();
	void OnPauseMenuClosed();
	void OnPlayerChangeCameraState(ECameraState NewState);
	void OnPostDynamicLoad();
	void OnScrubInitiated();
	void PauseReplay();
	void PreviousActor();
	void PreviousSelectableActor();
	void RefreshSelectableActors();
	void RemoveSplinePoint(int32 Param_Index);
	void RevertPreviousCameraState();
	void SetCurrentReplayPlayRate(float PlayRate);
	void SetCurrentReplayTimeToSeconds(float Seconds);
	bool SetPaused(bool bDoPause);
	bool SetPausedState(bool bDoPause, bool bMuteAudio);
	void SetViewOverride();
	void SkipReplayBackward();
	void SkipReplayForward();
	void StopFollowingSpline();
	void ToggleHUD();

	float GetCurrentReplayCurrentTimeInSeconds() const;
	float GetCurrentReplayTotalTimeInSeconds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplayController">();
	}
	static class AReplayController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReplayController>();
	}
};
static_assert(alignof(AReplayController) == 0x000008, "Wrong alignment on AReplayController");
static_assert(sizeof(AReplayController) == 0x000B20, "Wrong size on AReplayController");
static_assert(offsetof(AReplayController, SelectableActors) == 0x000A48, "Member 'AReplayController::SelectableActors' has a wrong offset!");
static_assert(offsetof(AReplayController, SelectedActor) == 0x000A58, "Member 'AReplayController::SelectedActor' has a wrong offset!");
static_assert(offsetof(AReplayController, SelectedActorIndex) == 0x000A60, "Member 'AReplayController::SelectedActorIndex' has a wrong offset!");
static_assert(offsetof(AReplayController, bIsReplayMenuOpen) == 0x000A64, "Member 'AReplayController::bIsReplayMenuOpen' has a wrong offset!");
static_assert(offsetof(AReplayController, ReplaySplineActor) == 0x000A68, "Member 'AReplayController::ReplaySplineActor' has a wrong offset!");
static_assert(offsetof(AReplayController, TotalSplineTime) == 0x000A70, "Member 'AReplayController::TotalSplineTime' has a wrong offset!");
static_assert(offsetof(AReplayController, bIsFollowingSpline) == 0x000A74, "Member 'AReplayController::bIsFollowingSpline' has a wrong offset!");
static_assert(offsetof(AReplayController, DeltaSplineTime) == 0x000A78, "Member 'AReplayController::DeltaSplineTime' has a wrong offset!");
static_assert(offsetof(AReplayController, SplineRotationType) == 0x000A7C, "Member 'AReplayController::SplineRotationType' has a wrong offset!");
static_assert(offsetof(AReplayController, ReplayControls) == 0x000A80, "Member 'AReplayController::ReplayControls' has a wrong offset!");
static_assert(offsetof(AReplayController, CurrentCameraState) == 0x000A88, "Member 'AReplayController::CurrentCameraState' has a wrong offset!");
static_assert(offsetof(AReplayController, AdjustableVerticalOffset) == 0x000A8C, "Member 'AReplayController::AdjustableVerticalOffset' has a wrong offset!");
static_assert(offsetof(AReplayController, bMountedTransformLock) == 0x000A90, "Member 'AReplayController::bMountedTransformLock' has a wrong offset!");
static_assert(offsetof(AReplayController, MountedMesh) == 0x000A98, "Member 'AReplayController::MountedMesh' has a wrong offset!");
static_assert(offsetof(AReplayController, MountedBoneName) == 0x000AA0, "Member 'AReplayController::MountedBoneName' has a wrong offset!");
static_assert(offsetof(AReplayController, MountedSubMeshes) == 0x000AB0, "Member 'AReplayController::MountedSubMeshes' has a wrong offset!");
static_assert(offsetof(AReplayController, MountedLocationOffset) == 0x000AC0, "Member 'AReplayController::MountedLocationOffset' has a wrong offset!");
static_assert(offsetof(AReplayController, MountedRotationOffset) == 0x000ACC, "Member 'AReplayController::MountedRotationOffset' has a wrong offset!");
static_assert(offsetof(AReplayController, EscapeWidgetInstance) == 0x000AF0, "Member 'AReplayController::EscapeWidgetInstance' has a wrong offset!");

// Class ReadyOrNot.TutorialTextPrompt_Widget
// 0x0000 (0x0260 - 0x0260)
class UTutorialTextPrompt_Widget : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialTextPrompt_Widget">();
	}
	static class UTutorialTextPrompt_Widget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialTextPrompt_Widget>();
	}
};
static_assert(alignof(UTutorialTextPrompt_Widget) == 0x000008, "Wrong alignment on UTutorialTextPrompt_Widget");
static_assert(sizeof(UTutorialTextPrompt_Widget) == 0x000260, "Wrong size on UTutorialTextPrompt_Widget");

// Class ReadyOrNot.AdminGameControls
// 0x0000 (0x0260 - 0x0260)
class UAdminGameControls : public UUserWidget
{
public:
	void GetKickablePlayers(TArray<class APlayerState*>* KickablePlayers);
	bool IsAdmin();
	void KickPlayer(class APlayerState* KickingPlayerState, class FText Reason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdminGameControls">();
	}
	static class UAdminGameControls* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdminGameControls>();
	}
};
static_assert(alignof(UAdminGameControls) == 0x000008, "Wrong alignment on UAdminGameControls");
static_assert(sizeof(UAdminGameControls) == 0x000260, "Wrong size on UAdminGameControls");

// Class ReadyOrNot.RosterCharacterArchetype
// 0x0050 (0x0080 - 0x0030)
class URosterCharacterArchetype final  : public UPrimaryDataAsset
{
public:
	TArray<class UCustomizationCharacter*>        CharacterPool;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCustomizationVoice*>            VoicePool;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           BackgroundTextPool;                                // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           FirstNamePool;                                     // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           LastNamePool;                                      // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterCharacterArchetype">();
	}
	static class URosterCharacterArchetype* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterCharacterArchetype>();
	}
};
static_assert(alignof(URosterCharacterArchetype) == 0x000008, "Wrong alignment on URosterCharacterArchetype");
static_assert(sizeof(URosterCharacterArchetype) == 0x000080, "Wrong size on URosterCharacterArchetype");
static_assert(offsetof(URosterCharacterArchetype, CharacterPool) == 0x000030, "Member 'URosterCharacterArchetype::CharacterPool' has a wrong offset!");
static_assert(offsetof(URosterCharacterArchetype, VoicePool) == 0x000040, "Member 'URosterCharacterArchetype::VoicePool' has a wrong offset!");
static_assert(offsetof(URosterCharacterArchetype, BackgroundTextPool) == 0x000050, "Member 'URosterCharacterArchetype::BackgroundTextPool' has a wrong offset!");
static_assert(offsetof(URosterCharacterArchetype, FirstNamePool) == 0x000060, "Member 'URosterCharacterArchetype::FirstNamePool' has a wrong offset!");
static_assert(offsetof(URosterCharacterArchetype, LastNamePool) == 0x000070, "Member 'URosterCharacterArchetype::LastNamePool' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotGameState
// 0x0570 (0x07E0 - 0x0270)
class AReadyOrNotGameState : public AGameStateBase
{
public:
	uint8                                         Pad_2087[0x34];                                    // 0x0270(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RandomStreamSeed;                                  // 0x02A4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2088[0x10];                                    // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         NumSuspectsActive;                                 // 0x02B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumCiviliansActive;                                // 0x02B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumSwatActive;                                     // 0x02BA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2089[0x5];                                     // 0x02BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UReadyOrNotVoiceConfig*                 VoiceConfig;                                       // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208A[0x8];                                     // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoadout_V2*                            Loadout_V2;                                        // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotLoadoutManager*              LoadoutFunctionLibrary;                            // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           NextHost;                                          // 0x02E0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MigrationGUID;                                     // 0x02E8(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208B[0x4];                                     // 0x02F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasHostFinishedLoading;                           // 0x02FC(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208C[0x3];                                     // 0x02FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABaseItem*>                      AllItems;                                          // 0x0300(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AEvidenceActor*>                 AllEvidenceActors;                                 // 0x0310(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AReportableActor*>               AllReportableActors;                               // 0x0320(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ATrapActorAttachedToDoor*>       AllDoorTrapActors;                                 // 0x0330(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ACoverLandmark*>                 AllCoverLandmarks;                                 // 0x0340(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AWallHoleTraversal*>             AllWallHoles;                                      // 0x0350(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class APairedInteractionDriver*>       AllPairedInteractionActors;                        // 0x0360(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UDataTable*>                     LoadedDataTables;                                  // 0x0370(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class AScoringManager*                        ScoringManager;                                    // 0x0380(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class AAIFactionManager*> AIFactionManagers;                                 // 0x0388(0x0050)(NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    Rep_GameModeSettings;                              // 0x03D8(0x0010)(Net, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TimeTillGameStartCountdown;                        // 0x03E8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208D[0xC];                                     // 0x03EC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABadAIAction*>                   BadAIActionActors;                                 // 0x03F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasLeftLoadOut;                                   // 0x0408(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208E[0x7];                                     // 0x0409(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelStreaming*                        PreMissionStreamedLevel;                           // 0x0410(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  SubPreMissionPlanningLevel;                        // 0x0418(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208F[0x8];                                     // 0x0440(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ModeName;                                          // 0x0448(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ModeRules;                                         // 0x0460(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class AObjective*>                     MissionObjectives;                                 // 0x0478(0x0010)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMissionObjectivesUpdated;                        // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObituaryData*                          ObituaryData;                                      // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnnounceReinforcements;                           // 0x04A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRadioGlareEnabled;                                // 0x04A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2090[0x6];                                     // 0x04A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             ReplenishAllAmmoSound;                             // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASpectatePawn*>                  SpectatePawns;                                     // 0x04B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           RedTeamPlayers;                                    // 0x04C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           BlueTeamPlayers;                                   // 0x04D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AThrownItem*>                    AllThrownItems;                                    // 0x04E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          AllDoors;                                          // 0x04F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           AllReadyOrNotCharacters;                           // 0x0500(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ACyberneticCharacter*>           AllAICharacters;                                   // 0x0510(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UInteractableComponent*>         AllInteractableComponents;                         // 0x0520(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    AnnouncerAudioComponent;                           // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalMissionAbuseCount;                            // 0x0538(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2091[0x4];                                     // 0x053C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TScriptInterface<class IListenForDeath>> DeathListeners;                                    // 0x0540(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TScriptInterface<class IListenForGameStart>> GameStartListeners;                                // 0x0550(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TScriptInterface<class IListenForGameEnd>> GameEndListeners;                                  // 0x0560(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bDisableEquipment;                                 // 0x0570(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCommandChat;                                // 0x0571(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseReinforcements;                                // 0x0572(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2092[0x1];                                     // 0x0573(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Reinforcements_TimeRemaining;                      // 0x0574(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunWarmup;                                        // 0x0578(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2093[0x7];                                     // 0x0579(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     SceneCapturePlayerCameraClass;                     // 0x0580(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowEnemiesAsSuspects;                            // 0x0588(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2094[0x7];                                     // 0x0589(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKillFeedData>                  KillFeedData;                                      // 0x0590(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateKillFeed;                                  // 0x05A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         ServerTimeUntilNextMap;                            // 0x05B0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2095[0x4];                                     // 0x05B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameRulesIntroAnnouncerRowName;                    // 0x05B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitingForPlayers;                                // 0x05C8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2096[0x3];                                     // 0x05C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlanningTimeLeft;                                  // 0x05CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RedTeamWins;                                       // 0x05D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlueTeamWins;                                      // 0x05D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2097[0x8];                                     // 0x05D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnWinsUpdated;                                     // 0x05E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         EndPlayTimer;                                      // 0x05F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundTimeRemaining;                                // 0x05F4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTimelimit;                                     // 0x05F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2098[0x3];                                     // 0x05F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Scorelimit;                                        // 0x05FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceMatchStarted;                             // 0x0600(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2099[0x4];                                     // 0x0604(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AReferendum*                            CurrentReferendum;                                 // 0x0608(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AReferendum>>        AllowedReferendumTypes;                            // 0x0610(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bCanShowScoreboard;                                // 0x0620(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePlanningUICamera;                              // 0x0621(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209A[0x2];                                     // 0x0622(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RoundTimeElapsed;                                  // 0x0624(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundsPlayed;                                      // 0x0628(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundsToPlay;                                      // 0x062C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     RoundWinningTeam;                                  // 0x0630(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     MatchWinningTeam;                                  // 0x0631(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209B[0x6];                                     // 0x0632(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotPlayerState*>         RoundWinners;                                      // 0x0638(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChatMessageReceived;                             // 0x0648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 MissionName;                                       // 0x0658(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MissionDescription;                                // 0x0668(0x0018)(Edit, BlueprintVisible, Net, NativeAccessSpecifierPublic)
	EMatchState                                   MatchState;                                        // 0x0680(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209C[0x7];                                     // 0x0681(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCharacterArrested;                               // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterKilled;                                 // 0x0698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 NextURLReplicated;                                 // 0x06A8(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSequenceStarted;                                 // 0x06B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FName>                           WhitelistedLabels;                                 // 0x06C8(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UDebugDisplayWidget>        DebugDisplayWidget;                                // 0x06D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ModeURL_Replicated;                                // 0x06E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFloorMapPointData>             DrawingPointData;                                  // 0x06F0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	bool                                          bPvPMode;                                          // 0x0700(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanReportToTOC;                                   // 0x0701(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209D[0x2];                                     // 0x0702(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GametypeDamageModifier;                            // 0x0704(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadDamageModifier;                                // 0x0708(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootDamageModifier;                                // 0x070C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegDamageModifier;                                 // 0x0710(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmDamageModifier;                                 // 0x0714(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtherLimbDamageModifier;                           // 0x0718(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreeForAll;                                       // 0x071C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablePickups;                                   // 0x071D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRevivesAllowed : 1;                               // 0x071E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_209E[0x1];                                     // 0x071F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRChatMessage>                  SavedChatMessages;                                 // 0x0720(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bBallisticsDebug;                                  // 0x0730(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamageDebug;                                      // 0x0731(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpeechRecognitionDebug;                           // 0x0732(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGOAPDebug;                                        // 0x0733(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnnounceTeamReinforcements;                       // 0x0734(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209F[0x3];                                     // 0x0735(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Msg_BothTeamsReinforced;                           // 0x0738(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Msg_RedTeamReinforced;                             // 0x0750(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Msg_BlueTeamReinforced;                            // 0x0768(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UChallenge>>         GameModeChallenges;                                // 0x0780(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         bInPlanningMenu : 1;                               // 0x0790(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_20A0[0x3];                                     // 0x0791(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomTimeDilationApplied;                         // 0x0794(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class APlayerController*>              AdminPlayerControllers;                            // 0x0798(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPublic)
	class ATOCManager*                            TOCManager;                                        // 0x07A8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideLevelEffectsInPreMission;                     // 0x07B0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20A1[0x7];                                     // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APostProcessVolume*>             WorldPostProcessVolumes;                           // 0x07B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AExponentialHeightFog*>          WorldExponentialHeightFogs;                        // 0x07C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20A2[0x8];                                     // 0x07D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDeathListener(TScriptInterface<class IListenForDeath> DeathListener);
	void AddGameEndListener(TScriptInterface<class IListenForGameEnd> GameEndListener);
	void AddGameStartListener(TScriptInterface<class IListenForGameStart> GameStartListener);
	void Client_BindCharacterEvents(class APlayerCharacter* Character);
	class UReadyOrNotProfile* GetCurrentProfile();
	int32 GetCurrentSuspectScore();
	int32 GetCurrentSwatScore();
	TArray<struct FDeploymentStatus> GetDeploymentStatusOfPlayers();
	struct FGameModeSettings GetGameModeSettings();
	class FString GetMapURL();
	int32 GetMaxSuspectScore();
	int32 GetMaxSwatScore();
	void GetNextMapMode(class FString* Map, class FString* Mode);
	TArray<class AReadyOrNotPlayerState*> GetPlayerStatesOfTeam(ETeamType Team);
	void GetPlayerStatesOnTeamOrderedByScore(ETeamType Team, TArray<class AReadyOrNotPlayerState*>* PlayerStates);
	int32 GetRemainingRounds();
	float GetTeamScore(ETeamType Team);
	float GetWinningScore(bool* bUsesScoring);
	bool IsAdminPlayerController(class APlayerController* PlayerController);
	bool IsEveryoneReady();
	void LoadStartupWidgetsAfterLoadingScreen();
	void Multicast_BroadcastChatMessage(const struct FRChatMessage& ChatMessage);
	void Multicast_OnCharacterDied(class AReadyOrNotCharacter* Victim, class AReadyOrNotCharacter* Killer, class AActor* Inflictor);
	void Multicast_OnGameEnded();
	void Multicast_OnGameStarted();
	void Multicast_OnRoundReset();
	void Multicast_PlayAnnouncerForTeam(const class FString& SpeechRowName, ETeamType TeamType);
	void Multicast_PlaySequence(class ULevelSequence* Sequence);
	void Multicast_StopSequence(class ULevelSequence* Sequence);
	void OnAlphaAccessChecked(bool bBanned, const class FString& BanReason);
	void OnAuthenticationResponse(bool bSuccess, bool bSerialFound, bool bSerialValid, const class FString& FailedReason);
	void OnCharacterArrested__DelegateSignature(class AReadyOrNotCharacter* Character, class AReadyOrNotCharacter* ArrestedBy);
	void OnCharacterKilled__DelegateSignature(class AReadyOrNotCharacter* Character, class AReadyOrNotCharacter* KilledBy);
	void OnChatMessage__DelegateSignature(const struct FRChatMessage& Message);
	void OnLoadoutFinished();
	void OnRep_CustomTimeDilation();
	void OnRep_DrawPointDataChanged();
	void OnRep_MatchState();
	void OnRep_MissionObjectives();
	void OnRep_NextHost();
	void OnRep_StreamSeed();
	void OnRep_WinsUpdated();
	void OnSequenceStarted__DelegateSignature(class ULevelSequence* LevelSequence);
	void OnSequenceStartedFunc(class ULevelSequence* LevelSequence);
	void OnUpdateKillFeed__DelegateSignature(class AActor* Causer, class ACharacter* InstigatorCharacter, class ACharacter* KilledCharacter);
	void OnWinsUpdated__DelegateSignature();
	void OverWriteModeNameText(class FText NewModeName);
	void PlayerArrested(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void PlayerKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void RemoveDeathListener(TScriptInterface<class IListenForDeath> DeathListener);
	void RemoveGameEndListener(TScriptInterface<class IListenForGameEnd> GameEndListener);
	void RemoveGameStartListener(TScriptInterface<class IListenForGameStart> GameStartListener);
	void ResetReplicatedTimers();
	void SetGlobalSuspendVoiceOver(bool bEnable);
	void SetTimeDilationSynced(float TimeDilation);
	void SkipMVPScreen();
	void UpdateDoorTickIntervals();

	TArray<class AReadyOrNotPlayerController*> GetControllersAvailableForVote() const;
	class FText GetModeText() const;
	class ABadAIAction* GetMostRecentBadAIActionReport() const;
	TArray<class AReadyOrNotPlayerState*> GetPlayersAvailableForVote() const;
	int32 GetTotalMissionAbuseCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotGameState">();
	}
	static class AReadyOrNotGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotGameState>();
	}
};
static_assert(alignof(AReadyOrNotGameState) == 0x000008, "Wrong alignment on AReadyOrNotGameState");
static_assert(sizeof(AReadyOrNotGameState) == 0x0007E0, "Wrong size on AReadyOrNotGameState");
static_assert(offsetof(AReadyOrNotGameState, RandomStreamSeed) == 0x0002A4, "Member 'AReadyOrNotGameState::RandomStreamSeed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, NumSuspectsActive) == 0x0002B8, "Member 'AReadyOrNotGameState::NumSuspectsActive' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, NumCiviliansActive) == 0x0002B9, "Member 'AReadyOrNotGameState::NumCiviliansActive' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, NumSwatActive) == 0x0002BA, "Member 'AReadyOrNotGameState::NumSwatActive' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, VoiceConfig) == 0x0002C0, "Member 'AReadyOrNotGameState::VoiceConfig' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, Loadout_V2) == 0x0002D0, "Member 'AReadyOrNotGameState::Loadout_V2' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, LoadoutFunctionLibrary) == 0x0002D8, "Member 'AReadyOrNotGameState::LoadoutFunctionLibrary' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, NextHost) == 0x0002E0, "Member 'AReadyOrNotGameState::NextHost' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, MigrationGUID) == 0x0002E8, "Member 'AReadyOrNotGameState::MigrationGUID' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bHasHostFinishedLoading) == 0x0002FC, "Member 'AReadyOrNotGameState::bHasHostFinishedLoading' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllItems) == 0x000300, "Member 'AReadyOrNotGameState::AllItems' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllEvidenceActors) == 0x000310, "Member 'AReadyOrNotGameState::AllEvidenceActors' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllReportableActors) == 0x000320, "Member 'AReadyOrNotGameState::AllReportableActors' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllDoorTrapActors) == 0x000330, "Member 'AReadyOrNotGameState::AllDoorTrapActors' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllCoverLandmarks) == 0x000340, "Member 'AReadyOrNotGameState::AllCoverLandmarks' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllWallHoles) == 0x000350, "Member 'AReadyOrNotGameState::AllWallHoles' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllPairedInteractionActors) == 0x000360, "Member 'AReadyOrNotGameState::AllPairedInteractionActors' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, LoadedDataTables) == 0x000370, "Member 'AReadyOrNotGameState::LoadedDataTables' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ScoringManager) == 0x000380, "Member 'AReadyOrNotGameState::ScoringManager' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AIFactionManagers) == 0x000388, "Member 'AReadyOrNotGameState::AIFactionManagers' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, Rep_GameModeSettings) == 0x0003D8, "Member 'AReadyOrNotGameState::Rep_GameModeSettings' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, TimeTillGameStartCountdown) == 0x0003E8, "Member 'AReadyOrNotGameState::TimeTillGameStartCountdown' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, BadAIActionActors) == 0x0003F8, "Member 'AReadyOrNotGameState::BadAIActionActors' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bHasLeftLoadOut) == 0x000408, "Member 'AReadyOrNotGameState::bHasLeftLoadOut' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, PreMissionStreamedLevel) == 0x000410, "Member 'AReadyOrNotGameState::PreMissionStreamedLevel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, SubPreMissionPlanningLevel) == 0x000418, "Member 'AReadyOrNotGameState::SubPreMissionPlanningLevel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ModeName) == 0x000448, "Member 'AReadyOrNotGameState::ModeName' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ModeRules) == 0x000460, "Member 'AReadyOrNotGameState::ModeRules' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, MissionObjectives) == 0x000478, "Member 'AReadyOrNotGameState::MissionObjectives' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, OnMissionObjectivesUpdated) == 0x000488, "Member 'AReadyOrNotGameState::OnMissionObjectivesUpdated' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ObituaryData) == 0x000498, "Member 'AReadyOrNotGameState::ObituaryData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bAnnounceReinforcements) == 0x0004A0, "Member 'AReadyOrNotGameState::bAnnounceReinforcements' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bRadioGlareEnabled) == 0x0004A1, "Member 'AReadyOrNotGameState::bRadioGlareEnabled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ReplenishAllAmmoSound) == 0x0004A8, "Member 'AReadyOrNotGameState::ReplenishAllAmmoSound' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, SpectatePawns) == 0x0004B0, "Member 'AReadyOrNotGameState::SpectatePawns' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, RedTeamPlayers) == 0x0004C0, "Member 'AReadyOrNotGameState::RedTeamPlayers' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, BlueTeamPlayers) == 0x0004D0, "Member 'AReadyOrNotGameState::BlueTeamPlayers' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllThrownItems) == 0x0004E0, "Member 'AReadyOrNotGameState::AllThrownItems' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllDoors) == 0x0004F0, "Member 'AReadyOrNotGameState::AllDoors' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllReadyOrNotCharacters) == 0x000500, "Member 'AReadyOrNotGameState::AllReadyOrNotCharacters' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllAICharacters) == 0x000510, "Member 'AReadyOrNotGameState::AllAICharacters' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllInteractableComponents) == 0x000520, "Member 'AReadyOrNotGameState::AllInteractableComponents' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AnnouncerAudioComponent) == 0x000530, "Member 'AReadyOrNotGameState::AnnouncerAudioComponent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, TotalMissionAbuseCount) == 0x000538, "Member 'AReadyOrNotGameState::TotalMissionAbuseCount' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, DeathListeners) == 0x000540, "Member 'AReadyOrNotGameState::DeathListeners' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, GameStartListeners) == 0x000550, "Member 'AReadyOrNotGameState::GameStartListeners' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, GameEndListeners) == 0x000560, "Member 'AReadyOrNotGameState::GameEndListeners' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bDisableEquipment) == 0x000570, "Member 'AReadyOrNotGameState::bDisableEquipment' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bEnableCommandChat) == 0x000571, "Member 'AReadyOrNotGameState::bEnableCommandChat' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bUseReinforcements) == 0x000572, "Member 'AReadyOrNotGameState::bUseReinforcements' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, Reinforcements_TimeRemaining) == 0x000574, "Member 'AReadyOrNotGameState::Reinforcements_TimeRemaining' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bRunWarmup) == 0x000578, "Member 'AReadyOrNotGameState::bRunWarmup' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, SceneCapturePlayerCameraClass) == 0x000580, "Member 'AReadyOrNotGameState::SceneCapturePlayerCameraClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bShowEnemiesAsSuspects) == 0x000588, "Member 'AReadyOrNotGameState::bShowEnemiesAsSuspects' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, KillFeedData) == 0x000590, "Member 'AReadyOrNotGameState::KillFeedData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, OnUpdateKillFeed) == 0x0005A0, "Member 'AReadyOrNotGameState::OnUpdateKillFeed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ServerTimeUntilNextMap) == 0x0005B0, "Member 'AReadyOrNotGameState::ServerTimeUntilNextMap' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, GameRulesIntroAnnouncerRowName) == 0x0005B8, "Member 'AReadyOrNotGameState::GameRulesIntroAnnouncerRowName' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bWaitingForPlayers) == 0x0005C8, "Member 'AReadyOrNotGameState::bWaitingForPlayers' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, PlanningTimeLeft) == 0x0005CC, "Member 'AReadyOrNotGameState::PlanningTimeLeft' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, RedTeamWins) == 0x0005D0, "Member 'AReadyOrNotGameState::RedTeamWins' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, BlueTeamWins) == 0x0005D4, "Member 'AReadyOrNotGameState::BlueTeamWins' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, OnWinsUpdated) == 0x0005E0, "Member 'AReadyOrNotGameState::OnWinsUpdated' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, EndPlayTimer) == 0x0005F0, "Member 'AReadyOrNotGameState::EndPlayTimer' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, RoundTimeRemaining) == 0x0005F4, "Member 'AReadyOrNotGameState::RoundTimeRemaining' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bUseTimelimit) == 0x0005F8, "Member 'AReadyOrNotGameState::bUseTimelimit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, Scorelimit) == 0x0005FC, "Member 'AReadyOrNotGameState::Scorelimit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, TimeSinceMatchStarted) == 0x000600, "Member 'AReadyOrNotGameState::TimeSinceMatchStarted' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, CurrentReferendum) == 0x000608, "Member 'AReadyOrNotGameState::CurrentReferendum' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllowedReferendumTypes) == 0x000610, "Member 'AReadyOrNotGameState::AllowedReferendumTypes' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bCanShowScoreboard) == 0x000620, "Member 'AReadyOrNotGameState::bCanShowScoreboard' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bUsePlanningUICamera) == 0x000621, "Member 'AReadyOrNotGameState::bUsePlanningUICamera' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, RoundTimeElapsed) == 0x000624, "Member 'AReadyOrNotGameState::RoundTimeElapsed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, RoundsPlayed) == 0x000628, "Member 'AReadyOrNotGameState::RoundsPlayed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, RoundsToPlay) == 0x00062C, "Member 'AReadyOrNotGameState::RoundsToPlay' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, RoundWinningTeam) == 0x000630, "Member 'AReadyOrNotGameState::RoundWinningTeam' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, MatchWinningTeam) == 0x000631, "Member 'AReadyOrNotGameState::MatchWinningTeam' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, RoundWinners) == 0x000638, "Member 'AReadyOrNotGameState::RoundWinners' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, OnChatMessageReceived) == 0x000648, "Member 'AReadyOrNotGameState::OnChatMessageReceived' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, MissionName) == 0x000658, "Member 'AReadyOrNotGameState::MissionName' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, MissionDescription) == 0x000668, "Member 'AReadyOrNotGameState::MissionDescription' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, MatchState) == 0x000680, "Member 'AReadyOrNotGameState::MatchState' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, OnCharacterArrested) == 0x000688, "Member 'AReadyOrNotGameState::OnCharacterArrested' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, OnCharacterKilled) == 0x000698, "Member 'AReadyOrNotGameState::OnCharacterKilled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, NextURLReplicated) == 0x0006A8, "Member 'AReadyOrNotGameState::NextURLReplicated' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, OnSequenceStarted) == 0x0006B8, "Member 'AReadyOrNotGameState::OnSequenceStarted' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, WhitelistedLabels) == 0x0006C8, "Member 'AReadyOrNotGameState::WhitelistedLabels' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, DebugDisplayWidget) == 0x0006D8, "Member 'AReadyOrNotGameState::DebugDisplayWidget' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ModeURL_Replicated) == 0x0006E0, "Member 'AReadyOrNotGameState::ModeURL_Replicated' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, DrawingPointData) == 0x0006F0, "Member 'AReadyOrNotGameState::DrawingPointData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bPvPMode) == 0x000700, "Member 'AReadyOrNotGameState::bPvPMode' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bCanReportToTOC) == 0x000701, "Member 'AReadyOrNotGameState::bCanReportToTOC' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, GametypeDamageModifier) == 0x000704, "Member 'AReadyOrNotGameState::GametypeDamageModifier' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, HeadDamageModifier) == 0x000708, "Member 'AReadyOrNotGameState::HeadDamageModifier' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, FootDamageModifier) == 0x00070C, "Member 'AReadyOrNotGameState::FootDamageModifier' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, LegDamageModifier) == 0x000710, "Member 'AReadyOrNotGameState::LegDamageModifier' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ArmDamageModifier) == 0x000714, "Member 'AReadyOrNotGameState::ArmDamageModifier' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, OtherLimbDamageModifier) == 0x000718, "Member 'AReadyOrNotGameState::OtherLimbDamageModifier' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bFreeForAll) == 0x00071C, "Member 'AReadyOrNotGameState::bFreeForAll' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bDisablePickups) == 0x00071D, "Member 'AReadyOrNotGameState::bDisablePickups' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, SavedChatMessages) == 0x000720, "Member 'AReadyOrNotGameState::SavedChatMessages' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bBallisticsDebug) == 0x000730, "Member 'AReadyOrNotGameState::bBallisticsDebug' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bDamageDebug) == 0x000731, "Member 'AReadyOrNotGameState::bDamageDebug' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bSpeechRecognitionDebug) == 0x000732, "Member 'AReadyOrNotGameState::bSpeechRecognitionDebug' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bGOAPDebug) == 0x000733, "Member 'AReadyOrNotGameState::bGOAPDebug' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bAnnounceTeamReinforcements) == 0x000734, "Member 'AReadyOrNotGameState::bAnnounceTeamReinforcements' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, Msg_BothTeamsReinforced) == 0x000738, "Member 'AReadyOrNotGameState::Msg_BothTeamsReinforced' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, Msg_RedTeamReinforced) == 0x000750, "Member 'AReadyOrNotGameState::Msg_RedTeamReinforced' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, Msg_BlueTeamReinforced) == 0x000768, "Member 'AReadyOrNotGameState::Msg_BlueTeamReinforced' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, GameModeChallenges) == 0x000780, "Member 'AReadyOrNotGameState::GameModeChallenges' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, CustomTimeDilationApplied) == 0x000794, "Member 'AReadyOrNotGameState::CustomTimeDilationApplied' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AdminPlayerControllers) == 0x000798, "Member 'AReadyOrNotGameState::AdminPlayerControllers' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, TOCManager) == 0x0007A8, "Member 'AReadyOrNotGameState::TOCManager' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bHideLevelEffectsInPreMission) == 0x0007B0, "Member 'AReadyOrNotGameState::bHideLevelEffectsInPreMission' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, WorldPostProcessVolumes) == 0x0007B8, "Member 'AReadyOrNotGameState::WorldPostProcessVolumes' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, WorldExponentialHeightFogs) == 0x0007C8, "Member 'AReadyOrNotGameState::WorldExponentialHeightFogs' has a wrong offset!");

// Class ReadyOrNot.IncriminationGS
// 0x00D8 (0x08B8 - 0x07E0)
class AIncriminationGS final  : public AReadyOrNotGameState
{
public:
	FMulticastInlineDelegateProperty_             OnIntelStateChanged;                               // 0x07E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIntelSearchAreaChosen;                           // 0x07F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIntelBuildingChosen;                             // 0x0800(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActiveClueChanged;                               // 0x0810(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPreviousActiveClueChanged;                       // 0x0820(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCluesChanged;                                    // 0x0830(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AEvidenceSpawnPoint*                    ChosenEvidenceSpawn;                               // 0x0840(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEvidenceActor*                         ChosenEvidenceActor;                               // 0x0848(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEvidenceExtractionDevice_Incrim*       ChosenExtractionDevice;                            // 0x0850(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AIncriminationClue*>             Clues;                                             // 0x0858(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<class AIncriminationClueSpawnPoint*>   ClueSpawnPoints;                                   // 0x0868(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	class AIncriminationClue*                     ActiveClue;                                        // 0x0878(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AIncriminationClue*                     PreviousActiveClue;                                // 0x0880(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASplineTrigger_Incrimination*           ChosenEvidenceSearchArea;                          // 0x0888(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingTrigger_Incrimination*         ChosenEvidenceBuilding;                            // 0x0890(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASplineTrigger_Incrimination*>   NonMainIntelSearchZones;                           // 0x0898(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	class AEvidenceExtractionDevice*              CurrentExtractionDevice;                           // 0x08A8(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     PickupTeam;                                        // 0x08B0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEvidenceActorState                           IntelState;                                        // 0x08B1(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntelExtracted;                                   // 0x08B2(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20AB[0x5];                                     // 0x08B3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AnyHigherCluesFound(int32 ClueNumber);
	bool AnyLowerCluesFound(int32 ClueNumber);
	bool DoesPlayerPossessAnyClue(class APlayerCharacter* PlayerCharacter);
	TArray<class AIncriminationClue*> GetAllCluesOfNumber(int32 ClueNumber);
	class AIncriminationClue* GetClue(int32 ClueNumber, bool* bSuccess, bool bMustBeFound);
	void OnActiveClueChanged__DelegateSignature(class AIncriminationClue* Param_ActiveClue);
	void OnCluesChanged__DelegateSignature(const TArray<class AIncriminationClue*>& Param_Clues);
	void OnEvidenceActorStateChanged__DelegateSignature(class AEvidenceActor* EvidenceActor, EEvidenceActorState NewEvidenceState, bool bExtracted);
	void OnEvidenceBuildingChosen__DelegateSignature(class ABuildingTrigger_Incrimination* EvidenceSearchArea);
	void OnEvidenceSearchAreaChosen__DelegateSignature(class ASplineTrigger_Incrimination* EvidenceSearchArea);
	void OnRep_OnActiveClueChanged();
	void OnRep_OnCluesChanged();
	void OnRep_OnIntelBuildingChosen();
	void OnRep_OnIntelSearchAreaChosen();
	void OnRep_OnIntelStateChanged();
	void OnRep_OnPreviousActiveClueChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncriminationGS">();
	}
	static class AIncriminationGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIncriminationGS>();
	}
};
static_assert(alignof(AIncriminationGS) == 0x000008, "Wrong alignment on AIncriminationGS");
static_assert(sizeof(AIncriminationGS) == 0x0008B8, "Wrong size on AIncriminationGS");
static_assert(offsetof(AIncriminationGS, OnIntelStateChanged) == 0x0007E0, "Member 'AIncriminationGS::OnIntelStateChanged' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, OnIntelSearchAreaChosen) == 0x0007F0, "Member 'AIncriminationGS::OnIntelSearchAreaChosen' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, OnIntelBuildingChosen) == 0x000800, "Member 'AIncriminationGS::OnIntelBuildingChosen' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, OnActiveClueChanged) == 0x000810, "Member 'AIncriminationGS::OnActiveClueChanged' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, OnPreviousActiveClueChanged) == 0x000820, "Member 'AIncriminationGS::OnPreviousActiveClueChanged' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, OnCluesChanged) == 0x000830, "Member 'AIncriminationGS::OnCluesChanged' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, ChosenEvidenceSpawn) == 0x000840, "Member 'AIncriminationGS::ChosenEvidenceSpawn' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, ChosenEvidenceActor) == 0x000848, "Member 'AIncriminationGS::ChosenEvidenceActor' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, ChosenExtractionDevice) == 0x000850, "Member 'AIncriminationGS::ChosenExtractionDevice' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, Clues) == 0x000858, "Member 'AIncriminationGS::Clues' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, ClueSpawnPoints) == 0x000868, "Member 'AIncriminationGS::ClueSpawnPoints' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, ActiveClue) == 0x000878, "Member 'AIncriminationGS::ActiveClue' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, PreviousActiveClue) == 0x000880, "Member 'AIncriminationGS::PreviousActiveClue' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, ChosenEvidenceSearchArea) == 0x000888, "Member 'AIncriminationGS::ChosenEvidenceSearchArea' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, ChosenEvidenceBuilding) == 0x000890, "Member 'AIncriminationGS::ChosenEvidenceBuilding' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, NonMainIntelSearchZones) == 0x000898, "Member 'AIncriminationGS::NonMainIntelSearchZones' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, CurrentExtractionDevice) == 0x0008A8, "Member 'AIncriminationGS::CurrentExtractionDevice' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, PickupTeam) == 0x0008B0, "Member 'AIncriminationGS::PickupTeam' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, IntelState) == 0x0008B1, "Member 'AIncriminationGS::IntelState' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, bIntelExtracted) == 0x0008B2, "Member 'AIncriminationGS::bIntelExtracted' has a wrong offset!");

// Class ReadyOrNot.AIAction
// 0x0030 (0x0058 - 0x0028)
class UAIAction : public UObject
{
public:
	uint8                                         Pad_20B2[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Tags;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ACyberneticController*                  OwningController;                                  // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20B3[0x4];                                     // 0x0048(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastMoveRequestPathID;                             // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LastMoveRequestMoveID;                             // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20B4[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbortAction();
	void BeginAction_Blueprint();
	void EndAction_Blueprint();
	void InitAction_Blueprint(class ACyberneticController* Controller);
	void OnCreate_Blueprint(class ACyberneticController* Controller);
	void OnFailedToConsider_Blueprint();
	void OnMoveComplete(class AAIController* Controller, int32 RequestID);
	void OnMoveComplete_Blueprint(class AAIController* Controller, int32 RequestID);
	void OnPathFound(int32 PathId, ERonNavigationQueryResult Result);
	void OnPathFound_Blueprint(int32 PathId, ERonNavigationQueryResult Result);
	void OnSucceededToConsider_Blueprint();
	void OnTakenDamage_Blueprint(float Damage, class AReadyOrNotCharacter* Instigator);
	void RequestMove(const struct FVector& Location, float AcceptanceRadius);
	void Tick_Blueprint(float DeltaTime);

	class FString GatherDebugInfo() const;
	struct FAIActionData GetActionData() const;
	int32 GetActionRunCount() const;
	class ACyberneticCharacter* GetCharacter() const;
	class FName GetMoveStyleOverride() const;
	bool HasTag(class FName Tag) const;
	bool ShouldPerformAction() const;
	bool WantsAbort() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction">();
	}
	static class UAIAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction>();
	}
};
static_assert(alignof(UAIAction) == 0x000008, "Wrong alignment on UAIAction");
static_assert(sizeof(UAIAction) == 0x000058, "Wrong size on UAIAction");
static_assert(offsetof(UAIAction, Tags) == 0x000030, "Member 'UAIAction::Tags' has a wrong offset!");
static_assert(offsetof(UAIAction, OwningController) == 0x000040, "Member 'UAIAction::OwningController' has a wrong offset!");
static_assert(offsetof(UAIAction, LastMoveRequestPathID) == 0x00004C, "Member 'UAIAction::LastMoveRequestPathID' has a wrong offset!");
static_assert(offsetof(UAIAction, LastMoveRequestMoveID) == 0x000050, "Member 'UAIAction::LastMoveRequestMoveID' has a wrong offset!");

// Class ReadyOrNot.RONCameraModifier_CameraShake
// 0x0000 (0x00B0 - 0x00B0)
class URONCameraModifier_CameraShake final  : public UCameraModifier_CameraShake
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RONCameraModifier_CameraShake">();
	}
	static class URONCameraModifier_CameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<URONCameraModifier_CameraShake>();
	}
};
static_assert(alignof(URONCameraModifier_CameraShake) == 0x000008, "Wrong alignment on URONCameraModifier_CameraShake");
static_assert(sizeof(URONCameraModifier_CameraShake) == 0x0000B0, "Wrong size on URONCameraModifier_CameraShake");

// Class ReadyOrNot.AIActionConsideration
// 0x00B0 (0x00D8 - 0x0028)
class UAIActionConsideration : public UObject
{
public:
	uint8                                         bManualCurveEdit : 1;                              // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCustomCurveFunction : 1;                          // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EEasingFunc                                   CurveType;                                         // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInverseX : 1;                                     // 0x002A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInverseY : 1;                                     // 0x002A(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bClamp : 1;                                        // 0x002A(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_20BB[0x5];                                     // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0030(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         bCustomRange : 1;                                  // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_20BC[0x3];                                     // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRange;                                          // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRange;                                          // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffsetX;                                           // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffsetY;                                           // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Exponent;                                          // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SubStep;                                           // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERichCurveInterpMode                          InterpMode;                                        // 0x00D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERichCurveTangentMode                         TangentMode;                                       // 0x00D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20BD[0x2];                                     // 0x00D6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalculateCurve(float X) const;
	float EvaluateResponseCurve(float Param_Score) const;
	float Score(struct FAIActionDecisionContext& Context, bool* bSuccess) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIActionConsideration">();
	}
	static class UAIActionConsideration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIActionConsideration>();
	}
};
static_assert(alignof(UAIActionConsideration) == 0x000008, "Wrong alignment on UAIActionConsideration");
static_assert(sizeof(UAIActionConsideration) == 0x0000D8, "Wrong size on UAIActionConsideration");
static_assert(offsetof(UAIActionConsideration, CurveType) == 0x000029, "Member 'UAIActionConsideration::CurveType' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, Curve) == 0x000030, "Member 'UAIActionConsideration::Curve' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, MinRange) == 0x0000BC, "Member 'UAIActionConsideration::MinRange' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, MaxRange) == 0x0000C0, "Member 'UAIActionConsideration::MaxRange' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, OffsetX) == 0x0000C4, "Member 'UAIActionConsideration::OffsetX' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, OffsetY) == 0x0000C8, "Member 'UAIActionConsideration::OffsetY' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, Exponent) == 0x0000CC, "Member 'UAIActionConsideration::Exponent' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, SubStep) == 0x0000D0, "Member 'UAIActionConsideration::SubStep' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, InterpMode) == 0x0000D4, "Member 'UAIActionConsideration::InterpMode' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, TangentMode) == 0x0000D5, "Member 'UAIActionConsideration::TangentMode' has a wrong offset!");

// Class ReadyOrNot.InventoryComponent
// 0x0378 (0x0428 - 0x00B0)
class UInventoryComponent final  : public UActorComponent
{
public:
	uint8                                         Pad_20BF[0x8];                                     // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnEquippedItemChanged;                             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClientItemAddedToInventory;                      // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemAddedToInventory;                            // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemRemovedFromInventory;                        // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemEquipped;                                    // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemHolstered;                                   // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C0[0x30];                                    // 0x0118(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemChangeRequest                     LatestItemChangeRequest;                           // 0x0148(0x0028)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FItemChangeRequest                     LastReceivedItemChangeRequest;                     // 0x0170(0x0028)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	class ABaseItem*                              QueuedItemSwap;                                    // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseItem*                              LastEquippedItem;                                  // 0x01A0(0x0008)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseWeapon*                            LastEquippedWeapon;                                // 0x01A8(0x0008)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseItem*                              LastEquippedItemWheel;                             // 0x01B0(0x0008)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABaseItem*>                      InventoryItems;                                    // 0x01B8(0x0010)(Edit, Net, ZeroConstructor, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class ABaseItem*>                      RemovedInventoryItems;                             // 0x01C8(0x0010)(Edit, Net, ZeroConstructor, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FSpawnedGear                           SpawnedGear;                                       // 0x01D8(0x0078)(BlueprintVisible, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FSavedLoadout                          LastEquippedLoadout;                               // 0x0250(0x0188)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	class ABaseItem*                              SelectedDevice;                                    // 0x03D8(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C1[0x38];                                    // 0x03E0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemSelectionGroup>            ItemSelectionGroups;                               // 0x0418(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	bool AddInventoryItem(class ABaseItem* Item);
	bool CanEquip(class ABaseItem* Item);
	void Client_NotifyInventoryItemsChanged();
	void Client_NotifyInventoryItemsDestroyed();
	void Client_NotifyInventorySpawned();
	void ClientOnItemAddedToInventory__DelegateSignature(class ABaseItem* Item);
	void DestroyAllEquippedItems();
	bool DestroyInventoryItem(class ABaseItem* Item);
	bool EquipHolsteredItem(bool bInstant);
	class ABaseItem* EquipItemFromGroup_Index(int32 GroupIndex, int32 ItemCategoryIndex);
	class ABaseItem* EquipItemFromGroup_Name(class FName GroupName, int32 ItemCategoryIndex);
	class ABaseItem* EquipItemOfClass(class UClass* ClassType, bool bInstant);
	class ABaseItem* EquipItemOfType(EItemCategory ItemCategory, bool bInstant);
	void EquipLastEquippedItem(bool bInstant, bool bForce);
	void EquipLastEquippedItemWheel(bool bInstant, bool bForce);
	void EquipLastEquippedWeapon(bool bInstant, bool bForce);
	bool Holster(class ABaseItem* Item, bool bInstant);
	bool HolsterEquippedItem(bool bInstant);
	bool IsEquippingItem();
	bool IsEquippingItemOfClass(class UClass* ClassType);
	bool IsEquippingItemOfType(EItemCategory ItemCategory);
	bool IsEquippingSpecificItem(class ABaseItem* Item);
	void Multicast_NotifyInventoryItemsChanged();
	void OnActorRelevancyChanged(class AActor* Actor, bool bIsRelevant);
	void OnEquippedItemChanged__DelegateSignature();
	void OnItemEquipped__DelegateSignature(class ABaseItem* Item);
	void OnItemRemoved__DelegateSignature(class ABaseItem* Item);
	void OnNewItemChangeDrawComplete(class ABaseItem* Item);
	void OnPlayerItemChanged__DelegateSignature(class ABaseItem* Item);
	void OnRep_InventoryItemsChanged();
	void OnRep_ItemChangeRequest();
	void OnRep_SpawnedGear();
	void PlayLocalDraw(const struct FItemChangeRequest& ItemChangeRequest);
	void PlayLocalHolster(const struct FItemChangeRequest& ItemChangeRequest);
	void PlayTPDraw(const struct FItemChangeRequest& ItemChangeRequest);
	bool PutItemInHands(class ABaseItem* Item, bool bInstant, bool bForce);
	bool RemoveInventoryItem(class ABaseItem* Item, bool bNullOwner);
	void Server_AttemptEquipNewLoadout(const struct FSavedLoadout& Loadout);
	void Server_ChangeEquippedItem(const struct FItemChangeRequest& ItemChangeRequest);
	void Server_PlayTPHolster(const struct FItemChangeRequest& ItemChangeRequest);
	void ThrowAllItems();
	void ThrowAllWeapons();
	void ThrowEquippedItem();
	void ThrowSpecificItem(class ABaseItem* Item);

	int32 CountInventoryItemType(EItemCategory ItemCategory) const;
	class ABaseArmour* GetArmour() const;
	class ABaseItem* GetEquippedItem() const;
	class AHeadwear* GetHeadArmour() const;
	class AHeadwear* GetHeadwear() const;
	class ABaseItem* GetHolsteredItem() const;
	class ABaseItem* GetInventoryItemOfClass(class UClass* Param_Class, bool bCanEquipCheck) const;
	class ABaseItem* GetInventoryItemOfClassType(EItemClass ItemClass) const;
	class ABaseItem* GetInventoryItemOfType(EItemCategory ItemCategory) const;
	TArray<class ABaseItem*> GetInventoryItems() const;
	TArray<class ABaseItem*> GetInventoryItemsOfType(EItemCategory ItemCategory) const;
	class ABaseItem* GetLastEquippedItem() const;
	struct FSavedLoadout GetLastEquippedLoadout() const;
	class ABaseWeapon* GetLastEquippedWeapon() const;
	TArray<class ABaseItem*> GetRemovedInventoryItems() const;
	bool HasAnyInventoryItems() const;
	bool HasAnyInventoryItemsOfClass(TSubclassOf<class ABaseItem> ItemClass) const;
	bool HasAnyInventoryItemsOfType(EItemCategory ItemCategory) const;
	bool HasInventoryItem(class ABaseItem* Item) const;
	bool IsAnyBlockingAnimationPlaying() const;
	bool IsAnyItemAttachedToBody() const;
	bool IsAnyItemAttachedToHands() const;
	bool IsEquippedWithShield(class ABaseItem* Item) const;
	bool IsItemEquipped(EItemCategory ItemCategory) const;
	bool IsItemEquipped_Class(TSubclassOf<class ABaseItem> ItemClass) const;
	bool IsWearingAntiFlashGoggles() const;
	bool IsWearingArmour() const;
	bool IsWearingExplosiveVest() const;
	bool IsWearingHeadArmour() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryComponent">();
	}
	static class UInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryComponent>();
	}
};
static_assert(alignof(UInventoryComponent) == 0x000008, "Wrong alignment on UInventoryComponent");
static_assert(sizeof(UInventoryComponent) == 0x000428, "Wrong size on UInventoryComponent");
static_assert(offsetof(UInventoryComponent, OnEquippedItemChanged) == 0x0000B8, "Member 'UInventoryComponent::OnEquippedItemChanged' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnClientItemAddedToInventory) == 0x0000C8, "Member 'UInventoryComponent::OnClientItemAddedToInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnItemAddedToInventory) == 0x0000D8, "Member 'UInventoryComponent::OnItemAddedToInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnItemRemovedFromInventory) == 0x0000E8, "Member 'UInventoryComponent::OnItemRemovedFromInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnItemEquipped) == 0x0000F8, "Member 'UInventoryComponent::OnItemEquipped' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnItemHolstered) == 0x000108, "Member 'UInventoryComponent::OnItemHolstered' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LatestItemChangeRequest) == 0x000148, "Member 'UInventoryComponent::LatestItemChangeRequest' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LastReceivedItemChangeRequest) == 0x000170, "Member 'UInventoryComponent::LastReceivedItemChangeRequest' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, QueuedItemSwap) == 0x000198, "Member 'UInventoryComponent::QueuedItemSwap' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LastEquippedItem) == 0x0001A0, "Member 'UInventoryComponent::LastEquippedItem' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LastEquippedWeapon) == 0x0001A8, "Member 'UInventoryComponent::LastEquippedWeapon' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LastEquippedItemWheel) == 0x0001B0, "Member 'UInventoryComponent::LastEquippedItemWheel' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, InventoryItems) == 0x0001B8, "Member 'UInventoryComponent::InventoryItems' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, RemovedInventoryItems) == 0x0001C8, "Member 'UInventoryComponent::RemovedInventoryItems' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, SpawnedGear) == 0x0001D8, "Member 'UInventoryComponent::SpawnedGear' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LastEquippedLoadout) == 0x000250, "Member 'UInventoryComponent::LastEquippedLoadout' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, SelectedDevice) == 0x0003D8, "Member 'UInventoryComponent::SelectedDevice' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemSelectionGroups) == 0x000418, "Member 'UInventoryComponent::ItemSelectionGroups' has a wrong offset!");

// Class ReadyOrNot.ACNumberOfNearbyAI
// 0x0010 (0x00E8 - 0x00D8)
class UACNumberOfNearbyAI : public UAIActionConsideration
{
public:
	ETeamType                                     TeamType;                                          // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20D7[0x3];                                     // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchRange;                                       // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMustBeVisible;                                    // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20D8[0x7];                                     // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ACNumberOfNearbyAI">();
	}
	static class UACNumberOfNearbyAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UACNumberOfNearbyAI>();
	}
};
static_assert(alignof(UACNumberOfNearbyAI) == 0x000008, "Wrong alignment on UACNumberOfNearbyAI");
static_assert(sizeof(UACNumberOfNearbyAI) == 0x0000E8, "Wrong size on UACNumberOfNearbyAI");
static_assert(offsetof(UACNumberOfNearbyAI, TeamType) == 0x0000D8, "Member 'UACNumberOfNearbyAI::TeamType' has a wrong offset!");
static_assert(offsetof(UACNumberOfNearbyAI, SearchRange) == 0x0000DC, "Member 'UACNumberOfNearbyAI::SearchRange' has a wrong offset!");
static_assert(offsetof(UACNumberOfNearbyAI, bMustBeVisible) == 0x0000E0, "Member 'UACNumberOfNearbyAI::bMustBeVisible' has a wrong offset!");

// Class ReadyOrNot.AC_Health
// 0x0000 (0x00D8 - 0x00D8)
class UAC_Health : public UAIActionConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_Health">();
	}
	static class UAC_Health* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_Health>();
	}
};
static_assert(alignof(UAC_Health) == 0x000008, "Wrong alignment on UAC_Health");
static_assert(sizeof(UAC_Health) == 0x0000D8, "Wrong size on UAC_Health");

// Class ReadyOrNot.BaseActivity
// 0x0180 (0x01A8 - 0x0028)
class UBaseActivity : public UObject
{
public:
	uint8                                         Pad_20D9[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStartActivity;                                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPerformActivity;                                 // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishActivity;                                  // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishActivity_NoOwner;                          // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_20DA[0x18];                                    // 0x0070(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ActivityName;                                      // 0x0088(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         MaxActivityTime;                                   // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivityStartDelay;                                // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNoResetDataOnFinish : 1;                          // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_20DB[0x7];                                     // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveAcceptanceRadius;                              // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20DC[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlobalCooldown;                                    // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGlobalCooldownRandomRange : 1;                    // 0x00BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_20DD[0x3];                                     // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              GlobalCooldownRange;                               // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsProgressActivity : 1;                           // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFinishActivityWhenOverriden : 1;                  // 0x00C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbortMoveWhenActivityFinished : 1;                // 0x00C8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbortMoveWhenActivityOverriden : 1;               // 0x00C8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbortActivityIfCannotReachLocation : 1;           // 0x00C8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbortActivityIfProjectedLocationFailed : 1;       // 0x00C8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbortIfTrackingEnemy : 1;                         // 0x00C8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPauseIfTrackingEnemy : 1;                         // 0x00C8(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPauseIfRecentlyInCombat : 1;                      // 0x00C9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_20DE[0x2];                                     // 0x00CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecentCombatTimeThreshold;                         // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAllowWhileArrested : 1;                           // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoMoveActivity : 1;                               // 0x00D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bResetStateMachineWhenActivityResumed : 1;         // 0x00D0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowPartialMove : 1;                             // 0x00D0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowRePathOnInvalidation : 1;                    // 0x00D0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbortIfNotMovingForAWhile : 1;                    // 0x00D0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysRequestMove : 1;                            // 0x00D0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbortIfSurrendered : 1;                           // 0x00D0(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_20DF[0x3];                                     // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ElapsedActivityTime;                               // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeNotMoving;                                     // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Location;                                          // 0x00DC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ProgressState;                                     // 0x00E8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastAsyncMove;                            // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastRequestedLocation;                             // 0x0104(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20E0[0x5C];                                    // 0x0110(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	EActivityStatus                               ActivityStatus;                                    // 0x016C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20E1[0x5];                                     // 0x016D(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_46 : 1;                                     // 0x0172(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bSearchingPath : 1;                                // 0x0172(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLastRequestedLocationWaitingForRepath : 1;        // 0x0172(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_20E2[0x15];                                    // 0x0173(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastPathLength;                                    // 0x0188(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20E3[0x4];                                     // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACyberneticController*                  OwningController;                                  // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACyberneticCharacter*                   OwningCharacter;                                   // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActivityFiniteStateMachine*            ActivityStateMachine;                              // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EquipItem(EItemCategory InItemCategory);
	void EquipItemOfClass(TSubclassOf<class ABaseItem> InItemClass);
	void EquipWeapon();
	void FinishedActivity_Blueprint(bool bSuccess);
	void OnFinishActivity__DelegateSignature(class UBaseActivity* Activity, class ACyberneticController* Controller);
	void OnIncapacitated(class AReadyOrNotCharacter* IncapacitatedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnPerformActivity__DelegateSignature(class UBaseActivity* Activity, class ACyberneticController* Controller, float DeltaTime);
	void OnStartActivity__DelegateSignature(class UBaseActivity* Activity, class ACyberneticController* Controller);
	bool OverrideFocalPoint_Blueprint(struct FVector* FocalPoint);
	void PerformActivity_Blueprint(float DeltaTime);
	void ResetData();
	void SetLocation(struct FVector& NewLocation, bool bRequestMove, const struct FVector& CustomExtent);
	void StartActivity_Blueprint(class AAIController* Owner);

	bool CanBePushed() const;
	bool CanOverrideActivity() const;
	int32 GetActiveStateID() const;
	class FString GetActiveStateName() const;
	float GetActiveStateUptime() const;
	EActivityStatus GetActivityStatus() const;
	class ACyberneticCharacter* GetCharacter() const;
	struct FVector GetLocation() const;
	class FName GetMoveStyleOverride() const;
	class ACyberneticController* GetOwningController() const;
	class FText GetProgressState() const;
	bool HasReachedLocation(float Tolerance) const;
	bool HasStartedActivity() const;
	bool IsActivityComplete() const;
	bool IsActivityInitialized() const;
	bool IsActivityPaused() const;
	bool IsNoMoveActivity() const;
	bool IsProgressActivity() const;
	bool ShouldForceNoStrafe() const;
	bool ShouldForceStrafe() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseActivity">();
	}
	static class UBaseActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseActivity>();
	}
};
static_assert(alignof(UBaseActivity) == 0x000008, "Wrong alignment on UBaseActivity");
static_assert(sizeof(UBaseActivity) == 0x0001A8, "Wrong size on UBaseActivity");
static_assert(offsetof(UBaseActivity, OnStartActivity) == 0x000030, "Member 'UBaseActivity::OnStartActivity' has a wrong offset!");
static_assert(offsetof(UBaseActivity, OnPerformActivity) == 0x000040, "Member 'UBaseActivity::OnPerformActivity' has a wrong offset!");
static_assert(offsetof(UBaseActivity, OnFinishActivity) == 0x000050, "Member 'UBaseActivity::OnFinishActivity' has a wrong offset!");
static_assert(offsetof(UBaseActivity, OnFinishActivity_NoOwner) == 0x000060, "Member 'UBaseActivity::OnFinishActivity_NoOwner' has a wrong offset!");
static_assert(offsetof(UBaseActivity, ActivityName) == 0x000088, "Member 'UBaseActivity::ActivityName' has a wrong offset!");
static_assert(offsetof(UBaseActivity, MaxActivityTime) == 0x0000A0, "Member 'UBaseActivity::MaxActivityTime' has a wrong offset!");
static_assert(offsetof(UBaseActivity, ActivityStartDelay) == 0x0000A4, "Member 'UBaseActivity::ActivityStartDelay' has a wrong offset!");
static_assert(offsetof(UBaseActivity, MoveAcceptanceRadius) == 0x0000B0, "Member 'UBaseActivity::MoveAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(UBaseActivity, GlobalCooldown) == 0x0000B8, "Member 'UBaseActivity::GlobalCooldown' has a wrong offset!");
static_assert(offsetof(UBaseActivity, GlobalCooldownRange) == 0x0000C0, "Member 'UBaseActivity::GlobalCooldownRange' has a wrong offset!");
static_assert(offsetof(UBaseActivity, RecentCombatTimeThreshold) == 0x0000CC, "Member 'UBaseActivity::RecentCombatTimeThreshold' has a wrong offset!");
static_assert(offsetof(UBaseActivity, ElapsedActivityTime) == 0x0000D4, "Member 'UBaseActivity::ElapsedActivityTime' has a wrong offset!");
static_assert(offsetof(UBaseActivity, TimeNotMoving) == 0x0000D8, "Member 'UBaseActivity::TimeNotMoving' has a wrong offset!");
static_assert(offsetof(UBaseActivity, Location) == 0x0000DC, "Member 'UBaseActivity::Location' has a wrong offset!");
static_assert(offsetof(UBaseActivity, ProgressState) == 0x0000E8, "Member 'UBaseActivity::ProgressState' has a wrong offset!");
static_assert(offsetof(UBaseActivity, TimeSinceLastAsyncMove) == 0x000100, "Member 'UBaseActivity::TimeSinceLastAsyncMove' has a wrong offset!");
static_assert(offsetof(UBaseActivity, LastRequestedLocation) == 0x000104, "Member 'UBaseActivity::LastRequestedLocation' has a wrong offset!");
static_assert(offsetof(UBaseActivity, ActivityStatus) == 0x00016C, "Member 'UBaseActivity::ActivityStatus' has a wrong offset!");
static_assert(offsetof(UBaseActivity, LastPathLength) == 0x000188, "Member 'UBaseActivity::LastPathLength' has a wrong offset!");
static_assert(offsetof(UBaseActivity, OwningController) == 0x000190, "Member 'UBaseActivity::OwningController' has a wrong offset!");
static_assert(offsetof(UBaseActivity, OwningCharacter) == 0x000198, "Member 'UBaseActivity::OwningCharacter' has a wrong offset!");
static_assert(offsetof(UBaseActivity, ActivityStateMachine) == 0x0001A0, "Member 'UBaseActivity::ActivityStateMachine' has a wrong offset!");

// Class ReadyOrNot.BaseCombatMoveActivity
// 0x0030 (0x01D8 - 0x01A8)
class UBaseCombatMoveActivity : public UBaseActivity
{
public:
	class UBaseCombatActivity*                    OwningCombatActivity;                              // 0x01A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FailureCount;                                      // 0x01B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastSuccessTime;                                   // 0x01B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastFailTime;                                      // 0x01B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20E8[0x4];                                     // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseActivity*                          InterruptActivity;                                 // 0x01C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20E9[0xC];                                     // 0x01C8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRequireMagazineWeapon;                            // 0x01D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20EA[0x3];                                     // 0x01D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishCombatMove(bool bSuccess);
	void GenerateNavigablePoints(struct FVector& GenAroundLoc, struct FNavGenerationParameters& NavGenerationParameters, TArray<struct FVector>* OutLocations);
	void RequestCombatMove_Blueprint(float DeltaTime);

	class UBaseActivity* GetInterruptActivity() const;
	bool HasAnyOtherCombatMoveGotLocation(struct FVector& TestLocation, float Tolerance) const;
	bool HasLOSToEnemy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCombatMoveActivity">();
	}
	static class UBaseCombatMoveActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCombatMoveActivity>();
	}
};
static_assert(alignof(UBaseCombatMoveActivity) == 0x000008, "Wrong alignment on UBaseCombatMoveActivity");
static_assert(sizeof(UBaseCombatMoveActivity) == 0x0001D8, "Wrong size on UBaseCombatMoveActivity");
static_assert(offsetof(UBaseCombatMoveActivity, OwningCombatActivity) == 0x0001A8, "Member 'UBaseCombatMoveActivity::OwningCombatActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatMoveActivity, FailureCount) == 0x0001B0, "Member 'UBaseCombatMoveActivity::FailureCount' has a wrong offset!");
static_assert(offsetof(UBaseCombatMoveActivity, LastSuccessTime) == 0x0001B4, "Member 'UBaseCombatMoveActivity::LastSuccessTime' has a wrong offset!");
static_assert(offsetof(UBaseCombatMoveActivity, LastFailTime) == 0x0001B8, "Member 'UBaseCombatMoveActivity::LastFailTime' has a wrong offset!");
static_assert(offsetof(UBaseCombatMoveActivity, InterruptActivity) == 0x0001C0, "Member 'UBaseCombatMoveActivity::InterruptActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatMoveActivity, bRequireMagazineWeapon) == 0x0001D4, "Member 'UBaseCombatMoveActivity::bRequireMagazineWeapon' has a wrong offset!");

// Class ReadyOrNot.FleeingCombatMove
// 0x0048 (0x0220 - 0x01D8)
class UFleeingCombatMove final  : public UBaseCombatMoveActivity
{
public:
	uint8                                         Pad_20EC[0x8];                                     // 0x01D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AThreatAwarenessActor*>          UsedFleePoints;                                    // 0x01E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AThreatAwarenessActor*>          LastExitPoints;                                    // 0x01F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AThreatAwarenessActor*                  LastFleePoint;                                     // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20ED[0x18];                                    // 0x0208(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EFleeType GetFleeType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FleeingCombatMove">();
	}
	static class UFleeingCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFleeingCombatMove>();
	}
};
static_assert(alignof(UFleeingCombatMove) == 0x000008, "Wrong alignment on UFleeingCombatMove");
static_assert(sizeof(UFleeingCombatMove) == 0x000220, "Wrong size on UFleeingCombatMove");
static_assert(offsetof(UFleeingCombatMove, UsedFleePoints) == 0x0001E0, "Member 'UFleeingCombatMove::UsedFleePoints' has a wrong offset!");
static_assert(offsetof(UFleeingCombatMove, LastExitPoints) == 0x0001F0, "Member 'UFleeingCombatMove::LastExitPoints' has a wrong offset!");
static_assert(offsetof(UFleeingCombatMove, LastFleePoint) == 0x000200, "Member 'UFleeingCombatMove::LastFleePoint' has a wrong offset!");

// Class ReadyOrNot.AC_TargetHealth
// 0x0000 (0x00D8 - 0x00D8)
class UAC_TargetHealth : public UAIActionConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_TargetHealth">();
	}
	static class UAC_TargetHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_TargetHealth>();
	}
};
static_assert(alignof(UAC_TargetHealth) == 0x000008, "Wrong alignment on UAC_TargetHealth");
static_assert(sizeof(UAC_TargetHealth) == 0x0000D8, "Wrong size on UAC_TargetHealth");

// Class ReadyOrNot.ReplayCameraPawn
// 0x0B18 (0x0DC0 - 0x02A8)
class AReplayCameraPawn : public ASpectatorPawn
{
public:
	class UCameraComponent*                       PawnCamera;                                        // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplaySpringArm*                       SpringArm;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatingPawnMovement*                  FloatingPawnMovement;                              // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x02C0(0x0560)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPostProcessSettings                   DefaultPostProcessSettings;                        // 0x0820(0x0560)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Sensitivity;                                       // 0x0D80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollAmount;                                        // 0x0D84(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20EE[0x4];                                     // 0x0D88(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialMaxSpeed;                                   // 0x0D8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAcceleration;                               // 0x0D90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDeceleration;                               // 0x0D94(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20EF[0x28];                                    // 0x0D98(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplayCameraPawn">();
	}
	static class AReplayCameraPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReplayCameraPawn>();
	}
};
static_assert(alignof(AReplayCameraPawn) == 0x000010, "Wrong alignment on AReplayCameraPawn");
static_assert(sizeof(AReplayCameraPawn) == 0x000DC0, "Wrong size on AReplayCameraPawn");
static_assert(offsetof(AReplayCameraPawn, PawnCamera) == 0x0002A8, "Member 'AReplayCameraPawn::PawnCamera' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, SpringArm) == 0x0002B0, "Member 'AReplayCameraPawn::SpringArm' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, FloatingPawnMovement) == 0x0002B8, "Member 'AReplayCameraPawn::FloatingPawnMovement' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, PostProcessSettings) == 0x0002C0, "Member 'AReplayCameraPawn::PostProcessSettings' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, DefaultPostProcessSettings) == 0x000820, "Member 'AReplayCameraPawn::DefaultPostProcessSettings' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, Sensitivity) == 0x000D80, "Member 'AReplayCameraPawn::Sensitivity' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, RollAmount) == 0x000D84, "Member 'AReplayCameraPawn::RollAmount' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, InitialMaxSpeed) == 0x000D8C, "Member 'AReplayCameraPawn::InitialMaxSpeed' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, InitialAcceleration) == 0x000D90, "Member 'AReplayCameraPawn::InitialAcceleration' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, InitialDeceleration) == 0x000D94, "Member 'AReplayCameraPawn::InitialDeceleration' has a wrong offset!");

// Class ReadyOrNot.AC_IncapacitationHealth
// 0x0000 (0x00D8 - 0x00D8)
class UAC_IncapacitationHealth : public UAIActionConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_IncapacitationHealth">();
	}
	static class UAC_IncapacitationHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_IncapacitationHealth>();
	}
};
static_assert(alignof(UAC_IncapacitationHealth) == 0x000008, "Wrong alignment on UAC_IncapacitationHealth");
static_assert(sizeof(UAC_IncapacitationHealth) == 0x0000D8, "Wrong size on UAC_IncapacitationHealth");

// Class ReadyOrNot.FirefightGS
// 0x0018 (0x07F8 - 0x07E0)
class AFirefightGS final  : public AReadyOrNotGameState
{
public:
	class FText                                   FreeTextLocalized;                                 // 0x07E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirefightGS">();
	}
	static class AFirefightGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFirefightGS>();
	}
};
static_assert(alignof(AFirefightGS) == 0x000008, "Wrong alignment on AFirefightGS");
static_assert(sizeof(AFirefightGS) == 0x0007F8, "Wrong size on AFirefightGS");
static_assert(offsetof(AFirefightGS, FreeTextLocalized) == 0x0007E0, "Member 'AFirefightGS::FreeTextLocalized' has a wrong offset!");

// Class ReadyOrNot.AC_Ammo
// 0x0000 (0x00D8 - 0x00D8)
class UAC_Ammo : public UAIActionConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_Ammo">();
	}
	static class UAC_Ammo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_Ammo>();
	}
};
static_assert(alignof(UAC_Ammo) == 0x000008, "Wrong alignment on UAC_Ammo");
static_assert(sizeof(UAC_Ammo) == 0x0000D8, "Wrong size on UAC_Ammo");

// Class ReadyOrNot.AC_Armor
// 0x0000 (0x00D8 - 0x00D8)
class UAC_Armor final  : public UAIActionConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_Armor">();
	}
	static class UAC_Armor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_Armor>();
	}
};
static_assert(alignof(UAC_Armor) == 0x000008, "Wrong alignment on UAC_Armor");
static_assert(sizeof(UAC_Armor) == 0x0000D8, "Wrong size on UAC_Armor");

// Class ReadyOrNot.Objective
// 0x0088 (0x02A8 - 0x0220)
class AObjective : public AInfo
{
public:
	class UScoringComponent*                      ScoringComponent;                                  // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnObjectiveUpdated;                                // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ObjectiveCompleteAudio;                            // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ObjectiveFailedAudio;                              // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ObjectiveName;                                     // 0x0248(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ObjectiveDescription;                              // 0x0260(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ECOOPMode                                     LockedToMode;                                      // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFailureEndsMission;                               // 0x0279(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenObjective;                                  // 0x027A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowCompletionWhileHidden;                       // 0x027B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHiddenObjectiveUnlockMethod                  UnlockMethod;                                      // 0x027C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F0[0x3];                                     // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AReportableActor>           UnlockingReportableClass;                          // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AObjective>                 UnlockingObjectiveClass;                           // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReportableActor*                       UnlockingReportable;                               // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AObjective*                             UnlockingObjective;                                // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectiveStatus                              ObjectiveStatus;                                   // 0x02A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20F1[0x7];                                     // 0x02A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetFormattedDescription();
	class FText GetFormattedName();
	void Multicast_UnlockObjective();
	void ObjectiveCompleted();
	void ObjectiveFailed();
	void OnObjectiveCompleted();
	void OnObjectiveCreated();
	void OnObjectiveFailed();
	void OnRep_ObjectiveStatus();
	void OnUnlockingObjectiveUpdated(class AObjective* Objective);
	void OnUnlockingReportableReported(class AReportableActor* ReportableActor);
	void TickObjective_BP();

	EObjectiveStatus GetObjectiveStatus() const;
	bool IsObjectiveCompleted() const;
	bool IsObjectiveFailed() const;
	bool IsObjectiveInProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Objective">();
	}
	static class AObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<AObjective>();
	}
};
static_assert(alignof(AObjective) == 0x000008, "Wrong alignment on AObjective");
static_assert(sizeof(AObjective) == 0x0002A8, "Wrong size on AObjective");
static_assert(offsetof(AObjective, ScoringComponent) == 0x000220, "Member 'AObjective::ScoringComponent' has a wrong offset!");
static_assert(offsetof(AObjective, OnObjectiveUpdated) == 0x000228, "Member 'AObjective::OnObjectiveUpdated' has a wrong offset!");
static_assert(offsetof(AObjective, ObjectiveCompleteAudio) == 0x000238, "Member 'AObjective::ObjectiveCompleteAudio' has a wrong offset!");
static_assert(offsetof(AObjective, ObjectiveFailedAudio) == 0x000240, "Member 'AObjective::ObjectiveFailedAudio' has a wrong offset!");
static_assert(offsetof(AObjective, ObjectiveName) == 0x000248, "Member 'AObjective::ObjectiveName' has a wrong offset!");
static_assert(offsetof(AObjective, ObjectiveDescription) == 0x000260, "Member 'AObjective::ObjectiveDescription' has a wrong offset!");
static_assert(offsetof(AObjective, LockedToMode) == 0x000278, "Member 'AObjective::LockedToMode' has a wrong offset!");
static_assert(offsetof(AObjective, bFailureEndsMission) == 0x000279, "Member 'AObjective::bFailureEndsMission' has a wrong offset!");
static_assert(offsetof(AObjective, bHiddenObjective) == 0x00027A, "Member 'AObjective::bHiddenObjective' has a wrong offset!");
static_assert(offsetof(AObjective, bAllowCompletionWhileHidden) == 0x00027B, "Member 'AObjective::bAllowCompletionWhileHidden' has a wrong offset!");
static_assert(offsetof(AObjective, UnlockMethod) == 0x00027C, "Member 'AObjective::UnlockMethod' has a wrong offset!");
static_assert(offsetof(AObjective, UnlockingReportableClass) == 0x000280, "Member 'AObjective::UnlockingReportableClass' has a wrong offset!");
static_assert(offsetof(AObjective, UnlockingObjectiveClass) == 0x000288, "Member 'AObjective::UnlockingObjectiveClass' has a wrong offset!");
static_assert(offsetof(AObjective, UnlockingReportable) == 0x000290, "Member 'AObjective::UnlockingReportable' has a wrong offset!");
static_assert(offsetof(AObjective, UnlockingObjective) == 0x000298, "Member 'AObjective::UnlockingObjective' has a wrong offset!");
static_assert(offsetof(AObjective, ObjectiveStatus) == 0x0002A0, "Member 'AObjective::ObjectiveStatus' has a wrong offset!");

// Class ReadyOrNot.InteractWithDoorObjective
// 0x0020 (0x02C8 - 0x02A8)
class AInteractWithDoorObjective final  : public AObjective
{
public:
	TArray<class ADoor*>                          Doors;                                             // 0x02A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class FName                                   DoorTag;                                           // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectiveDoorInteractions                    DoorInteractionType;                               // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F2[0x7];                                     // 0x02C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDoorKicked(class ADoor* Door, class AReadyOrNotCharacter* InstigatorCharacter, bool bSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractWithDoorObjective">();
	}
	static class AInteractWithDoorObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractWithDoorObjective>();
	}
};
static_assert(alignof(AInteractWithDoorObjective) == 0x000008, "Wrong alignment on AInteractWithDoorObjective");
static_assert(sizeof(AInteractWithDoorObjective) == 0x0002C8, "Wrong size on AInteractWithDoorObjective");
static_assert(offsetof(AInteractWithDoorObjective, Doors) == 0x0002A8, "Member 'AInteractWithDoorObjective::Doors' has a wrong offset!");
static_assert(offsetof(AInteractWithDoorObjective, DoorTag) == 0x0002B8, "Member 'AInteractWithDoorObjective::DoorTag' has a wrong offset!");
static_assert(offsetof(AInteractWithDoorObjective, DoorInteractionType) == 0x0002C0, "Member 'AInteractWithDoorObjective::DoorInteractionType' has a wrong offset!");

// Class ReadyOrNot.AC_Morale
// 0x0000 (0x00D8 - 0x00D8)
class UAC_Morale : public UAIActionConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_Morale">();
	}
	static class UAC_Morale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_Morale>();
	}
};
static_assert(alignof(UAC_Morale) == 0x000008, "Wrong alignment on UAC_Morale");
static_assert(sizeof(UAC_Morale) == 0x0000D8, "Wrong size on UAC_Morale");

// Class ReadyOrNot.AC_Stress
// 0x0000 (0x00D8 - 0x00D8)
class UAC_Stress : public UAIActionConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_Stress">();
	}
	static class UAC_Stress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_Stress>();
	}
};
static_assert(alignof(UAC_Stress) == 0x000008, "Wrong alignment on UAC_Stress");
static_assert(sizeof(UAC_Stress) == 0x0000D8, "Wrong size on UAC_Stress");

// Class ReadyOrNot.StunDamage
// 0x05E0 (0x0620 - 0x0040)
class UStunDamage : public UDamageType
{
public:
	bool                                          bProjectileStun;                                   // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F4[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMatineeCameraShake>        StunShake;                                         // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0050(0x0560)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UAnimMontage*                           HitMontage_3P;                                     // 0x05B0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CameraRotationOffset;                              // 0x05B8(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AppliedSpeed;                                      // 0x05C4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMovementSpeedWhenStunned;                       // 0x05C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorDamageMultiplier;                              // 0x05CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamageAllDoorPiecesAtOnce;                        // 0x05D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPushDoorWithForce;                             // 0x05D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F5[0x2];                                     // 0x05D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorPushScale;                                     // 0x05D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ImpactSound;                                       // 0x05D8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStunType                                     StunType;                                          // 0x05E0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayAudioWhenHit;                                 // 0x05E1(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F6[0x6];                                     // 0x05E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             StunSoundEffect;                                   // 0x05E8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCauseHealthDamage;                                // 0x05F0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCausesSuppression;                                // 0x05F1(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreaksDestructibles;                              // 0x05F2(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F7[0x1];                                     // 0x05F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SuppressionAmount;                                 // 0x05F4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        SuppressionCameraShake;                            // 0x05F8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustBeLookingAtDamageCauser;                      // 0x0600(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStunLocksAim;                                     // 0x0601(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F8[0x2];                                     // 0x0602(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StunSpeedMultiplier;                               // 0x0604(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponDownLengthOnStun;                            // 0x0608(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNonLethal;                                        // 0x060C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F9[0x3];                                     // 0x060D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LessThanLethalAmount;                              // 0x0610(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalUpcloseDamageIncrease;                   // 0x0614(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalHeadDamageIncrease;                      // 0x0618(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwatAIIsAbuse;                                    // 0x061C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChildAIIsAbuse;                                   // 0x061D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompliantIsAbuse;                                 // 0x061E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArrestedIsAbuse;                                  // 0x061F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ScriptedStunEvent(class AReadyOrNotCharacter* Victim, float* Damage, struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StunDamage">();
	}
	static class UStunDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStunDamage>();
	}
};
static_assert(alignof(UStunDamage) == 0x000010, "Wrong alignment on UStunDamage");
static_assert(sizeof(UStunDamage) == 0x000620, "Wrong size on UStunDamage");
static_assert(offsetof(UStunDamage, bProjectileStun) == 0x000040, "Member 'UStunDamage::bProjectileStun' has a wrong offset!");
static_assert(offsetof(UStunDamage, StunShake) == 0x000048, "Member 'UStunDamage::StunShake' has a wrong offset!");
static_assert(offsetof(UStunDamage, PostProcessSettings) == 0x000050, "Member 'UStunDamage::PostProcessSettings' has a wrong offset!");
static_assert(offsetof(UStunDamage, HitMontage_3P) == 0x0005B0, "Member 'UStunDamage::HitMontage_3P' has a wrong offset!");
static_assert(offsetof(UStunDamage, CameraRotationOffset) == 0x0005B8, "Member 'UStunDamage::CameraRotationOffset' has a wrong offset!");
static_assert(offsetof(UStunDamage, AppliedSpeed) == 0x0005C4, "Member 'UStunDamage::AppliedSpeed' has a wrong offset!");
static_assert(offsetof(UStunDamage, MaxMovementSpeedWhenStunned) == 0x0005C8, "Member 'UStunDamage::MaxMovementSpeedWhenStunned' has a wrong offset!");
static_assert(offsetof(UStunDamage, DoorDamageMultiplier) == 0x0005CC, "Member 'UStunDamage::DoorDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UStunDamage, bDamageAllDoorPiecesAtOnce) == 0x0005D0, "Member 'UStunDamage::bDamageAllDoorPiecesAtOnce' has a wrong offset!");
static_assert(offsetof(UStunDamage, bCanPushDoorWithForce) == 0x0005D1, "Member 'UStunDamage::bCanPushDoorWithForce' has a wrong offset!");
static_assert(offsetof(UStunDamage, DoorPushScale) == 0x0005D4, "Member 'UStunDamage::DoorPushScale' has a wrong offset!");
static_assert(offsetof(UStunDamage, ImpactSound) == 0x0005D8, "Member 'UStunDamage::ImpactSound' has a wrong offset!");
static_assert(offsetof(UStunDamage, StunType) == 0x0005E0, "Member 'UStunDamage::StunType' has a wrong offset!");
static_assert(offsetof(UStunDamage, bPlayAudioWhenHit) == 0x0005E1, "Member 'UStunDamage::bPlayAudioWhenHit' has a wrong offset!");
static_assert(offsetof(UStunDamage, StunSoundEffect) == 0x0005E8, "Member 'UStunDamage::StunSoundEffect' has a wrong offset!");
static_assert(offsetof(UStunDamage, bCauseHealthDamage) == 0x0005F0, "Member 'UStunDamage::bCauseHealthDamage' has a wrong offset!");
static_assert(offsetof(UStunDamage, bCausesSuppression) == 0x0005F1, "Member 'UStunDamage::bCausesSuppression' has a wrong offset!");
static_assert(offsetof(UStunDamage, bBreaksDestructibles) == 0x0005F2, "Member 'UStunDamage::bBreaksDestructibles' has a wrong offset!");
static_assert(offsetof(UStunDamage, SuppressionAmount) == 0x0005F4, "Member 'UStunDamage::SuppressionAmount' has a wrong offset!");
static_assert(offsetof(UStunDamage, SuppressionCameraShake) == 0x0005F8, "Member 'UStunDamage::SuppressionCameraShake' has a wrong offset!");
static_assert(offsetof(UStunDamage, bMustBeLookingAtDamageCauser) == 0x000600, "Member 'UStunDamage::bMustBeLookingAtDamageCauser' has a wrong offset!");
static_assert(offsetof(UStunDamage, bStunLocksAim) == 0x000601, "Member 'UStunDamage::bStunLocksAim' has a wrong offset!");
static_assert(offsetof(UStunDamage, StunSpeedMultiplier) == 0x000604, "Member 'UStunDamage::StunSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UStunDamage, WeaponDownLengthOnStun) == 0x000608, "Member 'UStunDamage::WeaponDownLengthOnStun' has a wrong offset!");
static_assert(offsetof(UStunDamage, bNonLethal) == 0x00060C, "Member 'UStunDamage::bNonLethal' has a wrong offset!");
static_assert(offsetof(UStunDamage, LessThanLethalAmount) == 0x000610, "Member 'UStunDamage::LessThanLethalAmount' has a wrong offset!");
static_assert(offsetof(UStunDamage, AdditionalUpcloseDamageIncrease) == 0x000614, "Member 'UStunDamage::AdditionalUpcloseDamageIncrease' has a wrong offset!");
static_assert(offsetof(UStunDamage, AdditionalHeadDamageIncrease) == 0x000618, "Member 'UStunDamage::AdditionalHeadDamageIncrease' has a wrong offset!");
static_assert(offsetof(UStunDamage, bSwatAIIsAbuse) == 0x00061C, "Member 'UStunDamage::bSwatAIIsAbuse' has a wrong offset!");
static_assert(offsetof(UStunDamage, bChildAIIsAbuse) == 0x00061D, "Member 'UStunDamage::bChildAIIsAbuse' has a wrong offset!");
static_assert(offsetof(UStunDamage, bCompliantIsAbuse) == 0x00061E, "Member 'UStunDamage::bCompliantIsAbuse' has a wrong offset!");
static_assert(offsetof(UStunDamage, bArrestedIsAbuse) == 0x00061F, "Member 'UStunDamage::bArrestedIsAbuse' has a wrong offset!");

// Class ReadyOrNot.FlashbangDamageType
// 0x0000 (0x0620 - 0x0620)
class UFlashbangDamageType : public UStunDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashbangDamageType">();
	}
	static class UFlashbangDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashbangDamageType>();
	}
};
static_assert(alignof(UFlashbangDamageType) == 0x000010, "Wrong alignment on UFlashbangDamageType");
static_assert(sizeof(UFlashbangDamageType) == 0x000620, "Wrong size on UFlashbangDamageType");

// Class ReadyOrNot.RoNMoveStyleCharacter
// 0x0020 (0x04E0 - 0x04C0)
class ARoNMoveStyleCharacter final  : public ACharacter
{
public:
	class USpringArmComponent*                    CameraBoom;                                        // 0x04B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       FollowCamera;                                      // 0x04C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URoNMoveStyleComponent*                 MoveStyle;                                         // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseTurnRate;                                      // 0x04D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseLookUpRate;                                    // 0x04D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20FB[0x8];                                     // 0x04D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoNMoveStyleCharacter">();
	}
	static class ARoNMoveStyleCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARoNMoveStyleCharacter>();
	}
};
static_assert(alignof(ARoNMoveStyleCharacter) == 0x000010, "Wrong alignment on ARoNMoveStyleCharacter");
static_assert(sizeof(ARoNMoveStyleCharacter) == 0x0004E0, "Wrong size on ARoNMoveStyleCharacter");
static_assert(offsetof(ARoNMoveStyleCharacter, CameraBoom) == 0x0004B8, "Member 'ARoNMoveStyleCharacter::CameraBoom' has a wrong offset!");
static_assert(offsetof(ARoNMoveStyleCharacter, FollowCamera) == 0x0004C0, "Member 'ARoNMoveStyleCharacter::FollowCamera' has a wrong offset!");
static_assert(offsetof(ARoNMoveStyleCharacter, MoveStyle) == 0x0004C8, "Member 'ARoNMoveStyleCharacter::MoveStyle' has a wrong offset!");
static_assert(offsetof(ARoNMoveStyleCharacter, BaseTurnRate) == 0x0004D0, "Member 'ARoNMoveStyleCharacter::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(ARoNMoveStyleCharacter, BaseLookUpRate) == 0x0004D4, "Member 'ARoNMoveStyleCharacter::BaseLookUpRate' has a wrong offset!");

// Class ReadyOrNot.AIActionGate
// 0x0000 (0x0028 - 0x0028)
class UAIActionGate : public UObject
{
public:
	bool CanOpen(struct FAIActionDecisionContext& Context) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIActionGate">();
	}
	static class UAIActionGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIActionGate>();
	}
};
static_assert(alignof(UAIActionGate) == 0x000008, "Wrong alignment on UAIActionGate");
static_assert(sizeof(UAIActionGate) == 0x000028, "Wrong size on UAIActionGate");

// Class ReadyOrNot.AGValidTarget
// 0x0008 (0x0030 - 0x0028)
class UAGValidTarget : public UAIActionGate
{
public:
	bool                                          bAllowFriendly;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowEnemy;                                       // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowNeutral;                                     // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowLastTrackedTarget;                           // 0x002B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20FD[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGValidTarget">();
	}
	static class UAGValidTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGValidTarget>();
	}
};
static_assert(alignof(UAGValidTarget) == 0x000008, "Wrong alignment on UAGValidTarget");
static_assert(sizeof(UAGValidTarget) == 0x000030, "Wrong size on UAGValidTarget");
static_assert(offsetof(UAGValidTarget, bAllowFriendly) == 0x000028, "Member 'UAGValidTarget::bAllowFriendly' has a wrong offset!");
static_assert(offsetof(UAGValidTarget, bAllowEnemy) == 0x000029, "Member 'UAGValidTarget::bAllowEnemy' has a wrong offset!");
static_assert(offsetof(UAGValidTarget, bAllowNeutral) == 0x00002A, "Member 'UAGValidTarget::bAllowNeutral' has a wrong offset!");
static_assert(offsetof(UAGValidTarget, bAllowLastTrackedTarget) == 0x00002B, "Member 'UAGValidTarget::bAllowLastTrackedTarget' has a wrong offset!");

// Class ReadyOrNot.SkinComponent
// 0x01B8 (0x0268 - 0x00B0)
class USkinComponent : public UActorComponent
{
public:
	uint8                                         Pad_20FE[0x8];                                     // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name_SkinComponent;                                // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x00D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresDLC;                                      // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameVersionRestriction                       Dlc;                                               // 0x0111(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetsToFactorySkin;                              // 0x0112(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     LockedToTeam;                                      // 0x0113(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20FF[0x4];                                     // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             LockedToBlueprint;                                 // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class USkeletalMesh*, class USkeletalMesh*> SkeletalMeshSkinMap;                               // 0x0128(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class USkeletalMeshComponent*, class USkeletalMesh*> PreAppliedSkeletalMeshMap;                         // 0x0178(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class UStaticMesh*, class UStaticMesh*>  StaticMeshSkinMap;                                 // 0x01C8(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class UStaticMeshComponent*, class UStaticMesh*> PreAppliedStaticMeshMap;                           // 0x0218(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UTexture2D* GetClassDefaultIcon(TSubclassOf<class USkinComponent> SkinComponent);

	bool HasDLCUnlocked();
	bool IsFactorySkin();
	void ResetSkin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkinComponent">();
	}
	static class USkinComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkinComponent>();
	}
};
static_assert(alignof(USkinComponent) == 0x000008, "Wrong alignment on USkinComponent");
static_assert(sizeof(USkinComponent) == 0x000268, "Wrong size on USkinComponent");
static_assert(offsetof(USkinComponent, Name_SkinComponent) == 0x0000B8, "Member 'USkinComponent::Name_SkinComponent' has a wrong offset!");
static_assert(offsetof(USkinComponent, Description) == 0x0000D0, "Member 'USkinComponent::Description' has a wrong offset!");
static_assert(offsetof(USkinComponent, Icon) == 0x0000E8, "Member 'USkinComponent::Icon' has a wrong offset!");
static_assert(offsetof(USkinComponent, bRequiresDLC) == 0x000110, "Member 'USkinComponent::bRequiresDLC' has a wrong offset!");
static_assert(offsetof(USkinComponent, Dlc) == 0x000111, "Member 'USkinComponent::Dlc' has a wrong offset!");
static_assert(offsetof(USkinComponent, bResetsToFactorySkin) == 0x000112, "Member 'USkinComponent::bResetsToFactorySkin' has a wrong offset!");
static_assert(offsetof(USkinComponent, LockedToTeam) == 0x000113, "Member 'USkinComponent::LockedToTeam' has a wrong offset!");
static_assert(offsetof(USkinComponent, LockedToBlueprint) == 0x000118, "Member 'USkinComponent::LockedToBlueprint' has a wrong offset!");
static_assert(offsetof(USkinComponent, SkeletalMeshSkinMap) == 0x000128, "Member 'USkinComponent::SkeletalMeshSkinMap' has a wrong offset!");
static_assert(offsetof(USkinComponent, PreAppliedSkeletalMeshMap) == 0x000178, "Member 'USkinComponent::PreAppliedSkeletalMeshMap' has a wrong offset!");
static_assert(offsetof(USkinComponent, StaticMeshSkinMap) == 0x0001C8, "Member 'USkinComponent::StaticMeshSkinMap' has a wrong offset!");
static_assert(offsetof(USkinComponent, PreAppliedStaticMeshMap) == 0x000218, "Member 'USkinComponent::PreAppliedStaticMeshMap' has a wrong offset!");

// Class ReadyOrNot.WeaponAttachment
// 0x0130 (0x1000 - 0x0ED0)
#pragma pack(push, 0x1)
class alignas(0x10) UWeaponAttachment : public USkeletalMeshComponent
{
public:
	TArray<class UMaterialInstanceDynamic*>       SkinMaterials;                                     // 0x0EC8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EWeaponAttachmentType                         WeaponAttachmentType;                              // 0x0ED8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2100[0x7];                                     // 0x0ED9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EWeaponAttachmentType>                 RemovesWeaponAttachmentTypes;                      // 0x0EE0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EWeaponUnderbarrelAnimationType               UnderbarrelAnimationType;                          // 0x0EF0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedNotAttach;                                    // 0x0EF1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNullAttachmentOnly;                               // 0x0EF2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2101[0x1];                                     // 0x0EF3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketAttachment;                                  // 0x0EF4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2102[0x4];                                     // 0x0EFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemName;                                          // 0x0F00(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         PointCost;                                         // 0x0F18(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2103[0x4];                                     // 0x0F1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttachmentUIElements                  UIElements;                                        // 0x0F20(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<EItemAttachment>                       AdditionalAttachments;                             // 0x0F98(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AttachmentWeight;                                  // 0x0FA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalRecoilMultiplier;                          // 0x0FAC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalRecoilMultiplier;                        // 0x0FB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpreadMultiplier;                                  // 0x0FB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadzoneMultiplier;                                // 0x0FB8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MuzzleVelocityMultiplier;                          // 0x0FBC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowReadyLengthMultiplier;                          // 0x0FC0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldSupressWeapon;                              // 0x0FC4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidesMuzzleFlash;                                 // 0x0FC5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMuzzleFlash;                              // 0x0FC6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2104[0x1];                                     // 0x0FC7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        MuzzleFlashParticle;                               // 0x0FC8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        MuzzleSmokeParticle;                               // 0x0FD0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2105[0x4];                                     // 0x0FD8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MagazineAmmoIncrease;                              // 0x0FDC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HideBoneOnMesh;                                    // 0x0FE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobAdditionFactor;                           // 0x0FE8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADS_Speed_Multiplier;                              // 0x0FEC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ToggleSound;                                       // 0x0FF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyWetness(float Wetness, float RainAmount);
	void PlayToggleSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAttachment">();
	}
	static class UWeaponAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAttachment>();
	}
};
#pragma pack(pop)
static_assert(alignof(UWeaponAttachment) == 0x000010, "Wrong alignment on UWeaponAttachment");
static_assert(sizeof(UWeaponAttachment) == 0x001000, "Wrong size on UWeaponAttachment");
static_assert(offsetof(UWeaponAttachment, SkinMaterials) == 0x000EC8, "Member 'UWeaponAttachment::SkinMaterials' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, WeaponAttachmentType) == 0x000ED8, "Member 'UWeaponAttachment::WeaponAttachmentType' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, RemovesWeaponAttachmentTypes) == 0x000EE0, "Member 'UWeaponAttachment::RemovesWeaponAttachmentTypes' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, UnderbarrelAnimationType) == 0x000EF0, "Member 'UWeaponAttachment::UnderbarrelAnimationType' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, bNeedNotAttach) == 0x000EF1, "Member 'UWeaponAttachment::bNeedNotAttach' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, bNullAttachmentOnly) == 0x000EF2, "Member 'UWeaponAttachment::bNullAttachmentOnly' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, SocketAttachment) == 0x000EF4, "Member 'UWeaponAttachment::SocketAttachment' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, ItemName) == 0x000F00, "Member 'UWeaponAttachment::ItemName' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, PointCost) == 0x000F18, "Member 'UWeaponAttachment::PointCost' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, UIElements) == 0x000F20, "Member 'UWeaponAttachment::UIElements' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, AdditionalAttachments) == 0x000F98, "Member 'UWeaponAttachment::AdditionalAttachments' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, AttachmentWeight) == 0x000FA8, "Member 'UWeaponAttachment::AttachmentWeight' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, VerticalRecoilMultiplier) == 0x000FAC, "Member 'UWeaponAttachment::VerticalRecoilMultiplier' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, HorizontalRecoilMultiplier) == 0x000FB0, "Member 'UWeaponAttachment::HorizontalRecoilMultiplier' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, SpreadMultiplier) == 0x000FB4, "Member 'UWeaponAttachment::SpreadMultiplier' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, DeadzoneMultiplier) == 0x000FB8, "Member 'UWeaponAttachment::DeadzoneMultiplier' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, MuzzleVelocityMultiplier) == 0x000FBC, "Member 'UWeaponAttachment::MuzzleVelocityMultiplier' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, LowReadyLengthMultiplier) == 0x000FC0, "Member 'UWeaponAttachment::LowReadyLengthMultiplier' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, bShouldSupressWeapon) == 0x000FC4, "Member 'UWeaponAttachment::bShouldSupressWeapon' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, bHidesMuzzleFlash) == 0x000FC5, "Member 'UWeaponAttachment::bHidesMuzzleFlash' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, bOverrideMuzzleFlash) == 0x000FC6, "Member 'UWeaponAttachment::bOverrideMuzzleFlash' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, MuzzleFlashParticle) == 0x000FC8, "Member 'UWeaponAttachment::MuzzleFlashParticle' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, MuzzleSmokeParticle) == 0x000FD0, "Member 'UWeaponAttachment::MuzzleSmokeParticle' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, MagazineAmmoIncrease) == 0x000FDC, "Member 'UWeaponAttachment::MagazineAmmoIncrease' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, HideBoneOnMesh) == 0x000FE0, "Member 'UWeaponAttachment::HideBoneOnMesh' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, CameraBobAdditionFactor) == 0x000FE8, "Member 'UWeaponAttachment::CameraBobAdditionFactor' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, ADS_Speed_Multiplier) == 0x000FEC, "Member 'UWeaponAttachment::ADS_Speed_Multiplier' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, ToggleSound) == 0x000FF0, "Member 'UWeaponAttachment::ToggleSound' has a wrong offset!");

// Class ReadyOrNot.AGAnyNearbyAI
// 0x0010 (0x0038 - 0x0028)
class UAGAnyNearbyAI final  : public UAIActionGate
{
public:
	ETeamType                                     TeamType;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2106[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchRange;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustBeVisible;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2107[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGAnyNearbyAI">();
	}
	static class UAGAnyNearbyAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGAnyNearbyAI>();
	}
};
static_assert(alignof(UAGAnyNearbyAI) == 0x000008, "Wrong alignment on UAGAnyNearbyAI");
static_assert(sizeof(UAGAnyNearbyAI) == 0x000038, "Wrong size on UAGAnyNearbyAI");
static_assert(offsetof(UAGAnyNearbyAI, TeamType) == 0x000028, "Member 'UAGAnyNearbyAI::TeamType' has a wrong offset!");
static_assert(offsetof(UAGAnyNearbyAI, SearchRange) == 0x00002C, "Member 'UAGAnyNearbyAI::SearchRange' has a wrong offset!");
static_assert(offsetof(UAGAnyNearbyAI, bMustBeVisible) == 0x000030, "Member 'UAGAnyNearbyAI::bMustBeVisible' has a wrong offset!");

// Class ReadyOrNot.AGNumActiveAI
// 0x0008 (0x0030 - 0x0028)
class UAGNumActiveAI : public UAIActionGate
{
public:
	ETeamType                                     Team;                                              // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumAI;                                             // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComparisonOp                                 ComparisonType;                                    // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2108[0x5];                                     // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGNumActiveAI">();
	}
	static class UAGNumActiveAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGNumActiveAI>();
	}
};
static_assert(alignof(UAGNumActiveAI) == 0x000008, "Wrong alignment on UAGNumActiveAI");
static_assert(sizeof(UAGNumActiveAI) == 0x000030, "Wrong size on UAGNumActiveAI");
static_assert(offsetof(UAGNumActiveAI, Team) == 0x000028, "Member 'UAGNumActiveAI::Team' has a wrong offset!");
static_assert(offsetof(UAGNumActiveAI, NumAI) == 0x000029, "Member 'UAGNumActiveAI::NumAI' has a wrong offset!");
static_assert(offsetof(UAGNumActiveAI, ComparisonType) == 0x00002A, "Member 'UAGNumActiveAI::ComparisonType' has a wrong offset!");

// Class ReadyOrNot.KingOfTheHillGM
// 0x0040 (0x0810 - 0x07D0)
class AKingOfTheHillGM final  : public AReadyOrNotGameMode_PVP
{
public:
	TArray<class APlayerCharacter*>               ArrestedBlueCharacters;                            // 0x07D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class APlayerCharacter*>               ArrestedRedCharacters;                             // 0x07E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFMODEvent*                             TOWVictorySound;                                   // 0x07F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchLoopMusic;                                    // 0x07F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchStartMusic;                                   // 0x0800(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchEndMusic;                                     // 0x0808(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KingOfTheHillGM">();
	}
	static class AKingOfTheHillGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKingOfTheHillGM>();
	}
};
static_assert(alignof(AKingOfTheHillGM) == 0x000010, "Wrong alignment on AKingOfTheHillGM");
static_assert(sizeof(AKingOfTheHillGM) == 0x000810, "Wrong size on AKingOfTheHillGM");
static_assert(offsetof(AKingOfTheHillGM, ArrestedBlueCharacters) == 0x0007D0, "Member 'AKingOfTheHillGM::ArrestedBlueCharacters' has a wrong offset!");
static_assert(offsetof(AKingOfTheHillGM, ArrestedRedCharacters) == 0x0007E0, "Member 'AKingOfTheHillGM::ArrestedRedCharacters' has a wrong offset!");
static_assert(offsetof(AKingOfTheHillGM, TOWVictorySound) == 0x0007F0, "Member 'AKingOfTheHillGM::TOWVictorySound' has a wrong offset!");
static_assert(offsetof(AKingOfTheHillGM, MatchLoopMusic) == 0x0007F8, "Member 'AKingOfTheHillGM::MatchLoopMusic' has a wrong offset!");
static_assert(offsetof(AKingOfTheHillGM, MatchStartMusic) == 0x000800, "Member 'AKingOfTheHillGM::MatchStartMusic' has a wrong offset!");
static_assert(offsetof(AKingOfTheHillGM, MatchEndMusic) == 0x000808, "Member 'AKingOfTheHillGM::MatchEndMusic' has a wrong offset!");

// Class ReadyOrNot.AG_HasEquippedItem
// 0x0000 (0x0028 - 0x0028)
class UAG_HasEquippedItem : public UAIActionGate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_HasEquippedItem">();
	}
	static class UAG_HasEquippedItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_HasEquippedItem>();
	}
};
static_assert(alignof(UAG_HasEquippedItem) == 0x000008, "Wrong alignment on UAG_HasEquippedItem");
static_assert(sizeof(UAG_HasEquippedItem) == 0x000028, "Wrong size on UAG_HasEquippedItem");

// Class ReadyOrNot.BaseWidget
// 0x0018 (0x0278 - 0x0260)
class UBaseWidget : public UUserWidget
{
public:
	struct FVector2D                              MouseAxisDeltaThreshold;                           // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              GamepadAxisDeltaThreshold;                         // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotGameState*                   RONGS;                                             // 0x0270(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FVector2D GetCenterScreenPosition();
	void HideWidget();
	bool IsBlockingAnimationPlaying();
	bool IsGamepadAxisBeyondThreshold(struct FVector2D& InGamepadAxis);
	bool IsMouseAxisBeyondThreshold(struct FVector2D& InMouseDelta);
	void PauseWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation);
	void PlaySoundEffect(class UFMODEvent* SoundEffectToPlay);
	void PlayWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation, bool bRestartIfAlreadyPlaying);
	void ShowWidget(bool bNotHitTestable);
	void StopWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation);
	void ToggleWidgetVisibility(bool bNotHitTestable);
	bool UpdateDebugInfo();

	struct FVector2D GetMouseDelta() const;
	struct FVector2D GetMousePosition() const;
	bool HasMouseMoved() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseWidget">();
	}
	static class UBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseWidget>();
	}
};
static_assert(alignof(UBaseWidget) == 0x000008, "Wrong alignment on UBaseWidget");
static_assert(sizeof(UBaseWidget) == 0x000278, "Wrong size on UBaseWidget");
static_assert(offsetof(UBaseWidget, MouseAxisDeltaThreshold) == 0x000260, "Member 'UBaseWidget::MouseAxisDeltaThreshold' has a wrong offset!");
static_assert(offsetof(UBaseWidget, GamepadAxisDeltaThreshold) == 0x000268, "Member 'UBaseWidget::GamepadAxisDeltaThreshold' has a wrong offset!");
static_assert(offsetof(UBaseWidget, RONGS) == 0x000270, "Member 'UBaseWidget::RONGS' has a wrong offset!");

// Class ReadyOrNot.ObjectiveWidget
// 0x0010 (0x0288 - 0x0278)
class UObjectiveWidget final  : public UBaseWidget
{
public:
	class UWidgetComponent*                       OwningComponent;                                   // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     ObjectiveTeam;                                     // 0x0280(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_210C[0x7];                                     // 0x0281(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetObjectiveText(class FText& NewText);
	void SetObjectiveType(EPlayerObjectiveMarkerType NewType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveWidget">();
	}
	static class UObjectiveWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveWidget>();
	}
};
static_assert(alignof(UObjectiveWidget) == 0x000008, "Wrong alignment on UObjectiveWidget");
static_assert(sizeof(UObjectiveWidget) == 0x000288, "Wrong size on UObjectiveWidget");
static_assert(offsetof(UObjectiveWidget, OwningComponent) == 0x000278, "Member 'UObjectiveWidget::OwningComponent' has a wrong offset!");
static_assert(offsetof(UObjectiveWidget, ObjectiveTeam) == 0x000280, "Member 'UObjectiveWidget::ObjectiveTeam' has a wrong offset!");

// Class ReadyOrNot.AG_HasEquippedWeapon
// 0x0000 (0x0028 - 0x0028)
class UAG_HasEquippedWeapon : public UAIActionGate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_HasEquippedWeapon">();
	}
	static class UAG_HasEquippedWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_HasEquippedWeapon>();
	}
};
static_assert(alignof(UAG_HasEquippedWeapon) == 0x000008, "Wrong alignment on UAG_HasEquippedWeapon");
static_assert(sizeof(UAG_HasEquippedWeapon) == 0x000028, "Wrong size on UAG_HasEquippedWeapon");

// Class ReadyOrNot.ItemSlotTactical_V2
// 0x0068 (0x02F0 - 0x0288)
class UItemSlotTactical_V2 : public UCommonUserWidget
{
public:
	ELoadoutTacticalSlotType                      SlotType;                                          // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_210D[0x7];                                     // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseItem>                  SlotItem;                                          // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotAmmunitionName;                                // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SlotName;                                          // 0x02A0(0x0018)(Edit, NativeAccessSpecifierPublic)
	TDelegate<void(EUINavigation Navigation)>     NavigationDelegate;                                // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class UTextBlock*                             ItemName;                                          // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemType;                                          // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemCount;                                         // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                LeftArrow;                                         // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                RightArrow;                                        // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FText GetItemDescription();
	class FText GetItemName();
	class UWidget* OnNavigateLeft(EUINavigation NavigationRule);
	class UWidget* OnNavigateRight(EUINavigation NavigationRule);
	void OnSlotsUpdated();
	void Refresh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSlotTactical_V2">();
	}
	static class UItemSlotTactical_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSlotTactical_V2>();
	}
};
static_assert(alignof(UItemSlotTactical_V2) == 0x000008, "Wrong alignment on UItemSlotTactical_V2");
static_assert(sizeof(UItemSlotTactical_V2) == 0x0002F0, "Wrong size on UItemSlotTactical_V2");
static_assert(offsetof(UItemSlotTactical_V2, SlotType) == 0x000288, "Member 'UItemSlotTactical_V2::SlotType' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, SlotItem) == 0x000290, "Member 'UItemSlotTactical_V2::SlotItem' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, SlotAmmunitionName) == 0x000298, "Member 'UItemSlotTactical_V2::SlotAmmunitionName' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, SlotName) == 0x0002A0, "Member 'UItemSlotTactical_V2::SlotName' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, NavigationDelegate) == 0x0002B8, "Member 'UItemSlotTactical_V2::NavigationDelegate' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, ItemName) == 0x0002C8, "Member 'UItemSlotTactical_V2::ItemName' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, ItemType) == 0x0002D0, "Member 'UItemSlotTactical_V2::ItemType' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, ItemCount) == 0x0002D8, "Member 'UItemSlotTactical_V2::ItemCount' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, LeftArrow) == 0x0002E0, "Member 'UItemSlotTactical_V2::LeftArrow' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, RightArrow) == 0x0002E8, "Member 'UItemSlotTactical_V2::RightArrow' has a wrong offset!");

// Class ReadyOrNot.AG_IsSurrendered
// 0x0008 (0x0030 - 0x0028)
class UAG_IsSurrendered : public UAIActionGate
{
public:
	float                                         Time;                                              // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2110[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_IsSurrendered">();
	}
	static class UAG_IsSurrendered* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_IsSurrendered>();
	}
};
static_assert(alignof(UAG_IsSurrendered) == 0x000008, "Wrong alignment on UAG_IsSurrendered");
static_assert(sizeof(UAG_IsSurrendered) == 0x000030, "Wrong size on UAG_IsSurrendered");
static_assert(offsetof(UAG_IsSurrendered, Time) == 0x000028, "Member 'UAG_IsSurrendered::Time' has a wrong offset!");

// Class ReadyOrNot.AIActionPresetData
// 0x02D0 (0x0300 - 0x0030)
class UAIActionPresetData final  : public UDataAsset
{
public:
	struct FAIActionData                          Action;                                            // 0x0030(0x02D0)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIActionPresetData">();
	}
	static class UAIActionPresetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIActionPresetData>();
	}
};
static_assert(alignof(UAIActionPresetData) == 0x000008, "Wrong alignment on UAIActionPresetData");
static_assert(sizeof(UAIActionPresetData) == 0x000300, "Wrong size on UAIActionPresetData");
static_assert(offsetof(UAIActionPresetData, Action) == 0x000030, "Member 'UAIActionPresetData::Action' has a wrong offset!");

// Class ReadyOrNot.Ladder
// 0x0010 (0x0230 - 0x0220)
class ALadder final  : public AActor
{
public:
	class UBoxComponent*                          BoxCollision;                                      // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   LadderMesh;                                        // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ladder">();
	}
	static class ALadder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALadder>();
	}
};
static_assert(alignof(ALadder) == 0x000008, "Wrong alignment on ALadder");
static_assert(sizeof(ALadder) == 0x000230, "Wrong size on ALadder");
static_assert(offsetof(ALadder, BoxCollision) == 0x000220, "Member 'ALadder::BoxCollision' has a wrong offset!");
static_assert(offsetof(ALadder, LadderMesh) == 0x000228, "Member 'ALadder::LadderMesh' has a wrong offset!");

// Class ReadyOrNot.AIArchetypeData
// 0x0100 (0x0130 - 0x0030)
class UAIArchetypeData final  : public UDataAsset
{
public:
	class FString                                 Name_AIArchetypeData;                              // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableAlertActions : 1;                           // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2111[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIActionDataContainer>         AlertActions;                                      // 0x0048(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bEnableUnalertActions : 1;                         // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2112[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIActionDataContainer>         UnalertActions;                                    // 0x0060(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bEnableSuspiciousActions : 1;                      // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2113[0x7];                                     // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIActionDataContainer>         SuspiciousActions;                                 // 0x0078(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bEnableContinuousActions : 1;                      // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2114[0x7];                                     // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIActionData_NameOnly>         ContinuousActions;                                 // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAIActionDataContainer>         ContinuousActionsCache;                            // 0x00A0(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bEnableCombatMoveActions : 1;                      // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2115[0x7];                                     // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIActionDataContainer>         CombatMoveActions;                                 // 0x00B8(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bEnableTraitActions : 1;                           // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2116[0x7];                                     // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAITraitActionData>             TraitActions;                                      // 0x00D0(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bOverrideAimSettings : 1;                          // 0x00E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2117[0x3];                                     // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocalPointInterpSpeed;                             // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             FocalPointInterpCurve;                             // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2118[0x3];                                     // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocusTurnSpeed;                                    // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnDegreesPerSecond;                              // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorRotationInterpStandingSpeed;                  // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorRotationInterpMovingSpeed;                    // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetInterpSpeed;                              // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIgnoreDamageHitReactions : 1;                     // 0x0100(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2119[0x7];                                     // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EAIAwarenessState>                     AllowCombatMoveInState;                            // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bSuppressionRequiresLOSOnLastKnownEnemyPosition : 1; // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAccuracyOverride : 1;                             // 0x0118(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_211A[0x3];                                     // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Accuracy;                                          // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMoraleOverride : 1;                               // 0x0120(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_211B[0x3];                                     // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinMorale;                                         // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMorale;                                         // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDisableVO : 1;                                    // 0x012C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_211C[0x3];                                     // 0x012D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIArchetypeData">();
	}
	static class UAIArchetypeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIArchetypeData>();
	}
};
static_assert(alignof(UAIArchetypeData) == 0x000008, "Wrong alignment on UAIArchetypeData");
static_assert(sizeof(UAIArchetypeData) == 0x000130, "Wrong size on UAIArchetypeData");
static_assert(offsetof(UAIArchetypeData, Name_AIArchetypeData) == 0x000030, "Member 'UAIArchetypeData::Name_AIArchetypeData' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, AlertActions) == 0x000048, "Member 'UAIArchetypeData::AlertActions' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, UnalertActions) == 0x000060, "Member 'UAIArchetypeData::UnalertActions' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, SuspiciousActions) == 0x000078, "Member 'UAIArchetypeData::SuspiciousActions' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, ContinuousActions) == 0x000090, "Member 'UAIArchetypeData::ContinuousActions' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, ContinuousActionsCache) == 0x0000A0, "Member 'UAIArchetypeData::ContinuousActionsCache' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, CombatMoveActions) == 0x0000B8, "Member 'UAIArchetypeData::CombatMoveActions' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, TraitActions) == 0x0000D0, "Member 'UAIArchetypeData::TraitActions' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, FocalPointInterpSpeed) == 0x0000E4, "Member 'UAIArchetypeData::FocalPointInterpSpeed' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, FocalPointInterpCurve) == 0x0000E8, "Member 'UAIArchetypeData::FocalPointInterpCurve' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, FocusTurnSpeed) == 0x0000EC, "Member 'UAIArchetypeData::FocusTurnSpeed' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, TurnDegreesPerSecond) == 0x0000F0, "Member 'UAIArchetypeData::TurnDegreesPerSecond' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, ActorRotationInterpStandingSpeed) == 0x0000F4, "Member 'UAIArchetypeData::ActorRotationInterpStandingSpeed' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, ActorRotationInterpMovingSpeed) == 0x0000F8, "Member 'UAIArchetypeData::ActorRotationInterpMovingSpeed' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, AimOffsetInterpSpeed) == 0x0000FC, "Member 'UAIArchetypeData::AimOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, AllowCombatMoveInState) == 0x000108, "Member 'UAIArchetypeData::AllowCombatMoveInState' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, Accuracy) == 0x00011C, "Member 'UAIArchetypeData::Accuracy' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, MinMorale) == 0x000124, "Member 'UAIArchetypeData::MinMorale' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, MaxMorale) == 0x000128, "Member 'UAIArchetypeData::MaxMorale' has a wrong offset!");

// Class ReadyOrNot.AICombatMovesWidget
// 0x0030 (0x0290 - 0x0260)
class UAICombatMovesWidget final  : public UUserWidget
{
public:
	class UVerticalBox*                           CombatMoves_VerticalBox;                           // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AIName_TextBlock;                                  // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                NextAI_Button;                                     // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACyberneticCharacter*                   CurrentAI;                                         // 0x0278(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAICombatMovesWidgetEntry>  WidgetEntryClass;                                  // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                AIWorldWidgetClass;                                // 0x0288(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnNextAIButtonClicked();
	void SetAIToFocus(class ACyberneticCharacter* CyberneticCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICombatMovesWidget">();
	}
	static class UAICombatMovesWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICombatMovesWidget>();
	}
};
static_assert(alignof(UAICombatMovesWidget) == 0x000008, "Wrong alignment on UAICombatMovesWidget");
static_assert(sizeof(UAICombatMovesWidget) == 0x000290, "Wrong size on UAICombatMovesWidget");
static_assert(offsetof(UAICombatMovesWidget, CombatMoves_VerticalBox) == 0x000260, "Member 'UAICombatMovesWidget::CombatMoves_VerticalBox' has a wrong offset!");
static_assert(offsetof(UAICombatMovesWidget, AIName_TextBlock) == 0x000268, "Member 'UAICombatMovesWidget::AIName_TextBlock' has a wrong offset!");
static_assert(offsetof(UAICombatMovesWidget, NextAI_Button) == 0x000270, "Member 'UAICombatMovesWidget::NextAI_Button' has a wrong offset!");
static_assert(offsetof(UAICombatMovesWidget, CurrentAI) == 0x000278, "Member 'UAICombatMovesWidget::CurrentAI' has a wrong offset!");
static_assert(offsetof(UAICombatMovesWidget, WidgetEntryClass) == 0x000280, "Member 'UAICombatMovesWidget::WidgetEntryClass' has a wrong offset!");
static_assert(offsetof(UAICombatMovesWidget, AIWorldWidgetClass) == 0x000288, "Member 'UAICombatMovesWidget::AIWorldWidgetClass' has a wrong offset!");

// Class ReadyOrNot.ListenForGameEnd
// 0x0000 (0x0028 - 0x0028)
class IListenForGameEnd final  : public IInterface
{
public:
	void OnGameEnded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ListenForGameEnd">();
	}
	static class IListenForGameEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<IListenForGameEnd>();
	}
};
static_assert(alignof(IListenForGameEnd) == 0x000008, "Wrong alignment on IListenForGameEnd");
static_assert(sizeof(IListenForGameEnd) == 0x000028, "Wrong size on IListenForGameEnd");

// Class ReadyOrNot.AICombatMovesWidgetEntry
// 0x0020 (0x0280 - 0x0260)
class UAICombatMovesWidgetEntry final  : public UUserWidget
{
public:
	class UTextBlock*                             CombatAction_TextBlock;                            // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             SuccessfulConsiderations_TextBlock;                // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             FailedConsiderations_TextBlock;                    // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             RunTime_TextBlock;                                 // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICombatMovesWidgetEntry">();
	}
	static class UAICombatMovesWidgetEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICombatMovesWidgetEntry>();
	}
};
static_assert(alignof(UAICombatMovesWidgetEntry) == 0x000008, "Wrong alignment on UAICombatMovesWidgetEntry");
static_assert(sizeof(UAICombatMovesWidgetEntry) == 0x000280, "Wrong size on UAICombatMovesWidgetEntry");
static_assert(offsetof(UAICombatMovesWidgetEntry, CombatAction_TextBlock) == 0x000260, "Member 'UAICombatMovesWidgetEntry::CombatAction_TextBlock' has a wrong offset!");
static_assert(offsetof(UAICombatMovesWidgetEntry, SuccessfulConsiderations_TextBlock) == 0x000268, "Member 'UAICombatMovesWidgetEntry::SuccessfulConsiderations_TextBlock' has a wrong offset!");
static_assert(offsetof(UAICombatMovesWidgetEntry, FailedConsiderations_TextBlock) == 0x000270, "Member 'UAICombatMovesWidgetEntry::FailedConsiderations_TextBlock' has a wrong offset!");
static_assert(offsetof(UAICombatMovesWidgetEntry, RunTime_TextBlock) == 0x000278, "Member 'UAICombatMovesWidgetEntry::RunTime_TextBlock' has a wrong offset!");

// Class ReadyOrNot.AIData
// 0x0000 (0x0030 - 0x0030)
class UAIData final  : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIData">();
	}
	static class UAIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIData>();
	}
};
static_assert(alignof(UAIData) == 0x000008, "Wrong alignment on UAIData");
static_assert(sizeof(UAIData) == 0x000030, "Wrong size on UAIData");

// Class ReadyOrNot.LensFlare
// 0x02D8 (0x04F8 - 0x0220)
class ALensFlare : public AActor
{
public:
	class USceneComponent*                        Scene;                                             // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialBillboardComponent*            LensFlare;                                         // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AReadyOrNotCharacter*                   OwningCharacter;                                   // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     FlareMat;                                          // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              BaseSize;                                          // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumRotationDeltaToBeVisible;                   // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_211D[0x4];                                     // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               FlareMatInstance;                                  // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_211E[0x4];                                     // 0x0258(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlobalBrightness;                                  // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GhostsBrightness;                                  // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlickerIntensity;                                  // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlickerTime;                                       // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           GlobalColor;                                       // 0x026C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeDistance;                                      // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFadeDistance;                                  // 0x0280(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_211F[0x3];                                     // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IncreasingBloomByDistance;                         // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDistanceBloom;                                 // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2120[0x3];                                     // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HaloOpacity;                                       // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HaloInnerRadius;                                   // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HaloBrightness;                                    // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           HaloOuterColor;                                    // 0x0298(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           HaloInnerColor;                                    // 0x02A8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               HaloTexture;                                       // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HaloTextureSize;                                   // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HaloContrast;                                      // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CentreFlareBrightness;                             // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2121[0x4];                                     // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               CentreFlareTexture;                                // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           CentreFlareColor;                                  // 0x02D8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CentreFlareSize;                                   // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CentreFlareContrast;                               // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MainFlareBrightness;                               // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2122[0x4];                                     // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               MainFlare;                                         // 0x02F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MainFlareInnerRadius;                              // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MainOuterColor;                                    // 0x0304(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MainLensInnerColor;                                // 0x0314(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MainFlareSize;                                     // 0x0324(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MainFlareContrast;                                 // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectionSize;                                    // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               ReflectionCentreTexture;                           // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ReflectionColor;                                   // 0x0338(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectionBrightness;                              // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectionContrast;                                // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OppositeFlaresAxisProjection;                      // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareOppositeSize01;                               // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareOppositeSize02;                               // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           FlareOppositeColor01;                              // 0x035C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           FlareOppositeColor02;                              // 0x036C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareOppositeBrightness01;                         // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareOppositeBrightness02;                         // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareOppositeContrast01;                           // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareOppositeContrast02;                           // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2123[0x4];                                     // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               FlareOpposite01;                                   // 0x0390(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               FlareOpposite02;                                   // 0x0398(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FrontFlaresAxisProjection;                         // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareFrontSize01;                                  // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareFrontSize02;                                  // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           FlareFrontColor01;                                 // 0x03AC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           FlareFrontColor02;                                 // 0x03BC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareFrontProximityCentre01;                       // 0x03CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareFrontProximityCentre02;                       // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2124[0x4];                                     // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               FlareFront01;                                      // 0x03D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               FlareFront02;                                      // 0x03E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareFrontContrast01;                              // 0x03E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareFrontContrast02;                              // 0x03EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareFrontBrightness01;                            // 0x03F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareFrontBrightness02;                            // 0x03F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectedFlareSize01;                              // 0x03F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectedFlareSize02;                              // 0x03FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectedFlareProximityCentre01;                   // 0x0400(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectedFlareProximityCentre02;                   // 0x0404(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               ReflectedFlare01;                                  // 0x0408(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               ReflectedFlare02;                                  // 0x0410(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ReflectedFlareColor01;                             // 0x0418(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ReflectedFlareColor02;                             // 0x0428(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectedFlareContrast01;                          // 0x0438(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectedFlareContrast02;                          // 0x043C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectedFlareBrightness01;                        // 0x0440(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectedFlareBrightness02;                        // 0x0444(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareProximityCentre01;                       // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareSize01;                                  // 0x044C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareSizeRandom01;                            // 0x0450(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2125[0x4];                                     // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               MinorFlare01;                                      // 0x0458(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MinorFlareColor01;                                 // 0x0460(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareContrast01;                              // 0x0470(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareBrightness01;                            // 0x0474(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MinorFlareColor02;                                 // 0x0478(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareContrast02;                              // 0x0488(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareBrightness02;                            // 0x048C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareProximityCentre02;                       // 0x0490(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareSize02;                                  // 0x0494(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareSizeRandom02;                            // 0x0498(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2126[0x4];                                     // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               MinorFlare02;                                      // 0x04A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               Iris;                                              // 0x04A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IrisSize;                                          // 0x04B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IrisProximityCentre;                               // 0x04B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IrisBrightness;                                    // 0x04B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IrisContrast;                                      // 0x04BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           IrisColor;                                         // 0x04C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               AdditionalFlare;                                   // 0x04D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalFlareSize;                               // 0x04D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalFlareContrast;                           // 0x04DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalFlareBrightness;                         // 0x04E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           AdditionalFlareColor;                              // 0x04E4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2127[0x4];                                     // 0x04F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LensFlare">();
	}
	static class ALensFlare* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALensFlare>();
	}
};
static_assert(alignof(ALensFlare) == 0x000008, "Wrong alignment on ALensFlare");
static_assert(sizeof(ALensFlare) == 0x0004F8, "Wrong size on ALensFlare");
static_assert(offsetof(ALensFlare, Scene) == 0x000220, "Member 'ALensFlare::Scene' has a wrong offset!");
static_assert(offsetof(ALensFlare, LensFlare) == 0x000228, "Member 'ALensFlare::LensFlare' has a wrong offset!");
static_assert(offsetof(ALensFlare, OwningCharacter) == 0x000230, "Member 'ALensFlare::OwningCharacter' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareMat) == 0x000238, "Member 'ALensFlare::FlareMat' has a wrong offset!");
static_assert(offsetof(ALensFlare, BaseSize) == 0x000240, "Member 'ALensFlare::BaseSize' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinimumRotationDeltaToBeVisible) == 0x000248, "Member 'ALensFlare::MinimumRotationDeltaToBeVisible' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareMatInstance) == 0x000250, "Member 'ALensFlare::FlareMatInstance' has a wrong offset!");
static_assert(offsetof(ALensFlare, GlobalBrightness) == 0x00025C, "Member 'ALensFlare::GlobalBrightness' has a wrong offset!");
static_assert(offsetof(ALensFlare, GhostsBrightness) == 0x000260, "Member 'ALensFlare::GhostsBrightness' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlickerIntensity) == 0x000264, "Member 'ALensFlare::FlickerIntensity' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlickerTime) == 0x000268, "Member 'ALensFlare::FlickerTime' has a wrong offset!");
static_assert(offsetof(ALensFlare, GlobalColor) == 0x00026C, "Member 'ALensFlare::GlobalColor' has a wrong offset!");
static_assert(offsetof(ALensFlare, FadeDistance) == 0x00027C, "Member 'ALensFlare::FadeDistance' has a wrong offset!");
static_assert(offsetof(ALensFlare, bUseFadeDistance) == 0x000280, "Member 'ALensFlare::bUseFadeDistance' has a wrong offset!");
static_assert(offsetof(ALensFlare, IncreasingBloomByDistance) == 0x000284, "Member 'ALensFlare::IncreasingBloomByDistance' has a wrong offset!");
static_assert(offsetof(ALensFlare, bUseDistanceBloom) == 0x000288, "Member 'ALensFlare::bUseDistanceBloom' has a wrong offset!");
static_assert(offsetof(ALensFlare, HaloOpacity) == 0x00028C, "Member 'ALensFlare::HaloOpacity' has a wrong offset!");
static_assert(offsetof(ALensFlare, HaloInnerRadius) == 0x000290, "Member 'ALensFlare::HaloInnerRadius' has a wrong offset!");
static_assert(offsetof(ALensFlare, HaloBrightness) == 0x000294, "Member 'ALensFlare::HaloBrightness' has a wrong offset!");
static_assert(offsetof(ALensFlare, HaloOuterColor) == 0x000298, "Member 'ALensFlare::HaloOuterColor' has a wrong offset!");
static_assert(offsetof(ALensFlare, HaloInnerColor) == 0x0002A8, "Member 'ALensFlare::HaloInnerColor' has a wrong offset!");
static_assert(offsetof(ALensFlare, HaloTexture) == 0x0002B8, "Member 'ALensFlare::HaloTexture' has a wrong offset!");
static_assert(offsetof(ALensFlare, HaloTextureSize) == 0x0002C0, "Member 'ALensFlare::HaloTextureSize' has a wrong offset!");
static_assert(offsetof(ALensFlare, HaloContrast) == 0x0002C4, "Member 'ALensFlare::HaloContrast' has a wrong offset!");
static_assert(offsetof(ALensFlare, CentreFlareBrightness) == 0x0002C8, "Member 'ALensFlare::CentreFlareBrightness' has a wrong offset!");
static_assert(offsetof(ALensFlare, CentreFlareTexture) == 0x0002D0, "Member 'ALensFlare::CentreFlareTexture' has a wrong offset!");
static_assert(offsetof(ALensFlare, CentreFlareColor) == 0x0002D8, "Member 'ALensFlare::CentreFlareColor' has a wrong offset!");
static_assert(offsetof(ALensFlare, CentreFlareSize) == 0x0002E8, "Member 'ALensFlare::CentreFlareSize' has a wrong offset!");
static_assert(offsetof(ALensFlare, CentreFlareContrast) == 0x0002EC, "Member 'ALensFlare::CentreFlareContrast' has a wrong offset!");
static_assert(offsetof(ALensFlare, MainFlareBrightness) == 0x0002F0, "Member 'ALensFlare::MainFlareBrightness' has a wrong offset!");
static_assert(offsetof(ALensFlare, MainFlare) == 0x0002F8, "Member 'ALensFlare::MainFlare' has a wrong offset!");
static_assert(offsetof(ALensFlare, MainFlareInnerRadius) == 0x000300, "Member 'ALensFlare::MainFlareInnerRadius' has a wrong offset!");
static_assert(offsetof(ALensFlare, MainOuterColor) == 0x000304, "Member 'ALensFlare::MainOuterColor' has a wrong offset!");
static_assert(offsetof(ALensFlare, MainLensInnerColor) == 0x000314, "Member 'ALensFlare::MainLensInnerColor' has a wrong offset!");
static_assert(offsetof(ALensFlare, MainFlareSize) == 0x000324, "Member 'ALensFlare::MainFlareSize' has a wrong offset!");
static_assert(offsetof(ALensFlare, MainFlareContrast) == 0x000328, "Member 'ALensFlare::MainFlareContrast' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectionSize) == 0x00032C, "Member 'ALensFlare::ReflectionSize' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectionCentreTexture) == 0x000330, "Member 'ALensFlare::ReflectionCentreTexture' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectionColor) == 0x000338, "Member 'ALensFlare::ReflectionColor' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectionBrightness) == 0x000348, "Member 'ALensFlare::ReflectionBrightness' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectionContrast) == 0x00034C, "Member 'ALensFlare::ReflectionContrast' has a wrong offset!");
static_assert(offsetof(ALensFlare, OppositeFlaresAxisProjection) == 0x000350, "Member 'ALensFlare::OppositeFlaresAxisProjection' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOppositeSize01) == 0x000354, "Member 'ALensFlare::FlareOppositeSize01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOppositeSize02) == 0x000358, "Member 'ALensFlare::FlareOppositeSize02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOppositeColor01) == 0x00035C, "Member 'ALensFlare::FlareOppositeColor01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOppositeColor02) == 0x00036C, "Member 'ALensFlare::FlareOppositeColor02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOppositeBrightness01) == 0x00037C, "Member 'ALensFlare::FlareOppositeBrightness01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOppositeBrightness02) == 0x000380, "Member 'ALensFlare::FlareOppositeBrightness02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOppositeContrast01) == 0x000384, "Member 'ALensFlare::FlareOppositeContrast01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOppositeContrast02) == 0x000388, "Member 'ALensFlare::FlareOppositeContrast02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOpposite01) == 0x000390, "Member 'ALensFlare::FlareOpposite01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOpposite02) == 0x000398, "Member 'ALensFlare::FlareOpposite02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FrontFlaresAxisProjection) == 0x0003A0, "Member 'ALensFlare::FrontFlaresAxisProjection' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontSize01) == 0x0003A4, "Member 'ALensFlare::FlareFrontSize01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontSize02) == 0x0003A8, "Member 'ALensFlare::FlareFrontSize02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontColor01) == 0x0003AC, "Member 'ALensFlare::FlareFrontColor01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontColor02) == 0x0003BC, "Member 'ALensFlare::FlareFrontColor02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontProximityCentre01) == 0x0003CC, "Member 'ALensFlare::FlareFrontProximityCentre01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontProximityCentre02) == 0x0003D0, "Member 'ALensFlare::FlareFrontProximityCentre02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFront01) == 0x0003D8, "Member 'ALensFlare::FlareFront01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFront02) == 0x0003E0, "Member 'ALensFlare::FlareFront02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontContrast01) == 0x0003E8, "Member 'ALensFlare::FlareFrontContrast01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontContrast02) == 0x0003EC, "Member 'ALensFlare::FlareFrontContrast02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontBrightness01) == 0x0003F0, "Member 'ALensFlare::FlareFrontBrightness01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontBrightness02) == 0x0003F4, "Member 'ALensFlare::FlareFrontBrightness02' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareSize01) == 0x0003F8, "Member 'ALensFlare::ReflectedFlareSize01' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareSize02) == 0x0003FC, "Member 'ALensFlare::ReflectedFlareSize02' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareProximityCentre01) == 0x000400, "Member 'ALensFlare::ReflectedFlareProximityCentre01' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareProximityCentre02) == 0x000404, "Member 'ALensFlare::ReflectedFlareProximityCentre02' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlare01) == 0x000408, "Member 'ALensFlare::ReflectedFlare01' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlare02) == 0x000410, "Member 'ALensFlare::ReflectedFlare02' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareColor01) == 0x000418, "Member 'ALensFlare::ReflectedFlareColor01' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareColor02) == 0x000428, "Member 'ALensFlare::ReflectedFlareColor02' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareContrast01) == 0x000438, "Member 'ALensFlare::ReflectedFlareContrast01' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareContrast02) == 0x00043C, "Member 'ALensFlare::ReflectedFlareContrast02' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareBrightness01) == 0x000440, "Member 'ALensFlare::ReflectedFlareBrightness01' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareBrightness02) == 0x000444, "Member 'ALensFlare::ReflectedFlareBrightness02' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareProximityCentre01) == 0x000448, "Member 'ALensFlare::MinorFlareProximityCentre01' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareSize01) == 0x00044C, "Member 'ALensFlare::MinorFlareSize01' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareSizeRandom01) == 0x000450, "Member 'ALensFlare::MinorFlareSizeRandom01' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlare01) == 0x000458, "Member 'ALensFlare::MinorFlare01' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareColor01) == 0x000460, "Member 'ALensFlare::MinorFlareColor01' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareContrast01) == 0x000470, "Member 'ALensFlare::MinorFlareContrast01' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareBrightness01) == 0x000474, "Member 'ALensFlare::MinorFlareBrightness01' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareColor02) == 0x000478, "Member 'ALensFlare::MinorFlareColor02' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareContrast02) == 0x000488, "Member 'ALensFlare::MinorFlareContrast02' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareBrightness02) == 0x00048C, "Member 'ALensFlare::MinorFlareBrightness02' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareProximityCentre02) == 0x000490, "Member 'ALensFlare::MinorFlareProximityCentre02' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareSize02) == 0x000494, "Member 'ALensFlare::MinorFlareSize02' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareSizeRandom02) == 0x000498, "Member 'ALensFlare::MinorFlareSizeRandom02' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlare02) == 0x0004A0, "Member 'ALensFlare::MinorFlare02' has a wrong offset!");
static_assert(offsetof(ALensFlare, Iris) == 0x0004A8, "Member 'ALensFlare::Iris' has a wrong offset!");
static_assert(offsetof(ALensFlare, IrisSize) == 0x0004B0, "Member 'ALensFlare::IrisSize' has a wrong offset!");
static_assert(offsetof(ALensFlare, IrisProximityCentre) == 0x0004B4, "Member 'ALensFlare::IrisProximityCentre' has a wrong offset!");
static_assert(offsetof(ALensFlare, IrisBrightness) == 0x0004B8, "Member 'ALensFlare::IrisBrightness' has a wrong offset!");
static_assert(offsetof(ALensFlare, IrisContrast) == 0x0004BC, "Member 'ALensFlare::IrisContrast' has a wrong offset!");
static_assert(offsetof(ALensFlare, IrisColor) == 0x0004C0, "Member 'ALensFlare::IrisColor' has a wrong offset!");
static_assert(offsetof(ALensFlare, AdditionalFlare) == 0x0004D0, "Member 'ALensFlare::AdditionalFlare' has a wrong offset!");
static_assert(offsetof(ALensFlare, AdditionalFlareSize) == 0x0004D8, "Member 'ALensFlare::AdditionalFlareSize' has a wrong offset!");
static_assert(offsetof(ALensFlare, AdditionalFlareContrast) == 0x0004DC, "Member 'ALensFlare::AdditionalFlareContrast' has a wrong offset!");
static_assert(offsetof(ALensFlare, AdditionalFlareBrightness) == 0x0004E0, "Member 'ALensFlare::AdditionalFlareBrightness' has a wrong offset!");
static_assert(offsetof(ALensFlare, AdditionalFlareColor) == 0x0004E4, "Member 'ALensFlare::AdditionalFlareColor' has a wrong offset!");

// Class ReadyOrNot.RoundupWidget
// 0x0050 (0x0370 - 0x0320)
class URoundupWidget : public UCommonActivatableWidget
{
public:
	bool                                          bIsCollapsed;                                      // 0x0320(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2128[0x7];                                     // 0x0321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           Unlocks;                                           // 0x0328(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FText>                           Actions;                                           // 0x0338(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUsingGamepad;                                     // 0x0348(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2129[0x7];                                     // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMetaGameProfile*                       MetaGameProfile;                                   // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommanderProfile*                      CommanderProfile;                                  // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URosterManager*                         RosterManager;                                     // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_212A[0x8];                                     // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddRoundupAction(class FText& Action);
	void AddRoundupUnlock(class FText& Unlock);
	void CollapseContent();
	void ExpandContent();
	void HideRoundupActions();
	void HideRoundupUnlocks();
	void HideWidget();
	void OnInputMethodChanged(ECommonInputType InputMethod);
	void RefreshWidget();
	void ShowWidget();
	void ToggleContent();

	bool IsNewCommanderModeSave() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoundupWidget">();
	}
	static class URoundupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoundupWidget>();
	}
};
static_assert(alignof(URoundupWidget) == 0x000008, "Wrong alignment on URoundupWidget");
static_assert(sizeof(URoundupWidget) == 0x000370, "Wrong size on URoundupWidget");
static_assert(offsetof(URoundupWidget, bIsCollapsed) == 0x000320, "Member 'URoundupWidget::bIsCollapsed' has a wrong offset!");
static_assert(offsetof(URoundupWidget, Unlocks) == 0x000328, "Member 'URoundupWidget::Unlocks' has a wrong offset!");
static_assert(offsetof(URoundupWidget, Actions) == 0x000338, "Member 'URoundupWidget::Actions' has a wrong offset!");
static_assert(offsetof(URoundupWidget, bUsingGamepad) == 0x000348, "Member 'URoundupWidget::bUsingGamepad' has a wrong offset!");
static_assert(offsetof(URoundupWidget, MetaGameProfile) == 0x000350, "Member 'URoundupWidget::MetaGameProfile' has a wrong offset!");
static_assert(offsetof(URoundupWidget, CommanderProfile) == 0x000358, "Member 'URoundupWidget::CommanderProfile' has a wrong offset!");
static_assert(offsetof(URoundupWidget, RosterManager) == 0x000360, "Member 'URoundupWidget::RosterManager' has a wrong offset!");

// Class ReadyOrNot.AIFactionManager
// 0x0058 (0x0278 - 0x0220)
class AAIFactionManager final  : public AActor
{
public:
	uint8                                         bGroupIntoTeams : 1;                               // 0x0220(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_212B[0x3];                                     // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeamsOf;                                           // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAssignRandomTeamTactics : 1;                      // 0x0228(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_212C[0x7];                                     // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFactionTeamTactics>            TacticsPool;                                       // 0x0230(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFactionSuspectTeam>            SuspectTeams;                                      // 0x0240(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ACyberneticCharacter*>           Characters;                                        // 0x0250(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ACyberneticCharacter*>           Leaders;                                           // 0x0260(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	float                                         TeamBehaviourStrengthReductionSpeed;               // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TeamBehaviourOverrideStrength;                     // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AlertOtherSuspectsInTeam_Blueprint(class ASuspectCharacter* Suspect, class AReadyOrNotCharacter* Enemy);
	bool GetSuspectsInTeam(class ASuspectCharacter* InSuspect, TArray<class ASuspectCharacter*>* OutSuspects, bool bIncludeSelf);
	void OnAIAdded_Blueprint(class ACyberneticCharacter* Character);
	void OnAISpottedEnemy(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Enemy);
	void OnAISpottedEnemy_Blueprint(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Enemy);
	void OnAISpottedFriendly(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Friendly);
	void OnAISpottedFriendly_Blueprint(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Friendly);
	void OnAISpottedNeutral(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Neutral);
	void OnAISpottedNeutral_Blueprint(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Neutral);
	void OnAllAISpawned_Blueprint();

	bool AreTeamSpotsAvailable(int32* OutIndex) const;
	class ASuspectCharacter* FindClosestSuspect(TArray<class ASuspectCharacter*>& OtherSuspects, class ASuspectCharacter* Suspect, float MaxDistance) const;
	TArray<class ACyberneticCharacter*> GetAllCharacters() const;
	TArray<class ACivilianCharacter*> GetAllCivilians() const;
	TArray<class ACyberneticCharacter*> GetAllLeaders() const;
	TArray<class ASuspectCharacter*> GetAllSuspects() const;
	int32 GetTeamIndex(class ASuspectCharacter* InSuspect) const;
	bool GetTeamTacticFor(class ASuspectCharacter* InSuspect, EAITeamTactic* OutTactic) const;
	bool IsSuspectInTeam(class ASuspectCharacter* InSuspect, struct FFactionSuspectTeam* OutTeam) const;
	bool IsTeamFull(struct FFactionSuspectTeam& InTeam) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIFactionManager">();
	}
	static class AAIFactionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIFactionManager>();
	}
};
static_assert(alignof(AAIFactionManager) == 0x000008, "Wrong alignment on AAIFactionManager");
static_assert(sizeof(AAIFactionManager) == 0x000278, "Wrong size on AAIFactionManager");
static_assert(offsetof(AAIFactionManager, TeamsOf) == 0x000224, "Member 'AAIFactionManager::TeamsOf' has a wrong offset!");
static_assert(offsetof(AAIFactionManager, TacticsPool) == 0x000230, "Member 'AAIFactionManager::TacticsPool' has a wrong offset!");
static_assert(offsetof(AAIFactionManager, SuspectTeams) == 0x000240, "Member 'AAIFactionManager::SuspectTeams' has a wrong offset!");
static_assert(offsetof(AAIFactionManager, Characters) == 0x000250, "Member 'AAIFactionManager::Characters' has a wrong offset!");
static_assert(offsetof(AAIFactionManager, Leaders) == 0x000260, "Member 'AAIFactionManager::Leaders' has a wrong offset!");
static_assert(offsetof(AAIFactionManager, TeamBehaviourStrengthReductionSpeed) == 0x000270, "Member 'AAIFactionManager::TeamBehaviourStrengthReductionSpeed' has a wrong offset!");
static_assert(offsetof(AAIFactionManager, TeamBehaviourOverrideStrength) == 0x000274, "Member 'AAIFactionManager::TeamBehaviourOverrideStrength' has a wrong offset!");

// Class ReadyOrNot.AISelectionDebugWidget
// 0x0008 (0x0268 - 0x0260)
class UAISelectionDebugWidget final  : public UUserWidget
{
public:
	class UTextBlock*                             AIName_TextBlock;                                  // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISelectionDebugWidget">();
	}
	static class UAISelectionDebugWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISelectionDebugWidget>();
	}
};
static_assert(alignof(UAISelectionDebugWidget) == 0x000008, "Wrong alignment on UAISelectionDebugWidget");
static_assert(sizeof(UAISelectionDebugWidget) == 0x000268, "Wrong size on UAISelectionDebugWidget");
static_assert(offsetof(UAISelectionDebugWidget, AIName_TextBlock) == 0x000260, "Member 'UAISelectionDebugWidget::AIName_TextBlock' has a wrong offset!");

// Class ReadyOrNot.SpinTestHeatmapVolume
// 0x0000 (0x0258 - 0x0258)
class ASpinTestHeatmapVolume final  : public AVolume
{
public:
	void FlushVisualization();
	void VisualizeHeatMapIfExists();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpinTestHeatmapVolume">();
	}
	static class ASpinTestHeatmapVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpinTestHeatmapVolume>();
	}
};
static_assert(alignof(ASpinTestHeatmapVolume) == 0x000008, "Wrong alignment on ASpinTestHeatmapVolume");
static_assert(sizeof(ASpinTestHeatmapVolume) == 0x000258, "Wrong size on ASpinTestHeatmapVolume");

// Class ReadyOrNot.KingOfTheHostageGM
// 0x0030 (0x0800 - 0x07D0)
class AKingOfTheHostageGM final  : public AReadyOrNotGameMode_PVP
{
public:
	TArray<class APawn*>                          SpawnedHostages;                                   // 0x07D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2134[0x10];                                    // 0x07E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Start_RoundTime;                                   // 0x07F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlueTeamOnAttack;                                 // 0x07F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2135[0xB];                                     // 0x07F5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AreAllHostagesSafe();
	void OnHostageRescued__DelegateSignature(class APawn* HostageRescued);
	class APawn* SpawnHostage(TSubclassOf<class APawn> HostageClass, const TArray<struct FVector>& SpawnLocations);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KingOfTheHostageGM">();
	}
	static class AKingOfTheHostageGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKingOfTheHostageGM>();
	}
};
static_assert(alignof(AKingOfTheHostageGM) == 0x000010, "Wrong alignment on AKingOfTheHostageGM");
static_assert(sizeof(AKingOfTheHostageGM) == 0x000800, "Wrong size on AKingOfTheHostageGM");
static_assert(offsetof(AKingOfTheHostageGM, SpawnedHostages) == 0x0007D0, "Member 'AKingOfTheHostageGM::SpawnedHostages' has a wrong offset!");
static_assert(offsetof(AKingOfTheHostageGM, Start_RoundTime) == 0x0007F0, "Member 'AKingOfTheHostageGM::Start_RoundTime' has a wrong offset!");
static_assert(offsetof(AKingOfTheHostageGM, bBlueTeamOnAttack) == 0x0007F4, "Member 'AKingOfTheHostageGM::bBlueTeamOnAttack' has a wrong offset!");

// Class ReadyOrNot.AISpawn
// 0x00D0 (0x02F0 - 0x0220)
class AAISpawn final  : public AActor
{
public:
	uint8                                         bEnabled : 1;                                      // 0x0220(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bAllowExplosiveVestSpawn;                          // 0x0221(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2136[0x2];                                     // 0x0222(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnChance;                                       // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         GroupID;                                           // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2137[0x8F];                                    // 0x0229(0x008F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpawnData>                     SpawnArray;                                        // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseWeapon>                GlobalWeaponOverride;                              // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIArchetypeData*                       ArchetypeOverride;                                 // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   SpawnedCharacter;                                  // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultScene;                                      // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        SpawnDirection;                                    // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static ETeamType GetSpawningTeamType(struct FSpawnData& Sd);

	bool DoSpawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISpawn">();
	}
	static class AAISpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAISpawn>();
	}
};
static_assert(alignof(AAISpawn) == 0x000008, "Wrong alignment on AAISpawn");
static_assert(sizeof(AAISpawn) == 0x0002F0, "Wrong size on AAISpawn");
static_assert(offsetof(AAISpawn, bAllowExplosiveVestSpawn) == 0x000221, "Member 'AAISpawn::bAllowExplosiveVestSpawn' has a wrong offset!");
static_assert(offsetof(AAISpawn, SpawnChance) == 0x000224, "Member 'AAISpawn::SpawnChance' has a wrong offset!");
static_assert(offsetof(AAISpawn, GroupID) == 0x000228, "Member 'AAISpawn::GroupID' has a wrong offset!");
static_assert(offsetof(AAISpawn, SpawnArray) == 0x0002B8, "Member 'AAISpawn::SpawnArray' has a wrong offset!");
static_assert(offsetof(AAISpawn, GlobalWeaponOverride) == 0x0002C8, "Member 'AAISpawn::GlobalWeaponOverride' has a wrong offset!");
static_assert(offsetof(AAISpawn, ArchetypeOverride) == 0x0002D0, "Member 'AAISpawn::ArchetypeOverride' has a wrong offset!");
static_assert(offsetof(AAISpawn, SpawnedCharacter) == 0x0002D8, "Member 'AAISpawn::SpawnedCharacter' has a wrong offset!");
static_assert(offsetof(AAISpawn, DefaultScene) == 0x0002E0, "Member 'AAISpawn::DefaultScene' has a wrong offset!");
static_assert(offsetof(AAISpawn, SpawnDirection) == 0x0002E8, "Member 'AAISpawn::SpawnDirection' has a wrong offset!");

// Class ReadyOrNot.ResourceComponent
// 0x0058 (0x0108 - 0x00B0)
class UResourceComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnFullResource;                                    // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLowResource;                                     // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDepletedResource;                                // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   ResourceName;                                      // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Resource;                                          // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxResource;                                       // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxResourceLimit;                                  // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowResourceThreshold;                              // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OriginalMaxResource;                               // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowResource;                                       // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviousResource;                                  // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUnlimited : 1;                                    // 0x0104(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2139[0x3];                                     // 0x0105(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecreaseResource(float Amount);
	void DecreaseResourceByRate(float Rate);
	void DepleteResource();
	void DisableUnlimitedResource();
	void EnableUnlimitedResource();
	void IncreaseResource(float Amount);
	void IncreaseResourceByRate(float Rate);
	void OnDepletedResourceSignature__DelegateSignature();
	void OnFullResourceSignature__DelegateSignature();
	void OnLowResourceSignature__DelegateSignature(float Param_Resource);
	void ResetResource();
	void Server_DecreaseResource(float Amount);
	void Server_DepleteResource();
	void Server_DisableUnlimitedResource();
	void Server_EnableUnlimitedResource();
	void Server_IncreaseResource(float Amount);
	void Server_InitResource();
	void Server_ResetResource();
	void Server_SetCurrentResourceToMax();
	void Server_SetMaxResource(float NewMaxResource);
	void Server_SetResource(float NewResourceAmount);
	void Server_SetUnlimitedResource(bool bEnabled);
	void Server_ToggleUnlimitedResource();
	void Server_UpdatePreviousResource();
	void SetCurrentResourceToMax();
	void SetMaxResource(float NewMaxResource);
	void SetResource(float NewResourceAmount);
	void SetUnlimitedResource(bool bEnabled);
	void ToggleUnlimitedResource();
	void UpdatePreviousResource();

	float DecreaseResource_Expression(float Amount) const;
	float GetCurrentResource() const;
	float GetHalfResource() const;
	float GetLowResource() const;
	float GetLowResourceThreshold() const;
	float GetMaxResource() const;
	float GetNormalizedResource() const;
	float GetOriginalMaxResource() const;
	float GetPreviousResource() const;
	class FName GetResourceName() const;
	bool HasResource() const;
	float IncreaseResource_Expression(float Amount) const;
	bool IsDepleted() const;
	bool IsFullResource() const;
	bool IsHalfResource() const;
	bool IsLowResource() const;
	bool IsResourceAbove(float ResourceValue) const;
	bool IsResourceAt(float ResourceValue) const;
	bool IsResourceAtOrAbove(float ResourceValue) const;
	bool IsResourceAtOrBelow(float ResourceValue) const;
	bool IsResourceBelow(float ResourceValue) const;
	bool IsUnlimitedResourceEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResourceComponent">();
	}
	static class UResourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResourceComponent>();
	}
};
static_assert(alignof(UResourceComponent) == 0x000008, "Wrong alignment on UResourceComponent");
static_assert(sizeof(UResourceComponent) == 0x000108, "Wrong size on UResourceComponent");
static_assert(offsetof(UResourceComponent, OnFullResource) == 0x0000B0, "Member 'UResourceComponent::OnFullResource' has a wrong offset!");
static_assert(offsetof(UResourceComponent, OnLowResource) == 0x0000C0, "Member 'UResourceComponent::OnLowResource' has a wrong offset!");
static_assert(offsetof(UResourceComponent, OnDepletedResource) == 0x0000D0, "Member 'UResourceComponent::OnDepletedResource' has a wrong offset!");
static_assert(offsetof(UResourceComponent, ResourceName) == 0x0000E0, "Member 'UResourceComponent::ResourceName' has a wrong offset!");
static_assert(offsetof(UResourceComponent, Resource) == 0x0000E8, "Member 'UResourceComponent::Resource' has a wrong offset!");
static_assert(offsetof(UResourceComponent, MaxResource) == 0x0000EC, "Member 'UResourceComponent::MaxResource' has a wrong offset!");
static_assert(offsetof(UResourceComponent, MaxResourceLimit) == 0x0000F0, "Member 'UResourceComponent::MaxResourceLimit' has a wrong offset!");
static_assert(offsetof(UResourceComponent, LowResourceThreshold) == 0x0000F4, "Member 'UResourceComponent::LowResourceThreshold' has a wrong offset!");
static_assert(offsetof(UResourceComponent, OriginalMaxResource) == 0x0000F8, "Member 'UResourceComponent::OriginalMaxResource' has a wrong offset!");
static_assert(offsetof(UResourceComponent, LowResource) == 0x0000FC, "Member 'UResourceComponent::LowResource' has a wrong offset!");
static_assert(offsetof(UResourceComponent, PreviousResource) == 0x000100, "Member 'UResourceComponent::PreviousResource' has a wrong offset!");

// Class ReadyOrNot.LightningGenerator
// 0x00A8 (0x02C8 - 0x0220)
class ALightningGenerator final  : public AActor
{
public:
	uint8                                         Pad_213F[0x10];                                    // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneRoot;                                         // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        Thunder;                                           // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ParticleComponent;                                 // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleSpawnChance;                               // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2140[0x4];                                     // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UParticleSystem*>                ParticleTemplates;                                 // 0x0250(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     ThunderSounds;                                     // 0x0260(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             Lightning;                                         // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThunderDelayMin;                                   // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThunderDelayMax;                                   // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightningColorMin;                                 // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightningColorMax;                                 // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningDelayMin;                                 // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningDelayMax;                                 // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningIntensityMin;                             // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningIntensityMax;                             // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningIntensityDecay;                           // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningIntensityJitterMin;                       // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningIntensityJitterMax;                       // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningIntensityJitterTimeMin;                   // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningIntensityJitterTimeMax;                   // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningJitterTimeRemaining;                      // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void PlayLightning();
	void PlayThunder();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightningGenerator">();
	}
	static class ALightningGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALightningGenerator>();
	}
};
static_assert(alignof(ALightningGenerator) == 0x000008, "Wrong alignment on ALightningGenerator");
static_assert(sizeof(ALightningGenerator) == 0x0002C8, "Wrong size on ALightningGenerator");
static_assert(offsetof(ALightningGenerator, SceneRoot) == 0x000230, "Member 'ALightningGenerator::SceneRoot' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, Thunder) == 0x000238, "Member 'ALightningGenerator::Thunder' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, ParticleComponent) == 0x000240, "Member 'ALightningGenerator::ParticleComponent' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, ParticleSpawnChance) == 0x000248, "Member 'ALightningGenerator::ParticleSpawnChance' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, ParticleTemplates) == 0x000250, "Member 'ALightningGenerator::ParticleTemplates' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, ThunderSounds) == 0x000260, "Member 'ALightningGenerator::ThunderSounds' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, Lightning) == 0x000270, "Member 'ALightningGenerator::Lightning' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, ThunderDelayMin) == 0x000278, "Member 'ALightningGenerator::ThunderDelayMin' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, ThunderDelayMax) == 0x00027C, "Member 'ALightningGenerator::ThunderDelayMax' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningColorMin) == 0x000280, "Member 'ALightningGenerator::LightningColorMin' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningColorMax) == 0x000290, "Member 'ALightningGenerator::LightningColorMax' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningDelayMin) == 0x0002A0, "Member 'ALightningGenerator::LightningDelayMin' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningDelayMax) == 0x0002A4, "Member 'ALightningGenerator::LightningDelayMax' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningIntensityMin) == 0x0002A8, "Member 'ALightningGenerator::LightningIntensityMin' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningIntensityMax) == 0x0002AC, "Member 'ALightningGenerator::LightningIntensityMax' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningIntensityDecay) == 0x0002B0, "Member 'ALightningGenerator::LightningIntensityDecay' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningIntensityJitterMin) == 0x0002B4, "Member 'ALightningGenerator::LightningIntensityJitterMin' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningIntensityJitterMax) == 0x0002B8, "Member 'ALightningGenerator::LightningIntensityJitterMax' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningIntensityJitterTimeMin) == 0x0002BC, "Member 'ALightningGenerator::LightningIntensityJitterTimeMin' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningIntensityJitterTimeMax) == 0x0002C0, "Member 'ALightningGenerator::LightningIntensityJitterTimeMax' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningJitterTimeRemaining) == 0x0002C4, "Member 'ALightningGenerator::LightningJitterTimeRemaining' has a wrong offset!");

// Class ReadyOrNot.AmmoComponent
// 0x0008 (0x0110 - 0x0108)
class UAmmoComponent final  : public UResourceComponent
{
public:
	float                                         AmmoUsagePerSecond;                                // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2141[0x4];                                     // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetAmmoUsagePerSecond() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoComponent">();
	}
	static class UAmmoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAmmoComponent>();
	}
};
static_assert(alignof(UAmmoComponent) == 0x000008, "Wrong alignment on UAmmoComponent");
static_assert(sizeof(UAmmoComponent) == 0x000110, "Wrong size on UAmmoComponent");
static_assert(offsetof(UAmmoComponent, AmmoUsagePerSecond) == 0x000108, "Member 'UAmmoComponent::AmmoUsagePerSecond' has a wrong offset!");

// Class ReadyOrNot.AmmoRefillBox
// 0x0038 (0x0258 - 0x0220)
class AAmmoRefillBox final  : public AActor
{
public:
	uint8                                         Pad_2142[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 InteractableComponent;                             // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2143[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   RefillCharacter;                                   // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2144[0x18];                                    // 0x0240(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoRefillBox">();
	}
	static class AAmmoRefillBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAmmoRefillBox>();
	}
};
static_assert(alignof(AAmmoRefillBox) == 0x000008, "Wrong alignment on AAmmoRefillBox");
static_assert(sizeof(AAmmoRefillBox) == 0x000258, "Wrong size on AAmmoRefillBox");
static_assert(offsetof(AAmmoRefillBox, InteractableComponent) == 0x000228, "Member 'AAmmoRefillBox::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AAmmoRefillBox, RefillCharacter) == 0x000238, "Member 'AAmmoRefillBox::RefillCharacter' has a wrong offset!");

// Class ReadyOrNot.ThrownItem
// 0x0240 (0x0460 - 0x0220)
class AThrownItem : public AActor
{
public:
	class AReadyOrNotCharacter*                   ThrowInstigator;                                   // 0x0220(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThrownInRoom;                                      // 0x0228(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SceneComponent;                                    // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIPerceptionStimuliSourceComponent*    PerceptionStimuliComp;                             // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnPhysicsOffDelay;                               // 0x0248(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowDistance;                                     // 0x024C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        FirstBouncePath;                                   // 0x0250(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FHitResult                             FirstBounceHit;                                    // 0x0260(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2145[0x8];                                     // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        SecondBouncePath;                                  // 0x02F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FHitResult                             SecondBounceHit;                                   // 0x0300(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2146[0x8];                                     // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ThirdBouncePath;                                   // 0x0390(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FHitResult                             ThirdBounceHit;                                    // 0x03A0(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2147[0x8];                                     // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector_NetQuantize>            CompletePath;                                      // 0x0430(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         BouncePt1;                                         // 0x0440(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BouncePt2;                                         // 0x0444(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BouncePt3;                                         // 0x0448(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2148[0x4];                                     // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThrowSpeed;                                        // 0x0450(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2149[0x8];                                     // 0x0454(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThrowBounciness;                                   // 0x045C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, struct FHitResult& Hit);
	void OnRep_ThrowPath();
	void UpdateServerPath(TArray<struct FVector_NetQuantize>& Path, int32 Bounce1, int32 Bounce2, int32 Bounce3);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrownItem">();
	}
	static class AThrownItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThrownItem>();
	}
};
static_assert(alignof(AThrownItem) == 0x000008, "Wrong alignment on AThrownItem");
static_assert(sizeof(AThrownItem) == 0x000460, "Wrong size on AThrownItem");
static_assert(offsetof(AThrownItem, ThrowInstigator) == 0x000220, "Member 'AThrownItem::ThrowInstigator' has a wrong offset!");
static_assert(offsetof(AThrownItem, ThrownInRoom) == 0x000228, "Member 'AThrownItem::ThrownInRoom' has a wrong offset!");
static_assert(offsetof(AThrownItem, SceneComponent) == 0x000230, "Member 'AThrownItem::SceneComponent' has a wrong offset!");
static_assert(offsetof(AThrownItem, StaticMesh) == 0x000238, "Member 'AThrownItem::StaticMesh' has a wrong offset!");
static_assert(offsetof(AThrownItem, PerceptionStimuliComp) == 0x000240, "Member 'AThrownItem::PerceptionStimuliComp' has a wrong offset!");
static_assert(offsetof(AThrownItem, TurnPhysicsOffDelay) == 0x000248, "Member 'AThrownItem::TurnPhysicsOffDelay' has a wrong offset!");
static_assert(offsetof(AThrownItem, ThrowDistance) == 0x00024C, "Member 'AThrownItem::ThrowDistance' has a wrong offset!");
static_assert(offsetof(AThrownItem, FirstBouncePath) == 0x000250, "Member 'AThrownItem::FirstBouncePath' has a wrong offset!");
static_assert(offsetof(AThrownItem, FirstBounceHit) == 0x000260, "Member 'AThrownItem::FirstBounceHit' has a wrong offset!");
static_assert(offsetof(AThrownItem, SecondBouncePath) == 0x0002F0, "Member 'AThrownItem::SecondBouncePath' has a wrong offset!");
static_assert(offsetof(AThrownItem, SecondBounceHit) == 0x000300, "Member 'AThrownItem::SecondBounceHit' has a wrong offset!");
static_assert(offsetof(AThrownItem, ThirdBouncePath) == 0x000390, "Member 'AThrownItem::ThirdBouncePath' has a wrong offset!");
static_assert(offsetof(AThrownItem, ThirdBounceHit) == 0x0003A0, "Member 'AThrownItem::ThirdBounceHit' has a wrong offset!");
static_assert(offsetof(AThrownItem, CompletePath) == 0x000430, "Member 'AThrownItem::CompletePath' has a wrong offset!");
static_assert(offsetof(AThrownItem, BouncePt1) == 0x000440, "Member 'AThrownItem::BouncePt1' has a wrong offset!");
static_assert(offsetof(AThrownItem, BouncePt2) == 0x000444, "Member 'AThrownItem::BouncePt2' has a wrong offset!");
static_assert(offsetof(AThrownItem, BouncePt3) == 0x000448, "Member 'AThrownItem::BouncePt3' has a wrong offset!");
static_assert(offsetof(AThrownItem, ThrowSpeed) == 0x000450, "Member 'AThrownItem::ThrowSpeed' has a wrong offset!");
static_assert(offsetof(AThrownItem, ThrowBounciness) == 0x00045C, "Member 'AThrownItem::ThrowBounciness' has a wrong offset!");

// Class ReadyOrNot.ThrownGrenade
// 0x0000 (0x0460 - 0x0460)
class AThrownGrenade : public AThrownItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrownGrenade">();
	}
	static class AThrownGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThrownGrenade>();
	}
};
static_assert(alignof(AThrownGrenade) == 0x000008, "Wrong alignment on AThrownGrenade");
static_assert(sizeof(AThrownGrenade) == 0x000460, "Wrong size on AThrownGrenade");

// Class ReadyOrNot.Loadout_V2
// 0x0458 (0x0778 - 0x0320)
class ULoadout_V2 : public UCommonActivatableWidget
{
public:
	class UOverview_V2*                           OverviewWidget;                                    // 0x0320(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonActivatableWidgetStack*          WidgetStack;                                       // 0x0328(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotGameState*                   Gs;                                                // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotPlayerController*            PC;                                                // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotPlayerState*                 Ps;                                                // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_214C[0x8];                                     // 0x0348(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotPlayerState*                 PreviewPlayerState;                                // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AReadyOrNotCharacter*, class AReadyOrNotPlayerState*> PlayerStatePreviewMap;                             // 0x0358(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   RedTeamClass;                                      // 0x03A8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   BlueTeamClass;                                     // 0x03D0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   VIPClass;                                          // 0x03F8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class ABaseItem>, struct FSavedWeaponPreset> WeaponToWeaponPresetsMap;                          // 0x0420(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class AReadyOrNotPlayerState*                 EquippingPlayerState;                              // 0x0470(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_214D[0x8];                                     // 0x0478(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EEquippingSwat, struct FSavedLoadout>    LastSavedLoadout;                                  // 0x0480(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<EEquippingSwat, struct FSavedLoadout>    LastEquippedPreviewLoadout;                        // 0x04D0(0x0050)(Protected, NativeAccessSpecifierProtected)
	class FString                                 PrimaryDrawAnim;                                   // 0x0520(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PrimaryHolsterAnim;                                // 0x0530(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SidearmDrawAnim;                                   // 0x0540(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SidearmHolsterAnim;                                // 0x0550(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CurrentPreviewAnimation;                           // 0x0560(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CurrentCameraTag;                                  // 0x0570(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HolsterTimeRemaining;                              // 0x0578(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_214E[0x4];                                     // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EItemCategory, class FName>              CategoryCameraTags;                                // 0x0580(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EItemCategory, class FString>            CategoryPoses;                                     // 0x05D0(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          ApplyingPresets;                                   // 0x0620(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UsingPreset;                                       // 0x0621(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          PresetDirty;                                       // 0x0622(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VerticalListOpen;                                  // 0x0623(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ListVisible;                                       // 0x0624(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_214F[0x3];                                     // 0x0625(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AnimExtendListSlide;                               // 0x0628(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class ABaseItem*>           WorkBenchItemPtrMap;                               // 0x0630(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class ABaseItem>, struct FSavedWeaponAttachmentData> WeaponToAttachmentsMap;                            // 0x0680(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsCustomizingPrimary;                             // 0x06D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2150[0x13];                                    // 0x06D1(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActiveCameraTag;                                   // 0x06E4(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2151[0x5C];                                    // 0x06EC(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoadoutSlotWidget*                     CurrentActiveSlot;                                 // 0x0748(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeOut;                                           // 0x0750(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2152[0x18];                                    // 0x0758(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UReadyOrNotLoadoutManager*              LoadoutFunctionLibrary;                            // 0x0770(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ApplyLoadoutPreset(const struct FLoadoutPreset& LoadoutPreset);
	void ExitLoadout();
	class AReadyOrNotCharacter* GetDefaultPreviewCharacter();
	bool GetInputLocked();
	void HidePrimary(bool bIsHidden);
	void HidePrimaryAndSecondary();
	void LoadAddAttachment(class ABaseWeapon* BaseWeapon, TSubclassOf<class UWeaponAttachment> Attachment, bool bReplicateAttachment);
	void LoadStoredWeaponAttachments();
	void LoadWeaponPresets();
	void OnLoadoutItemAttachmentsLoaded();
	void OnLoadoutItemAttachmentsSaved();
	void OnLoadoutItemPresetsLoaded();
	void OnLoadoutItemPresetsSaved();
	void OnLoadoutLoaded();
	void OnLoadoutPresetsLoaded();
	void OnLoadoutPresetsSaved();
	void OnLoadoutSaved();
	void OnSwatCharacterChanged();
	void OpenCustomization();
	void PlayAnimationOnPreviewCharacter(const class FString& Animation);
	void SaveStoredWeaponAttachments();
	void SetActiveCameraByTag(class FName Tag, float BlendTime);
	void SetActiveCameraByTagWithFade(class FName Tag, float BlendTime, float FadeTime);
	void SetBodyArmour(TSubclassOf<class ABaseItem> BodyArmour);
	void SetDefaultCamera(float BlendTime);
	void SetHeadwear(TSubclassOf<class ABaseItem> Headwear);
	void SetItem(EItemType ItemType, TSubclassOf<class ABaseItem> ItemClass);
	void SetLockInput(bool bShouldLockInput);
	void SetLongTactical(TSubclassOf<class ABaseItem> LongTactical);
	void SetPrimaryWeapon(const struct FWeaponData& WeaponData);
	void SetSecondaryWeapon(const struct FWeaponData& WeaponData);
	void SetWorkbenchItemClass(TSubclassOf<class ABaseItem> Item, class FName Tag, const struct FSavedLoadout& Loadout);
	void UpdateDefaultPreviewCharacter();
	void UpdatePreviewCharacter(class AReadyOrNotPlayerState* InPreviewPlayerState, class FName Tag);
	void UpdatePreviewCharacterArmour();
	void UpdatePreviewCharacterHeadwear();
	void UpdatePreviewCharacterLongTactical();
	void UpdatePreviewCharacterPrimary();
	void UpdatePreviewCharacterSecondary();
	void UpdatePreviewWeaponAttachments(bool IsSecondary, TSubclassOf<class UWeaponAttachment> Attachment);
	void UpdateWorkbenchItemAttachments(const struct FSavedLoadout& Loadout, bool IsSecondary);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Loadout_V2">();
	}
	static class ULoadout_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadout_V2>();
	}
};
static_assert(alignof(ULoadout_V2) == 0x000008, "Wrong alignment on ULoadout_V2");
static_assert(sizeof(ULoadout_V2) == 0x000778, "Wrong size on ULoadout_V2");
static_assert(offsetof(ULoadout_V2, OverviewWidget) == 0x000320, "Member 'ULoadout_V2::OverviewWidget' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, WidgetStack) == 0x000328, "Member 'ULoadout_V2::WidgetStack' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, Gs) == 0x000330, "Member 'ULoadout_V2::Gs' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, PC) == 0x000338, "Member 'ULoadout_V2::PC' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, Ps) == 0x000340, "Member 'ULoadout_V2::Ps' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, PreviewPlayerState) == 0x000350, "Member 'ULoadout_V2::PreviewPlayerState' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, PlayerStatePreviewMap) == 0x000358, "Member 'ULoadout_V2::PlayerStatePreviewMap' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, RedTeamClass) == 0x0003A8, "Member 'ULoadout_V2::RedTeamClass' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, BlueTeamClass) == 0x0003D0, "Member 'ULoadout_V2::BlueTeamClass' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, VIPClass) == 0x0003F8, "Member 'ULoadout_V2::VIPClass' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, WeaponToWeaponPresetsMap) == 0x000420, "Member 'ULoadout_V2::WeaponToWeaponPresetsMap' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, EquippingPlayerState) == 0x000470, "Member 'ULoadout_V2::EquippingPlayerState' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, LastSavedLoadout) == 0x000480, "Member 'ULoadout_V2::LastSavedLoadout' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, LastEquippedPreviewLoadout) == 0x0004D0, "Member 'ULoadout_V2::LastEquippedPreviewLoadout' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, PrimaryDrawAnim) == 0x000520, "Member 'ULoadout_V2::PrimaryDrawAnim' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, PrimaryHolsterAnim) == 0x000530, "Member 'ULoadout_V2::PrimaryHolsterAnim' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, SidearmDrawAnim) == 0x000540, "Member 'ULoadout_V2::SidearmDrawAnim' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, SidearmHolsterAnim) == 0x000550, "Member 'ULoadout_V2::SidearmHolsterAnim' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, CurrentPreviewAnimation) == 0x000560, "Member 'ULoadout_V2::CurrentPreviewAnimation' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, CurrentCameraTag) == 0x000570, "Member 'ULoadout_V2::CurrentCameraTag' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, HolsterTimeRemaining) == 0x000578, "Member 'ULoadout_V2::HolsterTimeRemaining' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, CategoryCameraTags) == 0x000580, "Member 'ULoadout_V2::CategoryCameraTags' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, CategoryPoses) == 0x0005D0, "Member 'ULoadout_V2::CategoryPoses' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, ApplyingPresets) == 0x000620, "Member 'ULoadout_V2::ApplyingPresets' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, UsingPreset) == 0x000621, "Member 'ULoadout_V2::UsingPreset' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, PresetDirty) == 0x000622, "Member 'ULoadout_V2::PresetDirty' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, VerticalListOpen) == 0x000623, "Member 'ULoadout_V2::VerticalListOpen' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, ListVisible) == 0x000624, "Member 'ULoadout_V2::ListVisible' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, AnimExtendListSlide) == 0x000628, "Member 'ULoadout_V2::AnimExtendListSlide' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, WorkBenchItemPtrMap) == 0x000630, "Member 'ULoadout_V2::WorkBenchItemPtrMap' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, WeaponToAttachmentsMap) == 0x000680, "Member 'ULoadout_V2::WeaponToAttachmentsMap' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, bIsCustomizingPrimary) == 0x0006D0, "Member 'ULoadout_V2::bIsCustomizingPrimary' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, ActiveCameraTag) == 0x0006E4, "Member 'ULoadout_V2::ActiveCameraTag' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, CurrentActiveSlot) == 0x000748, "Member 'ULoadout_V2::CurrentActiveSlot' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, FadeOut) == 0x000750, "Member 'ULoadout_V2::FadeOut' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, LoadoutFunctionLibrary) == 0x000770, "Member 'ULoadout_V2::LoadoutFunctionLibrary' has a wrong offset!");

// Class ReadyOrNot.AnimatedDecal
// 0x0098 (0x02B8 - 0x0220)
class AAnimatedDecal : public AActor
{
public:
	class UDecalComponent*                        Decal;                                             // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationTimescale;                                // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2157[0x4];                                     // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     AnimationCurve;                                    // 0x0230(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static float GetRuntimeFloatCurveValue(struct FRuntimeFloatCurve& Curve, float Time);

	void SetAnimatedDecalMaterial(class UMaterialInterface* Material);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimatedDecal">();
	}
	static class AAnimatedDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAnimatedDecal>();
	}
};
static_assert(alignof(AAnimatedDecal) == 0x000008, "Wrong alignment on AAnimatedDecal");
static_assert(sizeof(AAnimatedDecal) == 0x0002B8, "Wrong size on AAnimatedDecal");
static_assert(offsetof(AAnimatedDecal, Decal) == 0x000220, "Member 'AAnimatedDecal::Decal' has a wrong offset!");
static_assert(offsetof(AAnimatedDecal, AnimationTimescale) == 0x000228, "Member 'AAnimatedDecal::AnimationTimescale' has a wrong offset!");
static_assert(offsetof(AAnimatedDecal, AnimationCurve) == 0x000230, "Member 'AAnimatedDecal::AnimationCurve' has a wrong offset!");

// Class ReadyOrNot.AnimatedIconWidget
// 0x0100 (0x0360 - 0x0260)
class UAnimatedIconWidget : public UUserWidget
{
public:
	TArray<class UImage*>                         IconImages;                                        // 0x0260(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         CurrentIndex;                                      // 0x0270(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x0274(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPaused : 1;                                       // 0x0278(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2158[0x7];                                     // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               InteractCircle_Overlay;                            // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               InteractIcon_SizeBox;                              // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        IconSwitcher;                                      // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_1;                                           // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_2;                                           // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_3;                                           // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_4;                                           // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_5;                                           // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_6;                                           // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_7;                                           // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_8;                                           // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FrameImages[0x8];                                  // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ProgressCircle_Image;                              // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_Interact;                                     // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_Focus;                                        // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           InteractionInvalidTintColor;                       // 0x0330(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     ProgressCircleMaterial;                            // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ProgressParamName;                                 // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 ParentComponent;                                   // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MID_ProgressCircle;                                // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PauseIconAnim();
	void PlayFocusAnim(bool bReverse);
	void PlayInteractAnim();
	void SetActiveIcon(int32 Param_Index);
	void SetCurrentProgress(float Percent);
	void SetInteractIconSize(float InInteractCircleSize, float InInteractIconSize);
	void SetInteractState(bool bValid);
	void StopFocusAnim();
	void StopInteractAnim();
	void UnPauseIconAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimatedIconWidget">();
	}
	static class UAnimatedIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimatedIconWidget>();
	}
};
static_assert(alignof(UAnimatedIconWidget) == 0x000008, "Wrong alignment on UAnimatedIconWidget");
static_assert(sizeof(UAnimatedIconWidget) == 0x000360, "Wrong size on UAnimatedIconWidget");
static_assert(offsetof(UAnimatedIconWidget, IconImages) == 0x000260, "Member 'UAnimatedIconWidget::IconImages' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, CurrentIndex) == 0x000270, "Member 'UAnimatedIconWidget::CurrentIndex' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, ElapsedTime) == 0x000274, "Member 'UAnimatedIconWidget::ElapsedTime' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, InteractCircle_Overlay) == 0x000280, "Member 'UAnimatedIconWidget::InteractCircle_Overlay' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, InteractIcon_SizeBox) == 0x000288, "Member 'UAnimatedIconWidget::InteractIcon_SizeBox' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, IconSwitcher) == 0x000290, "Member 'UAnimatedIconWidget::IconSwitcher' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Frame_1) == 0x000298, "Member 'UAnimatedIconWidget::Frame_1' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Frame_2) == 0x0002A0, "Member 'UAnimatedIconWidget::Frame_2' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Frame_3) == 0x0002A8, "Member 'UAnimatedIconWidget::Frame_3' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Frame_4) == 0x0002B0, "Member 'UAnimatedIconWidget::Frame_4' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Frame_5) == 0x0002B8, "Member 'UAnimatedIconWidget::Frame_5' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Frame_6) == 0x0002C0, "Member 'UAnimatedIconWidget::Frame_6' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Frame_7) == 0x0002C8, "Member 'UAnimatedIconWidget::Frame_7' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Frame_8) == 0x0002D0, "Member 'UAnimatedIconWidget::Frame_8' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, FrameImages) == 0x0002D8, "Member 'UAnimatedIconWidget::FrameImages' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, ProgressCircle_Image) == 0x000318, "Member 'UAnimatedIconWidget::ProgressCircle_Image' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Anim_Interact) == 0x000320, "Member 'UAnimatedIconWidget::Anim_Interact' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Anim_Focus) == 0x000328, "Member 'UAnimatedIconWidget::Anim_Focus' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, InteractionInvalidTintColor) == 0x000330, "Member 'UAnimatedIconWidget::InteractionInvalidTintColor' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, ProgressCircleMaterial) == 0x000340, "Member 'UAnimatedIconWidget::ProgressCircleMaterial' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, ProgressParamName) == 0x000348, "Member 'UAnimatedIconWidget::ProgressParamName' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, ParentComponent) == 0x000350, "Member 'UAnimatedIconWidget::ParentComponent' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, MID_ProgressCircle) == 0x000358, "Member 'UAnimatedIconWidget::MID_ProgressCircle' has a wrong offset!");

// Class ReadyOrNot.LoadingScreen
// 0x0078 (0x02D8 - 0x0260)
class ULoadingScreen : public UUserWidget
{
public:
	uint8                                         Pad_2159[0x8];                                     // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelStreaming*                        StreamedLevel;                                     // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_215A[0x68];                                    // 0x0270(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetLoadingPercentage();
	void GetLoadingScreenDetails(class FString* OutMap, class FString* OutMode, class FString* OutSessionName);
	class FString GetMapName();
	void SetLoadingScreen(const class FString& InMap, const class FString& InMode, const class FString& InSessionName, bool bSeamlessTravel);
	void UpdateTip(class UTextBlock* TipBlock);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingScreen">();
	}
	static class ULoadingScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingScreen>();
	}
};
static_assert(alignof(ULoadingScreen) == 0x000008, "Wrong alignment on ULoadingScreen");
static_assert(sizeof(ULoadingScreen) == 0x0002D8, "Wrong size on ULoadingScreen");
static_assert(offsetof(ULoadingScreen, StreamedLevel) == 0x000268, "Member 'ULoadingScreen::StreamedLevel' has a wrong offset!");

// Class ReadyOrNot.AnimatedIconWidget_Imprint
// 0x0010 (0x0270 - 0x0260)
class UAnimatedIconWidget_Imprint : public UUserWidget
{
public:
	class UImage*                                 Icon_Image;                                        // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ImprintAnimation;                                  // 0x0268(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Init(const struct FVector& InWorldLocation, class UTexture2D* InIconImage);
	void SetIconImage(class UTexture2D* NewIconImage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimatedIconWidget_Imprint">();
	}
	static class UAnimatedIconWidget_Imprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimatedIconWidget_Imprint>();
	}
};
static_assert(alignof(UAnimatedIconWidget_Imprint) == 0x000008, "Wrong alignment on UAnimatedIconWidget_Imprint");
static_assert(sizeof(UAnimatedIconWidget_Imprint) == 0x000270, "Wrong size on UAnimatedIconWidget_Imprint");
static_assert(offsetof(UAnimatedIconWidget_Imprint, Icon_Image) == 0x000260, "Member 'UAnimatedIconWidget_Imprint::Icon_Image' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget_Imprint, ImprintAnimation) == 0x000268, "Member 'UAnimatedIconWidget_Imprint::ImprintAnimation' has a wrong offset!");

// Class ReadyOrNot.AnimatedIconWidgetWithActionPrompt
// 0x0040 (0x03A0 - 0x0360)
class UAnimatedIconWidgetWithActionPrompt final  : public UAnimatedIconWidget
{
public:
	class UVerticalBox*                           VerticalBox;                                       // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               InteractIcon_Overlay;                              // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              PlayerActionPrompt_ScaleBox;                       // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionPrompt_Widget;                         // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionPrompt_Widget2;                        // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionPrompt_Widget3;                        // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionPrompt_Widget4;                        // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ActionPromptBackground_Image;                      // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimatedIconWidgetWithActionPrompt">();
	}
	static class UAnimatedIconWidgetWithActionPrompt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimatedIconWidgetWithActionPrompt>();
	}
};
static_assert(alignof(UAnimatedIconWidgetWithActionPrompt) == 0x000008, "Wrong alignment on UAnimatedIconWidgetWithActionPrompt");
static_assert(sizeof(UAnimatedIconWidgetWithActionPrompt) == 0x0003A0, "Wrong size on UAnimatedIconWidgetWithActionPrompt");
static_assert(offsetof(UAnimatedIconWidgetWithActionPrompt, VerticalBox) == 0x000360, "Member 'UAnimatedIconWidgetWithActionPrompt::VerticalBox' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidgetWithActionPrompt, InteractIcon_Overlay) == 0x000368, "Member 'UAnimatedIconWidgetWithActionPrompt::InteractIcon_Overlay' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidgetWithActionPrompt, PlayerActionPrompt_ScaleBox) == 0x000370, "Member 'UAnimatedIconWidgetWithActionPrompt::PlayerActionPrompt_ScaleBox' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidgetWithActionPrompt, PlayerActionPrompt_Widget) == 0x000378, "Member 'UAnimatedIconWidgetWithActionPrompt::PlayerActionPrompt_Widget' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidgetWithActionPrompt, PlayerActionPrompt_Widget2) == 0x000380, "Member 'UAnimatedIconWidgetWithActionPrompt::PlayerActionPrompt_Widget2' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidgetWithActionPrompt, PlayerActionPrompt_Widget3) == 0x000388, "Member 'UAnimatedIconWidgetWithActionPrompt::PlayerActionPrompt_Widget3' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidgetWithActionPrompt, PlayerActionPrompt_Widget4) == 0x000390, "Member 'UAnimatedIconWidgetWithActionPrompt::PlayerActionPrompt_Widget4' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidgetWithActionPrompt, ActionPromptBackground_Image) == 0x000398, "Member 'UAnimatedIconWidgetWithActionPrompt::ActionPromptBackground_Image' has a wrong offset!");

// Class ReadyOrNot.LicenseSave
// 0x0008 (0x0030 - 0x0028)
class ULicenseSave final  : public USaveGame
{
public:
	bool                                          bAcceptedAlphaNonDisclosureAgreement;              // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_215D[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AcceptAlphaNDA();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LicenseSave">();
	}
	static class ULicenseSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULicenseSave>();
	}
};
static_assert(alignof(ULicenseSave) == 0x000008, "Wrong alignment on ULicenseSave");
static_assert(sizeof(ULicenseSave) == 0x000030, "Wrong size on ULicenseSave");
static_assert(offsetof(ULicenseSave, bAcceptedAlphaNonDisclosureAgreement) == 0x000028, "Member 'ULicenseSave::bAcceptedAlphaNonDisclosureAgreement' has a wrong offset!");

// Class ReadyOrNot.AnimCharacterMovementLibrary
// 0x0000 (0x0028 - 0x0028)
class UAnimCharacterMovementLibrary final  : public UBlueprintFunctionLibrary
{
public:
	static float CalculateDirAngle(const struct FVector& CurVel, const struct FRotator& CurActorRotation, const struct FRotator& DirRotation, float ClampMin, float ClampMax, float CurDirAngle);
	static EAnimCardinalDirection GetCardinalDirectionFromAngle(EAnimCardinalDirection PreviousCardinalDirection, float DirectionAngleInDegrees, float DeadZoneAngle);
	static struct FVector PredictGroundMovementPivotLocation(struct FAnimCharacterMovementSnapshot& MovementSnapshot, float GroundFriction);
	static struct FVector PredictGroundMovementStopLocation(struct FAnimCharacterMovementSnapshot& MovementSnapshot, struct FAnimCharacterMovementPredictionSnapshot& PredictionSnapshot);
	static const class UAnimSequence* SelectAnimForCardinalDirection(EAnimCardinalDirection CardinalDirection, struct FCardinalDirectionAnimSet& AnimSet);
	static void UpdateCharacterMovementSnapshot(struct FTransform& WorldTransform, struct FVector& WorldVelocity, struct FVector& WorldAcceleration, bool bIsOnGround, float RootYawOffset, struct FAnimCharacterMovementSnapshot& Snapshot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimCharacterMovementLibrary">();
	}
	static class UAnimCharacterMovementLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimCharacterMovementLibrary>();
	}
};
static_assert(alignof(UAnimCharacterMovementLibrary) == 0x000008, "Wrong alignment on UAnimCharacterMovementLibrary");
static_assert(sizeof(UAnimCharacterMovementLibrary) == 0x000028, "Wrong size on UAnimCharacterMovementLibrary");

// Class ReadyOrNot.AnimDistanceMatchingLibrary
// 0x0000 (0x0028 - 0x0028)
class UAnimDistanceMatchingLibrary final  : public UBlueprintFunctionLibrary
{
public:
	static void CalculateDistanceMatchingStates(float DeltaTime, class ACharacter* CurrentCharacter, class UCharacterMovementComponent* CurrentMovementComponent, EDistanceMatchingType* DistanceMatchingCurrentState, struct FAnimCharacterMovementSnapshot& MovementSnapshot, struct FAnimCharacterMovementPredictionSnapshot& PredictionSnapshot, class UWorld* TargetWorld, float MinPivotAngle, const TArray<class AActor*>& ActorsToIgnore, struct FVector* LastActorLocation, struct FCardinalDirectionSnapshot* PivotingCardinalDirSnapShot, struct FPredictionResult* StartMarker, struct FPredictionResult* StopMarker, struct FPredictionResult* PivotMarker, struct FPredictionResult* TakeOffMarker, struct FPredictionResult* ApexMarker, struct FPredictionResult* LandingMarker, bool* bSMStartRuleset, bool* bSMStopRuleset, bool bIsAICharacter, bool bShowDebug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimDistanceMatchingLibrary">();
	}
	static class UAnimDistanceMatchingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimDistanceMatchingLibrary>();
	}
};
static_assert(alignof(UAnimDistanceMatchingLibrary) == 0x000008, "Wrong alignment on UAnimDistanceMatchingLibrary");
static_assert(sizeof(UAnimDistanceMatchingLibrary) == 0x000028, "Wrong size on UAnimDistanceMatchingLibrary");

// Class ReadyOrNot.Loadout_SubSelection_V2
// 0x0000 (0x0288 - 0x0288)
class ULoadout_SubSelection_V2 final  : public UCommonUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Loadout_SubSelection_V2">();
	}
	static class ULoadout_SubSelection_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadout_SubSelection_V2>();
	}
};
static_assert(alignof(ULoadout_SubSelection_V2) == 0x000008, "Wrong alignment on ULoadout_SubSelection_V2");
static_assert(sizeof(ULoadout_SubSelection_V2) == 0x000288, "Wrong size on ULoadout_SubSelection_V2");

// Class ReadyOrNot.SpectateHUD
// 0x0000 (0x0310 - 0x0310)
class ASpectateHUD final  : public AHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectateHUD">();
	}
	static class ASpectateHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpectateHUD>();
	}
};
static_assert(alignof(ASpectateHUD) == 0x000008, "Wrong alignment on ASpectateHUD");
static_assert(sizeof(ASpectateHUD) == 0x000310, "Wrong size on ASpectateHUD");

// Class ReadyOrNot.AnimInputCapsuleLocomotionBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UAnimInputCapsuleLocomotionBlueprintLibrary final  : public UBlueprintFunctionLibrary
{
public:
	static void UpdateCapsuleLocomotionAnimInput(class APawn* Pawn, struct FAnimInput_CapsuleLocomotion& CapsuleLocomotionAnimInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInputCapsuleLocomotionBlueprintLibrary">();
	}
	static class UAnimInputCapsuleLocomotionBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInputCapsuleLocomotionBlueprintLibrary>();
	}
};
static_assert(alignof(UAnimInputCapsuleLocomotionBlueprintLibrary) == 0x000008, "Wrong alignment on UAnimInputCapsuleLocomotionBlueprintLibrary");
static_assert(sizeof(UAnimInputCapsuleLocomotionBlueprintLibrary) == 0x000028, "Wrong size on UAnimInputCapsuleLocomotionBlueprintLibrary");

// Class ReadyOrNot.AnimNotify_AIDoorBreachKick
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_AIDoorBreachKick final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AIDoorBreachKick">();
	}
	static class UAnimNotify_AIDoorBreachKick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AIDoorBreachKick>();
	}
};
static_assert(alignof(UAnimNotify_AIDoorBreachKick) == 0x000008, "Wrong alignment on UAnimNotify_AIDoorBreachKick");
static_assert(sizeof(UAnimNotify_AIDoorBreachKick) == 0x000038, "Wrong size on UAnimNotify_AIDoorBreachKick");

// Class ReadyOrNot.AnimNotify_AIDoorBreachRam
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_AIDoorBreachRam final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AIDoorBreachRam">();
	}
	static class UAnimNotify_AIDoorBreachRam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AIDoorBreachRam>();
	}
};
static_assert(alignof(UAnimNotify_AIDoorBreachRam) == 0x000008, "Wrong alignment on UAnimNotify_AIDoorBreachRam");
static_assert(sizeof(UAnimNotify_AIDoorBreachRam) == 0x000038, "Wrong size on UAnimNotify_AIDoorBreachRam");

// Class ReadyOrNot.AnimNotify_AIDoorBreachShotgun
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_AIDoorBreachShotgun final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AIDoorBreachShotgun">();
	}
	static class UAnimNotify_AIDoorBreachShotgun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AIDoorBreachShotgun>();
	}
};
static_assert(alignof(UAnimNotify_AIDoorBreachShotgun) == 0x000008, "Wrong alignment on UAnimNotify_AIDoorBreachShotgun");
static_assert(sizeof(UAnimNotify_AIDoorBreachShotgun) == 0x000038, "Wrong size on UAnimNotify_AIDoorBreachShotgun");

// Class ReadyOrNot.ShellRackShellComponent
// 0x0010 (0x04F0 - 0x04E0)
class UShellRackShellComponent final  : public UStaticMeshComponent
{
public:
	int32                                         ShellNumber;                                       // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2167[0xC];                                     // 0x04E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShellRackShellComponent">();
	}
	static class UShellRackShellComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShellRackShellComponent>();
	}
};
static_assert(alignof(UShellRackShellComponent) == 0x000010, "Wrong alignment on UShellRackShellComponent");
static_assert(sizeof(UShellRackShellComponent) == 0x0004F0, "Wrong size on UShellRackShellComponent");
static_assert(offsetof(UShellRackShellComponent, ShellNumber) == 0x0004E0, "Member 'UShellRackShellComponent::ShellNumber' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_AIThrowGrenade
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_AIThrowGrenade final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AIThrowGrenade">();
	}
	static class UAnimNotify_AIThrowGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AIThrowGrenade>();
	}
};
static_assert(alignof(UAnimNotify_AIThrowGrenade) == 0x000008, "Wrong alignment on UAnimNotify_AIThrowGrenade");
static_assert(sizeof(UAnimNotify_AIThrowGrenade) == 0x000038, "Wrong size on UAnimNotify_AIThrowGrenade");

// Class ReadyOrNot.AnimNotify_AIThrowGrenadeComplete
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_AIThrowGrenadeComplete final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AIThrowGrenadeComplete">();
	}
	static class UAnimNotify_AIThrowGrenadeComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AIThrowGrenadeComplete>();
	}
};
static_assert(alignof(UAnimNotify_AIThrowGrenadeComplete) == 0x000008, "Wrong alignment on UAnimNotify_AIThrowGrenadeComplete");
static_assert(sizeof(UAnimNotify_AIThrowGrenadeComplete) == 0x000038, "Wrong size on UAnimNotify_AIThrowGrenadeComplete");

// Class ReadyOrNot.CyberneticController
// 0x05B0 (0x08D8 - 0x0328)
class ACyberneticController : public AAIController
{
public:
	uint8                                         Pad_2168[0x10];                                    // 0x0328(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAIAction*>                      CustomActions;                                     // 0x0338(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UAIPerceptionComponent*                 AIPerceptionComponent;                             // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UReadyOrNotAISenseConfig_Sight*         SightConfig;                                       // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAISenseConfig_Touch*                   TouchConfig;                                       // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAISenseConfig_Damage*                  DamageConfig;                                      // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAISenseConfig_Hearing*                 HearingConfig;                                     // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMoraleComponent*                       MoraleComponent;                                   // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTargetingComponent*                    TargetingComponent;                                // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AActor*, float>                    LastHeardActorTime;                                // 0x0380(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       SensingCharacter;                                  // 0x03D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LastSensedActor;                                   // 0x03D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   HeardActorInstigator;                              // 0x03E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   LastSensedCharacter;                               // 0x03E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastSensedLocation;                                // 0x03F0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanOpenDoorThroughNavLink : 1;                    // 0x03FC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2169[0x3];                                     // 0x03FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceLastMove;                                 // 0x0400(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeUntilRecentlySeenCharactersClear;              // 0x0404(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           RecentlySeenSwat;                                  // 0x0408(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           RecentlySeenSuspects;                              // 0x0418(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           RecentlySeenCivilians;                             // 0x0428(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAsyncPathFound;                                  // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_216A[0x60];                                    // 0x0448(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastAcceptanceRadius;                              // 0x04A8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_216B[0x4];                                     // 0x04AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AReadyOrNotCharacter*, float>      DamagedBy;                                         // 0x04B0(0x0050)(NativeAccessSpecifierPublic)
	TMap<class AReadyOrNotCharacter*, struct FVector> DamagedByLocation;                                 // 0x0500(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_216C[0x8];                                     // 0x0550(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInvestigateStimulusActivity*           InvestigateStimulusActivity;                       // 0x0558(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_216D[0x8];                                     // 0x0560(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAwarenessStateChangedDelegate;                   // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	EAIAwarenessState                             PreviousAwarenessState;                            // 0x0578(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIAwarenessState                             AwarenessState;                                    // 0x0579(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_216E[0x32];                                    // 0x057A(0x0032)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIStimulus                            LatestStimulus;                                    // 0x05AC(0x003C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIStimulus                            LatestSightStimulus;                               // 0x05E8(0x003C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIStimulus                            LatestHearingStimulus;                             // 0x0624(0x003C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIStimulus                            LatestDamageStimulus;                              // 0x0660(0x003C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_216F[0x14];                                    // 0x069C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         TrackedDistractions;                               // 0x06B0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2170[0x20];                                    // 0x06C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMoveComplete;                                    // 0x06E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FActorSense>                    ActorSightSenseMap;                                // 0x06F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FActorSense>                    ActorSoundSenseMap;                                // 0x0700(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FActorSense>                    ActorDamageSenseMap;                               // 0x0710(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bStopDecisionMaking : 1;                           // 0x0720(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2171[0x7];                                     // 0x0721(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseActivity*                          CurrentActivity;                                   // 0x0728(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBaseActivity*>                  ActivityQueue;                                     // 0x0730(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2172[0x10];                                    // 0x0740(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CallForHelpCoolDownDuration;                       // 0x0750(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHearingForHelpDistance;                         // 0x0754(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlashLightSeenCoolDownDuration;                    // 0x0758(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDisableSensePerception : 1;                       // 0x075C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2173[0x3];                                     // 0x075D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FExposedToNoise>     ExposedToStimulusTags;                             // 0x0760(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_2174[0x58];                                    // 0x07B0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceLastExposedToAggressiveStimulus;          // 0x0808(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastExposedToAnyStimulus;                 // 0x080C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastExposedToSightStimulus;               // 0x0810(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastExposedToSoundStimulus;               // 0x0814(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEverHeardAggressiveStimulus : 1;                  // 0x0818(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2175[0x3];                                     // 0x0819(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnalertTime;                                       // 0x081C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlertTime;                                         // 0x0820(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuspiciousTime;                                    // 0x0824(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEverHeardSwat;                                 // 0x0828(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2176[0x17];                                    // 0x0829(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseCombatActivity*                    CombatActivity;                                    // 0x0840(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2177[0x50];                                    // 0x0848(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UMoveToActivity*                        MoveToActivity;                                    // 0x0898(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoveActivity*                          TeamMoveActivity;                                  // 0x08A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoveToActivity*                        PushMoveToActivity;                                // 0x08A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoveToActivity*                        AvoidanceMoveToActivity;                           // 0x08B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoveToExitActivity*                    MoveToExitActivity;                                // 0x08B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTargetNextCivilianActivity*            TargetNextCivilianActivity;                        // 0x08C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADoor*                                  LastHeardDoorKick;                                 // 0x08C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2178[0x8];                                     // 0x08D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbortCover();
	void AbortCoverLandmark();
	void AbortMove(bool bKeepVelocity);
	bool AddActivity(class UBaseActivity* Activity, bool bOverrideCurrentActivity);
	void AddExposedToStimulusTag(class FName& Tag, const struct FVector& StimulusLocation, bool bFriendly, class AReadyOrNotCharacter* StimulusInstigator, float ExpiryTime);
	void AsyncPathFoundDelegate__DelegateSignature(int32 PathId, ERonNavigationQueryResult Result);
	void AwarenessChangeEvent__DelegateSignature(class ACyberneticController* Controller, EAIAwarenessState Previous, EAIAwarenessState Current);
	void FinishActivity(class UBaseActivity* Activity, bool bSuccess, bool bForce);
	class FString GetActivityQueueAsString();
	class AReadyOrNotCharacter* GetTrackedTarget();
	bool HasActivityType(TSubclassOf<class UBaseActivity> ActivityType);
	void OnActivityComplete__DelegateSignature(class UBaseActivity* CompletedActivity, class UBaseActivity* NextActivity, bool bSuccessfullyCompleted);
	void OnAIFinishSpawning();
	void OnAIMoveCompleted__DelegateSignature(class AAIController* Controller, int32 RequestID);
	void OnDoorExploded(class ADoor* Door, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnKnownEnemyIncapacitated(class AReadyOrNotCharacter* IncapacitatedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnKnownEnemyIncapacitated_Blueprint(class AReadyOrNotCharacter* IncapacitatedCharacter);
	void OnKnownEnemyKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnKnownEnemyKilled_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnKnownEnemyStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnKnownEnemyStunned_Blueprint(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnKnownEnemyTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnKnownEnemyTakeDamage_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnKnownFriendlyIncapacitated(class AReadyOrNotCharacter* IncapacitatedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnKnownFriendlyIncapacitated_Blueprint(class AReadyOrNotCharacter* IncapacitatedCharacter);
	void OnKnownFriendlyKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnKnownFriendlyKilled_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnKnownFriendlyStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnKnownFriendlyStunned_Blueprint(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnKnownFriendlyTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnKnownFriendlyTakeDamage_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnKnownNeutralIncapacitated(class AReadyOrNotCharacter* IncapacitatedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnKnownNeutralIncapacitated_Blueprint(class AReadyOrNotCharacter* IncapacitatedCharacter);
	void OnKnownNeutralKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnKnownNeutralKilled_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnKnownNeutralStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnKnownNeutralStunned_Blueprint(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnKnownNeutralTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnKnownNeutralTakeDamage_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnPerceptionUpdated(TArray<class AActor*>& TestActors);
	void OnStunDamageTaken(EStunType StunType);
	void RemoveActivitiesOfType(TSubclassOf<class UBaseActivity> ActivityType, bool bClearCurrent);
	void RemoveAllActivitiesExcept(TSubclassOf<class UBaseActivity> ActivityType);
	int32 RequestMoveAsync(const struct FVector& Location, bool bProjectToNavigation, float AcceptanceRadius);

	bool DoesCharacterMatchTargetType(class AReadyOrNotCharacter* InCharacter, int32 TargetTypeMask) const;
	bool DoesPathGoThroughDoor(class ADoor** Door) const;
	class UBaseActivity* GetActivity(TSubclassOf<class UBaseActivity> ActivityType) const;
	int32 GetActivityQueueCount() const;
	class UMoveToActivity* GetAvoidanceMoveToActivity() const;
	EAIAwarenessState GetAwarenessState() const;
	class ACyberneticCharacter* GetCharacter() const;
	class UBaseCombatActivity* GetCombatActivity() const;
	int32 GetFailedConsiderCountForAction(class FName Action) const;
	class AReadyOrNotCharacter* GetHeardActorInstigator() const;
	struct FAIStimulus GetLatestStimulus() const;
	class UMoveActivity* GetMoveActivity() const;
	class UMoveToActivity* GetMoveToActivity() const;
	class UMoveToExitActivity* GetMoveToExitActivity() const;
	TSubclassOf<class UNavigationQueryFilter> GetNavQueryFilter() const;
	class UMoveToActivity* GetPushMoveToActivity() const;
	int32 GetSuccessConsiderCountForAction(class FName Action) const;
	class UTargetNextCivilianActivity* GetTargetNextCivilianActivity() const;
	ETeamType GetTeam() const;
	float GetTimeSinceLastMove() const;
	bool HasBeenExposedToAggressiveNoise(float SinceSeconds, float MaxDistance, int32 TargetTypeMask) const;
	bool HasBeenExposedToAggressiveNoise_Tag(class FName* OutTag, float SinceSeconds, float MaxDistance, int32 TargetTypeMask) const;
	bool HasBeenExposedToAnyNoise(float SinceSeconds, float MaxDistance, int32 TargetTypeMask) const;
	bool HasBeenExposedToAnyNoise_Tag(class FName* OutTag, float SinceSeconds, float MaxDistance, int32 TargetTypeMask) const;
	bool HasRecentlySeenCivilian() const;
	bool HasRecentlySeenSuspect() const;
	bool HasRecentlySeenSwat(struct FVector* OutLocation) const;
	bool IsActivelyMovingOnPath() const;
	bool IsCharacterEnemy(class AReadyOrNotCharacter* InCharacter) const;
	bool IsCharacterFriendly(class AReadyOrNotCharacter* InCharacter) const;
	bool IsCharacterKnownEnemy(class AReadyOrNotCharacter* InCharacter) const;
	bool IsCharacterNeutral(class AReadyOrNotCharacter* InCharacter) const;
	bool IsCivilian() const;
	bool IsFindingAnyPath() const;
	bool IsFindingPath(int32 PathId) const;
	bool IsLastAlive() const;
	bool IsMoving() const;
	bool IsMovingForRequest(int32 RequestID) const;
	bool IsMovingForRequests(const TArray<struct FAIRequestID>& Requests) const;
	bool IsSuspect() const;
	bool IsSWAT() const;
	bool IsTagAggressiveNoise(class FName& Tag) const;
	bool IsTagInvestigativeNoise(class FName& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CyberneticController">();
	}
	static class ACyberneticController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACyberneticController>();
	}
};
static_assert(alignof(ACyberneticController) == 0x000008, "Wrong alignment on ACyberneticController");
static_assert(sizeof(ACyberneticController) == 0x0008D8, "Wrong size on ACyberneticController");
static_assert(offsetof(ACyberneticController, CustomActions) == 0x000338, "Member 'ACyberneticController::CustomActions' has a wrong offset!");
static_assert(offsetof(ACyberneticController, AIPerceptionComponent) == 0x000348, "Member 'ACyberneticController::AIPerceptionComponent' has a wrong offset!");
static_assert(offsetof(ACyberneticController, SightConfig) == 0x000350, "Member 'ACyberneticController::SightConfig' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TouchConfig) == 0x000358, "Member 'ACyberneticController::TouchConfig' has a wrong offset!");
static_assert(offsetof(ACyberneticController, DamageConfig) == 0x000360, "Member 'ACyberneticController::DamageConfig' has a wrong offset!");
static_assert(offsetof(ACyberneticController, HearingConfig) == 0x000368, "Member 'ACyberneticController::HearingConfig' has a wrong offset!");
static_assert(offsetof(ACyberneticController, MoraleComponent) == 0x000370, "Member 'ACyberneticController::MoraleComponent' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TargetingComponent) == 0x000378, "Member 'ACyberneticController::TargetingComponent' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LastHeardActorTime) == 0x000380, "Member 'ACyberneticController::LastHeardActorTime' has a wrong offset!");
static_assert(offsetof(ACyberneticController, SensingCharacter) == 0x0003D0, "Member 'ACyberneticController::SensingCharacter' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LastSensedActor) == 0x0003D8, "Member 'ACyberneticController::LastSensedActor' has a wrong offset!");
static_assert(offsetof(ACyberneticController, HeardActorInstigator) == 0x0003E0, "Member 'ACyberneticController::HeardActorInstigator' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LastSensedCharacter) == 0x0003E8, "Member 'ACyberneticController::LastSensedCharacter' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LastSensedLocation) == 0x0003F0, "Member 'ACyberneticController::LastSensedLocation' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TimeSinceLastMove) == 0x000400, "Member 'ACyberneticController::TimeSinceLastMove' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TimeUntilRecentlySeenCharactersClear) == 0x000404, "Member 'ACyberneticController::TimeUntilRecentlySeenCharactersClear' has a wrong offset!");
static_assert(offsetof(ACyberneticController, RecentlySeenSwat) == 0x000408, "Member 'ACyberneticController::RecentlySeenSwat' has a wrong offset!");
static_assert(offsetof(ACyberneticController, RecentlySeenSuspects) == 0x000418, "Member 'ACyberneticController::RecentlySeenSuspects' has a wrong offset!");
static_assert(offsetof(ACyberneticController, RecentlySeenCivilians) == 0x000428, "Member 'ACyberneticController::RecentlySeenCivilians' has a wrong offset!");
static_assert(offsetof(ACyberneticController, OnAsyncPathFound) == 0x000438, "Member 'ACyberneticController::OnAsyncPathFound' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LastAcceptanceRadius) == 0x0004A8, "Member 'ACyberneticController::LastAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(ACyberneticController, DamagedBy) == 0x0004B0, "Member 'ACyberneticController::DamagedBy' has a wrong offset!");
static_assert(offsetof(ACyberneticController, DamagedByLocation) == 0x000500, "Member 'ACyberneticController::DamagedByLocation' has a wrong offset!");
static_assert(offsetof(ACyberneticController, InvestigateStimulusActivity) == 0x000558, "Member 'ACyberneticController::InvestigateStimulusActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, OnAwarenessStateChangedDelegate) == 0x000568, "Member 'ACyberneticController::OnAwarenessStateChangedDelegate' has a wrong offset!");
static_assert(offsetof(ACyberneticController, PreviousAwarenessState) == 0x000578, "Member 'ACyberneticController::PreviousAwarenessState' has a wrong offset!");
static_assert(offsetof(ACyberneticController, AwarenessState) == 0x000579, "Member 'ACyberneticController::AwarenessState' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LatestStimulus) == 0x0005AC, "Member 'ACyberneticController::LatestStimulus' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LatestSightStimulus) == 0x0005E8, "Member 'ACyberneticController::LatestSightStimulus' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LatestHearingStimulus) == 0x000624, "Member 'ACyberneticController::LatestHearingStimulus' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LatestDamageStimulus) == 0x000660, "Member 'ACyberneticController::LatestDamageStimulus' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TrackedDistractions) == 0x0006B0, "Member 'ACyberneticController::TrackedDistractions' has a wrong offset!");
static_assert(offsetof(ACyberneticController, OnMoveComplete) == 0x0006E0, "Member 'ACyberneticController::OnMoveComplete' has a wrong offset!");
static_assert(offsetof(ACyberneticController, ActorSightSenseMap) == 0x0006F0, "Member 'ACyberneticController::ActorSightSenseMap' has a wrong offset!");
static_assert(offsetof(ACyberneticController, ActorSoundSenseMap) == 0x000700, "Member 'ACyberneticController::ActorSoundSenseMap' has a wrong offset!");
static_assert(offsetof(ACyberneticController, ActorDamageSenseMap) == 0x000710, "Member 'ACyberneticController::ActorDamageSenseMap' has a wrong offset!");
static_assert(offsetof(ACyberneticController, CurrentActivity) == 0x000728, "Member 'ACyberneticController::CurrentActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, ActivityQueue) == 0x000730, "Member 'ACyberneticController::ActivityQueue' has a wrong offset!");
static_assert(offsetof(ACyberneticController, CallForHelpCoolDownDuration) == 0x000750, "Member 'ACyberneticController::CallForHelpCoolDownDuration' has a wrong offset!");
static_assert(offsetof(ACyberneticController, MaxHearingForHelpDistance) == 0x000754, "Member 'ACyberneticController::MaxHearingForHelpDistance' has a wrong offset!");
static_assert(offsetof(ACyberneticController, FlashLightSeenCoolDownDuration) == 0x000758, "Member 'ACyberneticController::FlashLightSeenCoolDownDuration' has a wrong offset!");
static_assert(offsetof(ACyberneticController, ExposedToStimulusTags) == 0x000760, "Member 'ACyberneticController::ExposedToStimulusTags' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TimeSinceLastExposedToAggressiveStimulus) == 0x000808, "Member 'ACyberneticController::TimeSinceLastExposedToAggressiveStimulus' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TimeSinceLastExposedToAnyStimulus) == 0x00080C, "Member 'ACyberneticController::TimeSinceLastExposedToAnyStimulus' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TimeSinceLastExposedToSightStimulus) == 0x000810, "Member 'ACyberneticController::TimeSinceLastExposedToSightStimulus' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TimeSinceLastExposedToSoundStimulus) == 0x000814, "Member 'ACyberneticController::TimeSinceLastExposedToSoundStimulus' has a wrong offset!");
static_assert(offsetof(ACyberneticController, UnalertTime) == 0x00081C, "Member 'ACyberneticController::UnalertTime' has a wrong offset!");
static_assert(offsetof(ACyberneticController, AlertTime) == 0x000820, "Member 'ACyberneticController::AlertTime' has a wrong offset!");
static_assert(offsetof(ACyberneticController, SuspiciousTime) == 0x000824, "Member 'ACyberneticController::SuspiciousTime' has a wrong offset!");
static_assert(offsetof(ACyberneticController, bHasEverHeardSwat) == 0x000828, "Member 'ACyberneticController::bHasEverHeardSwat' has a wrong offset!");
static_assert(offsetof(ACyberneticController, CombatActivity) == 0x000840, "Member 'ACyberneticController::CombatActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, MoveToActivity) == 0x000898, "Member 'ACyberneticController::MoveToActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TeamMoveActivity) == 0x0008A0, "Member 'ACyberneticController::TeamMoveActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, PushMoveToActivity) == 0x0008A8, "Member 'ACyberneticController::PushMoveToActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, AvoidanceMoveToActivity) == 0x0008B0, "Member 'ACyberneticController::AvoidanceMoveToActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, MoveToExitActivity) == 0x0008B8, "Member 'ACyberneticController::MoveToExitActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TargetNextCivilianActivity) == 0x0008C0, "Member 'ACyberneticController::TargetNextCivilianActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LastHeardDoorKick) == 0x0008C8, "Member 'ACyberneticController::LastHeardDoorKick' has a wrong offset!");

// Class ReadyOrNot.SuspectController
// 0x0000 (0x08D8 - 0x08D8)
class ASuspectController final  : public ACyberneticController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuspectController">();
	}
	static class ASuspectController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASuspectController>();
	}
};
static_assert(alignof(ASuspectController) == 0x000008, "Wrong alignment on ASuspectController");
static_assert(sizeof(ASuspectController) == 0x0008D8, "Wrong size on ASuspectController");

// Class ReadyOrNot.Loadout_Carousel_V3
// 0x0008 (0x0268 - 0x0260)
class ULoadout_Carousel_V3 final  : public UUserWidget
{
public:
	class UTextBlock*                             Text;                                              // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetText(class FText InputText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Loadout_Carousel_V3">();
	}
	static class ULoadout_Carousel_V3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadout_Carousel_V3>();
	}
};
static_assert(alignof(ULoadout_Carousel_V3) == 0x000008, "Wrong alignment on ULoadout_Carousel_V3");
static_assert(sizeof(ULoadout_Carousel_V3) == 0x000268, "Wrong size on ULoadout_Carousel_V3");
static_assert(offsetof(ULoadout_Carousel_V3, Text) == 0x000260, "Member 'ULoadout_Carousel_V3::Text' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_AIThrowPendingItem
// 0x0058 (0x0090 - 0x0038)
class UAnimNotify_AIThrowPendingItem final  : public UAnimNotify
{
public:
	class FName                                   BoneToSpawnOn;                                     // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LandingLocation;                                   // 0x0040(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_219A[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0050(0x0030)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bCustomThrowDirection : 1;                         // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_219B[0x3];                                     // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ThrowDirection;                                    // 0x0084(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AIThrowPendingItem">();
	}
	static class UAnimNotify_AIThrowPendingItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AIThrowPendingItem>();
	}
};
static_assert(alignof(UAnimNotify_AIThrowPendingItem) == 0x000010, "Wrong alignment on UAnimNotify_AIThrowPendingItem");
static_assert(sizeof(UAnimNotify_AIThrowPendingItem) == 0x000090, "Wrong size on UAnimNotify_AIThrowPendingItem");
static_assert(offsetof(UAnimNotify_AIThrowPendingItem, BoneToSpawnOn) == 0x000038, "Member 'UAnimNotify_AIThrowPendingItem::BoneToSpawnOn' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AIThrowPendingItem, LandingLocation) == 0x000040, "Member 'UAnimNotify_AIThrowPendingItem::LandingLocation' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AIThrowPendingItem, RelativeTransform) == 0x000050, "Member 'UAnimNotify_AIThrowPendingItem::RelativeTransform' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AIThrowPendingItem, ThrowDirection) == 0x000084, "Member 'UAnimNotify_AIThrowPendingItem::ThrowDirection' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_ApplyArteryDamage
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_ApplyArteryDamage final  : public UAnimNotify
{
public:
	class FName                                   ArteryBoneName;                                    // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ApplyArteryDamage">();
	}
	static class UAnimNotify_ApplyArteryDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ApplyArteryDamage>();
	}
};
static_assert(alignof(UAnimNotify_ApplyArteryDamage) == 0x000008, "Wrong alignment on UAnimNotify_ApplyArteryDamage");
static_assert(sizeof(UAnimNotify_ApplyArteryDamage) == 0x000040, "Wrong size on UAnimNotify_ApplyArteryDamage");
static_assert(offsetof(UAnimNotify_ApplyArteryDamage, ArteryBoneName) == 0x000038, "Member 'UAnimNotify_ApplyArteryDamage::ArteryBoneName' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_ApplyMeleeDamage
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_ApplyMeleeDamage final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ApplyMeleeDamage">();
	}
	static class UAnimNotify_ApplyMeleeDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ApplyMeleeDamage>();
	}
};
static_assert(alignof(UAnimNotify_ApplyMeleeDamage) == 0x000008, "Wrong alignment on UAnimNotify_ApplyMeleeDamage");
static_assert(sizeof(UAnimNotify_ApplyMeleeDamage) == 0x000038, "Wrong size on UAnimNotify_ApplyMeleeDamage");

// Class ReadyOrNot.AnimNotify_ArrestComplete
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_ArrestComplete final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ArrestComplete">();
	}
	static class UAnimNotify_ArrestComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ArrestComplete>();
	}
};
static_assert(alignof(UAnimNotify_ArrestComplete) == 0x000008, "Wrong alignment on UAnimNotify_ArrestComplete");
static_assert(sizeof(UAnimNotify_ArrestComplete) == 0x000038, "Wrong size on UAnimNotify_ArrestComplete");

// Class ReadyOrNot.SubtitlesWidget
// 0x0050 (0x02B0 - 0x0260)
class USubtitlesWidget : public UUserWidget
{
public:
	TSubclassOf<class USubtitleBlock>             SubtitleBlockClass;                                // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSubtitles;                                      // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LingerTime;                                        // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PadInTime;                                         // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219C[0x4];                                     // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVerticalBox*                           SubtitlesVerticalBox;                              // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USubtitleBlock*>                 SubtitleBlocks;                                    // 0x0288(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class USubtitleBlock*                         PreviousSubtitle;                                  // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_219D[0x10];                                    // 0x02A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSubtitlesSize(ESubtitlesSize Size);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitlesWidget">();
	}
	static class USubtitlesWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitlesWidget>();
	}
};
static_assert(alignof(USubtitlesWidget) == 0x000008, "Wrong alignment on USubtitlesWidget");
static_assert(sizeof(USubtitlesWidget) == 0x0002B0, "Wrong size on USubtitlesWidget");
static_assert(offsetof(USubtitlesWidget, SubtitleBlockClass) == 0x000260, "Member 'USubtitlesWidget::SubtitleBlockClass' has a wrong offset!");
static_assert(offsetof(USubtitlesWidget, MaxSubtitles) == 0x000268, "Member 'USubtitlesWidget::MaxSubtitles' has a wrong offset!");
static_assert(offsetof(USubtitlesWidget, LingerTime) == 0x00026C, "Member 'USubtitlesWidget::LingerTime' has a wrong offset!");
static_assert(offsetof(USubtitlesWidget, FadeInTime) == 0x000270, "Member 'USubtitlesWidget::FadeInTime' has a wrong offset!");
static_assert(offsetof(USubtitlesWidget, FadeOutTime) == 0x000274, "Member 'USubtitlesWidget::FadeOutTime' has a wrong offset!");
static_assert(offsetof(USubtitlesWidget, PadInTime) == 0x000278, "Member 'USubtitlesWidget::PadInTime' has a wrong offset!");
static_assert(offsetof(USubtitlesWidget, SubtitlesVerticalBox) == 0x000280, "Member 'USubtitlesWidget::SubtitlesVerticalBox' has a wrong offset!");
static_assert(offsetof(USubtitlesWidget, SubtitleBlocks) == 0x000288, "Member 'USubtitlesWidget::SubtitleBlocks' has a wrong offset!");
static_assert(offsetof(USubtitlesWidget, PreviousSubtitle) == 0x000298, "Member 'USubtitlesWidget::PreviousSubtitle' has a wrong offset!");

// Class ReadyOrNot.LobbyGS
// 0x0020 (0x0800 - 0x07E0)
class ALobbyGS final  : public AReadyOrNotGameState
{
public:
	class UFMODEvent*                             LobbyMusicEvent;                                   // 0x07E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_219E[0x8];                                     // 0x07E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MissionGradeMusic;                                 // 0x07F0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_219F[0xC];                                     // 0x07F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyGS">();
	}
	static class ALobbyGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyGS>();
	}
};
static_assert(alignof(ALobbyGS) == 0x000008, "Wrong alignment on ALobbyGS");
static_assert(sizeof(ALobbyGS) == 0x000800, "Wrong size on ALobbyGS");
static_assert(offsetof(ALobbyGS, LobbyMusicEvent) == 0x0007E0, "Member 'ALobbyGS::LobbyMusicEvent' has a wrong offset!");
static_assert(offsetof(ALobbyGS, MissionGradeMusic) == 0x0007F0, "Member 'ALobbyGS::MissionGradeMusic' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_Breach_C2Detonate
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_Breach_C2Detonate final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_Breach_C2Detonate">();
	}
	static class UAnimNotify_Breach_C2Detonate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_Breach_C2Detonate>();
	}
};
static_assert(alignof(UAnimNotify_Breach_C2Detonate) == 0x000008, "Wrong alignment on UAnimNotify_Breach_C2Detonate");
static_assert(sizeof(UAnimNotify_Breach_C2Detonate) == 0x000038, "Wrong size on UAnimNotify_Breach_C2Detonate");

// Class ReadyOrNot.AnimNotify_Breach_C2Placed
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_Breach_C2Placed final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_Breach_C2Placed">();
	}
	static class UAnimNotify_Breach_C2Placed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_Breach_C2Placed>();
	}
};
static_assert(alignof(UAnimNotify_Breach_C2Placed) == 0x000008, "Wrong alignment on UAnimNotify_Breach_C2Placed");
static_assert(sizeof(UAnimNotify_Breach_C2Placed) == 0x000038, "Wrong size on UAnimNotify_Breach_C2Placed");

// Class ReadyOrNot.LoadoutVerticalItemListWidget
// 0x0040 (0x0360 - 0x0320)
class ULoadoutVerticalItemListWidget : public UCommonActivatableWidget
{
public:
	FMulticastInlineDelegateProperty_             OnOverviewItemHovered;                             // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOverviewItemUnhovered;                           // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAttachmentSlotHovered;                           // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAttachmentSlotUnhovered;                         // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutVerticalItemListWidget">();
	}
	static class ULoadoutVerticalItemListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutVerticalItemListWidget>();
	}
};
static_assert(alignof(ULoadoutVerticalItemListWidget) == 0x000008, "Wrong alignment on ULoadoutVerticalItemListWidget");
static_assert(sizeof(ULoadoutVerticalItemListWidget) == 0x000360, "Wrong size on ULoadoutVerticalItemListWidget");
static_assert(offsetof(ULoadoutVerticalItemListWidget, OnOverviewItemHovered) == 0x000320, "Member 'ULoadoutVerticalItemListWidget::OnOverviewItemHovered' has a wrong offset!");
static_assert(offsetof(ULoadoutVerticalItemListWidget, OnOverviewItemUnhovered) == 0x000330, "Member 'ULoadoutVerticalItemListWidget::OnOverviewItemUnhovered' has a wrong offset!");
static_assert(offsetof(ULoadoutVerticalItemListWidget, OnAttachmentSlotHovered) == 0x000340, "Member 'ULoadoutVerticalItemListWidget::OnAttachmentSlotHovered' has a wrong offset!");
static_assert(offsetof(ULoadoutVerticalItemListWidget, OnAttachmentSlotUnhovered) == 0x000350, "Member 'ULoadoutVerticalItemListWidget::OnAttachmentSlotUnhovered' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_ChangeBodySocket
// 0x0010 (0x0048 - 0x0038)
class UAnimNotify_ChangeBodySocket final  : public UAnimNotify
{
public:
	EItemCategory                                 ItemCategory;                                      // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21A0[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Socket;                                            // 0x003C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21A1[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ChangeBodySocket">();
	}
	static class UAnimNotify_ChangeBodySocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ChangeBodySocket>();
	}
};
static_assert(alignof(UAnimNotify_ChangeBodySocket) == 0x000008, "Wrong alignment on UAnimNotify_ChangeBodySocket");
static_assert(sizeof(UAnimNotify_ChangeBodySocket) == 0x000048, "Wrong size on UAnimNotify_ChangeBodySocket");
static_assert(offsetof(UAnimNotify_ChangeBodySocket, ItemCategory) == 0x000038, "Member 'UAnimNotify_ChangeBodySocket::ItemCategory' has a wrong offset!");
static_assert(offsetof(UAnimNotify_ChangeBodySocket, Socket) == 0x00003C, "Member 'UAnimNotify_ChangeBodySocket::Socket' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_CollectEvidence
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_CollectEvidence final  : public UAnimNotify
{
public:
	uint8                                         bCollectFinished : 1;                              // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_21A2[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_CollectEvidence">();
	}
	static class UAnimNotify_CollectEvidence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_CollectEvidence>();
	}
};
static_assert(alignof(UAnimNotify_CollectEvidence) == 0x000008, "Wrong alignment on UAnimNotify_CollectEvidence");
static_assert(sizeof(UAnimNotify_CollectEvidence) == 0x000040, "Wrong size on UAnimNotify_CollectEvidence");

// Class ReadyOrNot.LoadoutOverviewWidget
// 0x0060 (0x02C0 - 0x0260)
class ULoadoutOverviewWidget final  : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnOverviewItemClicked;                             // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOverviewItemHovered;                             // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOverviewItemUnhovered;                           // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAttachmentSlotClicked;                           // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAttachmentSlotHovered;                           // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAttachmentSlotUnhovered;                         // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void InitializeOverviewList(bool bRemotePlayer);
	void LoadoutSlotAttachmentInteraction__DelegateSignature(class ULoadoutSlotAttachmentWidget* AttachmentSlot);
	void LoadoutSlotInteraction__DelegateSignature(class ULoadoutSlotWidget* TriggeringSlot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutOverviewWidget">();
	}
	static class ULoadoutOverviewWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutOverviewWidget>();
	}
};
static_assert(alignof(ULoadoutOverviewWidget) == 0x000008, "Wrong alignment on ULoadoutOverviewWidget");
static_assert(sizeof(ULoadoutOverviewWidget) == 0x0002C0, "Wrong size on ULoadoutOverviewWidget");
static_assert(offsetof(ULoadoutOverviewWidget, OnOverviewItemClicked) == 0x000260, "Member 'ULoadoutOverviewWidget::OnOverviewItemClicked' has a wrong offset!");
static_assert(offsetof(ULoadoutOverviewWidget, OnOverviewItemHovered) == 0x000270, "Member 'ULoadoutOverviewWidget::OnOverviewItemHovered' has a wrong offset!");
static_assert(offsetof(ULoadoutOverviewWidget, OnOverviewItemUnhovered) == 0x000280, "Member 'ULoadoutOverviewWidget::OnOverviewItemUnhovered' has a wrong offset!");
static_assert(offsetof(ULoadoutOverviewWidget, OnAttachmentSlotClicked) == 0x000290, "Member 'ULoadoutOverviewWidget::OnAttachmentSlotClicked' has a wrong offset!");
static_assert(offsetof(ULoadoutOverviewWidget, OnAttachmentSlotHovered) == 0x0002A0, "Member 'ULoadoutOverviewWidget::OnAttachmentSlotHovered' has a wrong offset!");
static_assert(offsetof(ULoadoutOverviewWidget, OnAttachmentSlotUnhovered) == 0x0002B0, "Member 'ULoadoutOverviewWidget::OnAttachmentSlotUnhovered' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_CompleteHeal
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_CompleteHeal final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_CompleteHeal">();
	}
	static class UAnimNotify_CompleteHeal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_CompleteHeal>();
	}
};
static_assert(alignof(UAnimNotify_CompleteHeal) == 0x000008, "Wrong alignment on UAnimNotify_CompleteHeal");
static_assert(sizeof(UAnimNotify_CompleteHeal) == 0x000038, "Wrong size on UAnimNotify_CompleteHeal");

// Class ReadyOrNot.AnimNotify_DisableWeaponFOV
// 0x0000 (0x0030 - 0x0030)
class UAnimNotify_DisableWeaponFOV final  : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DisableWeaponFOV">();
	}
	static class UAnimNotify_DisableWeaponFOV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DisableWeaponFOV>();
	}
};
static_assert(alignof(UAnimNotify_DisableWeaponFOV) == 0x000008, "Wrong alignment on UAnimNotify_DisableWeaponFOV");
static_assert(sizeof(UAnimNotify_DisableWeaponFOV) == 0x000030, "Wrong size on UAnimNotify_DisableWeaponFOV");

// Class ReadyOrNot.ReadyOrNotTriggerVolume
// 0x0028 (0x0250 - 0x0228)
class AReadyOrNotTriggerVolume : public ATriggerBox
{
public:
	TArray<TSubclassOf<class AActor>>             OverlappingClasses;                                // 0x0228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         TestActors;                                        // 0x0238(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A3[0x8];                                     // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorSpawned(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotTriggerVolume">();
	}
	static class AReadyOrNotTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotTriggerVolume>();
	}
};
static_assert(alignof(AReadyOrNotTriggerVolume) == 0x000008, "Wrong alignment on AReadyOrNotTriggerVolume");
static_assert(sizeof(AReadyOrNotTriggerVolume) == 0x000250, "Wrong size on AReadyOrNotTriggerVolume");
static_assert(offsetof(AReadyOrNotTriggerVolume, OverlappingClasses) == 0x000228, "Member 'AReadyOrNotTriggerVolume::OverlappingClasses' has a wrong offset!");
static_assert(offsetof(AReadyOrNotTriggerVolume, TestActors) == 0x000238, "Member 'AReadyOrNotTriggerVolume::TestActors' has a wrong offset!");

// Class ReadyOrNot.LobbyFiringRangeArea
// 0x0000 (0x0250 - 0x0250)
class ALobbyFiringRangeArea final  : public AReadyOrNotTriggerVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyFiringRangeArea">();
	}
	static class ALobbyFiringRangeArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyFiringRangeArea>();
	}
};
static_assert(alignof(ALobbyFiringRangeArea) == 0x000008, "Wrong alignment on ALobbyFiringRangeArea");
static_assert(sizeof(ALobbyFiringRangeArea) == 0x000250, "Wrong size on ALobbyFiringRangeArea");

// Class ReadyOrNot.AnimNotify_DisarmTrap
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_DisarmTrap final  : public UAnimNotify
{
public:
	uint8                                         bDisarmFinished : 1;                               // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_21A4[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DisarmTrap">();
	}
	static class UAnimNotify_DisarmTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DisarmTrap>();
	}
};
static_assert(alignof(UAnimNotify_DisarmTrap) == 0x000008, "Wrong alignment on UAnimNotify_DisarmTrap");
static_assert(sizeof(UAnimNotify_DisarmTrap) == 0x000040, "Wrong size on UAnimNotify_DisarmTrap");

// Class ReadyOrNot.AnimNotify_EquipItemOfClass
// 0x0010 (0x0048 - 0x0038)
class UAnimNotify_EquipItemOfClass final  : public UAnimNotify
{
public:
	TSubclassOf<class ABaseItem>                  ItemClass;                                         // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInstant : 1;                                      // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAIOnly : 1;                                       // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_21A5[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EquipItemOfClass">();
	}
	static class UAnimNotify_EquipItemOfClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EquipItemOfClass>();
	}
};
static_assert(alignof(UAnimNotify_EquipItemOfClass) == 0x000008, "Wrong alignment on UAnimNotify_EquipItemOfClass");
static_assert(sizeof(UAnimNotify_EquipItemOfClass) == 0x000048, "Wrong size on UAnimNotify_EquipItemOfClass");
static_assert(offsetof(UAnimNotify_EquipItemOfClass, ItemClass) == 0x000038, "Member 'UAnimNotify_EquipItemOfClass::ItemClass' has a wrong offset!");

// Class ReadyOrNot.BaseItem
// 0x07B0 (0x09D0 - 0x0220)
class ABaseItem : public AActor
{
public:
	uint8                                         Pad_21A6[0x40];                                    // 0x0220(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemName;                                          // 0x0260(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ItemIcon;                                          // 0x0278(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ItemDescription;                                   // 0x02A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EItemClass                                    ItemClass;                                         // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemType                                     ItemType;                                          // 0x02B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A7[0x2];                                     // 0x02BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        CategoryFlags;                                     // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadoutPriority;                                   // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInLoadout;                                    // 0x02C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A8[0x3];                                     // 0x02C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomizationTag;                                  // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemsPerSlot;                                      // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LookupTableIdx;                                    // 0x02D4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemWeight;                                        // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeedMultiplier;                           // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HolsterPlayRate;                                   // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawPlayRate;                                      // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanOffset;                                        // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisallowKicking;                                  // 0x02F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreelookEnabled;                                  // 0x02F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLowReady;                                      // 0x02F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A9[0x1];                                     // 0x02F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PushbackRange;                                     // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowReadyRange;                                     // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowReadyRangeSightsModifier;                       // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableTickWhenNotEquipped;                       // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21AA[0x7];                                     // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGameVersionRestriction>               LockedToDLC;                                       // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FItemVisualData                        Visuals;                                           // 0x0318(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             HudOutline;                                        // 0x0348(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobScaleH;                                   // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobScaleV;                                   // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobSpeedScaleH;                              // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobSpeedScaleV;                              // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobAmplitudeBaseSpeed;                       // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobIntensitySprintScale;                     // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobAmplitudeWalkScale;                       // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobAmplitudeSprintScale;                     // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobScaleH;                                   // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobScaleV;                                   // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobScaleInjured;                             // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobSpeedScaleH;                              // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobSpeedScaleV;                              // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobSpeedScaleInjured;                        // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobCrouchModifier;                           // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobADSModifier;                              // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotPitchScale;                            // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotRollScale;                             // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotPitchSpeed;                            // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotRollSpeed;                             // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotCrouchModifier;                        // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotADSModifier;                           // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SceneComp;                                         // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 ItemMesh;                                          // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          InteractionBox;                                    // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    FMODAudioComp;                                     // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 InteractableComponent;                             // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScoringComponent*                      ScoringComponent;                                  // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             PhysicsImpact;                                     // 0x03D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21AB[0x10];                                    // 0x03E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AThrownItem>                ThrownItemClass;                                   // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21AC[0x3C];                                    // 0x03F8(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAttachOnDrawComplete;                             // 0x0434(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21AD[0x3];                                     // 0x0435(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          Rep_CustomItemMeshFromAttachment;                  // 0x0438(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCustomizationSkin>      DefaultSkin;                                       // 0x0440(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationSkin*                     Skin;                                              // 0x0468(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21AE[0x1];                                     // 0x0470(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInInventory;                                      // 0x0471(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTickAnimBPWhenNotEquipped;                  // 0x0472(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21AF[0x1];                                     // 0x0473(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Server_ReplicatedPhysicsLocation;                  // 0x0474(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetWorldScale;                                  // 0x0480(0x000C)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetWorldScaleInterpSpeed;                       // 0x048C(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21B0[0x1];                                     // 0x0490(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bStartAsEvidence;                                  // 0x0491(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEvidence;                                       // 0x0492(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMarkAsEvidenceWhenNoOwner;                        // 0x0493(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClearable;                                      // 0x0494(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenCleared;                                   // 0x0495(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21B1[0xA];                                     // 0x0496(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UDamageType>>        BlockAnyDamageFrom;                                // 0x04A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UDamageType>>        BlockDirectHitsFrom;                               // 0x04B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bTaserDamageBlocked;                               // 0x04C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21B2[0x7];                                     // 0x04C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class UDamageType>, float>   MultiplyStunDamageFrom;                            // 0x04C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UDamageType>, struct FWeightStunMultiplier> MultiplyStunDamageByWeight;                        // 0x0518(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       Dynamic1PMaterialInstances;                        // 0x0568(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_21B3[0x8];                                     // 0x0578(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       DynamicWeaponFovMats;                              // 0x0580(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class USkeletalMesh*, struct FMeshFOVMaterials> SkeletalMeshToFOVMats;                             // 0x0590(0x0050)(NativeAccessSpecifierPublic)
	TMap<class UStaticMesh*, struct FMeshFOVMaterials> StaticMeshToFOVMats;                               // 0x05E0(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_21B4[0x8];                                     // 0x0630(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       FP_SkinMaterials;                                  // 0x0638(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       TP_SkinMaterials;                                  // 0x0648(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 MasterPoseRep;                                     // 0x0658(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowStaticMeshOnBody;                             // 0x0660(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21B5[0x3];                                     // 0x0661(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeaponWheelCategoryName;                           // 0x0664(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21B6[0x4];                                     // 0x066C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnItemUseCompleted;                                // 0x0670(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_21B7[0x18];                                    // 0x0680(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanReloadSameMagazine;                            // 0x0698(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21B8[0x7];                                     // 0x0699(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           LastReloadAnim_3P;                                 // 0x06A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanMultiplier;                               // 0x06A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeLeanMultiplier;                                // 0x06AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEvidenceCollected;                               // 0x06B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EWeaponType                                   WeaponType;                                        // 0x06C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableMeshspaceMovement;                         // 0x06C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21B9[0xE];                                     // 0x06C2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MeshspaceTransform_Default;                        // 0x06D0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             MeshspaceTransform_Aiming;                         // 0x0700(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             MeshspaceTransform_Back;                           // 0x0730(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InertiaDragAimRotation;                            // 0x0760(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaDragAimLocation;                            // 0x0764(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaDragStrafeRotation;                         // 0x0768(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaDragStrafeLocation;                         // 0x076C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MovementSpeedScale;                                // 0x0770(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MovementSpeedRotationScalePitchYawRoll;            // 0x077C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MeshSpaceAimInterp;                                // 0x0788(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21BA[0x4];                                     // 0x078C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MeshspaceTransform_OnDraw;                         // 0x0790(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         OnDrawMeshspaceInterp;                             // 0x07C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21BB[0xC];                                     // 0x07C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MeshspaceTransform_OnHolster;                      // 0x07D0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         OnHolsterMeshspaceInterp;                          // 0x0800(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodySocket;                                        // 0x0804(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HandsSocket;                                       // 0x080C(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimationIndex1P;                                  // 0x0814(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21BC[0x4];                                     // 0x0818(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AnimationIndex3P;                                  // 0x081C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21BD[0x4];                                     // 0x0820(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDeployable;                                       // 0x0824(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldEquipToHands;                               // 0x0825(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21BE[0x2];                                     // 0x0826(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EItemCategory>                         ItemCategories;                                    // 0x0828(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_21BF[0x10];                                    // 0x0838(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnItemDrawComplete;                                // 0x0848(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C0[0x8];                                     // 0x0858(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMatineeCameraShake>        Reload_CameraShake;                                // 0x0860(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        ReloadEmpty_CameraShake;                           // 0x0868(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        DrawCameraShake;                                   // 0x0870(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        HolsterCameraShake;                                // 0x0878(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   PreviousOwner;                                     // 0x0880(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C1[0x38];                                    // 0x0888(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 LastFPAnimInstanceClass;                           // 0x08C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C2[0x38];                                    // 0x08C8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 LastTPAnimInstanceClass;                           // 0x0900(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingCollected;                                 // 0x0908(0x0001)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C3[0x3];                                     // 0x0909(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentCollectionTime;                             // 0x090C(0x0004)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCollectionTime;                                 // 0x0910(0x0004)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C4[0x4];                                     // 0x0914(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   CollectingCharacter;                               // 0x0918(0x0008)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDropping;                                         // 0x0920(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C5[0xF];                                     // 0x0921(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisableAnimInstanceWhenNotEquipped;               // 0x0930(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C6[0xF];                                     // 0x0931(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UReadyOrNotWeaponAnimData*              AnimationData;                                     // 0x0940(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotWeaponAnimData*              DefaultAnimationData;                              // 0x0948(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotWeaponAnimData*              GripAnimationData;                                 // 0x0950(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotWeaponAnimData*              ShieldRaisedAnimationData;                         // 0x0958(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotWeaponAnimData*              ShieldLoweredAnimationData;                        // 0x0960(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimLimit;                                      // 0x0968(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimLimitADS;                                   // 0x096C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LazySpringStrength;                                // 0x0970(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LazySpringStrengthADS;                             // 0x0974(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimInterpSpeed;                                // 0x0978(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimInterpADSModifier;                          // 0x097C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimInterpHipModifier;                          // 0x0980(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimSlowMoveModifier;                           // 0x0984(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimSlowMoveTolerance;                          // 0x0988(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C7[0x4];                                     // 0x098C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMatineeCameraShake>        MeleeUserCameraShake;                              // 0x0990(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bADSCountsAsAbuse;                                 // 0x0998(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C8[0x3];                                     // 0x0999(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HesitationBoostMultiplier;                         // 0x099C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAimingDownSights;                               // 0x09A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C9[0x3];                                     // 0x09A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowReadyPitchThreshold;                            // 0x09A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponSound*                           SoundData;                                         // 0x09A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideBreathingEvent;                           // 0x09B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21CA[0x7];                                     // 0x09B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             BreathingAudioOverride;                            // 0x09B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEasyPickup;                                       // 0x09C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoPickup;                                         // 0x09C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScriptedFPHidden;                                 // 0x09C2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMotionBlockType                              ActiveMotionBlock;                                 // 0x09C3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOneHandedItem;                                  // 0x09C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21CB[0x3];                                     // 0x09C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FP_ADS_Motion_Weight;                              // 0x09C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21CC[0x4];                                     // 0x09CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachStatic();
	void BP_AttachmentRep();
	void CancelCurrentReloadAction(bool bCancel);
	bool CanShowActionSlot1(class AReadyOrNotCharacter* PC);
	void Client_OnItemPickedUp(class AActor* NewOwner, bool bEquipped);
	void Client_PlayFPMontage(class UAnimMontage* NewMontage, float PlayRate);
	void Client_PlayItemAnimation(struct FWeaponAnim& InWeaponAnim, bool bRestartIfAlreadyPlaying, bool bOnlyLocal, bool bOnlyTP);
	void Client_SetFPModelVisibility(bool bVisibility);
	void Client_StopItemAnimation(struct FWeaponAnim& InWeaponAnim, bool bOnlyTP);
	void ClientPlayDraw(bool bDrawFirst);
	void DetachStatic();
	void DisableOrEnableAnimation();
	void DisableOutline();
	void DrawOutline();
	void EndStunWhileEquipped();
	class UAnimMontage* GetCurrentFPMontage();
	class UAnimMontage* GetCurrentTPMontage();
	class FName GetEquipSocket();
	float GetLowReadyRange();
	float GetWeight();
	void InterpToTargetScale(const struct FVector& NewScale, float InterpSpeed);
	bool IsLocallyControlled();
	bool IsMontagePlaying(class UAnimMontage* Montage, bool bIncludeFP, bool bIncludeTP);
	bool IsPlayingStunnedAnimation();
	bool IsPlayingStunnedEndAnimation();
	void LastStunTick(EStunType StunType);
	void MarkAsEvidence(bool bMarkAsEvidence);
	void Multicast_PlayTPMontage(class UAnimMontage* NewMontage, float PlayRate);
	void NextFireMode();
	void OnEvidenceCollected__DelegateSignature();
	void OnItemAttachmentsChanged__DelegateSignature(EItemAttachment AttachmentChanged);
	void OnItemDrawComplete__DelegateSignature(class ABaseItem* Item);
	void OnItemEndUse();
	void OnItemPrimaryUse();
	void OnItemPrimaryUse__DelegateSignature(class ABaseItem* Item);
	void OnItemPrimaryUseEnd();
	void OnItemUseComplete();
	void OnItemUseCompleted__DelegateSignature(class ABaseItem* Item);
	void OnItemUsed();
	void OnMeshComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit);
	void OnOwnerPossessed();
	void OnPhysicsImpact(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit);
	void OnRep_AttachmentRep();
	void OnRep_IsDropping();
	void OnRep_MasterPoseComponent();
	void OnRep_Skin();
	void OnThrownFromInventory(class AReadyOrNotCharacter* Thrower, bool bMarkAsEvidence);
	void PlayButtonPushAnimation();
	void PlayDoorPushAnimation();
	bool PlayDraw(bool bDrawFirst);
	void PlayFMODAudio(class UFMODEvent* Event);
	void PlayFPMontage(class UAnimMontage* NewMontage, float PlayRate);
	void PlayTPMontage(class UAnimMontage* NewMontage, float PlayRate);
	void PlayWeaponCleaning();
	void Server_ApplyPointDamage(class AActor* DamagedActor, float BaseDamage, struct FVector& HitFromDirection, struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass);
	void Server_PlayTPMontage(class UAnimMontage* NewMontage, float PlayRate);
	void Server_SetMasterPoseComponent(class USkeletalMeshComponent* Mesh);
	void SetupBaseEvents();
	bool ShouldHideInPictureInPictureScopes();
	void SpawnThrownItemAtTransform(struct FTransform& Transform, struct FVector& ThrowDirection, struct FVector& ThrowLocation);
	void StopFPMontage(class UAnimMontage* AnimMontage);
	void StopTPMontage(class UAnimMontage* AnimMontage);
	void StunnedWhileEquipped();
	void StunTick(EStunType StunType);

	bool CanEquip(class AReadyOrNotCharacter* ToCharacter) const;
	bool ContainsItemCategory(EItemCategory TestCategory) const;
	class USkeletalMeshComponent* GetItemMesh() const;
	bool HasButtonPushAnimation() const;
	bool HasDoorPushAnimation() const;
	bool IsBlockingAnimationPlaying(const TArray<EBlockingAnimationExclusion>& Exclusions) const;
	bool IsButtonPushAnimationPlaying() const;
	bool IsCollidesWhileNotEquipped() const;
	bool IsCurrentlyReloading() const;
	bool IsDepleted() const;
	bool IsDoorPushAnimationPlaying() const;
	bool IsEquipped() const;
	bool IsPlayingDraw() const;
	bool IsPlayingHolster() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseItem">();
	}
	static class ABaseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseItem>();
	}
};
static_assert(alignof(ABaseItem) == 0x000010, "Wrong alignment on ABaseItem");
static_assert(sizeof(ABaseItem) == 0x0009D0, "Wrong size on ABaseItem");
static_assert(offsetof(ABaseItem, ItemName) == 0x000260, "Member 'ABaseItem::ItemName' has a wrong offset!");
static_assert(offsetof(ABaseItem, ItemIcon) == 0x000278, "Member 'ABaseItem::ItemIcon' has a wrong offset!");
static_assert(offsetof(ABaseItem, ItemDescription) == 0x0002A0, "Member 'ABaseItem::ItemDescription' has a wrong offset!");
static_assert(offsetof(ABaseItem, ItemClass) == 0x0002B8, "Member 'ABaseItem::ItemClass' has a wrong offset!");
static_assert(offsetof(ABaseItem, ItemType) == 0x0002B9, "Member 'ABaseItem::ItemType' has a wrong offset!");
static_assert(offsetof(ABaseItem, CategoryFlags) == 0x0002BC, "Member 'ABaseItem::CategoryFlags' has a wrong offset!");
static_assert(offsetof(ABaseItem, LoadoutPriority) == 0x0002C0, "Member 'ABaseItem::LoadoutPriority' has a wrong offset!");
static_assert(offsetof(ABaseItem, bShowInLoadout) == 0x0002C4, "Member 'ABaseItem::bShowInLoadout' has a wrong offset!");
static_assert(offsetof(ABaseItem, CustomizationTag) == 0x0002C8, "Member 'ABaseItem::CustomizationTag' has a wrong offset!");
static_assert(offsetof(ABaseItem, ItemsPerSlot) == 0x0002D0, "Member 'ABaseItem::ItemsPerSlot' has a wrong offset!");
static_assert(offsetof(ABaseItem, LookupTableIdx) == 0x0002D4, "Member 'ABaseItem::LookupTableIdx' has a wrong offset!");
static_assert(offsetof(ABaseItem, ItemWeight) == 0x0002DC, "Member 'ABaseItem::ItemWeight' has a wrong offset!");
static_assert(offsetof(ABaseItem, MovementSpeedMultiplier) == 0x0002E0, "Member 'ABaseItem::MovementSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseItem, HolsterPlayRate) == 0x0002E4, "Member 'ABaseItem::HolsterPlayRate' has a wrong offset!");
static_assert(offsetof(ABaseItem, DrawPlayRate) == 0x0002E8, "Member 'ABaseItem::DrawPlayRate' has a wrong offset!");
static_assert(offsetof(ABaseItem, LeanOffset) == 0x0002EC, "Member 'ABaseItem::LeanOffset' has a wrong offset!");
static_assert(offsetof(ABaseItem, bDisallowKicking) == 0x0002F0, "Member 'ABaseItem::bDisallowKicking' has a wrong offset!");
static_assert(offsetof(ABaseItem, bFreelookEnabled) == 0x0002F1, "Member 'ABaseItem::bFreelookEnabled' has a wrong offset!");
static_assert(offsetof(ABaseItem, bUseLowReady) == 0x0002F2, "Member 'ABaseItem::bUseLowReady' has a wrong offset!");
static_assert(offsetof(ABaseItem, PushbackRange) == 0x0002F4, "Member 'ABaseItem::PushbackRange' has a wrong offset!");
static_assert(offsetof(ABaseItem, LowReadyRange) == 0x0002F8, "Member 'ABaseItem::LowReadyRange' has a wrong offset!");
static_assert(offsetof(ABaseItem, LowReadyRangeSightsModifier) == 0x0002FC, "Member 'ABaseItem::LowReadyRangeSightsModifier' has a wrong offset!");
static_assert(offsetof(ABaseItem, bDisableTickWhenNotEquipped) == 0x000300, "Member 'ABaseItem::bDisableTickWhenNotEquipped' has a wrong offset!");
static_assert(offsetof(ABaseItem, LockedToDLC) == 0x000308, "Member 'ABaseItem::LockedToDLC' has a wrong offset!");
static_assert(offsetof(ABaseItem, Visuals) == 0x000318, "Member 'ABaseItem::Visuals' has a wrong offset!");
static_assert(offsetof(ABaseItem, HudOutline) == 0x000348, "Member 'ABaseItem::HudOutline' has a wrong offset!");
static_assert(offsetof(ABaseItem, CameraBobScaleH) == 0x000350, "Member 'ABaseItem::CameraBobScaleH' has a wrong offset!");
static_assert(offsetof(ABaseItem, CameraBobScaleV) == 0x000354, "Member 'ABaseItem::CameraBobScaleV' has a wrong offset!");
static_assert(offsetof(ABaseItem, CameraBobSpeedScaleH) == 0x000358, "Member 'ABaseItem::CameraBobSpeedScaleH' has a wrong offset!");
static_assert(offsetof(ABaseItem, CameraBobSpeedScaleV) == 0x00035C, "Member 'ABaseItem::CameraBobSpeedScaleV' has a wrong offset!");
static_assert(offsetof(ABaseItem, CameraBobAmplitudeBaseSpeed) == 0x000360, "Member 'ABaseItem::CameraBobAmplitudeBaseSpeed' has a wrong offset!");
static_assert(offsetof(ABaseItem, CameraBobIntensitySprintScale) == 0x000364, "Member 'ABaseItem::CameraBobIntensitySprintScale' has a wrong offset!");
static_assert(offsetof(ABaseItem, CameraBobAmplitudeWalkScale) == 0x000368, "Member 'ABaseItem::CameraBobAmplitudeWalkScale' has a wrong offset!");
static_assert(offsetof(ABaseItem, CameraBobAmplitudeSprintScale) == 0x00036C, "Member 'ABaseItem::CameraBobAmplitudeSprintScale' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobScaleH) == 0x000370, "Member 'ABaseItem::WeaponBobScaleH' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobScaleV) == 0x000374, "Member 'ABaseItem::WeaponBobScaleV' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobScaleInjured) == 0x000378, "Member 'ABaseItem::WeaponBobScaleInjured' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobSpeedScaleH) == 0x00037C, "Member 'ABaseItem::WeaponBobSpeedScaleH' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobSpeedScaleV) == 0x000380, "Member 'ABaseItem::WeaponBobSpeedScaleV' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobSpeedScaleInjured) == 0x000384, "Member 'ABaseItem::WeaponBobSpeedScaleInjured' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobCrouchModifier) == 0x000388, "Member 'ABaseItem::WeaponBobCrouchModifier' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobADSModifier) == 0x00038C, "Member 'ABaseItem::WeaponBobADSModifier' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobRotPitchScale) == 0x000390, "Member 'ABaseItem::WeaponBobRotPitchScale' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobRotRollScale) == 0x000394, "Member 'ABaseItem::WeaponBobRotRollScale' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobRotPitchSpeed) == 0x000398, "Member 'ABaseItem::WeaponBobRotPitchSpeed' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobRotRollSpeed) == 0x00039C, "Member 'ABaseItem::WeaponBobRotRollSpeed' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobRotCrouchModifier) == 0x0003A0, "Member 'ABaseItem::WeaponBobRotCrouchModifier' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobRotADSModifier) == 0x0003A4, "Member 'ABaseItem::WeaponBobRotADSModifier' has a wrong offset!");
static_assert(offsetof(ABaseItem, SceneComp) == 0x0003A8, "Member 'ABaseItem::SceneComp' has a wrong offset!");
static_assert(offsetof(ABaseItem, ItemMesh) == 0x0003B0, "Member 'ABaseItem::ItemMesh' has a wrong offset!");
static_assert(offsetof(ABaseItem, InteractionBox) == 0x0003B8, "Member 'ABaseItem::InteractionBox' has a wrong offset!");
static_assert(offsetof(ABaseItem, FMODAudioComp) == 0x0003C0, "Member 'ABaseItem::FMODAudioComp' has a wrong offset!");
static_assert(offsetof(ABaseItem, InteractableComponent) == 0x0003C8, "Member 'ABaseItem::InteractableComponent' has a wrong offset!");
static_assert(offsetof(ABaseItem, ScoringComponent) == 0x0003D0, "Member 'ABaseItem::ScoringComponent' has a wrong offset!");
static_assert(offsetof(ABaseItem, PhysicsImpact) == 0x0003D8, "Member 'ABaseItem::PhysicsImpact' has a wrong offset!");
static_assert(offsetof(ABaseItem, ThrownItemClass) == 0x0003F0, "Member 'ABaseItem::ThrownItemClass' has a wrong offset!");
static_assert(offsetof(ABaseItem, bAttachOnDrawComplete) == 0x000434, "Member 'ABaseItem::bAttachOnDrawComplete' has a wrong offset!");
static_assert(offsetof(ABaseItem, Rep_CustomItemMeshFromAttachment) == 0x000438, "Member 'ABaseItem::Rep_CustomItemMeshFromAttachment' has a wrong offset!");
static_assert(offsetof(ABaseItem, DefaultSkin) == 0x000440, "Member 'ABaseItem::DefaultSkin' has a wrong offset!");
static_assert(offsetof(ABaseItem, Skin) == 0x000468, "Member 'ABaseItem::Skin' has a wrong offset!");
static_assert(offsetof(ABaseItem, bInInventory) == 0x000471, "Member 'ABaseItem::bInInventory' has a wrong offset!");
static_assert(offsetof(ABaseItem, bShouldTickAnimBPWhenNotEquipped) == 0x000472, "Member 'ABaseItem::bShouldTickAnimBPWhenNotEquipped' has a wrong offset!");
static_assert(offsetof(ABaseItem, Server_ReplicatedPhysicsLocation) == 0x000474, "Member 'ABaseItem::Server_ReplicatedPhysicsLocation' has a wrong offset!");
static_assert(offsetof(ABaseItem, TargetWorldScale) == 0x000480, "Member 'ABaseItem::TargetWorldScale' has a wrong offset!");
static_assert(offsetof(ABaseItem, TargetWorldScaleInterpSpeed) == 0x00048C, "Member 'ABaseItem::TargetWorldScaleInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABaseItem, bStartAsEvidence) == 0x000491, "Member 'ABaseItem::bStartAsEvidence' has a wrong offset!");
static_assert(offsetof(ABaseItem, bIsEvidence) == 0x000492, "Member 'ABaseItem::bIsEvidence' has a wrong offset!");
static_assert(offsetof(ABaseItem, bMarkAsEvidenceWhenNoOwner) == 0x000493, "Member 'ABaseItem::bMarkAsEvidenceWhenNoOwner' has a wrong offset!");
static_assert(offsetof(ABaseItem, bIsClearable) == 0x000494, "Member 'ABaseItem::bIsClearable' has a wrong offset!");
static_assert(offsetof(ABaseItem, bHasBeenCleared) == 0x000495, "Member 'ABaseItem::bHasBeenCleared' has a wrong offset!");
static_assert(offsetof(ABaseItem, BlockAnyDamageFrom) == 0x0004A0, "Member 'ABaseItem::BlockAnyDamageFrom' has a wrong offset!");
static_assert(offsetof(ABaseItem, BlockDirectHitsFrom) == 0x0004B0, "Member 'ABaseItem::BlockDirectHitsFrom' has a wrong offset!");
static_assert(offsetof(ABaseItem, bTaserDamageBlocked) == 0x0004C0, "Member 'ABaseItem::bTaserDamageBlocked' has a wrong offset!");
static_assert(offsetof(ABaseItem, MultiplyStunDamageFrom) == 0x0004C8, "Member 'ABaseItem::MultiplyStunDamageFrom' has a wrong offset!");
static_assert(offsetof(ABaseItem, MultiplyStunDamageByWeight) == 0x000518, "Member 'ABaseItem::MultiplyStunDamageByWeight' has a wrong offset!");
static_assert(offsetof(ABaseItem, Dynamic1PMaterialInstances) == 0x000568, "Member 'ABaseItem::Dynamic1PMaterialInstances' has a wrong offset!");
static_assert(offsetof(ABaseItem, DynamicWeaponFovMats) == 0x000580, "Member 'ABaseItem::DynamicWeaponFovMats' has a wrong offset!");
static_assert(offsetof(ABaseItem, SkeletalMeshToFOVMats) == 0x000590, "Member 'ABaseItem::SkeletalMeshToFOVMats' has a wrong offset!");
static_assert(offsetof(ABaseItem, StaticMeshToFOVMats) == 0x0005E0, "Member 'ABaseItem::StaticMeshToFOVMats' has a wrong offset!");
static_assert(offsetof(ABaseItem, FP_SkinMaterials) == 0x000638, "Member 'ABaseItem::FP_SkinMaterials' has a wrong offset!");
static_assert(offsetof(ABaseItem, TP_SkinMaterials) == 0x000648, "Member 'ABaseItem::TP_SkinMaterials' has a wrong offset!");
static_assert(offsetof(ABaseItem, MasterPoseRep) == 0x000658, "Member 'ABaseItem::MasterPoseRep' has a wrong offset!");
static_assert(offsetof(ABaseItem, bShowStaticMeshOnBody) == 0x000660, "Member 'ABaseItem::bShowStaticMeshOnBody' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponWheelCategoryName) == 0x000664, "Member 'ABaseItem::WeaponWheelCategoryName' has a wrong offset!");
static_assert(offsetof(ABaseItem, OnItemUseCompleted) == 0x000670, "Member 'ABaseItem::OnItemUseCompleted' has a wrong offset!");
static_assert(offsetof(ABaseItem, bCanReloadSameMagazine) == 0x000698, "Member 'ABaseItem::bCanReloadSameMagazine' has a wrong offset!");
static_assert(offsetof(ABaseItem, LastReloadAnim_3P) == 0x0006A0, "Member 'ABaseItem::LastReloadAnim_3P' has a wrong offset!");
static_assert(offsetof(ABaseItem, QuickLeanMultiplier) == 0x0006A8, "Member 'ABaseItem::QuickLeanMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseItem, FreeLeanMultiplier) == 0x0006AC, "Member 'ABaseItem::FreeLeanMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseItem, OnEvidenceCollected) == 0x0006B0, "Member 'ABaseItem::OnEvidenceCollected' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponType) == 0x0006C0, "Member 'ABaseItem::WeaponType' has a wrong offset!");
static_assert(offsetof(ABaseItem, bDisableMeshspaceMovement) == 0x0006C1, "Member 'ABaseItem::bDisableMeshspaceMovement' has a wrong offset!");
static_assert(offsetof(ABaseItem, MeshspaceTransform_Default) == 0x0006D0, "Member 'ABaseItem::MeshspaceTransform_Default' has a wrong offset!");
static_assert(offsetof(ABaseItem, MeshspaceTransform_Aiming) == 0x000700, "Member 'ABaseItem::MeshspaceTransform_Aiming' has a wrong offset!");
static_assert(offsetof(ABaseItem, MeshspaceTransform_Back) == 0x000730, "Member 'ABaseItem::MeshspaceTransform_Back' has a wrong offset!");
static_assert(offsetof(ABaseItem, InertiaDragAimRotation) == 0x000760, "Member 'ABaseItem::InertiaDragAimRotation' has a wrong offset!");
static_assert(offsetof(ABaseItem, InertiaDragAimLocation) == 0x000764, "Member 'ABaseItem::InertiaDragAimLocation' has a wrong offset!");
static_assert(offsetof(ABaseItem, InertiaDragStrafeRotation) == 0x000768, "Member 'ABaseItem::InertiaDragStrafeRotation' has a wrong offset!");
static_assert(offsetof(ABaseItem, InertiaDragStrafeLocation) == 0x00076C, "Member 'ABaseItem::InertiaDragStrafeLocation' has a wrong offset!");
static_assert(offsetof(ABaseItem, MovementSpeedScale) == 0x000770, "Member 'ABaseItem::MovementSpeedScale' has a wrong offset!");
static_assert(offsetof(ABaseItem, MovementSpeedRotationScalePitchYawRoll) == 0x00077C, "Member 'ABaseItem::MovementSpeedRotationScalePitchYawRoll' has a wrong offset!");
static_assert(offsetof(ABaseItem, MeshSpaceAimInterp) == 0x000788, "Member 'ABaseItem::MeshSpaceAimInterp' has a wrong offset!");
static_assert(offsetof(ABaseItem, MeshspaceTransform_OnDraw) == 0x000790, "Member 'ABaseItem::MeshspaceTransform_OnDraw' has a wrong offset!");
static_assert(offsetof(ABaseItem, OnDrawMeshspaceInterp) == 0x0007C0, "Member 'ABaseItem::OnDrawMeshspaceInterp' has a wrong offset!");
static_assert(offsetof(ABaseItem, MeshspaceTransform_OnHolster) == 0x0007D0, "Member 'ABaseItem::MeshspaceTransform_OnHolster' has a wrong offset!");
static_assert(offsetof(ABaseItem, OnHolsterMeshspaceInterp) == 0x000800, "Member 'ABaseItem::OnHolsterMeshspaceInterp' has a wrong offset!");
static_assert(offsetof(ABaseItem, BodySocket) == 0x000804, "Member 'ABaseItem::BodySocket' has a wrong offset!");
static_assert(offsetof(ABaseItem, HandsSocket) == 0x00080C, "Member 'ABaseItem::HandsSocket' has a wrong offset!");
static_assert(offsetof(ABaseItem, AnimationIndex1P) == 0x000814, "Member 'ABaseItem::AnimationIndex1P' has a wrong offset!");
static_assert(offsetof(ABaseItem, AnimationIndex3P) == 0x00081C, "Member 'ABaseItem::AnimationIndex3P' has a wrong offset!");
static_assert(offsetof(ABaseItem, bDeployable) == 0x000824, "Member 'ABaseItem::bDeployable' has a wrong offset!");
static_assert(offsetof(ABaseItem, bShouldEquipToHands) == 0x000825, "Member 'ABaseItem::bShouldEquipToHands' has a wrong offset!");
static_assert(offsetof(ABaseItem, ItemCategories) == 0x000828, "Member 'ABaseItem::ItemCategories' has a wrong offset!");
static_assert(offsetof(ABaseItem, OnItemDrawComplete) == 0x000848, "Member 'ABaseItem::OnItemDrawComplete' has a wrong offset!");
static_assert(offsetof(ABaseItem, Reload_CameraShake) == 0x000860, "Member 'ABaseItem::Reload_CameraShake' has a wrong offset!");
static_assert(offsetof(ABaseItem, ReloadEmpty_CameraShake) == 0x000868, "Member 'ABaseItem::ReloadEmpty_CameraShake' has a wrong offset!");
static_assert(offsetof(ABaseItem, DrawCameraShake) == 0x000870, "Member 'ABaseItem::DrawCameraShake' has a wrong offset!");
static_assert(offsetof(ABaseItem, HolsterCameraShake) == 0x000878, "Member 'ABaseItem::HolsterCameraShake' has a wrong offset!");
static_assert(offsetof(ABaseItem, PreviousOwner) == 0x000880, "Member 'ABaseItem::PreviousOwner' has a wrong offset!");
static_assert(offsetof(ABaseItem, LastFPAnimInstanceClass) == 0x0008C0, "Member 'ABaseItem::LastFPAnimInstanceClass' has a wrong offset!");
static_assert(offsetof(ABaseItem, LastTPAnimInstanceClass) == 0x000900, "Member 'ABaseItem::LastTPAnimInstanceClass' has a wrong offset!");
static_assert(offsetof(ABaseItem, bIsBeingCollected) == 0x000908, "Member 'ABaseItem::bIsBeingCollected' has a wrong offset!");
static_assert(offsetof(ABaseItem, CurrentCollectionTime) == 0x00090C, "Member 'ABaseItem::CurrentCollectionTime' has a wrong offset!");
static_assert(offsetof(ABaseItem, MaxCollectionTime) == 0x000910, "Member 'ABaseItem::MaxCollectionTime' has a wrong offset!");
static_assert(offsetof(ABaseItem, CollectingCharacter) == 0x000918, "Member 'ABaseItem::CollectingCharacter' has a wrong offset!");
static_assert(offsetof(ABaseItem, bDropping) == 0x000920, "Member 'ABaseItem::bDropping' has a wrong offset!");
static_assert(offsetof(ABaseItem, bDisableAnimInstanceWhenNotEquipped) == 0x000930, "Member 'ABaseItem::bDisableAnimInstanceWhenNotEquipped' has a wrong offset!");
static_assert(offsetof(ABaseItem, AnimationData) == 0x000940, "Member 'ABaseItem::AnimationData' has a wrong offset!");
static_assert(offsetof(ABaseItem, DefaultAnimationData) == 0x000948, "Member 'ABaseItem::DefaultAnimationData' has a wrong offset!");
static_assert(offsetof(ABaseItem, GripAnimationData) == 0x000950, "Member 'ABaseItem::GripAnimationData' has a wrong offset!");
static_assert(offsetof(ABaseItem, ShieldRaisedAnimationData) == 0x000958, "Member 'ABaseItem::ShieldRaisedAnimationData' has a wrong offset!");
static_assert(offsetof(ABaseItem, ShieldLoweredAnimationData) == 0x000960, "Member 'ABaseItem::ShieldLoweredAnimationData' has a wrong offset!");
static_assert(offsetof(ABaseItem, FreeAimLimit) == 0x000968, "Member 'ABaseItem::FreeAimLimit' has a wrong offset!");
static_assert(offsetof(ABaseItem, FreeAimLimitADS) == 0x00096C, "Member 'ABaseItem::FreeAimLimitADS' has a wrong offset!");
static_assert(offsetof(ABaseItem, LazySpringStrength) == 0x000970, "Member 'ABaseItem::LazySpringStrength' has a wrong offset!");
static_assert(offsetof(ABaseItem, LazySpringStrengthADS) == 0x000974, "Member 'ABaseItem::LazySpringStrengthADS' has a wrong offset!");
static_assert(offsetof(ABaseItem, FreeAimInterpSpeed) == 0x000978, "Member 'ABaseItem::FreeAimInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABaseItem, FreeAimInterpADSModifier) == 0x00097C, "Member 'ABaseItem::FreeAimInterpADSModifier' has a wrong offset!");
static_assert(offsetof(ABaseItem, FreeAimInterpHipModifier) == 0x000980, "Member 'ABaseItem::FreeAimInterpHipModifier' has a wrong offset!");
static_assert(offsetof(ABaseItem, FreeAimSlowMoveModifier) == 0x000984, "Member 'ABaseItem::FreeAimSlowMoveModifier' has a wrong offset!");
static_assert(offsetof(ABaseItem, FreeAimSlowMoveTolerance) == 0x000988, "Member 'ABaseItem::FreeAimSlowMoveTolerance' has a wrong offset!");
static_assert(offsetof(ABaseItem, MeleeUserCameraShake) == 0x000990, "Member 'ABaseItem::MeleeUserCameraShake' has a wrong offset!");
static_assert(offsetof(ABaseItem, bADSCountsAsAbuse) == 0x000998, "Member 'ABaseItem::bADSCountsAsAbuse' has a wrong offset!");
static_assert(offsetof(ABaseItem, HesitationBoostMultiplier) == 0x00099C, "Member 'ABaseItem::HesitationBoostMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseItem, bIsAimingDownSights) == 0x0009A0, "Member 'ABaseItem::bIsAimingDownSights' has a wrong offset!");
static_assert(offsetof(ABaseItem, LowReadyPitchThreshold) == 0x0009A4, "Member 'ABaseItem::LowReadyPitchThreshold' has a wrong offset!");
static_assert(offsetof(ABaseItem, SoundData) == 0x0009A8, "Member 'ABaseItem::SoundData' has a wrong offset!");
static_assert(offsetof(ABaseItem, bOverrideBreathingEvent) == 0x0009B0, "Member 'ABaseItem::bOverrideBreathingEvent' has a wrong offset!");
static_assert(offsetof(ABaseItem, BreathingAudioOverride) == 0x0009B8, "Member 'ABaseItem::BreathingAudioOverride' has a wrong offset!");
static_assert(offsetof(ABaseItem, bEasyPickup) == 0x0009C0, "Member 'ABaseItem::bEasyPickup' has a wrong offset!");
static_assert(offsetof(ABaseItem, bNoPickup) == 0x0009C1, "Member 'ABaseItem::bNoPickup' has a wrong offset!");
static_assert(offsetof(ABaseItem, bScriptedFPHidden) == 0x0009C2, "Member 'ABaseItem::bScriptedFPHidden' has a wrong offset!");
static_assert(offsetof(ABaseItem, ActiveMotionBlock) == 0x0009C3, "Member 'ABaseItem::ActiveMotionBlock' has a wrong offset!");
static_assert(offsetof(ABaseItem, bIsOneHandedItem) == 0x0009C4, "Member 'ABaseItem::bIsOneHandedItem' has a wrong offset!");
static_assert(offsetof(ABaseItem, FP_ADS_Motion_Weight) == 0x0009C8, "Member 'ABaseItem::FP_ADS_Motion_Weight' has a wrong offset!");

// Class ReadyOrNot.Tool
// 0x0020 (0x09F0 - 0x09D0)
#pragma pack(push, 0x1)
class alignas(0x10) ATool : public ABaseItem
{
public:
	float                                         MaxOperatingTime;                                  // 0x09D0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentOperatingTime;                              // 0x09D4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bOperating : 1;                                    // 0x09D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_21DD[0x7];                                     // 0x09D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x09E0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Client_FinishedToolUse(class AActor* Target, class APlayerCharacter* PC);
	void Client_StopToolAnimation();
	void Server_StartUsingTool(class AActor* Target);
	void Server_StopUsingTool(class AActor* Target);
	void Server_ToolComplete();
	void StartUsingTool(class AActor* Target);
	void StopUsingTool(class AActor* Target);

	float GetCurrentOperatingTime() const;
	float GetMaxOperatingTime() const;
	bool IsOperating() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tool">();
	}
	static class ATool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATool>();
	}
};
#pragma pack(pop)
static_assert(alignof(ATool) == 0x000010, "Wrong alignment on ATool");
static_assert(sizeof(ATool) == 0x0009F0, "Wrong size on ATool");
static_assert(offsetof(ATool, MaxOperatingTime) == 0x0009D0, "Member 'ATool::MaxOperatingTime' has a wrong offset!");
static_assert(offsetof(ATool, CurrentOperatingTime) == 0x0009D4, "Member 'ATool::CurrentOperatingTime' has a wrong offset!");
static_assert(offsetof(ATool, TargetActor) == 0x0009E0, "Member 'ATool::TargetActor' has a wrong offset!");

// Class ReadyOrNot.SoundSourceAnimNotify
// 0x0020 (0x0058 - 0x0038)
class USoundSourceAnimNotify final  : public UAnimNotify
{
public:
	uint8                                         bFollow : 1;                                       // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21DE[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AttachName;                                        // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             Event;                                             // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundSourceAnimNotify">();
	}
	static class USoundSourceAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundSourceAnimNotify>();
	}
};
static_assert(alignof(USoundSourceAnimNotify) == 0x000008, "Wrong alignment on USoundSourceAnimNotify");
static_assert(sizeof(USoundSourceAnimNotify) == 0x000058, "Wrong size on USoundSourceAnimNotify");
static_assert(offsetof(USoundSourceAnimNotify, AttachName) == 0x000040, "Member 'USoundSourceAnimNotify::AttachName' has a wrong offset!");
static_assert(offsetof(USoundSourceAnimNotify, Event) == 0x000050, "Member 'USoundSourceAnimNotify::Event' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_EquipLastItem
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_EquipLastItem final  : public UAnimNotify
{
public:
	uint8                                         bInstant : 1;                                      // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_21DF[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EquipLastItem">();
	}
	static class UAnimNotify_EquipLastItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EquipLastItem>();
	}
};
static_assert(alignof(UAnimNotify_EquipLastItem) == 0x000008, "Wrong alignment on UAnimNotify_EquipLastItem");
static_assert(sizeof(UAnimNotify_EquipLastItem) == 0x000040, "Wrong size on UAnimNotify_EquipLastItem");

// Class ReadyOrNot.AnimNotify_ForceFireWeapon
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_ForceFireWeapon final  : public UAnimNotify
{
public:
	float                                         Chance;                                            // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNoEnemyRequired;                                  // 0x003C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21E0[0x3];                                     // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ForceFireWeapon">();
	}
	static class UAnimNotify_ForceFireWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ForceFireWeapon>();
	}
};
static_assert(alignof(UAnimNotify_ForceFireWeapon) == 0x000008, "Wrong alignment on UAnimNotify_ForceFireWeapon");
static_assert(sizeof(UAnimNotify_ForceFireWeapon) == 0x000040, "Wrong size on UAnimNotify_ForceFireWeapon");
static_assert(offsetof(UAnimNotify_ForceFireWeapon, Chance) == 0x000038, "Member 'UAnimNotify_ForceFireWeapon::Chance' has a wrong offset!");
static_assert(offsetof(UAnimNotify_ForceFireWeapon, bNoEnemyRequired) == 0x00003C, "Member 'UAnimNotify_ForceFireWeapon::bNoEnemyRequired' has a wrong offset!");

// Class ReadyOrNot.PreMissionPlanning
// 0x0610 (0x0930 - 0x0320)
class UPreMissionPlanning : public UMenuWidget
{
public:
	bool                                          bIsWeaponCustomization;                            // 0x0320(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpenInQuartermaster;                              // 0x0321(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCustomizingPrimary;                             // 0x0322(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21E1[0x5];                                     // 0x0323(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseItem>                  CustomizeItemClass;                                // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotGameState*                   Gs;                                                // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotPlayerController*            PC;                                                // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotPlayerState*                 Ps;                                                // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelStreaming*                        PreMissionStreamedLevel;                           // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             LoadoutMusic;                                      // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21E2[0x10];                                    // 0x0358(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotPlayerState*                 PreviewPlayerState;                                // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21E3[0x2];                                     // 0x0370(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EEquippingSwat                                EquippingSwatMember;                               // 0x0372(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21E4[0x5];                                     // 0x0373(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EEquippingSwat, struct FSavedLoadout>    LastSavedLoadout;                                  // 0x0378(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_21E5[0x58];                                    // 0x03C8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLoadedLoadout;                                    // 0x0420(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21E6[0x7];                                     // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedLoadout                          ActiveLoadout;                                     // 0x0428(0x0188)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLoadoutPreset>      LoadoutPresetMap;                                  // 0x05B0(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	class AReadyOrNotPlayerState*                 EquippingPlayerState;                              // 0x0600(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseItem>, struct FSavedWeaponPreset> WeaponToWeaponPresetsMap;                          // 0x0608(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseItem>, struct FSavedWeaponAttachmentData> WeaponToAttachmentsMap;                            // 0x0658(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseWeapon>, EFireMode> WeaponClassToDefaultFireModeMap;                   // 0x06A8(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_21E7[0x4];                                     // 0x06F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActiveCameraTag;                                   // 0x06FC(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21E8[0x4];                                     // 0x0704(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRequestRefresh;                                  // 0x0708(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_21E9[0x8];                                     // 0x0718(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   RedTeamClass;                                      // 0x0720(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   BlueTeamClass;                                     // 0x0748(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   VIPClass;                                          // 0x0770(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21EA[0x8];                                     // 0x0798(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AReadyOrNotCharacter*, class AReadyOrNotPlayerState*> PlayerStatePreviewMap;                             // 0x07A0(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_21EB[0xD8];                                    // 0x07F0(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class ABaseItem*>           WorkBenchItemPtrMap;                               // 0x08C8(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EItemType                                     LastSetItemType;                                   // 0x0918(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemClass                                    LastSetItemClass;                                  // 0x0919(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21EC[0x6];                                     // 0x091A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseItem>                  LastSetItemObjectClass;                            // 0x0920(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21ED[0x1];                                     // 0x0928(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanUpdateWithUI;                                  // 0x0929(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21EE[0x6];                                     // 0x092A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPreMissionPlanning* GetPremissionPlanning();

	void AttachPrimaryToSocket(class FName Socket);
	void AttachSecondaryToSocket(class FName Socket);
	void CleanPrimaryGun();
	void CleanSecondaryGun();
	void ClearPreviewWeaponSkin(bool IsSecondary);
	void DoPrimaryWeaponPreviewBlend();
	void DoSaveLoadout(EEquippingSwat SwatMember, const struct FSavedLoadout& Loadout);
	void EquipPrimary();
	void EquipSecondary();
	TArray<TSubclassOf<class USkinComponent>> GetAvailablePlayerSkins();
	class AReadyOrNotCharacter* GetDefaultPreviewCharacter();
	void GetEquippingSwatMember(EEquippingSwat* EquippingSwat);
	bool GetInputLocked();
	struct FSavedWeaponAttachmentData GetItemAttachmentData(TSubclassOf<class ABaseItem> Weapon);
	TSubclassOf<class ABaseItem> GetLastItemInSlot(EItemType ItemType);
	EPreMissionSubCategory GetSubcategory();
	struct FWeaponPreset GetWeaponPresetData(TSubclassOf<class ABaseItem> Weapon, int32 Param_Index);
	struct FSavedWeaponPreset GetWeaponPresetsData(TSubclassOf<class ABaseItem> Weapon);
	void HidePrimary(bool bIsHidden);
	void HideSecondary(bool bIsHidden);
	void HideWeapons(bool bHidePrimary, bool bHideSecondary, float Delay);
	void Init(bool bReadOnly, const struct FSavedLoadout& PreviewLoadout);
	bool IsAnyWeaponVisible();
	bool IsInLobby();
	void LoadLoadoutPresets();
	void LoadWeaponAttachments();
	void LoadWeaponDefaultFireModes();
	void LoadWeaponPresets();
	void OnLoadoutItemAttachmentsLoaded();
	void OnLoadoutItemAttachmentsSaved();
	void OnLoadoutItemPresetsLoaded();
	void OnLoadoutItemPresetsSaved();
	void OnLoadoutLoaded();
	void OnLoadoutPresetsLoaded();
	void OnLoadoutPresetsSaved();
	void OnLoadoutSaved();
	void OnRequestRefresh__DelegateSignature();
	void OnSwatCharacterChanged();
	void OnWeaponDefaultFireModesLoaded();
	void PlayAnimationOnPreviewCharacter(const class FString& Animation);
	void PlayAnimationOnQuartermaster(const class FString& Animation);
	void SaveActiveLoadout();
	void SaveItemClassAsSlot(EItemType ItemType, TSubclassOf<class ABaseItem> Param_Class);
	void SaveLoadoutPresets();
	void SaveWeaponAttachments();
	void SaveWeaponDefaultFireMode();
	void SaveWeaponPresets();
	void SetActiveCameraByTag(class FName Tag, float BlendTime);
	void SetBodyArmour(TSubclassOf<class ABaseItem> BodyArmour);
	void SetEquippingSwatMember(EEquippingSwat NewEquippingSwat, class AReadyOrNotPlayerState* NewEquippingPlayerState);
	void SetHeadwear(TSubclassOf<class ABaseItem> Headwear);
	void SetItem(EItemType ItemType, TSubclassOf<class ABaseItem> ItemClass);
	void SetItem_V2(EItemClass ItemClass, TSubclassOf<class ABaseItem> ItemObjectClass);
	void SetLightColorByTag(class FName Tag, const struct FLinearColor& Color);
	void SetLockInput(bool bShouldLockInput);
	void SetLongTactical(TSubclassOf<class ABaseItem> LongTactical);
	void SetPlayerSkin(TSubclassOf<class USkinComponent> SkinCompClass);
	void SetPrimaryAmmunitionAttachment(TSubclassOf<class UWeaponAttachment> AmmunitionAttachment);
	void SetPrimaryGripAttachment(TSubclassOf<class UWeaponAttachment> GripAttachment);
	void SetPrimaryIlluminatorAttachment(TSubclassOf<class UWeaponAttachment> IlluminatorAttachment);
	void SetPrimaryMuzzleAttachment(TSubclassOf<class UWeaponAttachment> MuzzleAttachment);
	void SetPrimaryOverbarrelAttachment(TSubclassOf<class UWeaponAttachment> OverbarrelAttachment);
	void SetPrimaryScopeAttachment(TSubclassOf<class UWeaponAttachment> ScopeAttachment);
	void SetPrimarySkinAttachment(TSubclassOf<class USkinComponent> SkinAttachment);
	void SetPrimaryStockAttachment(TSubclassOf<class UWeaponAttachment> StockAttachment);
	void SetPrimaryUnderbarrelAttachment(TSubclassOf<class UWeaponAttachment> UnderbarrelAttachment);
	void SetPrimaryWeapon(const struct FWeaponData& WeaponData);
	void SetSecondaryAmmunitionAttachment(TSubclassOf<class UWeaponAttachment> AmmunitionAttachment);
	void SetSecondaryGripAttachment(TSubclassOf<class UWeaponAttachment> GripAttachment);
	void SetSecondaryIlluminatorAttachment(TSubclassOf<class UWeaponAttachment> IlluminatorAttachment);
	void SetSecondaryMuzzleAttachment(TSubclassOf<class UWeaponAttachment> MuzzleAttachment);
	void SetSecondaryOverbarrelAttachment(TSubclassOf<class UWeaponAttachment> OverbarrelAttachment);
	void SetSecondaryScopeAttachment(TSubclassOf<class UWeaponAttachment> ScopeAttachment);
	void SetSecondarySkinAttachment(TSubclassOf<class USkinComponent> SkinAttachment);
	void SetSecondaryStockAttachment(TSubclassOf<class UWeaponAttachment> StockAttachment);
	void SetSecondaryUnderbarrelAttachment(TSubclassOf<class UWeaponAttachment> UnderbarrelAttachment);
	void SetSecondaryWeapon(const struct FWeaponData& WeaponData);
	void SetSubcategory(EPreMissionSubCategory NewSubCategory);
	void SetWorkbenchItemClass(TSubclassOf<class ABaseItem> Item, class FName Tag);
	void UpdatePreviewCharacter(class AReadyOrNotPlayerState* InPreviewPlayerState, class FName Tag);
	void UpdatePreviewCharacterArmour();
	void UpdatePreviewCharacterHeadwear();
	void UpdatePreviewCharacterLongTactical();
	void UpdatePreviewCharacterPrimary();
	void UpdatePreviewCharacterSecondary();
	void UpdatePreviewWeaponAttachments(bool IsSecondary, TSubclassOf<class UWeaponAttachment> Attachment);
	void UpdatePreviewWeaponSkin(bool IsSecondary, TSubclassOf<class USkinComponent> SkinAttachment);
	void UpdateWeaponDefaultFireMode(TSubclassOf<class ABaseWeapon> Weapon, EFireMode NewDefaultFireMode);
	void UpdateWeaponPreset(TSubclassOf<class ABaseItem> Weapon, const struct FWeaponPreset& PresetData, int32 Param_Index);
	void UpdateWeaponPresets(TSubclassOf<class ABaseItem> Weapon, const struct FSavedWeaponPreset& Presets);
	void UpdateWorkbenchItemAttachments();

	EItemType ItemClassToItemType(EItemClass InItemClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreMissionPlanning">();
	}
	static class UPreMissionPlanning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreMissionPlanning>();
	}
};
static_assert(alignof(UPreMissionPlanning) == 0x000008, "Wrong alignment on UPreMissionPlanning");
static_assert(sizeof(UPreMissionPlanning) == 0x000930, "Wrong size on UPreMissionPlanning");
static_assert(offsetof(UPreMissionPlanning, bIsWeaponCustomization) == 0x000320, "Member 'UPreMissionPlanning::bIsWeaponCustomization' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, bOpenInQuartermaster) == 0x000321, "Member 'UPreMissionPlanning::bOpenInQuartermaster' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, bIsCustomizingPrimary) == 0x000322, "Member 'UPreMissionPlanning::bIsCustomizingPrimary' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, CustomizeItemClass) == 0x000328, "Member 'UPreMissionPlanning::CustomizeItemClass' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, Gs) == 0x000330, "Member 'UPreMissionPlanning::Gs' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, PC) == 0x000338, "Member 'UPreMissionPlanning::PC' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, Ps) == 0x000340, "Member 'UPreMissionPlanning::Ps' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, PreMissionStreamedLevel) == 0x000348, "Member 'UPreMissionPlanning::PreMissionStreamedLevel' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, LoadoutMusic) == 0x000350, "Member 'UPreMissionPlanning::LoadoutMusic' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, PreviewPlayerState) == 0x000368, "Member 'UPreMissionPlanning::PreviewPlayerState' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, EquippingSwatMember) == 0x000372, "Member 'UPreMissionPlanning::EquippingSwatMember' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, LastSavedLoadout) == 0x000378, "Member 'UPreMissionPlanning::LastSavedLoadout' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, bLoadedLoadout) == 0x000420, "Member 'UPreMissionPlanning::bLoadedLoadout' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, ActiveLoadout) == 0x000428, "Member 'UPreMissionPlanning::ActiveLoadout' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, LoadoutPresetMap) == 0x0005B0, "Member 'UPreMissionPlanning::LoadoutPresetMap' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, EquippingPlayerState) == 0x000600, "Member 'UPreMissionPlanning::EquippingPlayerState' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, WeaponToWeaponPresetsMap) == 0x000608, "Member 'UPreMissionPlanning::WeaponToWeaponPresetsMap' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, WeaponToAttachmentsMap) == 0x000658, "Member 'UPreMissionPlanning::WeaponToAttachmentsMap' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, WeaponClassToDefaultFireModeMap) == 0x0006A8, "Member 'UPreMissionPlanning::WeaponClassToDefaultFireModeMap' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, ActiveCameraTag) == 0x0006FC, "Member 'UPreMissionPlanning::ActiveCameraTag' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, OnRequestRefresh) == 0x000708, "Member 'UPreMissionPlanning::OnRequestRefresh' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, RedTeamClass) == 0x000720, "Member 'UPreMissionPlanning::RedTeamClass' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, BlueTeamClass) == 0x000748, "Member 'UPreMissionPlanning::BlueTeamClass' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, VIPClass) == 0x000770, "Member 'UPreMissionPlanning::VIPClass' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, PlayerStatePreviewMap) == 0x0007A0, "Member 'UPreMissionPlanning::PlayerStatePreviewMap' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, WorkBenchItemPtrMap) == 0x0008C8, "Member 'UPreMissionPlanning::WorkBenchItemPtrMap' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, LastSetItemType) == 0x000918, "Member 'UPreMissionPlanning::LastSetItemType' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, LastSetItemClass) == 0x000919, "Member 'UPreMissionPlanning::LastSetItemClass' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, LastSetItemObjectClass) == 0x000920, "Member 'UPreMissionPlanning::LastSetItemObjectClass' has a wrong offset!");
static_assert(offsetof(UPreMissionPlanning, bCanUpdateWithUI) == 0x000929, "Member 'UPreMissionPlanning::bCanUpdateWithUI' has a wrong offset!");

// Class ReadyOrNot.LoadoutWidget
// 0x01D0 (0x0B00 - 0x0930)
class ULoadoutWidget final  : public UPreMissionPlanning
{
public:
	TSubclassOf<class UUserWidget>                HUDWidgetClass;                                    // 0x0930(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULoadoutUnitSelectWidget*               WLoadoutCharacterSelect;                           // 0x0938(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULoadoutOverviewWidget*                 WLoadoutOverview;                                  // 0x0940(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULoadoutVerticalItemListWidget*         VerticalItemList;                                  // 0x0948(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULoadoutInformationTableWidget*         InfoPanel;                                         // 0x0950(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EItemCategory, class FName>              CategoryCameraTags;                                // 0x0958(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<EItemCategory, class FString>            CategoryPoses;                                     // 0x09A8(0x0050)(Edit, NativeAccessSpecifierPrivate)
	class FString                                 PrimaryDrawAnim;                                   // 0x09F8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SidearmDrawAnim;                                   // 0x0A08(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 PrimaryHolsterAnim;                                // 0x0A18(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SidearmHolsterAnim;                                // 0x0A28(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             WeaponHolsteredSound;                              // 0x0A38(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21FC[0xC0];                                    // 0x0A40(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ULoadoutWidget* GetLoadoutWidget();

	void ApplyLoadoutPreset(const struct FLoadoutPreset& LoadoutPreset);
	void AttachmentClicked(class ULoadoutSlotAttachmentWidget* AttachmentSlot);
	void AttachmentHovered(class ULoadoutSlotAttachmentWidget* AttachmentSlot);
	void AttachmentUnhovered(class ULoadoutSlotAttachmentWidget* AttachmentSlot);
	void CheckPreset();
	void CleanCurrentWeapon();
	void ClearPreset();
	void CloseLoadout();
	void DeleteLoadoutPreset(class UUserWidget* TriggeringModal, class FText TextEntry);
	void DeselectAttachmentSlot();
	void DeselectLoadoutSlot();
	void DoItemUnhover();
	void EquipArmor(class ABaseItem* ItemData);
	void EquipArmourMaterial(class UArmourMaterial* ArmourMaterial);
	void EquipAttachment(class ABaseItem* AttachingWeapon, class UWeaponAttachment* AttachmentData);
	void EquipGrenades(TArray<class ABaseItem*>& ItemData);
	void EquipHeadwear(class ABaseItem* ItemData);
	void EquipItem(class ABaseItem* ItemData);
	void EquipLongTactical(class ABaseItem* ItemData);
	void EquipPrimaryAmmo(TArray<class FName>& PrimaryAmmo);
	void EquipPrimaryAttachments(EWeaponAttachmentType AttachmentType, class UWeaponAttachment* AttachmentData, class ABaseItem* AttachingWeapon);
	void EquipSidearmAmmo(TArray<class FName>& SidearmAmmo);
	void EquipSidearmAttachments(EWeaponAttachmentType AttachmentType, class UWeaponAttachment* AttachmentData, class ABaseItem* AttachingWeapon);
	void EquipTactical(TArray<class ABaseItem*>& ItemData);
	void GoBack();
	void HideHUD();
	void HideItemInfoPanel();
	void HideItemList();
	bool HolsterPreviewCharacterWeapon();
	void InitializeAttachmentSelectionPanel(class ULoadoutSlotWidget* TriggeringSlot);
	void InitializeItemSelectionPanel(class ULoadoutSlotWidget* TriggeringSlot);
	void InitializeItemSelectionRemote(class ULoadoutSlotWidget* TriggeringSlot);
	void InitializeOverview();
	void InitializeQuartermaster();
	void InitializeWeaponAttachmentMap();
	bool IsNullAttachment(TSubclassOf<class UWeaponAttachment> Attachment);
	void ItemClicked(class ULoadoutSlotWidget* TriggeringSlot);
	void ItemHovered(class ULoadoutSlotWidget* TriggeringSlot);
	void ItemUnhovered(class ULoadoutSlotWidget* TriggeringSlot);
	void LoadDefaultLoadout();
	void LookAtAttachmentSlot(EWeaponAttachmentType AttachmentSlot);
	void OpenAmmoList(bool bVerticalList, class FName ExcludedAmmoType, TSubclassOf<class ABaseItem> Weapon);
	void OpenArmorQuartermaster(class ABaseItem* ItemToModify);
	void OpenArmourMaterialList(bool bVerticalList);
	void OpenAttachmentList(bool bVerticalList, TSubclassOf<class ABaseItem> ItemData, EWeaponAttachmentType AttachmentType);
	void OpenDeployableList(bool bVerticalList, EItemCategory LoadoutSlot, TArray<struct ReadyOrNot::FLoadoutCategory>& GearCategoryClasses, TArray<TSubclassOf<class ABaseItem>>& ExcludedItems);
	void OpenItemList(bool bVerticalList, EItemCategory LoadoutSlot, TArray<struct ReadyOrNot::FLoadoutCategory>& GearCategoryClasses);
	void OpenLoadoutPresetModal(const class FString& CurrentPreset, bool bDelete);
	void OpenWeaponQuartermaster(class ABaseItem* ItemToModify);
	void PlaySetPreMissionCameraAnimation();
	void PrimaryChanged();
	void RefreshAttachmentInfoPanel(class ULoadoutSlotWidget* LoadoutSlot);
	void RefreshItemInfoPanel(class ULoadoutSlotWidget* LoadoutSlot);
	void SaveActiveLoadoutOld();
	void SaveArmorCoverage(EArmourCoverage ArmourCoverage);
	void SaveGrenadeSlotCount(int32 GrenadeSlotsCount);
	void SaveLoadoutPreset(class UUserWidget* TriggeringModal, class FText TextEntry);
	void SavePrimaryAmmoSlotCount(int32 PrimaryAmmoSlotCount);
	void SaveSidearmAmmoSlotCount(int32 SidearmAmmoSlotCount);
	void SaveTacticalSlotcount(int32 TacticalSlotsCount);
	void SaveWeaponPreset(class UUserWidget* TriggeringModal, class FText TextEntry);
	void SetActiveLoadout(const class FString& LoadoutName, class AReadyOrNotPlayerState* RoNPlayerState, EEquippingSwat EquippingUnit);
	void SetActiveQuartermasterSlot();
	void SetPreMissionCamera(class FName Tag, const class FString& Animation, float BlendTime);
	void SetPreMissionCameraBySlot(EItemCategory LoadoutSlot, float BlendTime);
	void SetPresetModified(bool bPresetDirty);
	void SetupBindings();
	void SetupWorkbenchCamera();
	void ShowHUD();
	void ShowItemInfoPanel(class ULoadoutSlotWidget* LoadoutSlot);
	void ShowToolTip(const struct FLevelDataLookupTable& MissionDetails);
	void SidearmChanged();
	void UpdateAllPreviewWeaponAttachments(bool bIsWorkbench, TSubclassOf<class ABaseItem> Weapon, bool bIsSidearm);
	void UpdateCurrentItem();
	void UpdateHUDStates();
	void UpdatePreview(EItemCategory Selection);
	void UpdateWorkbenchCameraRotation(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutWidget">();
	}
	static class ULoadoutWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutWidget>();
	}
};
static_assert(alignof(ULoadoutWidget) == 0x000008, "Wrong alignment on ULoadoutWidget");
static_assert(sizeof(ULoadoutWidget) == 0x000B00, "Wrong size on ULoadoutWidget");
static_assert(offsetof(ULoadoutWidget, HUDWidgetClass) == 0x000930, "Member 'ULoadoutWidget::HUDWidgetClass' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, WLoadoutCharacterSelect) == 0x000938, "Member 'ULoadoutWidget::WLoadoutCharacterSelect' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, WLoadoutOverview) == 0x000940, "Member 'ULoadoutWidget::WLoadoutOverview' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, VerticalItemList) == 0x000948, "Member 'ULoadoutWidget::VerticalItemList' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, InfoPanel) == 0x000950, "Member 'ULoadoutWidget::InfoPanel' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, CategoryCameraTags) == 0x000958, "Member 'ULoadoutWidget::CategoryCameraTags' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, CategoryPoses) == 0x0009A8, "Member 'ULoadoutWidget::CategoryPoses' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, PrimaryDrawAnim) == 0x0009F8, "Member 'ULoadoutWidget::PrimaryDrawAnim' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, SidearmDrawAnim) == 0x000A08, "Member 'ULoadoutWidget::SidearmDrawAnim' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, PrimaryHolsterAnim) == 0x000A18, "Member 'ULoadoutWidget::PrimaryHolsterAnim' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, SidearmHolsterAnim) == 0x000A28, "Member 'ULoadoutWidget::SidearmHolsterAnim' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, WeaponHolsteredSound) == 0x000A38, "Member 'ULoadoutWidget::WeaponHolsteredSound' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_ForceRagdoll
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_ForceRagdoll final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ForceRagdoll">();
	}
	static class UAnimNotify_ForceRagdoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ForceRagdoll>();
	}
};
static_assert(alignof(UAnimNotify_ForceRagdoll) == 0x000008, "Wrong alignment on UAnimNotify_ForceRagdoll");
static_assert(sizeof(UAnimNotify_ForceRagdoll) == 0x000038, "Wrong size on UAnimNotify_ForceRagdoll");

// Class ReadyOrNot.AnimNotify_GetupComplete
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_GetupComplete final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_GetupComplete">();
	}
	static class UAnimNotify_GetupComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GetupComplete>();
	}
};
static_assert(alignof(UAnimNotify_GetupComplete) == 0x000008, "Wrong alignment on UAnimNotify_GetupComplete");
static_assert(sizeof(UAnimNotify_GetupComplete) == 0x000038, "Wrong size on UAnimNotify_GetupComplete");

// Class ReadyOrNot.MagazineAttachment
// 0x0010 (0x1010 - 0x1000)
class UMagazineAttachment : public UWeaponAttachment
{
public:
	class UStaticMesh*                            MagazineStaticMesh;                                // 0x0FF8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket_01;                                         // 0x1000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket_02;                                         // 0x1008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagazineAttachment">();
	}
	static class UMagazineAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagazineAttachment>();
	}
};
static_assert(alignof(UMagazineAttachment) == 0x000010, "Wrong alignment on UMagazineAttachment");
static_assert(sizeof(UMagazineAttachment) == 0x001010, "Wrong size on UMagazineAttachment");
static_assert(offsetof(UMagazineAttachment, MagazineStaticMesh) == 0x000FF8, "Member 'UMagazineAttachment::MagazineStaticMesh' has a wrong offset!");
static_assert(offsetof(UMagazineAttachment, Socket_01) == 0x001000, "Member 'UMagazineAttachment::Socket_01' has a wrong offset!");
static_assert(offsetof(UMagazineAttachment, Socket_02) == 0x001008, "Member 'UMagazineAttachment::Socket_02' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_ItemSwitchSocket
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_ItemSwitchSocket final  : public UAnimNotify
{
public:
	EItemSocket                                   DesiredItemSocket;                                 // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220C[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ItemSwitchSocket">();
	}
	static class UAnimNotify_ItemSwitchSocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ItemSwitchSocket>();
	}
};
static_assert(alignof(UAnimNotify_ItemSwitchSocket) == 0x000008, "Wrong alignment on UAnimNotify_ItemSwitchSocket");
static_assert(sizeof(UAnimNotify_ItemSwitchSocket) == 0x000040, "Wrong size on UAnimNotify_ItemSwitchSocket");
static_assert(offsetof(UAnimNotify_ItemSwitchSocket, DesiredItemSocket) == 0x000038, "Member 'UAnimNotify_ItemSwitchSocket::DesiredItemSocket' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_KillMyself
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_KillMyself final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_KillMyself">();
	}
	static class UAnimNotify_KillMyself* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_KillMyself>();
	}
};
static_assert(alignof(UAnimNotify_KillMyself) == 0x000008, "Wrong alignment on UAnimNotify_KillMyself");
static_assert(sizeof(UAnimNotify_KillMyself) == 0x000038, "Wrong size on UAnimNotify_KillMyself");

// Class ReadyOrNot.ScanDoorActivity
// 0x0078 (0x0220 - 0x01A8)
class UScanDoorActivity final  : public UBaseActivity
{
public:
	class ADoor*                                  Door;                                              // 0x01A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_220D[0x20];                                    // 0x01B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACyberneticCharacter*>           SpottedCharacters;                                 // 0x01D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ATrapActorAttachedToDoor*               SpottedTrap;                                       // 0x01E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_220E[0x38];                                    // 0x01E8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterCompleteStage();
	void EnterMoveToStage();
	void EnterScanStage();
	void TickCompleteStage(float DeltaTime, float Uptime);
	void TickMoveToStage(float DeltaTime, float Uptime);
	void TickScanStage(float DeltaTime, float Uptime);

	bool CanStartScanning() const;
	bool IsScanComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScanDoorActivity">();
	}
	static class UScanDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScanDoorActivity>();
	}
};
static_assert(alignof(UScanDoorActivity) == 0x000008, "Wrong alignment on UScanDoorActivity");
static_assert(sizeof(UScanDoorActivity) == 0x000220, "Wrong size on UScanDoorActivity");
static_assert(offsetof(UScanDoorActivity, Door) == 0x0001A8, "Member 'UScanDoorActivity::Door' has a wrong offset!");
static_assert(offsetof(UScanDoorActivity, SpottedCharacters) == 0x0001D0, "Member 'UScanDoorActivity::SpottedCharacters' has a wrong offset!");
static_assert(offsetof(UScanDoorActivity, SpottedTrap) == 0x0001E0, "Member 'UScanDoorActivity::SpottedTrap' has a wrong offset!");

// Class ReadyOrNot.Referendum
// 0x0088 (0x02A8 - 0x0220)
class AReferendum : public AActor
{
public:
	class FText                                   ReferendumName;                                    // 0x0220(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ReferendumDescription;                             // 0x0238(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         ReferendumTime;                                    // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReferendumHoldingTime;                             // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YesVotes;                                          // 0x0258(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NoVotes;                                           // 0x025C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReferendumTimeRemaining;                           // 0x0260(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReferendumHoldingTimeRemaining;                    // 0x0264(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReferendumRunning;                                // 0x0268(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReferendumWaitingToTakeEffect;                    // 0x0269(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_220F[0x6];                                     // 0x026A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotPlayerState*                 ReferendumCaller;                                  // 0x0270(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotPlayerController*>    YesVoters;                                         // 0x0278(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotPlayerController*>    NoVoters;                                          // 0x0288(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotPlayerController*>    EligibleVoters;                                    // 0x0298(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void CastedNoVote(class AReadyOrNotPlayerController* Voter);
	void CastedYesVote(class AReadyOrNotPlayerController* Voter);
	class FText GetHudDescription();
	void Multicast_AnnounceNoVote(class AReadyOrNotPlayerState* Voter);
	void Multicast_AnnounceVoteFailed();
	void Multicast_AnnounceVotePassed();
	void Multicast_AnnounceVoteStarted(class AReadyOrNotPlayerState* CallingVoter);
	void Multicast_AnnounceYesVote(class AReadyOrNotPlayerState* Voter);
	void OnAnnounceNoVote(class AReadyOrNotPlayerState* Voter);
	void OnAnnounceVoteFailed();
	void OnAnnounceVotePassed();
	void OnAnnounceVoteStarted(class AReadyOrNotPlayerState* CallingVoter);
	void OnAnnounceYesVote(class AReadyOrNotPlayerState* Voter);
	void OnReferendumPassed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Referendum">();
	}
	static class AReferendum* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReferendum>();
	}
};
static_assert(alignof(AReferendum) == 0x000008, "Wrong alignment on AReferendum");
static_assert(sizeof(AReferendum) == 0x0002A8, "Wrong size on AReferendum");
static_assert(offsetof(AReferendum, ReferendumName) == 0x000220, "Member 'AReferendum::ReferendumName' has a wrong offset!");
static_assert(offsetof(AReferendum, ReferendumDescription) == 0x000238, "Member 'AReferendum::ReferendumDescription' has a wrong offset!");
static_assert(offsetof(AReferendum, ReferendumTime) == 0x000250, "Member 'AReferendum::ReferendumTime' has a wrong offset!");
static_assert(offsetof(AReferendum, ReferendumHoldingTime) == 0x000254, "Member 'AReferendum::ReferendumHoldingTime' has a wrong offset!");
static_assert(offsetof(AReferendum, YesVotes) == 0x000258, "Member 'AReferendum::YesVotes' has a wrong offset!");
static_assert(offsetof(AReferendum, NoVotes) == 0x00025C, "Member 'AReferendum::NoVotes' has a wrong offset!");
static_assert(offsetof(AReferendum, ReferendumTimeRemaining) == 0x000260, "Member 'AReferendum::ReferendumTimeRemaining' has a wrong offset!");
static_assert(offsetof(AReferendum, ReferendumHoldingTimeRemaining) == 0x000264, "Member 'AReferendum::ReferendumHoldingTimeRemaining' has a wrong offset!");
static_assert(offsetof(AReferendum, bReferendumRunning) == 0x000268, "Member 'AReferendum::bReferendumRunning' has a wrong offset!");
static_assert(offsetof(AReferendum, bReferendumWaitingToTakeEffect) == 0x000269, "Member 'AReferendum::bReferendumWaitingToTakeEffect' has a wrong offset!");
static_assert(offsetof(AReferendum, ReferendumCaller) == 0x000270, "Member 'AReferendum::ReferendumCaller' has a wrong offset!");
static_assert(offsetof(AReferendum, YesVoters) == 0x000278, "Member 'AReferendum::YesVoters' has a wrong offset!");
static_assert(offsetof(AReferendum, NoVoters) == 0x000288, "Member 'AReferendum::NoVoters' has a wrong offset!");
static_assert(offsetof(AReferendum, EligibleVoters) == 0x000298, "Member 'AReferendum::EligibleVoters' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_LockPickDoor
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_LockPickDoor final  : public UAnimNotify
{
public:
	uint8                                         bLockPickFinished : 1;                             // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2210[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_LockPickDoor">();
	}
	static class UAnimNotify_LockPickDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_LockPickDoor>();
	}
};
static_assert(alignof(UAnimNotify_LockPickDoor) == 0x000008, "Wrong alignment on UAnimNotify_LockPickDoor");
static_assert(sizeof(UAnimNotify_LockPickDoor) == 0x000040, "Wrong size on UAnimNotify_LockPickDoor");

// Class ReadyOrNot.AnimNotify_MirrorDoor
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_MirrorDoor final  : public UAnimNotify
{
public:
	uint8                                         bMirrorFinish : 1;                                 // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2211[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_MirrorDoor">();
	}
	static class UAnimNotify_MirrorDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_MirrorDoor>();
	}
};
static_assert(alignof(UAnimNotify_MirrorDoor) == 0x000008, "Wrong alignment on UAnimNotify_MirrorDoor");
static_assert(sizeof(UAnimNotify_MirrorDoor) == 0x000040, "Wrong size on UAnimNotify_MirrorDoor");

// Class ReadyOrNot.MainMenu_V3
// 0x0090 (0x03B0 - 0x0320)
class UMainMenu_V3 : public UCommonActivatableWidget
{
public:
	TMap<ReadyOrNot::ELoginState, class FText>    BackendConnectionStatus;                           // 0x0320(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         bEnableFindSessionCOOPButton : 1;                  // 0x0370(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableFindSessionPVPButton : 1;                   // 0x0370(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2212[0x3F];                                    // 0x0371(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseModMenu();
	void DisableMainMenuInputPreprocessor();
	void EnableMainMenuInputPreprocessor();
	void HideModMenu();
	bool IsModUpdating();
	void OnModMenuClosed();
	void OnModMenuClosedDuringUpdate();
	bool OpenModMenu(class APlayerController* PlayerController);
	bool ShouldShowModsButton();
	bool ShouldShowRestartDialog();

	bool CanFindSession(bool bCOOP) const;
	bool CanPlayPublicLobby() const;
	class FText GetBackEndConnectionStatus(ReadyOrNot::ELoginState LoginState) const;
	class FText GetPublicLobbyCooldown() const;
	bool IsLoggedIn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenu_V3">();
	}
	static class UMainMenu_V3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenu_V3>();
	}
};
static_assert(alignof(UMainMenu_V3) == 0x000008, "Wrong alignment on UMainMenu_V3");
static_assert(sizeof(UMainMenu_V3) == 0x0003B0, "Wrong size on UMainMenu_V3");
static_assert(offsetof(UMainMenu_V3, BackendConnectionStatus) == 0x000320, "Member 'UMainMenu_V3::BackendConnectionStatus' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_NextMag
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_NextMag final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_NextMag">();
	}
	static class UAnimNotify_NextMag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_NextMag>();
	}
};
static_assert(alignof(UAnimNotify_NextMag) == 0x000008, "Wrong alignment on UAnimNotify_NextMag");
static_assert(sizeof(UAnimNotify_NextMag) == 0x000038, "Wrong size on UAnimNotify_NextMag");

// Class ReadyOrNot.AnimNotify_OnCheckedDoor
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_OnCheckedDoor final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_OnCheckedDoor">();
	}
	static class UAnimNotify_OnCheckedDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_OnCheckedDoor>();
	}
};
static_assert(alignof(UAnimNotify_OnCheckedDoor) == 0x000008, "Wrong alignment on UAnimNotify_OnCheckedDoor");
static_assert(sizeof(UAnimNotify_OnCheckedDoor) == 0x000038, "Wrong size on UAnimNotify_OnCheckedDoor");

// Class ReadyOrNot.LookupData
// 0x00C8 (0x00F8 - 0x0030)
class ULookupData final  : public UDataAsset
{
public:
	bool                                          bToggleToDoAssetUpdate;                            // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2215[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           Items;                                             // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UClass>>           Weapons;                                           // 0x0048(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UClass>>           Armour;                                            // 0x0058(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UClass>>           Grenades;                                          // 0x0068(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UClass>>           Shells;                                            // 0x0078(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UClass>>           Projectiles;                                       // 0x0088(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UClass>>           Characters;                                        // 0x0098(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UClass>>           AI;                                                // 0x00A8(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bAddSelectedBlueprintToItemData;                   // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2216[0x7];                                     // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ABaseItem>>          biClassArray;                                      // 0x00C0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UDataTable*                             ItemDataLookupTable;                               // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bToggleForceLevelDataTable;                        // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2217[0x7];                                     // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             LevelDataLookupTable;                              // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bToggleForceAIData;                                // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2218[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             AIDataLookupTable;                                 // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void EmptyData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookupData">();
	}
	static class ULookupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookupData>();
	}
};
static_assert(alignof(ULookupData) == 0x000008, "Wrong alignment on ULookupData");
static_assert(sizeof(ULookupData) == 0x0000F8, "Wrong size on ULookupData");
static_assert(offsetof(ULookupData, bToggleToDoAssetUpdate) == 0x000030, "Member 'ULookupData::bToggleToDoAssetUpdate' has a wrong offset!");
static_assert(offsetof(ULookupData, Items) == 0x000038, "Member 'ULookupData::Items' has a wrong offset!");
static_assert(offsetof(ULookupData, Weapons) == 0x000048, "Member 'ULookupData::Weapons' has a wrong offset!");
static_assert(offsetof(ULookupData, Armour) == 0x000058, "Member 'ULookupData::Armour' has a wrong offset!");
static_assert(offsetof(ULookupData, Grenades) == 0x000068, "Member 'ULookupData::Grenades' has a wrong offset!");
static_assert(offsetof(ULookupData, Shells) == 0x000078, "Member 'ULookupData::Shells' has a wrong offset!");
static_assert(offsetof(ULookupData, Projectiles) == 0x000088, "Member 'ULookupData::Projectiles' has a wrong offset!");
static_assert(offsetof(ULookupData, Characters) == 0x000098, "Member 'ULookupData::Characters' has a wrong offset!");
static_assert(offsetof(ULookupData, AI) == 0x0000A8, "Member 'ULookupData::AI' has a wrong offset!");
static_assert(offsetof(ULookupData, bAddSelectedBlueprintToItemData) == 0x0000B8, "Member 'ULookupData::bAddSelectedBlueprintToItemData' has a wrong offset!");
static_assert(offsetof(ULookupData, biClassArray) == 0x0000C0, "Member 'ULookupData::biClassArray' has a wrong offset!");
static_assert(offsetof(ULookupData, ItemDataLookupTable) == 0x0000D0, "Member 'ULookupData::ItemDataLookupTable' has a wrong offset!");
static_assert(offsetof(ULookupData, bToggleForceLevelDataTable) == 0x0000D8, "Member 'ULookupData::bToggleForceLevelDataTable' has a wrong offset!");
static_assert(offsetof(ULookupData, LevelDataLookupTable) == 0x0000E0, "Member 'ULookupData::LevelDataLookupTable' has a wrong offset!");
static_assert(offsetof(ULookupData, bToggleForceAIData) == 0x0000E8, "Member 'ULookupData::bToggleForceAIData' has a wrong offset!");
static_assert(offsetof(ULookupData, AIDataLookupTable) == 0x0000F0, "Member 'ULookupData::AIDataLookupTable' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_OnLandmarkProxyUse
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_OnLandmarkProxyUse final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_OnLandmarkProxyUse">();
	}
	static class UAnimNotify_OnLandmarkProxyUse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_OnLandmarkProxyUse>();
	}
};
static_assert(alignof(UAnimNotify_OnLandmarkProxyUse) == 0x000008, "Wrong alignment on UAnimNotify_OnLandmarkProxyUse");
static_assert(sizeof(UAnimNotify_OnLandmarkProxyUse) == 0x000038, "Wrong size on UAnimNotify_OnLandmarkProxyUse");

// Class ReadyOrNot.AnimNotify_PickupItemComplete
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_PickupItemComplete final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PickupItemComplete">();
	}
	static class UAnimNotify_PickupItemComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PickupItemComplete>();
	}
};
static_assert(alignof(UAnimNotify_PickupItemComplete) == 0x000008, "Wrong alignment on UAnimNotify_PickupItemComplete");
static_assert(sizeof(UAnimNotify_PickupItemComplete) == 0x000038, "Wrong size on UAnimNotify_PickupItemComplete");

// Class ReadyOrNot.MapActorWidget
// 0x0038 (0x02B0 - 0x0278)
class UMapActorWidget : public UBaseWidget
{
public:
	class UTextBlock*                             MapActor_Text;                                     // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ActorToTrack;                                      // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseActorRotation;                                 // 0x0288(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseLocation;                                      // 0x0289(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2219[0x2];                                     // 0x028A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationToTrack;                                   // 0x028C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationOffset;                                    // 0x0298(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapSize;                                           // 0x029C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapTextureSize;                                    // 0x02A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MapOrigin;                                         // 0x02A4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221A[0x4];                                     // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeWidget(class AActor* InActorToTrack, bool bInUseActorRotation, bool bInUseLocation, const struct FVector& InLocationToTrack, float InRotationOffset);
	void SetMapActorText(class FText InText);
	void SetMapActorTextColor(const struct FLinearColor& InTextColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorWidget">();
	}
	static class UMapActorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActorWidget>();
	}
};
static_assert(alignof(UMapActorWidget) == 0x000008, "Wrong alignment on UMapActorWidget");
static_assert(sizeof(UMapActorWidget) == 0x0002B0, "Wrong size on UMapActorWidget");
static_assert(offsetof(UMapActorWidget, MapActor_Text) == 0x000278, "Member 'UMapActorWidget::MapActor_Text' has a wrong offset!");
static_assert(offsetof(UMapActorWidget, ActorToTrack) == 0x000280, "Member 'UMapActorWidget::ActorToTrack' has a wrong offset!");
static_assert(offsetof(UMapActorWidget, bUseActorRotation) == 0x000288, "Member 'UMapActorWidget::bUseActorRotation' has a wrong offset!");
static_assert(offsetof(UMapActorWidget, bUseLocation) == 0x000289, "Member 'UMapActorWidget::bUseLocation' has a wrong offset!");
static_assert(offsetof(UMapActorWidget, LocationToTrack) == 0x00028C, "Member 'UMapActorWidget::LocationToTrack' has a wrong offset!");
static_assert(offsetof(UMapActorWidget, RotationOffset) == 0x000298, "Member 'UMapActorWidget::RotationOffset' has a wrong offset!");
static_assert(offsetof(UMapActorWidget, MapSize) == 0x00029C, "Member 'UMapActorWidget::MapSize' has a wrong offset!");
static_assert(offsetof(UMapActorWidget, MapTextureSize) == 0x0002A0, "Member 'UMapActorWidget::MapTextureSize' has a wrong offset!");
static_assert(offsetof(UMapActorWidget, MapOrigin) == 0x0002A4, "Member 'UMapActorWidget::MapOrigin' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_PlayMontage
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_PlayMontage final  : public UAnimNotify
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayMontage">();
	}
	static class UAnimNotify_PlayMontage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayMontage>();
	}
};
static_assert(alignof(UAnimNotify_PlayMontage) == 0x000008, "Wrong alignment on UAnimNotify_PlayMontage");
static_assert(sizeof(UAnimNotify_PlayMontage) == 0x000040, "Wrong size on UAnimNotify_PlayMontage");
static_assert(offsetof(UAnimNotify_PlayMontage, Montage) == 0x000038, "Member 'UAnimNotify_PlayMontage::Montage' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_PlayPostProcessEffect
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_PlayPostProcessEffect final  : public UAnimNotify
{
public:
	class FName                                   PostProcessEffectName;                             // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayPostProcessEffect">();
	}
	static class UAnimNotify_PlayPostProcessEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayPostProcessEffect>();
	}
};
static_assert(alignof(UAnimNotify_PlayPostProcessEffect) == 0x000008, "Wrong alignment on UAnimNotify_PlayPostProcessEffect");
static_assert(sizeof(UAnimNotify_PlayPostProcessEffect) == 0x000040, "Wrong size on UAnimNotify_PlayPostProcessEffect");
static_assert(offsetof(UAnimNotify_PlayPostProcessEffect, PostProcessEffectName) == 0x000038, "Member 'UAnimNotify_PlayPostProcessEffect::PostProcessEffectName' has a wrong offset!");

// Class ReadyOrNot.ItemWheelElement
// 0x00C0 (0x0320 - 0x0260)
class UItemWheelElement : public UUserWidget
{
public:
	uint8                                         Pad_221D[0x8];                                     // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EItemCategory                                 ElementCategory;                                   // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221E[0x7];                                     // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 ElementImage;                                      // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            ElementBrush;                                      // 0x0278(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             CounterText;                                       // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221F[0x18];                                    // 0x0308(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsSelectable();
	void Selected(bool Param_Selected);
	bool ShowCounter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWheelElement">();
	}
	static class UItemWheelElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemWheelElement>();
	}
};
static_assert(alignof(UItemWheelElement) == 0x000008, "Wrong alignment on UItemWheelElement");
static_assert(sizeof(UItemWheelElement) == 0x000320, "Wrong size on UItemWheelElement");
static_assert(offsetof(UItemWheelElement, ElementCategory) == 0x000268, "Member 'UItemWheelElement::ElementCategory' has a wrong offset!");
static_assert(offsetof(UItemWheelElement, ElementImage) == 0x000270, "Member 'UItemWheelElement::ElementImage' has a wrong offset!");
static_assert(offsetof(UItemWheelElement, ElementBrush) == 0x000278, "Member 'UItemWheelElement::ElementBrush' has a wrong offset!");
static_assert(offsetof(UItemWheelElement, CounterText) == 0x000300, "Member 'UItemWheelElement::CounterText' has a wrong offset!");

// Class ReadyOrNot.ItemWheelMagazineElement
// 0x0030 (0x0350 - 0x0320)
class UItemWheelMagazineElement : public UItemWheelElement
{
public:
	uint8                                         Pad_2220[0x10];                                    // 0x0320(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             MagazineType;                                      // 0x0330(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2221[0x18];                                    // 0x0338(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWheelMagazineElement">();
	}
	static class UItemWheelMagazineElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemWheelMagazineElement>();
	}
};
static_assert(alignof(UItemWheelMagazineElement) == 0x000008, "Wrong alignment on UItemWheelMagazineElement");
static_assert(sizeof(UItemWheelMagazineElement) == 0x000350, "Wrong size on UItemWheelMagazineElement");
static_assert(offsetof(UItemWheelMagazineElement, MagazineType) == 0x000330, "Member 'UItemWheelMagazineElement::MagazineType' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_PreMissionWeaponVis
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_PreMissionWeaponVis final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PreMissionWeaponVis">();
	}
	static class UAnimNotify_PreMissionWeaponVis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PreMissionWeaponVis>();
	}
};
static_assert(alignof(UAnimNotify_PreMissionWeaponVis) == 0x000008, "Wrong alignment on UAnimNotify_PreMissionWeaponVis");
static_assert(sizeof(UAnimNotify_PreMissionWeaponVis) == 0x000038, "Wrong size on UAnimNotify_PreMissionWeaponVis");

// Class ReadyOrNot.AnimNotify_PushQueuedDoor
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_PushQueuedDoor final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PushQueuedDoor">();
	}
	static class UAnimNotify_PushQueuedDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PushQueuedDoor>();
	}
};
static_assert(alignof(UAnimNotify_PushQueuedDoor) == 0x000008, "Wrong alignment on UAnimNotify_PushQueuedDoor");
static_assert(sizeof(UAnimNotify_PushQueuedDoor) == 0x000038, "Wrong size on UAnimNotify_PushQueuedDoor");

// Class ReadyOrNot.ItemData
// 0x0370 (0x03A0 - 0x0030)
class UItemData final  : public UDataAsset
{
public:
	TArray<struct FWeaponData>                    BluePVPUniquePrimaryWeapons;                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponData>                    RedPVPUniquePrimaryWeapons;                        // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponData>                    PrimaryWeapons;                                    // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FWeaponData>                    SecondaryWeapons;                                  // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FDeviceData>                    LongTacticalItems;                                 // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FDeviceData>                    TacticalItems;                                     // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class ABaseItem>                  NullItem;                                          // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          NullPrimaryScopeAttachment;                        // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          NullMuzzleAttachment;                              // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          NullOverbarrelAttachment;                          // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          NullUnderbarrelAttachment;                         // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          NullStockAttachment;                               // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          NullGripAttachment;                                // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          NullIlluminatorAttachment;                         // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          NullAmmunitionAttachment;                          // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ABaseItem>>          DefaultItemsGivenToPlayer;                         // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class USkinComponent>             FactorySkin;                                       // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSavedLoadout>                  DefaultLoadouts;                                   // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSavedCustomization                    DefaultCustomization;                              // 0x0100(0x00D0)(Edit, NativeAccessSpecifierPublic)
	TMap<EEquippingSwat, struct FDefaultCharacterCustomization> DefaultCharacters;                                 // 0x01D0(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FSavedCustomization                    TrailerCustomization;                              // 0x0220(0x00D0)(Edit, NativeAccessSpecifierPublic)
	TArray<class UCustomizationCharacter*>        TrailerCharacters;                                 // 0x02F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FArmourData>                    BodySelection;                                     // 0x0300(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FArmourData>                    HeadSelection;                                     // 0x0310(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class UArmourMaterial>> ArmourMaterials;                                   // 0x0320(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class USkinComponent>>     UniformSelection;                                  // 0x0330(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FCharacterData>                 CharacterSelection;                                // 0x0340(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              DefaultItemImage;                                  // 0x0350(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           PersonnelNames;                                    // 0x0378(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           PersonnelDescriptions;                             // 0x0388(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AttachmentPointsBase;                              // 0x0398(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2222[0x4];                                     // 0x039C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemData">();
	}
	static class UItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemData>();
	}
};
static_assert(alignof(UItemData) == 0x000008, "Wrong alignment on UItemData");
static_assert(sizeof(UItemData) == 0x0003A0, "Wrong size on UItemData");
static_assert(offsetof(UItemData, BluePVPUniquePrimaryWeapons) == 0x000030, "Member 'UItemData::BluePVPUniquePrimaryWeapons' has a wrong offset!");
static_assert(offsetof(UItemData, RedPVPUniquePrimaryWeapons) == 0x000040, "Member 'UItemData::RedPVPUniquePrimaryWeapons' has a wrong offset!");
static_assert(offsetof(UItemData, PrimaryWeapons) == 0x000050, "Member 'UItemData::PrimaryWeapons' has a wrong offset!");
static_assert(offsetof(UItemData, SecondaryWeapons) == 0x000060, "Member 'UItemData::SecondaryWeapons' has a wrong offset!");
static_assert(offsetof(UItemData, LongTacticalItems) == 0x000070, "Member 'UItemData::LongTacticalItems' has a wrong offset!");
static_assert(offsetof(UItemData, TacticalItems) == 0x000080, "Member 'UItemData::TacticalItems' has a wrong offset!");
static_assert(offsetof(UItemData, NullItem) == 0x000090, "Member 'UItemData::NullItem' has a wrong offset!");
static_assert(offsetof(UItemData, NullPrimaryScopeAttachment) == 0x000098, "Member 'UItemData::NullPrimaryScopeAttachment' has a wrong offset!");
static_assert(offsetof(UItemData, NullMuzzleAttachment) == 0x0000A0, "Member 'UItemData::NullMuzzleAttachment' has a wrong offset!");
static_assert(offsetof(UItemData, NullOverbarrelAttachment) == 0x0000A8, "Member 'UItemData::NullOverbarrelAttachment' has a wrong offset!");
static_assert(offsetof(UItemData, NullUnderbarrelAttachment) == 0x0000B0, "Member 'UItemData::NullUnderbarrelAttachment' has a wrong offset!");
static_assert(offsetof(UItemData, NullStockAttachment) == 0x0000B8, "Member 'UItemData::NullStockAttachment' has a wrong offset!");
static_assert(offsetof(UItemData, NullGripAttachment) == 0x0000C0, "Member 'UItemData::NullGripAttachment' has a wrong offset!");
static_assert(offsetof(UItemData, NullIlluminatorAttachment) == 0x0000C8, "Member 'UItemData::NullIlluminatorAttachment' has a wrong offset!");
static_assert(offsetof(UItemData, NullAmmunitionAttachment) == 0x0000D0, "Member 'UItemData::NullAmmunitionAttachment' has a wrong offset!");
static_assert(offsetof(UItemData, DefaultItemsGivenToPlayer) == 0x0000D8, "Member 'UItemData::DefaultItemsGivenToPlayer' has a wrong offset!");
static_assert(offsetof(UItemData, FactorySkin) == 0x0000E8, "Member 'UItemData::FactorySkin' has a wrong offset!");
static_assert(offsetof(UItemData, DefaultLoadouts) == 0x0000F0, "Member 'UItemData::DefaultLoadouts' has a wrong offset!");
static_assert(offsetof(UItemData, DefaultCustomization) == 0x000100, "Member 'UItemData::DefaultCustomization' has a wrong offset!");
static_assert(offsetof(UItemData, DefaultCharacters) == 0x0001D0, "Member 'UItemData::DefaultCharacters' has a wrong offset!");
static_assert(offsetof(UItemData, TrailerCustomization) == 0x000220, "Member 'UItemData::TrailerCustomization' has a wrong offset!");
static_assert(offsetof(UItemData, TrailerCharacters) == 0x0002F0, "Member 'UItemData::TrailerCharacters' has a wrong offset!");
static_assert(offsetof(UItemData, BodySelection) == 0x000300, "Member 'UItemData::BodySelection' has a wrong offset!");
static_assert(offsetof(UItemData, HeadSelection) == 0x000310, "Member 'UItemData::HeadSelection' has a wrong offset!");
static_assert(offsetof(UItemData, ArmourMaterials) == 0x000320, "Member 'UItemData::ArmourMaterials' has a wrong offset!");
static_assert(offsetof(UItemData, UniformSelection) == 0x000330, "Member 'UItemData::UniformSelection' has a wrong offset!");
static_assert(offsetof(UItemData, CharacterSelection) == 0x000340, "Member 'UItemData::CharacterSelection' has a wrong offset!");
static_assert(offsetof(UItemData, DefaultItemImage) == 0x000350, "Member 'UItemData::DefaultItemImage' has a wrong offset!");
static_assert(offsetof(UItemData, PersonnelNames) == 0x000378, "Member 'UItemData::PersonnelNames' has a wrong offset!");
static_assert(offsetof(UItemData, PersonnelDescriptions) == 0x000388, "Member 'UItemData::PersonnelDescriptions' has a wrong offset!");
static_assert(offsetof(UItemData, AttachmentPointsBase) == 0x000398, "Member 'UItemData::AttachmentPointsBase' has a wrong offset!");

// Class ReadyOrNot.SubtitlesStatics
// 0x0000 (0x0028 - 0x0028)
class USubtitlesStatics final  : public UBlueprintFunctionLibrary
{
public:
	static const TMap<class FString, class FText> GetAvailableLocales();
	static void PlaySubtitles(class UObject* WorldContextObject, const class FString& Speaker, const class FString& VoiceLine, float Length, class FName SpeakerTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitlesStatics">();
	}
	static class USubtitlesStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitlesStatics>();
	}
};
static_assert(alignof(USubtitlesStatics) == 0x000008, "Wrong alignment on USubtitlesStatics");
static_assert(sizeof(USubtitlesStatics) == 0x000028, "Wrong size on USubtitlesStatics");

// Class ReadyOrNot.AnimNotify_RemovePlacedC2
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_RemovePlacedC2 final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_RemovePlacedC2">();
	}
	static class UAnimNotify_RemovePlacedC2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_RemovePlacedC2>();
	}
};
static_assert(alignof(UAnimNotify_RemovePlacedC2) == 0x000008, "Wrong alignment on UAnimNotify_RemovePlacedC2");
static_assert(sizeof(UAnimNotify_RemovePlacedC2) == 0x000038, "Wrong size on UAnimNotify_RemovePlacedC2");

// Class ReadyOrNot.AnimNotify_SearchLandmark
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_SearchLandmark final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SearchLandmark">();
	}
	static class UAnimNotify_SearchLandmark* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SearchLandmark>();
	}
};
static_assert(alignof(UAnimNotify_SearchLandmark) == 0x000008, "Wrong alignment on UAnimNotify_SearchLandmark");
static_assert(sizeof(UAnimNotify_SearchLandmark) == 0x000038, "Wrong size on UAnimNotify_SearchLandmark");

// Class ReadyOrNot.MainMenuGM
// 0x00B8 (0x0378 - 0x02C0)
class AMainMenuGM : public AGameModeBase
{
public:
	class UCreateSessionCallbackProxyAdvanced*    CreateSessionCallbackProxyAdvanced;                // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFindSessionsCallbackProxyAdvanced*     FindSessionsCallbackProxyAdvanced;                 // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDestroySessionCallbackProxyAdvanced*   DestroySessionCallbackProxyAdvanced;               // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             MainMenuMusic;                                     // 0x02D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MainMenuAmbience;                                  // 0x02E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2224[0x38];                                    // 0x02E8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnUpdateSessionSearch;                             // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2225[0x30];                                    // 0x0330(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            AuthenticationMenu;                                // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2226[0x8];                                     // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            MainMenu;                                          // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static bool HasCompletedTraining();

	void CancelSessionSearch();
	bool CanContinueCommanderMode();
	void ContinueCommanderMode();
	void CreateRestartWidget();
	void FindNextSessionList();
	void FindOnlineSession(bool bNewSearch, bool bPVPSession);
	void GoToCommanderMode(int32 ProfileSlot, bool bIronmanMode, bool bTutorialMode);
	void GoToLobby(bool bOnlineMode, bool bFriendsOnly);
	void GoToTraining();
	void OnBanStatusChecked(const class FString& SteamId, bool bIsBanned, const class FString& BanReason, bool bIsMySteamId);
	void OnDestroySessionBeforeStartingLobby();
	void OnFindSessionFailed(TArray<struct FBlueprintSessionResult>& Results);
	void OnFindSessionSuccess(TArray<struct FBlueprintSessionResult>& Results);
	void OnLobbyFailed();
	void OnLobbySuccess();
	void OnTrainingSuccess();
	void OnUpdateSessionSearch__DelegateSignature(bool bComplete, class FText OutMessage, bool bPVPSearch);
	void ShowMainMenuMsg();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuGM">();
	}
	static class AMainMenuGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMainMenuGM>();
	}
};
static_assert(alignof(AMainMenuGM) == 0x000008, "Wrong alignment on AMainMenuGM");
static_assert(sizeof(AMainMenuGM) == 0x000378, "Wrong size on AMainMenuGM");
static_assert(offsetof(AMainMenuGM, CreateSessionCallbackProxyAdvanced) == 0x0002C0, "Member 'AMainMenuGM::CreateSessionCallbackProxyAdvanced' has a wrong offset!");
static_assert(offsetof(AMainMenuGM, FindSessionsCallbackProxyAdvanced) == 0x0002C8, "Member 'AMainMenuGM::FindSessionsCallbackProxyAdvanced' has a wrong offset!");
static_assert(offsetof(AMainMenuGM, DestroySessionCallbackProxyAdvanced) == 0x0002D0, "Member 'AMainMenuGM::DestroySessionCallbackProxyAdvanced' has a wrong offset!");
static_assert(offsetof(AMainMenuGM, MainMenuMusic) == 0x0002D8, "Member 'AMainMenuGM::MainMenuMusic' has a wrong offset!");
static_assert(offsetof(AMainMenuGM, MainMenuAmbience) == 0x0002E0, "Member 'AMainMenuGM::MainMenuAmbience' has a wrong offset!");
static_assert(offsetof(AMainMenuGM, OnUpdateSessionSearch) == 0x000320, "Member 'AMainMenuGM::OnUpdateSessionSearch' has a wrong offset!");
static_assert(offsetof(AMainMenuGM, AuthenticationMenu) == 0x000360, "Member 'AMainMenuGM::AuthenticationMenu' has a wrong offset!");
static_assert(offsetof(AMainMenuGM, MainMenu) == 0x000370, "Member 'AMainMenuGM::MainMenu' has a wrong offset!");

// Class ReadyOrNot.SetControlRotationToCamBoneAnimNotify
// 0x0008 (0x0040 - 0x0038)
class USetControlRotationToCamBoneAnimNotify final  : public UAnimNotify
{
public:
	class FName                                   CameraBoneName;                                    // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetControlRotationToCamBoneAnimNotify">();
	}
	static class USetControlRotationToCamBoneAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetControlRotationToCamBoneAnimNotify>();
	}
};
static_assert(alignof(USetControlRotationToCamBoneAnimNotify) == 0x000008, "Wrong alignment on USetControlRotationToCamBoneAnimNotify");
static_assert(sizeof(USetControlRotationToCamBoneAnimNotify) == 0x000040, "Wrong size on USetControlRotationToCamBoneAnimNotify");
static_assert(offsetof(USetControlRotationToCamBoneAnimNotify, CameraBoneName) == 0x000038, "Member 'USetControlRotationToCamBoneAnimNotify::CameraBoneName' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_SetCoverFirePose
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_SetCoverFirePose final  : public UAnimNotify
{
public:
	class UAnimSequence*                          Pose;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SetCoverFirePose">();
	}
	static class UAnimNotify_SetCoverFirePose* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SetCoverFirePose>();
	}
};
static_assert(alignof(UAnimNotify_SetCoverFirePose) == 0x000008, "Wrong alignment on UAnimNotify_SetCoverFirePose");
static_assert(sizeof(UAnimNotify_SetCoverFirePose) == 0x000040, "Wrong size on UAnimNotify_SetCoverFirePose");
static_assert(offsetof(UAnimNotify_SetCoverFirePose, Pose) == 0x000038, "Member 'UAnimNotify_SetCoverFirePose::Pose' has a wrong offset!");

// Class ReadyOrNot.ItemWheel
// 0x01A0 (0x0400 - 0x0260)
class UItemWheel : public UUserWidget
{
public:
	class UWidgetAnimation*                       FadeIn;                                            // 0x0260(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeOut;                                           // 0x0268(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OuterWheelFadeIn;                                  // 0x0270(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OuterWheelFadeOut;                                 // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       InnerWheelFadeIn;                                  // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       InnerWheelFadeOut;                                 // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            OuterWheel;                                        // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TacticalCategory;                                  // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MiscCategory;                                      // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 GrenadeCategory;                                   // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MagazineCategory;                                  // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemWheelElement*                      GrenadeFlashbang;                                  // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemWheelElement*                      GrenadeCSGas;                                      // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemWheelElement*                      GrenadeStinger;                                    // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemWheelElement*                      TacticalC2;                                        // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemWheelElement*                      TacticalSpray;                                     // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemWheelElement*                      TacticalWedge;                                     // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemWheelElement*                      TacticalTaser;                                     // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemWheelElement*                      TacticalLockpickGun;                               // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemWheelElement*                      MiscDetonator;                                     // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemWheelElement*                      MiscMultitool;                                     // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemWheelElement*                      MiscZipcuffs;                                      // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemWheelMagazineElement*              MagazineSlot1;                                     // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemWheelMagazineElement*              MagazineSlot2;                                     // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           GrenadeWheel;                                      // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           TacticalWheel;                                     // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           MiscWheel;                                         // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           MagazineWheel;                                     // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            InnerWheel;                                        // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           InnerWheelCanvasPanel;                             // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           OuterWheelCanvasPanel;                             // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShowOuterWheelMenu;                                // 0x0358(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_222C[0x7];                                     // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             HeaderText;                                        // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_222D[0x98];                                    // 0x0368(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetInnerWheelPosition();
	struct FVector GetOuterWheelPosition();
	void OnMagazineIconChange(class UTexture2D* Icon);
	void OnNumberOfSegmentsChange(int32 NumSegments);
	void SetInnerwheelOpacity(float Opacity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWheel">();
	}
	static class UItemWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemWheel>();
	}
};
static_assert(alignof(UItemWheel) == 0x000008, "Wrong alignment on UItemWheel");
static_assert(sizeof(UItemWheel) == 0x000400, "Wrong size on UItemWheel");
static_assert(offsetof(UItemWheel, FadeIn) == 0x000260, "Member 'UItemWheel::FadeIn' has a wrong offset!");
static_assert(offsetof(UItemWheel, FadeOut) == 0x000268, "Member 'UItemWheel::FadeOut' has a wrong offset!");
static_assert(offsetof(UItemWheel, OuterWheelFadeIn) == 0x000270, "Member 'UItemWheel::OuterWheelFadeIn' has a wrong offset!");
static_assert(offsetof(UItemWheel, OuterWheelFadeOut) == 0x000278, "Member 'UItemWheel::OuterWheelFadeOut' has a wrong offset!");
static_assert(offsetof(UItemWheel, InnerWheelFadeIn) == 0x000280, "Member 'UItemWheel::InnerWheelFadeIn' has a wrong offset!");
static_assert(offsetof(UItemWheel, InnerWheelFadeOut) == 0x000288, "Member 'UItemWheel::InnerWheelFadeOut' has a wrong offset!");
static_assert(offsetof(UItemWheel, OuterWheel) == 0x000290, "Member 'UItemWheel::OuterWheel' has a wrong offset!");
static_assert(offsetof(UItemWheel, TacticalCategory) == 0x000298, "Member 'UItemWheel::TacticalCategory' has a wrong offset!");
static_assert(offsetof(UItemWheel, MiscCategory) == 0x0002A0, "Member 'UItemWheel::MiscCategory' has a wrong offset!");
static_assert(offsetof(UItemWheel, GrenadeCategory) == 0x0002A8, "Member 'UItemWheel::GrenadeCategory' has a wrong offset!");
static_assert(offsetof(UItemWheel, MagazineCategory) == 0x0002B0, "Member 'UItemWheel::MagazineCategory' has a wrong offset!");
static_assert(offsetof(UItemWheel, GrenadeFlashbang) == 0x0002B8, "Member 'UItemWheel::GrenadeFlashbang' has a wrong offset!");
static_assert(offsetof(UItemWheel, GrenadeCSGas) == 0x0002C0, "Member 'UItemWheel::GrenadeCSGas' has a wrong offset!");
static_assert(offsetof(UItemWheel, GrenadeStinger) == 0x0002C8, "Member 'UItemWheel::GrenadeStinger' has a wrong offset!");
static_assert(offsetof(UItemWheel, TacticalC2) == 0x0002D0, "Member 'UItemWheel::TacticalC2' has a wrong offset!");
static_assert(offsetof(UItemWheel, TacticalSpray) == 0x0002D8, "Member 'UItemWheel::TacticalSpray' has a wrong offset!");
static_assert(offsetof(UItemWheel, TacticalWedge) == 0x0002E0, "Member 'UItemWheel::TacticalWedge' has a wrong offset!");
static_assert(offsetof(UItemWheel, TacticalTaser) == 0x0002E8, "Member 'UItemWheel::TacticalTaser' has a wrong offset!");
static_assert(offsetof(UItemWheel, TacticalLockpickGun) == 0x0002F0, "Member 'UItemWheel::TacticalLockpickGun' has a wrong offset!");
static_assert(offsetof(UItemWheel, MiscDetonator) == 0x0002F8, "Member 'UItemWheel::MiscDetonator' has a wrong offset!");
static_assert(offsetof(UItemWheel, MiscMultitool) == 0x000300, "Member 'UItemWheel::MiscMultitool' has a wrong offset!");
static_assert(offsetof(UItemWheel, MiscZipcuffs) == 0x000308, "Member 'UItemWheel::MiscZipcuffs' has a wrong offset!");
static_assert(offsetof(UItemWheel, MagazineSlot1) == 0x000310, "Member 'UItemWheel::MagazineSlot1' has a wrong offset!");
static_assert(offsetof(UItemWheel, MagazineSlot2) == 0x000318, "Member 'UItemWheel::MagazineSlot2' has a wrong offset!");
static_assert(offsetof(UItemWheel, GrenadeWheel) == 0x000320, "Member 'UItemWheel::GrenadeWheel' has a wrong offset!");
static_assert(offsetof(UItemWheel, TacticalWheel) == 0x000328, "Member 'UItemWheel::TacticalWheel' has a wrong offset!");
static_assert(offsetof(UItemWheel, MiscWheel) == 0x000330, "Member 'UItemWheel::MiscWheel' has a wrong offset!");
static_assert(offsetof(UItemWheel, MagazineWheel) == 0x000338, "Member 'UItemWheel::MagazineWheel' has a wrong offset!");
static_assert(offsetof(UItemWheel, InnerWheel) == 0x000340, "Member 'UItemWheel::InnerWheel' has a wrong offset!");
static_assert(offsetof(UItemWheel, InnerWheelCanvasPanel) == 0x000348, "Member 'UItemWheel::InnerWheelCanvasPanel' has a wrong offset!");
static_assert(offsetof(UItemWheel, OuterWheelCanvasPanel) == 0x000350, "Member 'UItemWheel::OuterWheelCanvasPanel' has a wrong offset!");
static_assert(offsetof(UItemWheel, ShowOuterWheelMenu) == 0x000358, "Member 'UItemWheel::ShowOuterWheelMenu' has a wrong offset!");
static_assert(offsetof(UItemWheel, HeaderText) == 0x000360, "Member 'UItemWheel::HeaderText' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_SetCoverHidePose
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_SetCoverHidePose final  : public UAnimNotify
{
public:
	class UAnimSequence*                          Pose;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SetCoverHidePose">();
	}
	static class UAnimNotify_SetCoverHidePose* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SetCoverHidePose>();
	}
};
static_assert(alignof(UAnimNotify_SetCoverHidePose) == 0x000008, "Wrong alignment on UAnimNotify_SetCoverHidePose");
static_assert(sizeof(UAnimNotify_SetCoverHidePose) == 0x000040, "Wrong size on UAnimNotify_SetCoverHidePose");
static_assert(offsetof(UAnimNotify_SetCoverHidePose, Pose) == 0x000038, "Member 'UAnimNotify_SetCoverHidePose::Pose' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_SetCoverIdlePose
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_SetCoverIdlePose final  : public UAnimNotify
{
public:
	class UAnimSequence*                          Pose;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SetCoverIdlePose">();
	}
	static class UAnimNotify_SetCoverIdlePose* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SetCoverIdlePose>();
	}
};
static_assert(alignof(UAnimNotify_SetCoverIdlePose) == 0x000008, "Wrong alignment on UAnimNotify_SetCoverIdlePose");
static_assert(sizeof(UAnimNotify_SetCoverIdlePose) == 0x000040, "Wrong size on UAnimNotify_SetCoverIdlePose");
static_assert(offsetof(UAnimNotify_SetCoverIdlePose, Pose) == 0x000038, "Member 'UAnimNotify_SetCoverIdlePose::Pose' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_SetHoleTraversalPose
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_SetHoleTraversalPose final  : public UAnimNotify
{
public:
	class UAnimSequence*                          Pose;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SetHoleTraversalPose">();
	}
	static class UAnimNotify_SetHoleTraversalPose* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SetHoleTraversalPose>();
	}
};
static_assert(alignof(UAnimNotify_SetHoleTraversalPose) == 0x000008, "Wrong alignment on UAnimNotify_SetHoleTraversalPose");
static_assert(sizeof(UAnimNotify_SetHoleTraversalPose) == 0x000040, "Wrong size on UAnimNotify_SetHoleTraversalPose");
static_assert(offsetof(UAnimNotify_SetHoleTraversalPose, Pose) == 0x000038, "Member 'UAnimNotify_SetHoleTraversalPose::Pose' has a wrong offset!");

// Class ReadyOrNot.DeployableData
// 0x0078 (0x00A8 - 0x0030)
class UDeployableData final  : public UDataAsset
{
public:
	class FText                                   DeployableName;                                    // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DeployableShortName;                               // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DeployableDescription;                             // 0x0060(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              DeployableTexture;                                 // 0x0078(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DeployableLabel;                                   // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployableData">();
	}
	static class UDeployableData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployableData>();
	}
};
static_assert(alignof(UDeployableData) == 0x000008, "Wrong alignment on UDeployableData");
static_assert(sizeof(UDeployableData) == 0x0000A8, "Wrong size on UDeployableData");
static_assert(offsetof(UDeployableData, DeployableName) == 0x000030, "Member 'UDeployableData::DeployableName' has a wrong offset!");
static_assert(offsetof(UDeployableData, DeployableShortName) == 0x000048, "Member 'UDeployableData::DeployableShortName' has a wrong offset!");
static_assert(offsetof(UDeployableData, DeployableDescription) == 0x000060, "Member 'UDeployableData::DeployableDescription' has a wrong offset!");
static_assert(offsetof(UDeployableData, DeployableTexture) == 0x000078, "Member 'UDeployableData::DeployableTexture' has a wrong offset!");
static_assert(offsetof(UDeployableData, DeployableLabel) == 0x0000A0, "Member 'UDeployableData::DeployableLabel' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_SetStrafe
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_SetStrafe final  : public UAnimNotify
{
public:
	bool                                          bSetStrafe;                                        // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_222E[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SetStrafe">();
	}
	static class UAnimNotify_SetStrafe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SetStrafe>();
	}
};
static_assert(alignof(UAnimNotify_SetStrafe) == 0x000008, "Wrong alignment on UAnimNotify_SetStrafe");
static_assert(sizeof(UAnimNotify_SetStrafe) == 0x000040, "Wrong size on UAnimNotify_SetStrafe");
static_assert(offsetof(UAnimNotify_SetStrafe, bSetStrafe) == 0x000038, "Member 'UAnimNotify_SetStrafe::bSetStrafe' has a wrong offset!");

// Class ReadyOrNot.SplineTrigger
// 0x0058 (0x0278 - 0x0220)
class ASplineTrigger : public AActor
{
public:
	FMulticastInlineDelegateProperty_             Delegate_OnSplineEnclosureEntered;                 // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Delegate_OnSplineEnclosureExited;                  // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bInvertBounds;                                     // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_222F[0x3];                                     // 0x0241(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastValidPlayerLocation;                           // 0x0244(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnabled : 1;                                      // 0x0250(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawDebugElements : 1;                            // 0x0250(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2230[0x3];                                     // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AverageSplinePointLocation;                        // 0x0254(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsOutsideSplineEnclosure : 1;                     // 0x0260(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2231[0x7];                                     // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       SplineComponent;                                   // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2232[0x8];                                     // 0x0270(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableTrigger();
	void EnableTrigger();
	void OnSplineEnclosureEntered(class APlayerCharacter* PlayerCharacter);
	void OnSplineEnclosureEntered__DelegateSignature(class APlayerCharacter* PlayerCharacter);
	void OnSplineEnclosureExited(class APlayerCharacter* PlayerCharacter);
	void OnSplineEnclosureExited__DelegateSignature(class APlayerCharacter* PlayerCharacter);
	void ToggleDrawDebug();

	bool IsActorInsideSplineEnclosure(class AActor* InActor) const;
	bool IsActorOutsideSplineEnclosure(class AActor* InActor) const;
	bool IsInsideSplineEnclosure() const;
	bool IsOutsideSplineEnclosure() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineTrigger">();
	}
	static class ASplineTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplineTrigger>();
	}
};
static_assert(alignof(ASplineTrigger) == 0x000008, "Wrong alignment on ASplineTrigger");
static_assert(sizeof(ASplineTrigger) == 0x000278, "Wrong size on ASplineTrigger");
static_assert(offsetof(ASplineTrigger, Delegate_OnSplineEnclosureEntered) == 0x000220, "Member 'ASplineTrigger::Delegate_OnSplineEnclosureEntered' has a wrong offset!");
static_assert(offsetof(ASplineTrigger, Delegate_OnSplineEnclosureExited) == 0x000230, "Member 'ASplineTrigger::Delegate_OnSplineEnclosureExited' has a wrong offset!");
static_assert(offsetof(ASplineTrigger, bInvertBounds) == 0x000240, "Member 'ASplineTrigger::bInvertBounds' has a wrong offset!");
static_assert(offsetof(ASplineTrigger, LastValidPlayerLocation) == 0x000244, "Member 'ASplineTrigger::LastValidPlayerLocation' has a wrong offset!");
static_assert(offsetof(ASplineTrigger, AverageSplinePointLocation) == 0x000254, "Member 'ASplineTrigger::AverageSplinePointLocation' has a wrong offset!");
static_assert(offsetof(ASplineTrigger, SplineComponent) == 0x000268, "Member 'ASplineTrigger::SplineComponent' has a wrong offset!");

// Class ReadyOrNot.SplineTrigger_Incrimination
// 0x0000 (0x0278 - 0x0278)
class ASplineTrigger_Incrimination final  : public ASplineTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineTrigger_Incrimination">();
	}
	static class ASplineTrigger_Incrimination* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplineTrigger_Incrimination>();
	}
};
static_assert(alignof(ASplineTrigger_Incrimination) == 0x000008, "Wrong alignment on ASplineTrigger_Incrimination");
static_assert(sizeof(ASplineTrigger_Incrimination) == 0x000278, "Wrong size on ASplineTrigger_Incrimination");

// Class ReadyOrNot.AnimNotify_SpawnThrownItem
// 0x0028 (0x0060 - 0x0038)
class UAnimNotify_SpawnThrownItem final  : public UAnimNotify
{
public:
	TSubclassOf<class ABaseItem>                  ItemClass;                                         // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLocalOnly : 1;                                    // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNonLocalOnly : 1;                                 // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2235[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneToSpawnOn;                                     // 0x0044(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCustomThrowDirection : 1;                         // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2236[0x3];                                     // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ThrowDirection;                                    // 0x0050(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2237[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SpawnThrownItem">();
	}
	static class UAnimNotify_SpawnThrownItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SpawnThrownItem>();
	}
};
static_assert(alignof(UAnimNotify_SpawnThrownItem) == 0x000008, "Wrong alignment on UAnimNotify_SpawnThrownItem");
static_assert(sizeof(UAnimNotify_SpawnThrownItem) == 0x000060, "Wrong size on UAnimNotify_SpawnThrownItem");
static_assert(offsetof(UAnimNotify_SpawnThrownItem, ItemClass) == 0x000038, "Member 'UAnimNotify_SpawnThrownItem::ItemClass' has a wrong offset!");
static_assert(offsetof(UAnimNotify_SpawnThrownItem, BoneToSpawnOn) == 0x000044, "Member 'UAnimNotify_SpawnThrownItem::BoneToSpawnOn' has a wrong offset!");
static_assert(offsetof(UAnimNotify_SpawnThrownItem, ThrowDirection) == 0x000050, "Member 'UAnimNotify_SpawnThrownItem::ThrowDirection' has a wrong offset!");

// Class ReadyOrNot.ConsoleContextSwitcher
// 0x0040 (0x02B8 - 0x0278)
class UConsoleContextSwitcher final  : public UBaseWidget
{
public:
	class UWidgetSwitcher*                        ContextSwitcher;                                   // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleSelection*                      GrenadeSelection;                                  // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleSelection*                      TacticalSelection;                                 // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleFireModes*                      FireModes;                                         // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleMagSelection*                   MagSelection;                                      // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeIn;                                            // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeOut;                                           // 0x02A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2238[0x8];                                     // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SwapToFireModes();
	void SwapToGrenades();
	void SwapToMag(class ABaseMagazineWeapon* MagazineWeapon);
	void SwapToTactical();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleContextSwitcher">();
	}
	static class UConsoleContextSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleContextSwitcher>();
	}
};
static_assert(alignof(UConsoleContextSwitcher) == 0x000008, "Wrong alignment on UConsoleContextSwitcher");
static_assert(sizeof(UConsoleContextSwitcher) == 0x0002B8, "Wrong size on UConsoleContextSwitcher");
static_assert(offsetof(UConsoleContextSwitcher, ContextSwitcher) == 0x000278, "Member 'UConsoleContextSwitcher::ContextSwitcher' has a wrong offset!");
static_assert(offsetof(UConsoleContextSwitcher, GrenadeSelection) == 0x000280, "Member 'UConsoleContextSwitcher::GrenadeSelection' has a wrong offset!");
static_assert(offsetof(UConsoleContextSwitcher, TacticalSelection) == 0x000288, "Member 'UConsoleContextSwitcher::TacticalSelection' has a wrong offset!");
static_assert(offsetof(UConsoleContextSwitcher, FireModes) == 0x000290, "Member 'UConsoleContextSwitcher::FireModes' has a wrong offset!");
static_assert(offsetof(UConsoleContextSwitcher, MagSelection) == 0x000298, "Member 'UConsoleContextSwitcher::MagSelection' has a wrong offset!");
static_assert(offsetof(UConsoleContextSwitcher, FadeIn) == 0x0002A0, "Member 'UConsoleContextSwitcher::FadeIn' has a wrong offset!");
static_assert(offsetof(UConsoleContextSwitcher, FadeOut) == 0x0002A8, "Member 'UConsoleContextSwitcher::FadeOut' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_SpawnWeapon
// 0x0010 (0x0048 - 0x0038)
class UAnimNotify_SpawnWeapon final  : public UAnimNotify
{
public:
	TArray<TSubclassOf<class ABaseWeapon>>        PotentialWeapons;                                  // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SpawnWeapon">();
	}
	static class UAnimNotify_SpawnWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SpawnWeapon>();
	}
};
static_assert(alignof(UAnimNotify_SpawnWeapon) == 0x000008, "Wrong alignment on UAnimNotify_SpawnWeapon");
static_assert(sizeof(UAnimNotify_SpawnWeapon) == 0x000048, "Wrong size on UAnimNotify_SpawnWeapon");
static_assert(offsetof(UAnimNotify_SpawnWeapon, PotentialWeapons) == 0x000038, "Member 'UAnimNotify_SpawnWeapon::PotentialWeapons' has a wrong offset!");

// Class ReadyOrNot.AnimNotifyState_HideBoneVis
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_HideBoneVis final  : public UAnimNotifyState
{
public:
	class FName                                   BoneNameToHide;                                    // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_HideBoneVis">();
	}
	static class UAnimNotifyState_HideBoneVis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_HideBoneVis>();
	}
};
static_assert(alignof(UAnimNotifyState_HideBoneVis) == 0x000008, "Wrong alignment on UAnimNotifyState_HideBoneVis");
static_assert(sizeof(UAnimNotifyState_HideBoneVis) == 0x000038, "Wrong size on UAnimNotifyState_HideBoneVis");
static_assert(offsetof(UAnimNotifyState_HideBoneVis, BoneNameToHide) == 0x000030, "Member 'UAnimNotifyState_HideBoneVis::BoneNameToHide' has a wrong offset!");

// Class ReadyOrNot.DeployItemAtLocationActivity
// 0x0018 (0x01C0 - 0x01A8)
class UDeployItemAtLocationActivity : public UBaseActivity
{
public:
	TSubclassOf<class ABaseItem>                  DeployItemClass;                                   // 0x01A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DeployLocation;                                    // 0x01B0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2239[0x4];                                     // 0x01BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Blueprint_EnterDeployStage();
	void Blueprint_ExitDeployStage();
	void Blueprint_TickDeployStage(float DeltaTime, float Uptime);
	void EnterDeployStage();
	void EnterMoveToStage();
	void ExitDeployStage();
	void ExitMoveToStage();
	void TickDeployStage(float DeltaTime, float Uptime);
	void TickMoveToStage(float DeltaTime, float Uptime);

	bool CanDeploy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployItemAtLocationActivity">();
	}
	static class UDeployItemAtLocationActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployItemAtLocationActivity>();
	}
};
static_assert(alignof(UDeployItemAtLocationActivity) == 0x000008, "Wrong alignment on UDeployItemAtLocationActivity");
static_assert(sizeof(UDeployItemAtLocationActivity) == 0x0001C0, "Wrong size on UDeployItemAtLocationActivity");
static_assert(offsetof(UDeployItemAtLocationActivity, DeployItemClass) == 0x0001A8, "Member 'UDeployItemAtLocationActivity::DeployItemClass' has a wrong offset!");
static_assert(offsetof(UDeployItemAtLocationActivity, DeployLocation) == 0x0001B0, "Member 'UDeployItemAtLocationActivity::DeployLocation' has a wrong offset!");

// Class ReadyOrNot.DeployChemlightActivity
// 0x0000 (0x01C0 - 0x01C0)
class UDeployChemlightActivity final  : public UDeployItemAtLocationActivity
{
public:
	void OnChemlightThrown(class ABaseItem* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployChemlightActivity">();
	}
	static class UDeployChemlightActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployChemlightActivity>();
	}
};
static_assert(alignof(UDeployChemlightActivity) == 0x000008, "Wrong alignment on UDeployChemlightActivity");
static_assert(sizeof(UDeployChemlightActivity) == 0x0001C0, "Wrong size on UDeployChemlightActivity");

// Class ReadyOrNot.AnimNotify_ToggleEquipmentVis
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_ToggleEquipmentVis final  : public UAnimNotify
{
public:
	EToggleInventoryVis                           InventroyVis;                                      // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_223A[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ToggleEquipmentVis">();
	}
	static class UAnimNotify_ToggleEquipmentVis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ToggleEquipmentVis>();
	}
};
static_assert(alignof(UAnimNotify_ToggleEquipmentVis) == 0x000008, "Wrong alignment on UAnimNotify_ToggleEquipmentVis");
static_assert(sizeof(UAnimNotify_ToggleEquipmentVis) == 0x000040, "Wrong size on UAnimNotify_ToggleEquipmentVis");
static_assert(offsetof(UAnimNotify_ToggleEquipmentVis, InventroyVis) == 0x000038, "Member 'UAnimNotify_ToggleEquipmentVis::InventroyVis' has a wrong offset!");

// Class ReadyOrNot.SmallSlot_V2
// 0x0010 (0x0298 - 0x0288)
class USmallSlot_V2 : public UCommonUserWidget
{
public:
	class UTextBlock*                             ItemName;                                          // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Equipped;                                          // 0x0290(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_223B[0x7];                                     // 0x0291(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetEquipped();
	void OnEquipped();
	void SetEquipped(bool IsEquipped);
	void SetText(class FText Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmallSlot_V2">();
	}
	static class USmallSlot_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmallSlot_V2>();
	}
};
static_assert(alignof(USmallSlot_V2) == 0x000008, "Wrong alignment on USmallSlot_V2");
static_assert(sizeof(USmallSlot_V2) == 0x000298, "Wrong size on USmallSlot_V2");
static_assert(offsetof(USmallSlot_V2, ItemName) == 0x000288, "Member 'USmallSlot_V2::ItemName' has a wrong offset!");
static_assert(offsetof(USmallSlot_V2, Equipped) == 0x000290, "Member 'USmallSlot_V2::Equipped' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_WedgeDoor
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_WedgeDoor final  : public UAnimNotify
{
public:
	uint8                                         bWedgeDeployFinished : 1;                          // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_223C[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_WedgeDoor">();
	}
	static class UAnimNotify_WedgeDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_WedgeDoor>();
	}
};
static_assert(alignof(UAnimNotify_WedgeDoor) == 0x000008, "Wrong alignment on UAnimNotify_WedgeDoor");
static_assert(sizeof(UAnimNotify_WedgeDoor) == 0x000040, "Wrong size on UAnimNotify_WedgeDoor");

// Class ReadyOrNot.DefusalGS
// 0x0030 (0x0810 - 0x07E0)
class ADefusalGS final  : public AReadyOrNotGameState
{
public:
	EDefusalMatchSate                             DefusalMatchState;                                 // 0x07E0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_223D[0x7];                                     // 0x07E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            DefusalHudInst;                                    // 0x07E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                DefusalHudClass;                                   // 0x07F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALoadoutPortal*                         LoadoutPortal;                                     // 0x07F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CountdownUntilMatchStarts;                         // 0x0800(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ElapsedRoundTime;                                  // 0x0804(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BombTimeRemaining;                                 // 0x0808(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_223E[0x4];                                     // 0x080C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefusalGS">();
	}
	static class ADefusalGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADefusalGS>();
	}
};
static_assert(alignof(ADefusalGS) == 0x000008, "Wrong alignment on ADefusalGS");
static_assert(sizeof(ADefusalGS) == 0x000810, "Wrong size on ADefusalGS");
static_assert(offsetof(ADefusalGS, DefusalMatchState) == 0x0007E0, "Member 'ADefusalGS::DefusalMatchState' has a wrong offset!");
static_assert(offsetof(ADefusalGS, DefusalHudInst) == 0x0007E8, "Member 'ADefusalGS::DefusalHudInst' has a wrong offset!");
static_assert(offsetof(ADefusalGS, DefusalHudClass) == 0x0007F0, "Member 'ADefusalGS::DefusalHudClass' has a wrong offset!");
static_assert(offsetof(ADefusalGS, LoadoutPortal) == 0x0007F8, "Member 'ADefusalGS::LoadoutPortal' has a wrong offset!");
static_assert(offsetof(ADefusalGS, CountdownUntilMatchStarts) == 0x000800, "Member 'ADefusalGS::CountdownUntilMatchStarts' has a wrong offset!");
static_assert(offsetof(ADefusalGS, ElapsedRoundTime) == 0x000804, "Member 'ADefusalGS::ElapsedRoundTime' has a wrong offset!");
static_assert(offsetof(ADefusalGS, BombTimeRemaining) == 0x000808, "Member 'ADefusalGS::BombTimeRemaining' has a wrong offset!");

// Class ReadyOrNot.AnimNotifyState_SpawnLight
// 0x0038 (0x0068 - 0x0030)
class UAnimNotifyState_SpawnLight final  : public UAnimNotifyState
{
public:
	struct FLinearColor                           LightColor;                                        // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartIntensity;                                    // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MiddleIntensity;                                   // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EndIntensity;                                      // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InterpSpeed;                                       // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APointLight*                            PointLight;                                        // 0x0050(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDuration;                                       // 0x0058(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentDuration;                                   // 0x005C(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SocketName;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SpawnLight">();
	}
	static class UAnimNotifyState_SpawnLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SpawnLight>();
	}
};
static_assert(alignof(UAnimNotifyState_SpawnLight) == 0x000008, "Wrong alignment on UAnimNotifyState_SpawnLight");
static_assert(sizeof(UAnimNotifyState_SpawnLight) == 0x000068, "Wrong size on UAnimNotifyState_SpawnLight");
static_assert(offsetof(UAnimNotifyState_SpawnLight, LightColor) == 0x000030, "Member 'UAnimNotifyState_SpawnLight::LightColor' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnLight, StartIntensity) == 0x000040, "Member 'UAnimNotifyState_SpawnLight::StartIntensity' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnLight, MiddleIntensity) == 0x000044, "Member 'UAnimNotifyState_SpawnLight::MiddleIntensity' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnLight, EndIntensity) == 0x000048, "Member 'UAnimNotifyState_SpawnLight::EndIntensity' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnLight, InterpSpeed) == 0x00004C, "Member 'UAnimNotifyState_SpawnLight::InterpSpeed' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnLight, PointLight) == 0x000050, "Member 'UAnimNotifyState_SpawnLight::PointLight' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnLight, MaxDuration) == 0x000058, "Member 'UAnimNotifyState_SpawnLight::MaxDuration' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnLight, CurrentDuration) == 0x00005C, "Member 'UAnimNotifyState_SpawnLight::CurrentDuration' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnLight, SocketName) == 0x000060, "Member 'UAnimNotifyState_SpawnLight::SocketName' has a wrong offset!");

// Class ReadyOrNot.AnimTurnInPlaceLibrary
// 0x0000 (0x0028 - 0x0028)
class UAnimTurnInPlaceLibrary final  : public UBlueprintFunctionLibrary
{
public:
	static void PostProcessYawOffset(float DeltaSeconds, float& YawOffset, float& LastYawOffset, float& LastPostProcessedYawOffset, float& TurnAroundTimeToGo, float TurnAroundBlendTime);
	static void UpdateTurnInPlace(float DeltaTime, bool bAllowTurnInPlace, bool bHoldYawOffset, bool bIsTurnTransitionStateRelevant, bool bClampYawOffset, float YawOffsetLimit, struct FRotator& MeshWorldRotation, struct FAnimTurnInPlaceAnimSet& AnimSet, struct FAnimTurnInPlaceState& TurnInPlaceState, float TurnInPlaceSpeedMultiplier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimTurnInPlaceLibrary">();
	}
	static class UAnimTurnInPlaceLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimTurnInPlaceLibrary>();
	}
};
static_assert(alignof(UAnimTurnInPlaceLibrary) == 0x000008, "Wrong alignment on UAnimTurnInPlaceLibrary");
static_assert(sizeof(UAnimTurnInPlaceLibrary) == 0x000028, "Wrong size on UAnimTurnInPlaceLibrary");

// Class ReadyOrNot.CommonTabListWidgetImplementation
// 0x0008 (0x0360 - 0x0358)
class UCommonTabListWidgetImplementation : public UCommonTabListWidgetBase
{
public:
	uint8                                         Pad_2240[0x8];                                     // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonTabListWidgetImplementation">();
	}
	static class UCommonTabListWidgetImplementation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonTabListWidgetImplementation>();
	}
};
static_assert(alignof(UCommonTabListWidgetImplementation) == 0x000008, "Wrong alignment on UCommonTabListWidgetImplementation");
static_assert(sizeof(UCommonTabListWidgetImplementation) == 0x000360, "Wrong size on UCommonTabListWidgetImplementation");

// Class ReadyOrNot.ArmourResourceComponent
// 0x0010 (0x0118 - 0x0108)
class UArmourResourceComponent final  : public UResourceComponent
{
public:
	int32                                         MaxTickets;                                        // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Resistance;                                        // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RemainingTickets;                                  // 0x0110(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2241[0x4];                                     // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMaxTickets(int32 NewMax);
	void SetResistance(float NewResistancePercentage);

	int32 GetMaxTickets() const;
	int32 GetRemainingTickets() const;
	float GetResistancePercentage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmourResourceComponent">();
	}
	static class UArmourResourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmourResourceComponent>();
	}
};
static_assert(alignof(UArmourResourceComponent) == 0x000008, "Wrong alignment on UArmourResourceComponent");
static_assert(sizeof(UArmourResourceComponent) == 0x000118, "Wrong size on UArmourResourceComponent");
static_assert(offsetof(UArmourResourceComponent, MaxTickets) == 0x000108, "Member 'UArmourResourceComponent::MaxTickets' has a wrong offset!");
static_assert(offsetof(UArmourResourceComponent, Resistance) == 0x00010C, "Member 'UArmourResourceComponent::Resistance' has a wrong offset!");
static_assert(offsetof(UArmourResourceComponent, RemainingTickets) == 0x000110, "Member 'UArmourResourceComponent::RemainingTickets' has a wrong offset!");

// Class ReadyOrNot.SWATController
// 0x00E0 (0x09B8 - 0x08D8)
class ASWATController final  : public ACyberneticController
{
public:
	class UTeamFallinActivity*                    FallinActivity;                                    // 0x08D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrestTargetActivity*                  ArrestTargetActivity;                              // 0x08E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTeamStackUpActivity*                   StackUpActivity;                                   // 0x08E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTeamBreachAndClearActivity*            BreachAndClearActivity;                            // 0x08F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDeployChemlightActivity*               DeployChemlightActivity;                           // 0x08F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHoldActivity*                          HoldActivity;                                      // 0x0900(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UReportTargetActivity*                  ReportTargetActivity;                              // 0x0908(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCollectEvidenceActivity*               CollectEvidenceActivity;                           // 0x0910(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDisarmStandaloneTrapActivity*          DisarmStandaloneTrapActivity;                      // 0x0918(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDeployGrenadeAtLocationActivity*       DeployGrenadeAtLocationActivity;                   // 0x0920(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKickDoorActivity*                      KickDoorActivity;                                  // 0x0928(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UC2DoorActivity*                        C2DoorActivity;                                    // 0x0930(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URamDoorActivity*                       RamDoorActivity;                                   // 0x0938(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShotgunDoorActivity*                   ShotgunDoorActivity;                               // 0x0940(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UThrowGrenadeThroughDoorActivity*       ThrowGrenadeThroughDoorActivity;                   // 0x0948(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULaunchGrenadeThroughDoorActivity*      LaunchGrenadeThroughDoorActivity;                  // 0x0950(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USearchAndSecureActivity*               SearchAndSecureActivity;                           // 0x0958(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMirrorUnderDoorActivity*               MirrorUnderDoorActivity;                           // 0x0960(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDisarmDoorTrapActivity*                DisarmDoorTrapActivity;                            // 0x0968(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDeployWedgeActivity*                   DeployWedgeActivity;                               // 0x0970(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULockPickDoorActivity*                  LockPickDoorActivity;                              // 0x0978(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UToggleDoorActivity*                    ToggleDoorActivity;                                // 0x0980(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScanDoorActivity*                      ScanDoorActivity;                                  // 0x0988(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTeamCoverAreaActivity*                 CoverAreaActivity;                                 // 0x0990(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USearchLandmarkActivity*                SearchLandmarkActivity;                            // 0x0998(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPickUpCharacterActivity*               PickUpCharacterActivity;                           // 0x09A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTrailerSearchAndSecureActivity*        TrailerSearchAndSecureActivity;                    // 0x09A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEngageTargetLessLethalActivity*        EngageLessLethalActivity;                          // 0x09B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UArrestTargetActivity* GetArrestTargetActivity() const;
	class UTeamBreachAndClearActivity* GetBreachAndClearActivity() const;
	class UC2DoorActivity* GetC2DoorActivity() const;
	class UCollectEvidenceActivity* GetCollectEvidenceActivity() const;
	class UTeamCoverAreaActivity* GetCoverAreaActivity() const;
	class UDeployChemlightActivity* GetDeployChemlightActivity() const;
	class UDeployGrenadeAtLocationActivity* GetDeployGrenadeAtLocationActivity() const;
	class UDeployWedgeActivity* GetDeployWedgeActivity() const;
	class UDisarmDoorTrapActivity* GetDisarmDoorTrapActivity() const;
	class UDisarmStandaloneTrapActivity* GetDisarmStandaloneTrapActivity() const;
	class UEngageTargetLessLethalActivity* GetEngageLessLethalActivity() const;
	class UTeamFallinActivity* GetFallinActivity() const;
	class UHoldActivity* GetHoldActivity() const;
	class UKickDoorActivity* GetKickDoorActivity() const;
	class ULaunchGrenadeThroughDoorActivity* GetLaunchGrenadeThroughDoorActivity() const;
	class ULockPickDoorActivity* GetLockPickDoorDoorActivity() const;
	class UMirrorUnderDoorActivity* GetMirrorUnderDoorActivity() const;
	class UPickUpCharacterActivity* GetPickUpCharacterActivity() const;
	class URamDoorActivity* GetRamDoorActivity() const;
	class UReportTargetActivity* GetReportTargetActivity() const;
	class UScanDoorActivity* GetScanDoorActivity() const;
	class USearchAndSecureActivity* GetSearchAndSecureActivity() const;
	class USearchLandmarkActivity* GetSearchLandmarkActivity() const;
	class UShotgunDoorActivity* GetShotgunDoorActivity() const;
	class UTeamStackUpActivity* GetStackUpActivity() const;
	class UThrowGrenadeThroughDoorActivity* GetThrowGrenadeThroughDoorActivity() const;
	class UToggleDoorActivity* GetToggleDoorActivity() const;
	class UTrailerSearchAndSecureActivity* GetTrailerSearchAndSecureActivity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SWATController">();
	}
	static class ASWATController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASWATController>();
	}
};
static_assert(alignof(ASWATController) == 0x000008, "Wrong alignment on ASWATController");
static_assert(sizeof(ASWATController) == 0x0009B8, "Wrong size on ASWATController");
static_assert(offsetof(ASWATController, FallinActivity) == 0x0008D8, "Member 'ASWATController::FallinActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, ArrestTargetActivity) == 0x0008E0, "Member 'ASWATController::ArrestTargetActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, StackUpActivity) == 0x0008E8, "Member 'ASWATController::StackUpActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, BreachAndClearActivity) == 0x0008F0, "Member 'ASWATController::BreachAndClearActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, DeployChemlightActivity) == 0x0008F8, "Member 'ASWATController::DeployChemlightActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, HoldActivity) == 0x000900, "Member 'ASWATController::HoldActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, ReportTargetActivity) == 0x000908, "Member 'ASWATController::ReportTargetActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, CollectEvidenceActivity) == 0x000910, "Member 'ASWATController::CollectEvidenceActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, DisarmStandaloneTrapActivity) == 0x000918, "Member 'ASWATController::DisarmStandaloneTrapActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, DeployGrenadeAtLocationActivity) == 0x000920, "Member 'ASWATController::DeployGrenadeAtLocationActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, KickDoorActivity) == 0x000928, "Member 'ASWATController::KickDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, C2DoorActivity) == 0x000930, "Member 'ASWATController::C2DoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, RamDoorActivity) == 0x000938, "Member 'ASWATController::RamDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, ShotgunDoorActivity) == 0x000940, "Member 'ASWATController::ShotgunDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, ThrowGrenadeThroughDoorActivity) == 0x000948, "Member 'ASWATController::ThrowGrenadeThroughDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, LaunchGrenadeThroughDoorActivity) == 0x000950, "Member 'ASWATController::LaunchGrenadeThroughDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, SearchAndSecureActivity) == 0x000958, "Member 'ASWATController::SearchAndSecureActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, MirrorUnderDoorActivity) == 0x000960, "Member 'ASWATController::MirrorUnderDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, DisarmDoorTrapActivity) == 0x000968, "Member 'ASWATController::DisarmDoorTrapActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, DeployWedgeActivity) == 0x000970, "Member 'ASWATController::DeployWedgeActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, LockPickDoorActivity) == 0x000978, "Member 'ASWATController::LockPickDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, ToggleDoorActivity) == 0x000980, "Member 'ASWATController::ToggleDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, ScanDoorActivity) == 0x000988, "Member 'ASWATController::ScanDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, CoverAreaActivity) == 0x000990, "Member 'ASWATController::CoverAreaActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, SearchLandmarkActivity) == 0x000998, "Member 'ASWATController::SearchLandmarkActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, PickUpCharacterActivity) == 0x0009A0, "Member 'ASWATController::PickUpCharacterActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, TrailerSearchAndSecureActivity) == 0x0009A8, "Member 'ASWATController::TrailerSearchAndSecureActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, EngageLessLethalActivity) == 0x0009B0, "Member 'ASWATController::EngageLessLethalActivity' has a wrong offset!");

// Class ReadyOrNot.ConsoleMagSelectionItem
// 0x0030 (0x0290 - 0x0260)
class UConsoleMagSelectionItem : public UUserWidget
{
public:
	class UMaterial*                              MagazineMaterial;                                  // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 MagazineIcon;                                      // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 SelectedIcon;                                      // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             MagazineText;                                      // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MagazineMaterialDynamic;                           // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2242[0x8];                                     // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetMagIndex();
	void SetMagIndex(int32 Param_Index);
	void SetSelected(bool bCond);
	void UpdateMagPercentage(float Percentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleMagSelectionItem">();
	}
	static class UConsoleMagSelectionItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleMagSelectionItem>();
	}
};
static_assert(alignof(UConsoleMagSelectionItem) == 0x000008, "Wrong alignment on UConsoleMagSelectionItem");
static_assert(sizeof(UConsoleMagSelectionItem) == 0x000290, "Wrong size on UConsoleMagSelectionItem");
static_assert(offsetof(UConsoleMagSelectionItem, MagazineMaterial) == 0x000260, "Member 'UConsoleMagSelectionItem::MagazineMaterial' has a wrong offset!");
static_assert(offsetof(UConsoleMagSelectionItem, MagazineIcon) == 0x000268, "Member 'UConsoleMagSelectionItem::MagazineIcon' has a wrong offset!");
static_assert(offsetof(UConsoleMagSelectionItem, SelectedIcon) == 0x000270, "Member 'UConsoleMagSelectionItem::SelectedIcon' has a wrong offset!");
static_assert(offsetof(UConsoleMagSelectionItem, MagazineText) == 0x000278, "Member 'UConsoleMagSelectionItem::MagazineText' has a wrong offset!");
static_assert(offsetof(UConsoleMagSelectionItem, MagazineMaterialDynamic) == 0x000280, "Member 'UConsoleMagSelectionItem::MagazineMaterialDynamic' has a wrong offset!");

// Class ReadyOrNot.ArrestAndRescueGM
// 0x0040 (0x0810 - 0x07D0)
class AArrestAndRescueGM final  : public AReadyOrNotGameMode_PVP
{
public:
	bool                                          bSuddenDeath;                                      // 0x07D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2243[0x7];                                     // 0x07D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerCharacter*>               ArrestedBlueCharacters;                            // 0x07D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class APlayerCharacter*>               ArrestedRedCharacters;                             // 0x07E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFMODEvent*                             VIPArrestedSound;                                  // 0x07F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             VIPKilledSound;                                    // 0x0800(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2244[0x8];                                     // 0x0808(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrestAndRescueGM">();
	}
	static class AArrestAndRescueGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArrestAndRescueGM>();
	}
};
static_assert(alignof(AArrestAndRescueGM) == 0x000010, "Wrong alignment on AArrestAndRescueGM");
static_assert(sizeof(AArrestAndRescueGM) == 0x000810, "Wrong size on AArrestAndRescueGM");
static_assert(offsetof(AArrestAndRescueGM, bSuddenDeath) == 0x0007D0, "Member 'AArrestAndRescueGM::bSuddenDeath' has a wrong offset!");
static_assert(offsetof(AArrestAndRescueGM, ArrestedBlueCharacters) == 0x0007D8, "Member 'AArrestAndRescueGM::ArrestedBlueCharacters' has a wrong offset!");
static_assert(offsetof(AArrestAndRescueGM, ArrestedRedCharacters) == 0x0007E8, "Member 'AArrestAndRescueGM::ArrestedRedCharacters' has a wrong offset!");
static_assert(offsetof(AArrestAndRescueGM, VIPArrestedSound) == 0x0007F8, "Member 'AArrestAndRescueGM::VIPArrestedSound' has a wrong offset!");
static_assert(offsetof(AArrestAndRescueGM, VIPKilledSound) == 0x000800, "Member 'AArrestAndRescueGM::VIPKilledSound' has a wrong offset!");

// Class ReadyOrNot.ConsoleFireModes
// 0x0020 (0x0280 - 0x0260)
class UConsoleFireModes final  : public UUserWidget
{
public:
	class UUserWidget*                            FireModeSafe;                                      // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            FireModeSingle;                                    // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            FireModeBurst;                                     // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            FireModeAuto;                                      // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnEquipped(class ABaseItem* Item);
	void OnFireModeChanged(class APlayerCharacter* PlayerCharacter, EFireMode NewFireMode, EFireMode LastFireMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleFireModes">();
	}
	static class UConsoleFireModes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleFireModes>();
	}
};
static_assert(alignof(UConsoleFireModes) == 0x000008, "Wrong alignment on UConsoleFireModes");
static_assert(sizeof(UConsoleFireModes) == 0x000280, "Wrong size on UConsoleFireModes");
static_assert(offsetof(UConsoleFireModes, FireModeSafe) == 0x000260, "Member 'UConsoleFireModes::FireModeSafe' has a wrong offset!");
static_assert(offsetof(UConsoleFireModes, FireModeSingle) == 0x000268, "Member 'UConsoleFireModes::FireModeSingle' has a wrong offset!");
static_assert(offsetof(UConsoleFireModes, FireModeBurst) == 0x000270, "Member 'UConsoleFireModes::FireModeBurst' has a wrong offset!");
static_assert(offsetof(UConsoleFireModes, FireModeAuto) == 0x000278, "Member 'UConsoleFireModes::FireModeAuto' has a wrong offset!");

// Class ReadyOrNot.ArrestAndRescueGS
// 0x0008 (0x07E8 - 0x07E0)
class AArrestAndRescueGS final  : public AReadyOrNotGameState
{
public:
	int32                                         BlueRespawnWaves;                                  // 0x07E0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RedRespawnWaves;                                   // 0x07E4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrestAndRescueGS">();
	}
	static class AArrestAndRescueGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArrestAndRescueGS>();
	}
};
static_assert(alignof(AArrestAndRescueGS) == 0x000008, "Wrong alignment on AArrestAndRescueGS");
static_assert(sizeof(AArrestAndRescueGS) == 0x0007E8, "Wrong size on AArrestAndRescueGS");
static_assert(offsetof(AArrestAndRescueGS, BlueRespawnWaves) == 0x0007E0, "Member 'AArrestAndRescueGS::BlueRespawnWaves' has a wrong offset!");
static_assert(offsetof(AArrestAndRescueGS, RedRespawnWaves) == 0x0007E4, "Member 'AArrestAndRescueGS::RedRespawnWaves' has a wrong offset!");

// Class ReadyOrNot.CommonRichTextBlockImageDecorator
// 0x0050 (0x0080 - 0x0030)
class UCommonRichTextBlockImageDecorator : public URichTextBlockImageDecorator
{
public:
	uint8                                         Pad_2246[0x50];                                    // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonRichTextBlockImageDecorator">();
	}
	static class UCommonRichTextBlockImageDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonRichTextBlockImageDecorator>();
	}
};
static_assert(alignof(UCommonRichTextBlockImageDecorator) == 0x000008, "Wrong alignment on UCommonRichTextBlockImageDecorator");
static_assert(sizeof(UCommonRichTextBlockImageDecorator) == 0x000080, "Wrong size on UCommonRichTextBlockImageDecorator");

// Class ReadyOrNot.ArrestTargetActivity
// 0x0020 (0x01C8 - 0x01A8)
class UArrestTargetActivity final  : public UBaseActivity
{
public:
	class ACyberneticCharacter*                   ArrestTarget;                                      // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractionsData*                      ArrestInteraction;                                 // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2247[0x10];                                    // 0x01B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterArrestStage();
	void EnterMoveToStage();
	void OnArresterKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void TickArrestStage(float DeltaTime, float Uptime);

	bool CanArrest() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrestTargetActivity">();
	}
	static class UArrestTargetActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArrestTargetActivity>();
	}
};
static_assert(alignof(UArrestTargetActivity) == 0x000008, "Wrong alignment on UArrestTargetActivity");
static_assert(sizeof(UArrestTargetActivity) == 0x0001C8, "Wrong size on UArrestTargetActivity");
static_assert(offsetof(UArrestTargetActivity, ArrestTarget) == 0x0001A8, "Member 'UArrestTargetActivity::ArrestTarget' has a wrong offset!");
static_assert(offsetof(UArrestTargetActivity, ArrestInteraction) == 0x0001B0, "Member 'UArrestTargetActivity::ArrestInteraction' has a wrong offset!");

// Class ReadyOrNot.ConsoleLobbyManager
// 0x0008 (0x0328 - 0x0320)
class UConsoleLobbyManager : public UMenuWidget
{
public:
	class UCommonActivatableWidgetStack*          WidgetStack;                                       // 0x0320(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetLobbyPrivacy(ELobbyPrivacy Privacy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleLobbyManager">();
	}
	static class UConsoleLobbyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleLobbyManager>();
	}
};
static_assert(alignof(UConsoleLobbyManager) == 0x000008, "Wrong alignment on UConsoleLobbyManager");
static_assert(sizeof(UConsoleLobbyManager) == 0x000328, "Wrong size on UConsoleLobbyManager");
static_assert(offsetof(UConsoleLobbyManager, WidgetStack) == 0x000320, "Member 'UConsoleLobbyManager::WidgetStack' has a wrong offset!");

// Class ReadyOrNot.ArmourMaterial
// 0x0098 (0x00C8 - 0x0030)
class UArmourMaterial final  : public UPrimaryDataAsset
{
public:
	float                                         DamageReduction;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDamageReduction;                                // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDurabilityEnabled;                                // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2248[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Durability;                                        // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ArmourLevel;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpallingChance;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeedModifier;                             // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementAccelerationModifier;                      // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        HitParticle;                                       // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2249[0x4];                                     // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              LoadoutIcon;                                       // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EGameVersionRestriction>               LockedToDLC;                                       // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmourMaterial">();
	}
	static class UArmourMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmourMaterial>();
	}
};
static_assert(alignof(UArmourMaterial) == 0x000008, "Wrong alignment on UArmourMaterial");
static_assert(sizeof(UArmourMaterial) == 0x0000C8, "Wrong size on UArmourMaterial");
static_assert(offsetof(UArmourMaterial, DamageReduction) == 0x000030, "Member 'UArmourMaterial::DamageReduction' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, MinDamageReduction) == 0x000034, "Member 'UArmourMaterial::MinDamageReduction' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, bDurabilityEnabled) == 0x000038, "Member 'UArmourMaterial::bDurabilityEnabled' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, Durability) == 0x00003C, "Member 'UArmourMaterial::Durability' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, ArmourLevel) == 0x000040, "Member 'UArmourMaterial::ArmourLevel' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, SpallingChance) == 0x000044, "Member 'UArmourMaterial::SpallingChance' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, MovementSpeedModifier) == 0x000048, "Member 'UArmourMaterial::MovementSpeedModifier' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, MovementAccelerationModifier) == 0x00004C, "Member 'UArmourMaterial::MovementAccelerationModifier' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, HitParticle) == 0x000050, "Member 'UArmourMaterial::HitParticle' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, DisplayName) == 0x000058, "Member 'UArmourMaterial::DisplayName' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, Priority) == 0x000070, "Member 'UArmourMaterial::Priority' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, Description) == 0x000078, "Member 'UArmourMaterial::Description' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, LoadoutIcon) == 0x000090, "Member 'UArmourMaterial::LoadoutIcon' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, LockedToDLC) == 0x0000B8, "Member 'UArmourMaterial::LockedToDLC' has a wrong offset!");

// Class ReadyOrNot.ArrestXSuspects
// 0x0008 (0x02B0 - 0x02A8)
class AArrestXSuspects final  : public AObjective
{
public:
	int32                                         RequiredArrests;                                   // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_224A[0x4];                                     // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrestXSuspects">();
	}
	static class AArrestXSuspects* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArrestXSuspects>();
	}
};
static_assert(alignof(AArrestXSuspects) == 0x000008, "Wrong alignment on AArrestXSuspects");
static_assert(sizeof(AArrestXSuspects) == 0x0002B0, "Wrong size on AArrestXSuspects");
static_assert(offsetof(AArrestXSuspects, RequiredArrests) == 0x0002A8, "Member 'AArrestXSuspects::RequiredArrests' has a wrong offset!");

// Class ReadyOrNot.ConsoleSelection
// 0x0028 (0x0288 - 0x0260)
class UConsoleSelection final  : public UUserWidget
{
public:
	class UHorizontalBox*                         Container;                                         // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Button;                                            // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ButtonName;                                        // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EItemCategory                                 ItemCategory;                                      // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_224B[0x7];                                     // 0x0281(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ItemAdded(class ABaseItem* Item);
	void ItemEquipped(class ABaseItem* Item);
	void ItemRemoved(class ABaseItem* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleSelection">();
	}
	static class UConsoleSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleSelection>();
	}
};
static_assert(alignof(UConsoleSelection) == 0x000008, "Wrong alignment on UConsoleSelection");
static_assert(sizeof(UConsoleSelection) == 0x000288, "Wrong size on UConsoleSelection");
static_assert(offsetof(UConsoleSelection, Container) == 0x000260, "Member 'UConsoleSelection::Container' has a wrong offset!");
static_assert(offsetof(UConsoleSelection, Button) == 0x000268, "Member 'UConsoleSelection::Button' has a wrong offset!");
static_assert(offsetof(UConsoleSelection, ButtonName) == 0x000270, "Member 'UConsoleSelection::ButtonName' has a wrong offset!");
static_assert(offsetof(UConsoleSelection, ItemCategory) == 0x000280, "Member 'UConsoleSelection::ItemCategory' has a wrong offset!");

// Class ReadyOrNot.ASequenceInteraction
// 0x0030 (0x02D8 - 0x02A8)
class AASequenceInteraction final  : public ALevelSequenceActor
{
public:
	uint8                                         Pad_224C[0x10];                                    // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoActivateInRange;                              // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224D[0x7];                                     // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReferencedCharacterViewTarget;                     // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          RadiusComp;                                        // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       LastPlayedSequencerCharacter;                      // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnBoxEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnBoxOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void OnSequencerFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASequenceInteraction">();
	}
	static class AASequenceInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AASequenceInteraction>();
	}
};
static_assert(alignof(AASequenceInteraction) == 0x000008, "Wrong alignment on AASequenceInteraction");
static_assert(sizeof(AASequenceInteraction) == 0x0002D8, "Wrong size on AASequenceInteraction");
static_assert(offsetof(AASequenceInteraction, bAutoActivateInRange) == 0x0002B8, "Member 'AASequenceInteraction::bAutoActivateInRange' has a wrong offset!");
static_assert(offsetof(AASequenceInteraction, ReferencedCharacterViewTarget) == 0x0002C0, "Member 'AASequenceInteraction::ReferencedCharacterViewTarget' has a wrong offset!");
static_assert(offsetof(AASequenceInteraction, RadiusComp) == 0x0002C8, "Member 'AASequenceInteraction::RadiusComp' has a wrong offset!");
static_assert(offsetof(AASequenceInteraction, LastPlayedSequencerCharacter) == 0x0002D0, "Member 'AASequenceInteraction::LastPlayedSequencerCharacter' has a wrong offset!");

// Class ReadyOrNot.TocSpeechData
// 0x00B8 (0x00E8 - 0x0030)
class UTocSpeechData final  : public UDataAsset
{
public:
	class USoundCue*                              CivilianIncapacitated;                             // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              CivilianDead;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              CivilianRestrained;                                // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SuspectIncapacitated;                              // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SuspectDead;                                       // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SuspectRestrained;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OfficerDown;                                       // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              DOA;                                               // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SWATVictory;                                       // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SuspectVictory;                                    // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SWATInCustody;                                     // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SuspectInCustody_MP;                               // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SWATReinforcements;                                // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SuspectReinforcements;                             // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BothTeamsReinforcements;                           // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SWATFriendlyFire;                                  // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SuspectFriendlyFire;                               // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             VIPEscorted;                                       // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             VIPExecuted;                                       // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SWATKilledVIP;                                     // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SuspectKilledVIP;                                  // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             VIPInCustody;                                      // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             VIPReleased;                                       // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TocSpeechData">();
	}
	static class UTocSpeechData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTocSpeechData>();
	}
};
static_assert(alignof(UTocSpeechData) == 0x000008, "Wrong alignment on UTocSpeechData");
static_assert(sizeof(UTocSpeechData) == 0x0000E8, "Wrong size on UTocSpeechData");
static_assert(offsetof(UTocSpeechData, CivilianIncapacitated) == 0x000030, "Member 'UTocSpeechData::CivilianIncapacitated' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, CivilianDead) == 0x000038, "Member 'UTocSpeechData::CivilianDead' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, CivilianRestrained) == 0x000040, "Member 'UTocSpeechData::CivilianRestrained' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SuspectIncapacitated) == 0x000048, "Member 'UTocSpeechData::SuspectIncapacitated' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SuspectDead) == 0x000050, "Member 'UTocSpeechData::SuspectDead' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SuspectRestrained) == 0x000058, "Member 'UTocSpeechData::SuspectRestrained' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, OfficerDown) == 0x000060, "Member 'UTocSpeechData::OfficerDown' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, DOA) == 0x000068, "Member 'UTocSpeechData::DOA' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SWATVictory) == 0x000070, "Member 'UTocSpeechData::SWATVictory' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SuspectVictory) == 0x000078, "Member 'UTocSpeechData::SuspectVictory' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SWATInCustody) == 0x000080, "Member 'UTocSpeechData::SWATInCustody' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SuspectInCustody_MP) == 0x000088, "Member 'UTocSpeechData::SuspectInCustody_MP' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SWATReinforcements) == 0x000090, "Member 'UTocSpeechData::SWATReinforcements' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SuspectReinforcements) == 0x000098, "Member 'UTocSpeechData::SuspectReinforcements' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, BothTeamsReinforcements) == 0x0000A0, "Member 'UTocSpeechData::BothTeamsReinforcements' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SWATFriendlyFire) == 0x0000A8, "Member 'UTocSpeechData::SWATFriendlyFire' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SuspectFriendlyFire) == 0x0000B0, "Member 'UTocSpeechData::SuspectFriendlyFire' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, VIPEscorted) == 0x0000B8, "Member 'UTocSpeechData::VIPEscorted' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, VIPExecuted) == 0x0000C0, "Member 'UTocSpeechData::VIPExecuted' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SWATKilledVIP) == 0x0000C8, "Member 'UTocSpeechData::SWATKilledVIP' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SuspectKilledVIP) == 0x0000D0, "Member 'UTocSpeechData::SuspectKilledVIP' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, VIPInCustody) == 0x0000D8, "Member 'UTocSpeechData::VIPInCustody' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, VIPReleased) == 0x0000E0, "Member 'UTocSpeechData::VIPReleased' has a wrong offset!");

// Class ReadyOrNot.AspectRatioConstraintBox
// 0x0018 (0x0138 - 0x0120)
class UAspectRatioConstraintBox final  : public UContentWidget
{
public:
	bool                                          bUseFixedConstraint;                               // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2250[0x3];                                     // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedAspectRatio;                                  // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2251[0x10];                                    // 0x0128(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableConstraint();
	void EnableConstraint();
	void OnSettingsUpdated();
	void SetFixedAspectRatio(float NewAspectRatio);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AspectRatioConstraintBox">();
	}
	static class UAspectRatioConstraintBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAspectRatioConstraintBox>();
	}
};
static_assert(alignof(UAspectRatioConstraintBox) == 0x000008, "Wrong alignment on UAspectRatioConstraintBox");
static_assert(sizeof(UAspectRatioConstraintBox) == 0x000138, "Wrong size on UAspectRatioConstraintBox");
static_assert(offsetof(UAspectRatioConstraintBox, bUseFixedConstraint) == 0x000120, "Member 'UAspectRatioConstraintBox::bUseFixedConstraint' has a wrong offset!");
static_assert(offsetof(UAspectRatioConstraintBox, FixedAspectRatio) == 0x000124, "Member 'UAspectRatioConstraintBox::FixedAspectRatio' has a wrong offset!");

// Class ReadyOrNot.ConsoleHotkeys
// 0x0050 (0x02B0 - 0x0260)
class UConsoleHotkeys : public UUserWidget
{
public:
	class UConsoleHotkey*                         Hotkey_NVG;                                        // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleHotkey*                         Hotkey_Laser;                                      // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleHotkey*                         Hotkey_Firemode;                                   // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleHotkey*                         Hotkey_TeamView;                                   // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleHotkey*                         Hotkey_Chemlight;                                  // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleHotkey*                         Hotkey_ItemWheel;                                  // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2252[0x8];                                     // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABaseItem*                              CurrentItem;                                       // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2253[0x8];                                     // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ItemEquipped(class ABaseItem* Item);
	void RefreshHotkeys();
	void SetLayout(EConsoleHotkeysLayout Layout);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleHotkeys">();
	}
	static class UConsoleHotkeys* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleHotkeys>();
	}
};
static_assert(alignof(UConsoleHotkeys) == 0x000008, "Wrong alignment on UConsoleHotkeys");
static_assert(sizeof(UConsoleHotkeys) == 0x0002B0, "Wrong size on UConsoleHotkeys");
static_assert(offsetof(UConsoleHotkeys, Hotkey_NVG) == 0x000260, "Member 'UConsoleHotkeys::Hotkey_NVG' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, Hotkey_Laser) == 0x000268, "Member 'UConsoleHotkeys::Hotkey_Laser' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, Hotkey_Firemode) == 0x000270, "Member 'UConsoleHotkeys::Hotkey_Firemode' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, Hotkey_TeamView) == 0x000278, "Member 'UConsoleHotkeys::Hotkey_TeamView' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, Hotkey_Chemlight) == 0x000280, "Member 'UConsoleHotkeys::Hotkey_Chemlight' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, Hotkey_ItemWheel) == 0x000288, "Member 'UConsoleHotkeys::Hotkey_ItemWheel' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, PlayerCharacter) == 0x000298, "Member 'UConsoleHotkeys::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, CurrentItem) == 0x0002A0, "Member 'UConsoleHotkeys::CurrentItem' has a wrong offset!");

// Class ReadyOrNot.AsyncLoader
// 0x0000 (0x0028 - 0x0028)
class UAsyncLoader final  : public UBlueprintFunctionLibrary
{
public:
	static class UAnimMontage* GetLazyLoadedAnimMontage(TSoftObjectPtr<class UAnimMontage> Montage);
	static class UAnimSequence* GetLazyLoadedAnimSequence(TSoftObjectPtr<class UAnimSequence> Anim);
	static class UClass* GetLazyLoadedClass(TSoftClassPtr<class UClass> Param_Class);
	static TArray<TSubclassOf<class UClass>> GetLazyLoadedClassArray(const TArray<TSoftClassPtr<class UClass>>& Array);
	static class UTexture2D* GetLazyLoadedImage(TSoftObjectPtr<class UTexture2D> Texture);
	static TSubclassOf<class ABaseItem> GetLazyLoadedItem(TSoftClassPtr<class UClass> Item);
	static class UMaterialInstance* GetLazyLoadedMaterialInstance(TSoftObjectPtr<class UMaterialInstance> Material);
	static class UStaticMesh* GetLazyLoadedMesh(TSoftObjectPtr<class UStaticMesh> Mesh);
	static class UObject* GetLazyLoadedObject(TSoftObjectPtr<class UObject> Object);
	static class UParticleSystem* GetLazyLoadedParticleSystem(TSoftObjectPtr<class UParticleSystem> Particle);
	static TArray<TSubclassOf<class AReadyOrNotGameMode>> GetLazyLoadedReadyOrNotGameModeArray(const TArray<TSoftClassPtr<class UClass>>& Array);
	static class USkeletalMesh* GetLazyLoadedSkeletalMesh(TSoftObjectPtr<class USkeletalMesh> Mesh);
	static class USoundCue* GetLazyLoadedSoundCue(TSoftObjectPtr<class USoundCue> Cue);
	static TSubclassOf<class ABaseWeapon> GetLazyLoadedWeapon(TSoftClassPtr<class UClass> Item);
	static TSubclassOf<class UUserWidget> GetLazyLoadedWidget(TSoftClassPtr<class UClass> Widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncLoader">();
	}
	static class UAsyncLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncLoader>();
	}
};
static_assert(alignof(UAsyncLoader) == 0x000008, "Wrong alignment on UAsyncLoader");
static_assert(sizeof(UAsyncLoader) == 0x000028, "Wrong size on UAsyncLoader");

// Class ReadyOrNot.AttachmentSlot_V2
// 0x0048 (0x02D0 - 0x0288)
class UAttachmentSlot_V2 final  : public UCommonUserWidget
{
public:
	EWeaponAttachmentType                         AttachmentType;                                    // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2254[0x7];                                     // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ItemImage;                                         // 0x0290(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             EmptyImage;                                        // 0x0298(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ItemName;                                          // 0x02A0(0x0018)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemType;                                          // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWeaponAttachment*                      Attachment;                                        // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Equipped;                                          // 0x02C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2255[0x7];                                     // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TSubclassOf<class UWeaponAttachment> GetAttachment();
	EWeaponAttachmentType GetAttachmentType();
	bool GetEquipped();
	void OnEquipped();
	void RefreshAttachmentInfo();
	void SetAttachment(class UWeaponAttachment* WeaponAttachment);
	void SetAttachmentType(EWeaponAttachmentType Type);
	void SetEquipped(bool IsEquipped);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachmentSlot_V2">();
	}
	static class UAttachmentSlot_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttachmentSlot_V2>();
	}
};
static_assert(alignof(UAttachmentSlot_V2) == 0x000008, "Wrong alignment on UAttachmentSlot_V2");
static_assert(sizeof(UAttachmentSlot_V2) == 0x0002D0, "Wrong size on UAttachmentSlot_V2");
static_assert(offsetof(UAttachmentSlot_V2, AttachmentType) == 0x000288, "Member 'UAttachmentSlot_V2::AttachmentType' has a wrong offset!");
static_assert(offsetof(UAttachmentSlot_V2, ItemImage) == 0x000290, "Member 'UAttachmentSlot_V2::ItemImage' has a wrong offset!");
static_assert(offsetof(UAttachmentSlot_V2, EmptyImage) == 0x000298, "Member 'UAttachmentSlot_V2::EmptyImage' has a wrong offset!");
static_assert(offsetof(UAttachmentSlot_V2, ItemName) == 0x0002A0, "Member 'UAttachmentSlot_V2::ItemName' has a wrong offset!");
static_assert(offsetof(UAttachmentSlot_V2, ItemType) == 0x0002B8, "Member 'UAttachmentSlot_V2::ItemType' has a wrong offset!");
static_assert(offsetof(UAttachmentSlot_V2, Attachment) == 0x0002C0, "Member 'UAttachmentSlot_V2::Attachment' has a wrong offset!");
static_assert(offsetof(UAttachmentSlot_V2, Equipped) == 0x0002C8, "Member 'UAttachmentSlot_V2::Equipped' has a wrong offset!");

// Class ReadyOrNot.Conversation
// 0x0058 (0x0080 - 0x0028)
class UConversation final  : public UObject
{
public:
	uint8                                         Pad_2256[0x18];                                    // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConversationData>              ConversationData;                                  // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2257[0x10];                                    // 0x0050(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnConversationContinuing;                          // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndConversation;                                 // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void BeginConversation(class ACyberneticCharacter* ConversationStarter, class FName ID);
	void BuildConversation(class FName ID);
	void ContinueConversation();
	struct FConversationData GetConversationData();
	class ACyberneticCharacter* GetSpeakerForConversationIdx(int32 Idx);
	class ACyberneticCharacter* GetSpeakerForId(class FName ID);
	void GiveWorldBuildingActivityByTag(class FName SpeakerId, class FName Tag);
	void GoToSpecificConversationIdAndContinueConversation(int32 Idx);
	void OnConversationContinuing__DelegateSignature(int32 Idx);
	void OnEndConversation__DelegateSignature();
	void ReplyToConversation(class AReadyOrNotCharacter* Speaker);
	bool RequirementsMet();
	void TryGetSpeakers();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Conversation">();
	}
	static class UConversation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConversation>();
	}
};
static_assert(alignof(UConversation) == 0x000008, "Wrong alignment on UConversation");
static_assert(sizeof(UConversation) == 0x000080, "Wrong size on UConversation");
static_assert(offsetof(UConversation, ConversationData) == 0x000040, "Member 'UConversation::ConversationData' has a wrong offset!");
static_assert(offsetof(UConversation, OnConversationContinuing) == 0x000060, "Member 'UConversation::OnConversationContinuing' has a wrong offset!");
static_assert(offsetof(UConversation, OnEndConversation) == 0x000070, "Member 'UConversation::OnEndConversation' has a wrong offset!");

// Class ReadyOrNot.BadAIAction
// 0x0060 (0x0280 - 0x0220)
class ABadAIAction final  : public AActor
{
public:
	class FText                                   Summary;                                           // 0x0220(0x0018)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0238(0x0018)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_2259[0x8];                                     // 0x0250(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBillboardComponent*                    BillboardComponent;                                // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_225A[0x20];                                    // 0x0260(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddNote(class FText& InSummary, class FText& InDescription);
	void RemoveBadAIAction();
	void RemoveReport(bool bReportToLog, bool bDrawString);
	void Report(bool bReportToLog, bool bDrawString);
	void ReportBadAIAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BadAIAction">();
	}
	static class ABadAIAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABadAIAction>();
	}
};
static_assert(alignof(ABadAIAction) == 0x000008, "Wrong alignment on ABadAIAction");
static_assert(sizeof(ABadAIAction) == 0x000280, "Wrong size on ABadAIAction");
static_assert(offsetof(ABadAIAction, Summary) == 0x000220, "Member 'ABadAIAction::Summary' has a wrong offset!");
static_assert(offsetof(ABadAIAction, Description) == 0x000238, "Member 'ABadAIAction::Description' has a wrong offset!");
static_assert(offsetof(ABadAIAction, BillboardComponent) == 0x000258, "Member 'ABadAIAction::BillboardComponent' has a wrong offset!");

// Class ReadyOrNot.TeamBaseActivity
// 0x0010 (0x01B8 - 0x01A8)
class UTeamBaseActivity : public UBaseActivity
{
public:
	ESquadPosition                                OverrideSquadPosition;                             // 0x01A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESquadPosition                                PreviousSquadPosition;                             // 0x01A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSwapping;                                       // 0x01AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_225B[0xD];                                     // 0x01AB(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACyberneticCharacter* GetCharacterAtSquadPosition(ESquadPosition SquadPosition) const;
	class ACyberneticCharacter* GetCharacterClosestToCharacter(class ACyberneticCharacter* InCharacter) const;
	class ACyberneticCharacter* GetCharacterClosestToLocation(struct FVector& TestLocation) const;
	class ACyberneticCharacter* GetCharacterWithItem(TSubclassOf<class ABaseItem> ItemClass) const;
	class AReadyOrNotCharacter* GetSquadLeader() const;
	bool HasTeamReachedPosition(float Tolerance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamBaseActivity">();
	}
	static class UTeamBaseActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamBaseActivity>();
	}
};
static_assert(alignof(UTeamBaseActivity) == 0x000008, "Wrong alignment on UTeamBaseActivity");
static_assert(sizeof(UTeamBaseActivity) == 0x0001B8, "Wrong size on UTeamBaseActivity");
static_assert(offsetof(UTeamBaseActivity, OverrideSquadPosition) == 0x0001A8, "Member 'UTeamBaseActivity::OverrideSquadPosition' has a wrong offset!");
static_assert(offsetof(UTeamBaseActivity, PreviousSquadPosition) == 0x0001A9, "Member 'UTeamBaseActivity::PreviousSquadPosition' has a wrong offset!");
static_assert(offsetof(UTeamBaseActivity, bIsSwapping) == 0x0001AA, "Member 'UTeamBaseActivity::bIsSwapping' has a wrong offset!");

// Class ReadyOrNot.TeamStackUpActivity
// 0x0040 (0x01F8 - 0x01B8)
class UTeamStackUpActivity : public UTeamBaseActivity
{
public:
	class AStackUpActor*                          OccupiedStackUpActor;                              // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_225F[0x38];                                    // 0x01C0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterCheckStage();
	void EnterStackedStage();
	void EnterStackupStage();
	void ExitCheckStage();
	void ExitStackupStage();
	void OnDoorChecked();
	void OnDoorOpened();
	void PerformCheckStage(float DeltaTime, float Uptime);
	void PerformStackedStage(float DeltaTime, float Uptime);
	void PerformStackUpStage(float DeltaTime, float Uptime);

	bool CanPerformCheck() const;
	class ACyberneticCharacter* GetCharacterAtHighestSquadPositionInStackUpArea(EStackupGenArea StackupArea) const;
	class ACyberneticCharacter* GetCharacterAtSquadPositionInStackUpArea(ESquadPosition SquadPosition, EStackupGenArea StackupArea) const;
	bool IsCheckFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamStackUpActivity">();
	}
	static class UTeamStackUpActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamStackUpActivity>();
	}
};
static_assert(alignof(UTeamStackUpActivity) == 0x000008, "Wrong alignment on UTeamStackUpActivity");
static_assert(sizeof(UTeamStackUpActivity) == 0x0001F8, "Wrong size on UTeamStackUpActivity");
static_assert(offsetof(UTeamStackUpActivity, OccupiedStackUpActor) == 0x0001B8, "Member 'UTeamStackUpActivity::OccupiedStackUpActor' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotCSGasSettings
// 0x0028 (0x0060 - 0x0038)
class UReadyOrNotCSGasSettings final  : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UCSGasData>              GasDataAsset;                                      // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotCSGasSettings">();
	}
	static class UReadyOrNotCSGasSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotCSGasSettings>();
	}
};
static_assert(alignof(UReadyOrNotCSGasSettings) == 0x000008, "Wrong alignment on UReadyOrNotCSGasSettings");
static_assert(sizeof(UReadyOrNotCSGasSettings) == 0x000060, "Wrong size on UReadyOrNotCSGasSettings");
static_assert(offsetof(UReadyOrNotCSGasSettings, GasDataAsset) == 0x000038, "Member 'UReadyOrNotCSGasSettings::GasDataAsset' has a wrong offset!");

// Class ReadyOrNot.BaseDeployableGear
// 0x0000 (0x09D0 - 0x09D0)
class ABaseDeployableGear : public ABaseItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseDeployableGear">();
	}
	static class ABaseDeployableGear* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseDeployableGear>();
	}
};
static_assert(alignof(ABaseDeployableGear) == 0x000010, "Wrong alignment on ABaseDeployableGear");
static_assert(sizeof(ABaseDeployableGear) == 0x0009D0, "Wrong size on ABaseDeployableGear");

// Class ReadyOrNot.BallisticsShield
// 0x0040 (0x0A10 - 0x09D0)
class ABallisticsShield : public ABaseDeployableGear
{
public:
	class UMaterialInstanceDynamic*               GlassMaterialInstance;                             // 0x09D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseMagazineWeapon*                    PistolEquippedWithShield;                          // 0x09D8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2262[0x8];                                     // 0x09E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             ShieldHitEvent;                                    // 0x09E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage;                                            // 0x09F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlassPhaseParam;                                   // 0x09F4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2263[0x2];                                     // 0x09F8(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLowered;                                          // 0x09FA(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2264[0x5];                                     // 0x09FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMatineeCameraShake>        ShieldHitCameraShake;                              // 0x0A00(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2265[0x8];                                     // 0x0A08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_PlayShieldHitSound();
	void Client_SetPistol(class ABaseItem* NewPistol);
	void OnTPShieldHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit);
	void Server_SetLowered(bool bShouldLower);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BallisticsShield">();
	}
	static class ABallisticsShield* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABallisticsShield>();
	}
};
static_assert(alignof(ABallisticsShield) == 0x000010, "Wrong alignment on ABallisticsShield");
static_assert(sizeof(ABallisticsShield) == 0x000A10, "Wrong size on ABallisticsShield");
static_assert(offsetof(ABallisticsShield, GlassMaterialInstance) == 0x0009D0, "Member 'ABallisticsShield::GlassMaterialInstance' has a wrong offset!");
static_assert(offsetof(ABallisticsShield, PistolEquippedWithShield) == 0x0009D8, "Member 'ABallisticsShield::PistolEquippedWithShield' has a wrong offset!");
static_assert(offsetof(ABallisticsShield, ShieldHitEvent) == 0x0009E8, "Member 'ABallisticsShield::ShieldHitEvent' has a wrong offset!");
static_assert(offsetof(ABallisticsShield, Damage) == 0x0009F0, "Member 'ABallisticsShield::Damage' has a wrong offset!");
static_assert(offsetof(ABallisticsShield, GlassPhaseParam) == 0x0009F4, "Member 'ABallisticsShield::GlassPhaseParam' has a wrong offset!");
static_assert(offsetof(ABallisticsShield, bLowered) == 0x0009FA, "Member 'ABallisticsShield::bLowered' has a wrong offset!");
static_assert(offsetof(ABallisticsShield, ShieldHitCameraShake) == 0x000A00, "Member 'ABallisticsShield::ShieldHitCameraShake' has a wrong offset!");

// Class ReadyOrNot.CoverFinderRenderingComponent
// 0x00B0 (0x0500 - 0x0450)
class UCoverFinderRenderingComponent final  : public UPrimitiveComponent
{
public:
	uint8                                         Pad_2267[0xB0];                                    // 0x0450(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverFinderRenderingComponent">();
	}
	static class UCoverFinderRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoverFinderRenderingComponent>();
	}
};
static_assert(alignof(UCoverFinderRenderingComponent) == 0x000010, "Wrong alignment on UCoverFinderRenderingComponent");
static_assert(sizeof(UCoverFinderRenderingComponent) == 0x000500, "Wrong size on UCoverFinderRenderingComponent");

// Class ReadyOrNot.BaseArmour
// 0x0070 (0x0A40 - 0x09D0)
class ABaseArmour : public ABaseItem
{
public:
	bool                                          bIsHeavy;                                          // 0x09D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2268[0x3];                                     // 0x09D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleLensFlare;                                    // 0x09D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMesh*>                  Variations;                                        // 0x09D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ArmourHitParticle;                                 // 0x09E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ArmourHitSound;                                    // 0x09F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ArmourHitSoundFirstPerson;                         // 0x09F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PaperdollTexture;                                  // 0x0A00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PaperdollTexture_Crouch;                           // 0x0A08(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PaperdollTexture_Carry;                            // 0x0A10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PaperdollTexture_Carry_Crouch;                     // 0x0A18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        InterceptShakeFront;                               // 0x0A20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        InterceptShakeBack;                                // 0x0A28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        InterceptShakeLeft;                                // 0x0A30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        InterceptShakeRight;                               // 0x0A38(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float GetDurabilityPercentage() const;
	bool HasRemainingProtection() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseArmour">();
	}
	static class ABaseArmour* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseArmour>();
	}
};
static_assert(alignof(ABaseArmour) == 0x000010, "Wrong alignment on ABaseArmour");
static_assert(sizeof(ABaseArmour) == 0x000A40, "Wrong size on ABaseArmour");
static_assert(offsetof(ABaseArmour, bIsHeavy) == 0x0009D0, "Member 'ABaseArmour::bIsHeavy' has a wrong offset!");
static_assert(offsetof(ABaseArmour, ScaleLensFlare) == 0x0009D4, "Member 'ABaseArmour::ScaleLensFlare' has a wrong offset!");
static_assert(offsetof(ABaseArmour, Variations) == 0x0009D8, "Member 'ABaseArmour::Variations' has a wrong offset!");
static_assert(offsetof(ABaseArmour, ArmourHitParticle) == 0x0009E8, "Member 'ABaseArmour::ArmourHitParticle' has a wrong offset!");
static_assert(offsetof(ABaseArmour, ArmourHitSound) == 0x0009F0, "Member 'ABaseArmour::ArmourHitSound' has a wrong offset!");
static_assert(offsetof(ABaseArmour, ArmourHitSoundFirstPerson) == 0x0009F8, "Member 'ABaseArmour::ArmourHitSoundFirstPerson' has a wrong offset!");
static_assert(offsetof(ABaseArmour, PaperdollTexture) == 0x000A00, "Member 'ABaseArmour::PaperdollTexture' has a wrong offset!");
static_assert(offsetof(ABaseArmour, PaperdollTexture_Crouch) == 0x000A08, "Member 'ABaseArmour::PaperdollTexture_Crouch' has a wrong offset!");
static_assert(offsetof(ABaseArmour, PaperdollTexture_Carry) == 0x000A10, "Member 'ABaseArmour::PaperdollTexture_Carry' has a wrong offset!");
static_assert(offsetof(ABaseArmour, PaperdollTexture_Carry_Crouch) == 0x000A18, "Member 'ABaseArmour::PaperdollTexture_Carry_Crouch' has a wrong offset!");
static_assert(offsetof(ABaseArmour, InterceptShakeFront) == 0x000A20, "Member 'ABaseArmour::InterceptShakeFront' has a wrong offset!");
static_assert(offsetof(ABaseArmour, InterceptShakeBack) == 0x000A28, "Member 'ABaseArmour::InterceptShakeBack' has a wrong offset!");
static_assert(offsetof(ABaseArmour, InterceptShakeLeft) == 0x000A30, "Member 'ABaseArmour::InterceptShakeLeft' has a wrong offset!");
static_assert(offsetof(ABaseArmour, InterceptShakeRight) == 0x000A38, "Member 'ABaseArmour::InterceptShakeRight' has a wrong offset!");

// Class ReadyOrNot.BaseCombatActivity
// 0x0278 (0x0420 - 0x01A8)
class UBaseCombatActivity : public UBaseActivity
{
public:
	FMulticastInlineDelegateProperty_             OnTrackNewEnemy;                                   // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FScriptedFireAt                        CurrentScriptedFireAt;                             // 0x01B8(0x0028)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FScriptedLookAt                        CurrentScriptedLookAt;                             // 0x01E0(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2269[0x8];                                     // 0x01F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FleeDesire;                                        // 0x0200(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSincePerformingAnyCombatMove;                  // 0x0204(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimePerformingAnyCombatMove;                       // 0x0208(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_226A[0x4];                                     // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTraverseHoleActivity*                  TraverseHoleActivity;                              // 0x0210(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBaseCombatMoveActivity*                CombatMoveActivity;                                // 0x0218(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBaseCombatMoveActivity*                PreviousCombatMoveActivity;                        // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHardCoverCombatMove*                   HardCoverCombatMove;                               // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDuelingCombatMove*                     DuelingCombatMove;                                 // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFlankingCombatMove*                    FlankingCombatMove;                                // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USuppressionCombatMove*                 SuppressionCombatMove;                             // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPushCombatMove*                        PushCombatMove;                                    // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChargeCombatMove*                      ChargeCombatMove;                                  // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFleeingCombatMove*                     FleeingCombatMove;                                 // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URepositionCombatMove*                  RepositionCombatMove;                              // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_226B[0x18];                                    // 0x0268(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoverLandmarkEvaluationCooldown;                   // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_226C[0x4];                                     // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   LastTrackedEnemy;                                  // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_226D[0x10];                                    // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPickupItemActivity*                    PickupItemActivity;                                // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UReloadSafelyActivity*                  ReloadSafelyActivity;                              // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayDeadActivity*                      PlayDeadActivity;                                  // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommitSuicideActivity*                 CommitSuicideActivity;                             // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_226E[0x160];                                   // 0x02C0(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterNoStrafeState();
	void EnterStrafeState();
	void FinishCombatMove(bool bSuccess);
	void OnCoverExit();
	void OnCoverFound();
	void OnCoverLandmarkExit();
	void OnNoCoverFound();
	void OnRequestCover();
	void OnRequestCoverLandmark();
	void OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnSuicideFakeOutSuccess();
	void OnTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnTrackNewEnemy__DelegateSignature(class AReadyOrNotCharacter* NewTrackedEnemy);
	void PerformNoStrafeLogic(float DeltaTime, float Uptime);
	void PerformStrafeLogic(float DeltaTime, float Uptime);
	void PlayDeadFinished(class UBaseActivity* Activity, class ACyberneticController* Controller);
	void PlayDeadStarted(class UBaseActivity* Activity, class ACyberneticController* Controller);
	void ScriptedFireAtActor(class AActor* InActor, float InTime, bool bOverrideTarget, float AccuracyPenaltyMultiplier, bool bInfiniteAmmo);
	void ScriptedFireAtLocation(const struct FVector& InLocation, float InTime, bool bOverrideTarget, float AccuracyPenaltyMultiplier, bool bInfiniteAmmo);
	void ScriptedLookAtActor(class AActor* InActor, float InTime);
	void ScriptedLookAtLocation(const struct FVector& InLocation, float InTime);
	void StartRunningCombatMove(class UBaseCombatMoveActivity* CombatMove);
	void StopScriptedFire();
	void StopScriptedLook();
	void TrackEnemyFire(class AReadyOrNotCharacter* FromCharacter, class ABaseMagazineWeapon* Weapon, const struct FVector& FireDirection);
	void TrackEnemyKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);

	class UBaseCombatMoveActivity* GetCombatMoveActivity() const;
	int32 GetFailureCountForCombatMove(TSubclassOf<class UBaseCombatMoveActivity> CombatMoveClass) const;
	bool IsFocusingOnActor(class AActor* InActor) const;
	bool IsRunningCombatMoveActivity(class UClass* Param_Class) const;
	bool IsTryingToFireAtScriptedActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCombatActivity">();
	}
	static class UBaseCombatActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCombatActivity>();
	}
};
static_assert(alignof(UBaseCombatActivity) == 0x000008, "Wrong alignment on UBaseCombatActivity");
static_assert(sizeof(UBaseCombatActivity) == 0x000420, "Wrong size on UBaseCombatActivity");
static_assert(offsetof(UBaseCombatActivity, OnTrackNewEnemy) == 0x0001A8, "Member 'UBaseCombatActivity::OnTrackNewEnemy' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, CurrentScriptedFireAt) == 0x0001B8, "Member 'UBaseCombatActivity::CurrentScriptedFireAt' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, CurrentScriptedLookAt) == 0x0001E0, "Member 'UBaseCombatActivity::CurrentScriptedLookAt' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, FleeDesire) == 0x000200, "Member 'UBaseCombatActivity::FleeDesire' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, TimeSincePerformingAnyCombatMove) == 0x000204, "Member 'UBaseCombatActivity::TimeSincePerformingAnyCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, TimePerformingAnyCombatMove) == 0x000208, "Member 'UBaseCombatActivity::TimePerformingAnyCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, TraverseHoleActivity) == 0x000210, "Member 'UBaseCombatActivity::TraverseHoleActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, CombatMoveActivity) == 0x000218, "Member 'UBaseCombatActivity::CombatMoveActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, PreviousCombatMoveActivity) == 0x000220, "Member 'UBaseCombatActivity::PreviousCombatMoveActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, HardCoverCombatMove) == 0x000228, "Member 'UBaseCombatActivity::HardCoverCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, DuelingCombatMove) == 0x000230, "Member 'UBaseCombatActivity::DuelingCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, FlankingCombatMove) == 0x000238, "Member 'UBaseCombatActivity::FlankingCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, SuppressionCombatMove) == 0x000240, "Member 'UBaseCombatActivity::SuppressionCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, PushCombatMove) == 0x000248, "Member 'UBaseCombatActivity::PushCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, ChargeCombatMove) == 0x000250, "Member 'UBaseCombatActivity::ChargeCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, FleeingCombatMove) == 0x000258, "Member 'UBaseCombatActivity::FleeingCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, RepositionCombatMove) == 0x000260, "Member 'UBaseCombatActivity::RepositionCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, CoverLandmarkEvaluationCooldown) == 0x000280, "Member 'UBaseCombatActivity::CoverLandmarkEvaluationCooldown' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, LastTrackedEnemy) == 0x000288, "Member 'UBaseCombatActivity::LastTrackedEnemy' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, PickupItemActivity) == 0x0002A0, "Member 'UBaseCombatActivity::PickupItemActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, ReloadSafelyActivity) == 0x0002A8, "Member 'UBaseCombatActivity::ReloadSafelyActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, PlayDeadActivity) == 0x0002B0, "Member 'UBaseCombatActivity::PlayDeadActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, CommitSuicideActivity) == 0x0002B8, "Member 'UBaseCombatActivity::CommitSuicideActivity' has a wrong offset!");

// Class ReadyOrNot.NavSplinePathRenderingComponent
// 0x00B0 (0x0500 - 0x0450)
class UNavSplinePathRenderingComponent final  : public UPrimitiveComponent
{
public:
	uint8                                         Pad_2279[0xB0];                                    // 0x0450(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavSplinePathRenderingComponent">();
	}
	static class UNavSplinePathRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavSplinePathRenderingComponent>();
	}
};
static_assert(alignof(UNavSplinePathRenderingComponent) == 0x000010, "Wrong alignment on UNavSplinePathRenderingComponent");
static_assert(sizeof(UNavSplinePathRenderingComponent) == 0x000500, "Wrong size on UNavSplinePathRenderingComponent");

// Class ReadyOrNot.ControllableByTablet
// 0x0000 (0x0028 - 0x0028)
class IControllableByTablet final  : public IInterface
{
public:
	void AssumeTabletControl(class APlayerCharacter* TabletOwner);
	bool CanControlWithTablet(class APlayerCharacter* TabletOwner);
	bool CanTabletViewMe(class APlayerCharacter* TabletOwner, class AReadyOrNotGameState* GameState);
	class FText GetTabletNameText();
	class USceneComponent* GetTabletViewComponent();
	class FName GetTabletViewSocket();
	ETeamType GetTabletViewTeamColor();
	void HideActorsForTabletView(class USceneCaptureComponent2D* Component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllableByTablet">();
	}
	static class IControllableByTablet* GetDefaultObj()
	{
		return GetDefaultObjImpl<IControllableByTablet>();
	}
};
static_assert(alignof(IControllableByTablet) == 0x000008, "Wrong alignment on IControllableByTablet");
static_assert(sizeof(IControllableByTablet) == 0x000028, "Wrong size on IControllableByTablet");

// Class ReadyOrNot.BaseCredit
// 0x0008 (0x0268 - 0x0260)
class UBaseCredit : public UUserWidget
{
public:
	bool                                          bRevealed;                                         // 0x0260(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_227C[0x3];                                     // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FAnimationSpeed;                                   // 0x0264(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCredit">();
	}
	static class UBaseCredit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCredit>();
	}
};
static_assert(alignof(UBaseCredit) == 0x000008, "Wrong alignment on UBaseCredit");
static_assert(sizeof(UBaseCredit) == 0x000268, "Wrong size on UBaseCredit");
static_assert(offsetof(UBaseCredit, bRevealed) == 0x000260, "Member 'UBaseCredit::bRevealed' has a wrong offset!");
static_assert(offsetof(UBaseCredit, FAnimationSpeed) == 0x000264, "Member 'UBaseCredit::FAnimationSpeed' has a wrong offset!");

// Class ReadyOrNot.BaseGrenade
// 0x0480 (0x0E50 - 0x09D0)
class ABaseGrenade : public ABaseItem
{
public:
	uint8                                         Pad_227D[0x8];                                     // 0x09D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPointLightComponent*                   DetonationLight;                                   // 0x09D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URadialForceComponent*                  DetonationRadialForce;                             // 0x09E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    FMODBounceSoundComponent;                          // 0x09E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIPerceptionStimuliSourceComponent*    DetonationStimuliComp;                             // 0x09F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrenadeBounciness;                                 // 0x09F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetonationTriggersStimuli;                        // 0x09FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_227E[0x3];                                     // 0x09FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DetonationSoundMaxRange;                           // 0x0A00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetonationLoudness;                                // 0x0A04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DetonationTag;                                     // 0x0A08(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThrownTag;                                         // 0x0A10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BounceTag;                                         // 0x0A18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_227F[0x8];                                     // 0x0A20(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AThrownGrenade*                         Thrown;                                            // 0x0A28(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUsedFixedThrowTrajectory : 1;                     // 0x0A30(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2280[0x7];                                     // 0x0A31(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        FirstBouncePath;                                   // 0x0A38(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FHitResult                             FirstBounceHit;                                    // 0x0A48(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2281[0x8];                                     // 0x0AD0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        SecondBouncePath;                                  // 0x0AD8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FHitResult                             SecondBounceHit;                                   // 0x0AE8(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2282[0x8];                                     // 0x0B70(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ThirdBouncePath;                                   // 0x0B78(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FHitResult                             ThirdBounceHit;                                    // 0x0B88(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2283[0x8];                                     // 0x0C10(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector_NetQuantize>            CompletePath;                                      // 0x0C18(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_2284[0xC];                                     // 0x0C28(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BouncePt1;                                         // 0x0C34(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BouncePt2;                                         // 0x0C38(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BouncePt3;                                         // 0x0C3C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2285[0x8];                                     // 0x0C40(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DeployGrenadeVoiceLine;                            // 0x0C48(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrenadeSpeed;                                      // 0x0C58(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2286[0x8];                                     // 0x0C5C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BounceSoundMinImpulse;                             // 0x0C64(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     BounceSoundEffects;                                // 0x0C68(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ActivationEffect;                                  // 0x0C78(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        GrenadeBounceEffect;                               // 0x0C80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ActivationSound;                                   // 0x0C88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationTime;                                    // 0x0C90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationElapsedTime;                             // 0x0C94(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivated;                                        // 0x0C98(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayDetonationEffectsExactlyOnce;                 // 0x0C99(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetonationEffectsPlayed;                          // 0x0C9A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2287[0x1];                                     // 0x0C9B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceUsed;                                     // 0x0C9C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceDetonate;                                 // 0x0CA0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2288[0x1];                                     // 0x0CA4(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0CA5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bThrowAsQuickThrow;                                // 0x0CA6(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastThrowOnceEquipped;                            // 0x0CA7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastThrowing;                                     // 0x0CA8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGrenadeReleased;                                  // 0x0CA9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2289[0x6];                                     // 0x0CAA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThrowImpulse;                                      // 0x0CB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpImpulse;                                         // 0x0CB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggersActionMusic;                              // 0x0CB8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanThrowGrenade;                                  // 0x0CB9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228A[0x2];                                     // 0x0CBA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DetonationTime;                                    // 0x0CBC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncreaseDamageRadiusOverTime;                     // 0x0CC0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228B[0x7];                                     // 0x0CC1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnderarmForceScale;                                // 0x0CC8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Drag;                                              // 0x0CCC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragAppliedPerBounce;                              // 0x0CD0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetonationFlashIntensitiy;                         // 0x0CD4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetonationFlashInterp;                             // 0x0CD8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReDetonationTime;                                  // 0x0CDC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerSFXOnRedetonate;                           // 0x0CE0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228C[0x3];                                     // 0x0CE1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThrowDistance;                                     // 0x0CE4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RedotonateCount;                                   // 0x0CE8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNoMoraleDamage : 1;                               // 0x0CEC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_228D[0x3];                                     // 0x0CED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ListenerTriggerDistance;                           // 0x0CF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228E[0xC];                                     // 0x0CF4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MaxRandomizedForceOnDetonation;                    // 0x0D00(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FixedForceOnDetonation;                            // 0x0D0C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystem*>                DetonationParticles;                               // 0x0D18(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       SpawnedParticles;                                  // 0x0D28(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRotator                               ParticleSpawnRotation;                             // 0x0D38(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_228F[0x4];                                     // 0x0D44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             DetonationFMODEvent;                               // 0x0D48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              DetonationEvent;                                   // 0x0D50(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideGrenadeOnDetonate;                            // 0x0D58(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGrenadeType                                  Type;                                              // 0x0D59(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2290[0x6];                                     // 0x0D5A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnGrenadeDetonated;                                // 0x0D60(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGrenadeThrown;                                   // 0x0D70(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         RedrawDelayAfterThrow;                             // 0x0D80(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsed;                                             // 0x0D84(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2291[0x3];                                     // 0x0D85(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   ThrownBy;                                          // 0x0D88(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2292[0x10];                                    // 0x0D90(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGrenadeDamage>                 DetonationDamage;                                  // 0x0DA0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseScreenShake;                                   // 0x0DB0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2293[0x7];                                     // 0x0DB1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMatineeCameraShake>        ExplosionScreenShake;                              // 0x0DB8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShakeRadius;                                 // 0x0DC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDetonationDecal;                               // 0x0DC4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2294[0x3];                                     // 0x0DC5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DetonationDecalTraceDistance;                      // 0x0DC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2295[0x4];                                     // 0x0DCC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DetonationDecal;                                   // 0x0DD0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DetonationDecalSize;                               // 0x0DD8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2296[0x4];                                     // 0x0DE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           HideBonesOnUsed;                                   // 0x0DE8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BounceActivationRadius;                            // 0x0DF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2297[0x4];                                     // 0x0DFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             FMODGrenadeBounce;                                 // 0x0E00(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2298[0x8];                                     // 0x0E08(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GrenadeOcclusionMultiplier;                        // 0x0E10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrenadeFullOcclusionDepth;                         // 0x0E14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceDifference;                             // 0x0E18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpStrength;                                    // 0x0E1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClientReplicationFrequency;                        // 0x0E20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2299[0x2C];                                    // 0x0E24(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Detonate();
	void DoThrowFast();
	bool IsOutside();
	void Multicast_AddImpulse(const struct FVector& Impulse, const struct FVector& FromLocation);
	void Multicast_DetonationEffects(const struct FVector& CalculatedForce);
	void Multicast_GrenadeThrow(bool bOverarmThrow, const struct FVector& ThrowDirection, const struct FVector& ThrowStart);
	void Multicast_OnDeadDropped();
	void OnDetonate__DelegateSignature(class ABaseGrenade* Grenade);
	void OnGrenadeBounceSoundStopped();
	void OnGrenadeThrown__DelegateSignature(class ABaseGrenade* ThrownGrenade);
	void OnRep_GrenadePath();
	void OnRep_GrenadeUsed();
	void Server_SetThrowOverarm(bool bThrowOverarm, bool bQuickThrow);
	void Server_StartFastThrow();
	void Server_ThrowGrenade(bool bOverarmThrow, const struct FVector& ThrowDirection, const struct FVector& ThrowStart);
	void Server_UpdateThrowPosition(const struct FVector& Position, const struct FRotator& Rotation, const struct FVector& Velocity);
	void SetFullyPrimed();
	void Throw(bool bLocalOnly, bool bOverarmThrow, struct FVector& ThrowDirection, struct FVector& ThrowStart);
	void UpdateServerPath(TArray<struct FVector_NetQuantize>& Path, int32 Bounce1, int32 Bounce2, int32 Bounce3);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseGrenade">();
	}
	static class ABaseGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseGrenade>();
	}
};
static_assert(alignof(ABaseGrenade) == 0x000010, "Wrong alignment on ABaseGrenade");
static_assert(sizeof(ABaseGrenade) == 0x000E50, "Wrong size on ABaseGrenade");
static_assert(offsetof(ABaseGrenade, DetonationLight) == 0x0009D8, "Member 'ABaseGrenade::DetonationLight' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationRadialForce) == 0x0009E0, "Member 'ABaseGrenade::DetonationRadialForce' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, FMODBounceSoundComponent) == 0x0009E8, "Member 'ABaseGrenade::FMODBounceSoundComponent' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationStimuliComp) == 0x0009F0, "Member 'ABaseGrenade::DetonationStimuliComp' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, GrenadeBounciness) == 0x0009F8, "Member 'ABaseGrenade::GrenadeBounciness' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bDetonationTriggersStimuli) == 0x0009FC, "Member 'ABaseGrenade::bDetonationTriggersStimuli' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationSoundMaxRange) == 0x000A00, "Member 'ABaseGrenade::DetonationSoundMaxRange' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationLoudness) == 0x000A04, "Member 'ABaseGrenade::DetonationLoudness' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationTag) == 0x000A08, "Member 'ABaseGrenade::DetonationTag' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ThrownTag) == 0x000A10, "Member 'ABaseGrenade::ThrownTag' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, BounceTag) == 0x000A18, "Member 'ABaseGrenade::BounceTag' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, Thrown) == 0x000A28, "Member 'ABaseGrenade::Thrown' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, FirstBouncePath) == 0x000A38, "Member 'ABaseGrenade::FirstBouncePath' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, FirstBounceHit) == 0x000A48, "Member 'ABaseGrenade::FirstBounceHit' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, SecondBouncePath) == 0x000AD8, "Member 'ABaseGrenade::SecondBouncePath' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, SecondBounceHit) == 0x000AE8, "Member 'ABaseGrenade::SecondBounceHit' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ThirdBouncePath) == 0x000B78, "Member 'ABaseGrenade::ThirdBouncePath' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ThirdBounceHit) == 0x000B88, "Member 'ABaseGrenade::ThirdBounceHit' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, CompletePath) == 0x000C18, "Member 'ABaseGrenade::CompletePath' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, BouncePt1) == 0x000C34, "Member 'ABaseGrenade::BouncePt1' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, BouncePt2) == 0x000C38, "Member 'ABaseGrenade::BouncePt2' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, BouncePt3) == 0x000C3C, "Member 'ABaseGrenade::BouncePt3' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DeployGrenadeVoiceLine) == 0x000C48, "Member 'ABaseGrenade::DeployGrenadeVoiceLine' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, GrenadeSpeed) == 0x000C58, "Member 'ABaseGrenade::GrenadeSpeed' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, BounceSoundMinImpulse) == 0x000C64, "Member 'ABaseGrenade::BounceSoundMinImpulse' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, BounceSoundEffects) == 0x000C68, "Member 'ABaseGrenade::BounceSoundEffects' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ActivationEffect) == 0x000C78, "Member 'ABaseGrenade::ActivationEffect' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, GrenadeBounceEffect) == 0x000C80, "Member 'ABaseGrenade::GrenadeBounceEffect' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ActivationSound) == 0x000C88, "Member 'ABaseGrenade::ActivationSound' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ActivationTime) == 0x000C90, "Member 'ABaseGrenade::ActivationTime' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ActivationElapsedTime) == 0x000C94, "Member 'ABaseGrenade::ActivationElapsedTime' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bActivated) == 0x000C98, "Member 'ABaseGrenade::bActivated' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bPlayDetonationEffectsExactlyOnce) == 0x000C99, "Member 'ABaseGrenade::bPlayDetonationEffectsExactlyOnce' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bDetonationEffectsPlayed) == 0x000C9A, "Member 'ABaseGrenade::bDetonationEffectsPlayed' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, TimeSinceUsed) == 0x000C9C, "Member 'ABaseGrenade::TimeSinceUsed' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, TimeSinceDetonate) == 0x000CA0, "Member 'ABaseGrenade::TimeSinceDetonate' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DrawDebugType) == 0x000CA5, "Member 'ABaseGrenade::DrawDebugType' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bThrowAsQuickThrow) == 0x000CA6, "Member 'ABaseGrenade::bThrowAsQuickThrow' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bFastThrowOnceEquipped) == 0x000CA7, "Member 'ABaseGrenade::bFastThrowOnceEquipped' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bFastThrowing) == 0x000CA8, "Member 'ABaseGrenade::bFastThrowing' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bGrenadeReleased) == 0x000CA9, "Member 'ABaseGrenade::bGrenadeReleased' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ThrowImpulse) == 0x000CB0, "Member 'ABaseGrenade::ThrowImpulse' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, UpImpulse) == 0x000CB4, "Member 'ABaseGrenade::UpImpulse' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bTriggersActionMusic) == 0x000CB8, "Member 'ABaseGrenade::bTriggersActionMusic' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bCanThrowGrenade) == 0x000CB9, "Member 'ABaseGrenade::bCanThrowGrenade' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationTime) == 0x000CBC, "Member 'ABaseGrenade::DetonationTime' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bIncreaseDamageRadiusOverTime) == 0x000CC0, "Member 'ABaseGrenade::bIncreaseDamageRadiusOverTime' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, UnderarmForceScale) == 0x000CC8, "Member 'ABaseGrenade::UnderarmForceScale' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, Drag) == 0x000CCC, "Member 'ABaseGrenade::Drag' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DragAppliedPerBounce) == 0x000CD0, "Member 'ABaseGrenade::DragAppliedPerBounce' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationFlashIntensitiy) == 0x000CD4, "Member 'ABaseGrenade::DetonationFlashIntensitiy' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationFlashInterp) == 0x000CD8, "Member 'ABaseGrenade::DetonationFlashInterp' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ReDetonationTime) == 0x000CDC, "Member 'ABaseGrenade::ReDetonationTime' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bTriggerSFXOnRedetonate) == 0x000CE0, "Member 'ABaseGrenade::bTriggerSFXOnRedetonate' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ThrowDistance) == 0x000CE4, "Member 'ABaseGrenade::ThrowDistance' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, RedotonateCount) == 0x000CE8, "Member 'ABaseGrenade::RedotonateCount' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ListenerTriggerDistance) == 0x000CF0, "Member 'ABaseGrenade::ListenerTriggerDistance' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, MaxRandomizedForceOnDetonation) == 0x000D00, "Member 'ABaseGrenade::MaxRandomizedForceOnDetonation' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, FixedForceOnDetonation) == 0x000D0C, "Member 'ABaseGrenade::FixedForceOnDetonation' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationParticles) == 0x000D18, "Member 'ABaseGrenade::DetonationParticles' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, SpawnedParticles) == 0x000D28, "Member 'ABaseGrenade::SpawnedParticles' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ParticleSpawnRotation) == 0x000D38, "Member 'ABaseGrenade::ParticleSpawnRotation' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationFMODEvent) == 0x000D48, "Member 'ABaseGrenade::DetonationFMODEvent' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationEvent) == 0x000D50, "Member 'ABaseGrenade::DetonationEvent' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bHideGrenadeOnDetonate) == 0x000D58, "Member 'ABaseGrenade::bHideGrenadeOnDetonate' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, Type) == 0x000D59, "Member 'ABaseGrenade::Type' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, OnGrenadeDetonated) == 0x000D60, "Member 'ABaseGrenade::OnGrenadeDetonated' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, OnGrenadeThrown) == 0x000D70, "Member 'ABaseGrenade::OnGrenadeThrown' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, RedrawDelayAfterThrow) == 0x000D80, "Member 'ABaseGrenade::RedrawDelayAfterThrow' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bUsed) == 0x000D84, "Member 'ABaseGrenade::bUsed' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ThrownBy) == 0x000D88, "Member 'ABaseGrenade::ThrownBy' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationDamage) == 0x000DA0, "Member 'ABaseGrenade::DetonationDamage' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bUseScreenShake) == 0x000DB0, "Member 'ABaseGrenade::bUseScreenShake' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ExplosionScreenShake) == 0x000DB8, "Member 'ABaseGrenade::ExplosionScreenShake' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, CameraShakeRadius) == 0x000DC0, "Member 'ABaseGrenade::CameraShakeRadius' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bUseDetonationDecal) == 0x000DC4, "Member 'ABaseGrenade::bUseDetonationDecal' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationDecalTraceDistance) == 0x000DC8, "Member 'ABaseGrenade::DetonationDecalTraceDistance' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationDecal) == 0x000DD0, "Member 'ABaseGrenade::DetonationDecal' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationDecalSize) == 0x000DD8, "Member 'ABaseGrenade::DetonationDecalSize' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, HideBonesOnUsed) == 0x000DE8, "Member 'ABaseGrenade::HideBonesOnUsed' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, BounceActivationRadius) == 0x000DF8, "Member 'ABaseGrenade::BounceActivationRadius' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, FMODGrenadeBounce) == 0x000E00, "Member 'ABaseGrenade::FMODGrenadeBounce' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, GrenadeOcclusionMultiplier) == 0x000E10, "Member 'ABaseGrenade::GrenadeOcclusionMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, GrenadeFullOcclusionDepth) == 0x000E14, "Member 'ABaseGrenade::GrenadeFullOcclusionDepth' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, MaxDistanceDifference) == 0x000E18, "Member 'ABaseGrenade::MaxDistanceDifference' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, InterpStrength) == 0x000E1C, "Member 'ABaseGrenade::InterpStrength' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ClientReplicationFrequency) == 0x000E20, "Member 'ABaseGrenade::ClientReplicationFrequency' has a wrong offset!");

// Class ReadyOrNot.BaseGasGrenade
// 0x0040 (0x0E90 - 0x0E50)
class ABaseGasGrenade : public ABaseGrenade
{
public:
	int32                                         MaxGasPoints;                                      // 0x0E50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229E[0x14];                                    // 0x0E54(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationRecordingRate;                             // 0x0E68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecordDistanceThreshold;                           // 0x0E6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229F[0x20];                                    // 0x0E70(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RecordLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseGasGrenade">();
	}
	static class ABaseGasGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseGasGrenade>();
	}
};
static_assert(alignof(ABaseGasGrenade) == 0x000010, "Wrong alignment on ABaseGasGrenade");
static_assert(sizeof(ABaseGasGrenade) == 0x000E90, "Wrong size on ABaseGasGrenade");
static_assert(offsetof(ABaseGasGrenade, MaxGasPoints) == 0x000E50, "Member 'ABaseGasGrenade::MaxGasPoints' has a wrong offset!");
static_assert(offsetof(ABaseGasGrenade, LocationRecordingRate) == 0x000E68, "Member 'ABaseGasGrenade::LocationRecordingRate' has a wrong offset!");
static_assert(offsetof(ABaseGasGrenade, RecordDistanceThreshold) == 0x000E6C, "Member 'ABaseGasGrenade::RecordDistanceThreshold' has a wrong offset!");

// Class ReadyOrNot.CustomizationDataBase
// 0x0140 (0x0170 - 0x0030)
class UCustomizationDataBase : public UPrimaryDataAsset
{
public:
	ECustomizationType                            Type;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A0[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomizationDataBase*                 Parent;                                            // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name_CustomizationDataBase;                        // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Variant;                                           // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      VariantIcon;                                       // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayPriority;                                   // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A1[0x4];                                     // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           RequiredTags;                                      // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   RequirementsText;                                  // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSet<ECustomizationType>                      TypesToHide;                                       // 0x0108(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bShowInLoadout;                                    // 0x0158(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A2[0x7];                                     // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGameVersionRestriction>               LockedToDLC;                                       // 0x0160(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationDataBase">();
	}
	static class UCustomizationDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationDataBase>();
	}
};
static_assert(alignof(UCustomizationDataBase) == 0x000008, "Wrong alignment on UCustomizationDataBase");
static_assert(sizeof(UCustomizationDataBase) == 0x000170, "Wrong size on UCustomizationDataBase");
static_assert(offsetof(UCustomizationDataBase, Type) == 0x000030, "Member 'UCustomizationDataBase::Type' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, Parent) == 0x000038, "Member 'UCustomizationDataBase::Parent' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, Name_CustomizationDataBase) == 0x000040, "Member 'UCustomizationDataBase::Name_CustomizationDataBase' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, Variant) == 0x000058, "Member 'UCustomizationDataBase::Variant' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, Description) == 0x000070, "Member 'UCustomizationDataBase::Description' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, Icon) == 0x000088, "Member 'UCustomizationDataBase::Icon' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, VariantIcon) == 0x0000B0, "Member 'UCustomizationDataBase::VariantIcon' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, DisplayPriority) == 0x0000D8, "Member 'UCustomizationDataBase::DisplayPriority' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, RequiredTags) == 0x0000E0, "Member 'UCustomizationDataBase::RequiredTags' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, RequirementsText) == 0x0000F0, "Member 'UCustomizationDataBase::RequirementsText' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, TypesToHide) == 0x000108, "Member 'UCustomizationDataBase::TypesToHide' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, bShowInLoadout) == 0x000158, "Member 'UCustomizationDataBase::bShowInLoadout' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, LockedToDLC) == 0x000160, "Member 'UCustomizationDataBase::LockedToDLC' has a wrong offset!");

// Class ReadyOrNot.BaseWeapon
// 0x0630 (0x1000 - 0x09D0)
class ABaseWeapon : public ABaseItem
{
public:
	bool                                          bPistolGrip;                                       // 0x09D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFireMode                                     FiremodeBeforeSafe;                                // 0x09D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22A3[0x6];                                     // 0x09D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAmmoTypeData                          CurrentAmmoType;                                   // 0x09D8(0x0160)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_22A4[0x8];                                     // 0x0B38(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             AmmoDataTable;                                     // 0x0B40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           AmmunitionTypes;                                   // 0x0B48(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UReadyOrNotLoadoutManager*              LoadoutFunctionLibrary;                            // 0x0B58(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        BulletSpawn;                                       // 0x0B60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        ShellSpawn;                                        // 0x0B68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ShellParticle;                                     // 0x0B70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpotLightComponent*                    Flashlight;                                        // 0x0B78(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScopedWeaponAttachment*                ScopeAttachment;                                   // 0x0B80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAttachment*                      MuzzleAttachment;                                  // 0x0B88(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAttachment*                      UnderbarrelAttachment;                             // 0x0B90(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAttachment*                      OverbarrelAttachment;                              // 0x0B98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAttachment*                      StockAttachment;                                   // 0x0BA0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAttachment*                      GripAttachment;                                    // 0x0BA8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAttachment*                      IlluminatorAttachment;                             // 0x0BB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAttachment*                      AmmunitionAttachment;                              // 0x0BB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    ADSAudioComponent;                                 // 0x0BC0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    ADSEndAudioComponent;                              // 0x0BC8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    ADSAudioComponents[0x5];                           // 0x0BD0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    ADSEndAudioComponents[0x5];                        // 0x0BF8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A5[0x4];                                     // 0x0C20(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AttachmentPoints;                                  // 0x0C24(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupressed;                                        // 0x0C28(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A6[0xF];                                     // 0x0C29(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnFireModeChanged;                                 // 0x0C38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EFireMode                                     CurrentFireMode;                                   // 0x0C48(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFireMode                                     DefaultFireMode;                                   // 0x0C49(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A7[0x6];                                     // 0x0C4A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EFireMode>                             AvailableFireModes;                                // 0x0C50(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BurstBulletCount;                                  // 0x0C60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSafeMode;                                      // 0x0C64(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A8[0x3];                                     // 0x0C65(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AddedMagazineCountFromAttachments;                 // 0x0C68(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Optics_UI_Socket;                                  // 0x0C6C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Grip_UI_Socket;                                    // 0x0C74(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Muzzle_UI_Socket;                                  // 0x0C7C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Stock_UI_Socket;                                   // 0x0C84(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Magazine_UI_Socket;                                // 0x0C8C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSZoom;                                           // 0x0C94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSZoomInSpeed;                                    // 0x0C98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSZoomOutSpeed;                                   // 0x0C9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DefaultDamageType;                                 // 0x0CA0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0CA8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        FireCameraShake;                                   // 0x0CB0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraShakeBase*                       FireCameraShakeInst;                               // 0x0CB8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     DamageOverRange;                                   // 0x0CC0(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0D48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageSeverityMultiplier;                          // 0x0D4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageSeverityChance;                              // 0x0D50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BleedoutDamageMultiplier;                          // 0x0D54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BleedoutDamageChance;                              // 0x0D58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultDamage;                                     // 0x0D5C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireRate;                                          // 0x0D60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFireRateAI;                                     // 0x0D64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFireRateAI;                                     // 0x0D68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletsFiredUntilFullyAccurate;                    // 0x0D6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileMovementSpeed;                           // 0x0D70(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArmorPiercing;                                    // 0x0D74(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A9[0x3];                                     // 0x0D75(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AImpactEffect>              ImpactEffects;                                     // 0x0D78(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AImpactEffect>              RicochetEffects;                                   // 0x0D80(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        RicochetParticleSystem;                            // 0x0D88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             RicochetEvent;                                     // 0x0D90(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SpallingDecal;                                     // 0x0D98(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        SpallingParticleSystem;                            // 0x0DA0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SpallingEvent;                                     // 0x0DA8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AImpactEffect>              ExitEffects;                                       // 0x0DB0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Wobble;                                            // 0x0DB8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialWobbleDelay;                                // 0x0DBC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachBulletOnHit;                                // 0x0DC0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22AA[0x3];                                     // 0x0DC1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BulletPhysicsImpulseMultiplier;                    // 0x0DC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyBulletOnHit;                               // 0x0DC8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22AB[0x7];                                     // 0x0DC9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          BulletProjectileMesh;                              // 0x0DD0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            FakeProjectileMeshStatic;                          // 0x0DD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BulletProjectileMeshStatic;                        // 0x0DE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BulletProjectileScale;                             // 0x0DE8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22AC[0x4];                                     // 0x0DF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseShell>                 ShellClass;                                        // 0x0DF8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            ShellMesh;                                         // 0x0E00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRotator>                       RecoilPattern;                                     // 0x0E08(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_22AD[0x4];                                     // 0x0E18(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BulletDrag;                                        // 0x0E1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilInterpSpeed;                                 // 0x0E20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSRecoilMultiplier;                               // 0x0E24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSSpreadMultiplier;                               // 0x0E28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilReturnRate;                                  // 0x0E2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreAmmoTypeSpread;                             // 0x0E30(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22AE[0x3];                                     // 0x0E31(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SpreadPattern;                                     // 0x0E34(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_22AF[0x4];                                     // 0x0E40(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpreadReturnRate;                                  // 0x0E44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PendingSpread;                                     // 0x0E48(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               FireDirection;                                     // 0x0E54(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         GlimmerIntensity;                                  // 0x0E60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnProjectileCount;                              // 0x0E64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstShotRecoil;                                   // 0x0E68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstShotSpread;                                   // 0x0E6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstShotResetTime;                                // 0x0E70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocitySpreadMultiplier;                          // 0x0E74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityRecoilMultiplier;                          // 0x0E78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilMultiplierPitch;                             // 0x0E7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilMultiplierYaw;                               // 0x0E80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefireDelay;                                       // 0x0E84(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilReturnPercentage;                            // 0x0E88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilReturnInterpSpeed;                           // 0x0E8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B0[0x2A];                                    // 0x0E90(0x002A)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAcceptsScopeAttachments;                          // 0x0EBA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptsMuzzleAttachments;                         // 0x0EBB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptsUnderbarrelAttachments;                    // 0x0EBC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptsOverbarrelAttachments;                     // 0x0EBD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptsStockAttachments;                          // 0x0EBE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptsGripAttachments;                           // 0x0EBF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptsIlluminatorAttachments;                    // 0x0EC0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptsAmmunitionAttachments;                     // 0x0EC1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B1[0x6];                                     // 0x0EC2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UScopedWeaponAttachment>> AvailableScopeAttachments;                         // 0x0EC8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableMuzzleAttachments;                        // 0x0ED8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableUnderbarrelAttachments;                   // 0x0EE8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableOverbarrelAttachments;                    // 0x0EF8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableStockAttachments;                         // 0x0F08(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableGripAttachments;                          // 0x0F18(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableIlluminatorAttachments;                   // 0x0F28(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableAmmunitionAttachments;                    // 0x0F38(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bCalculateProcRecoil;                              // 0x0F48(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B2[0x3];                                     // 0x0F49(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoilDampStrength;                                // 0x0F4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilFireTime;                                    // 0x0F50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilFireStrength;                                // 0x0F54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilFireStrengthFirst;                           // 0x0F58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilAngleStrength;                               // 0x0F5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilRandomness;                                  // 0x0F60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilFireADSModifier;                             // 0x0F64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilAngleADSModifier;                            // 0x0F68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RecoilRotationBuildup;                             // 0x0F6C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RecoilPositionBuildup;                             // 0x0F78(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilBuildupADSModifier;                          // 0x0F84(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RecoilHasBuildup;                                  // 0x0F88(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B3[0x3];                                     // 0x0F89(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoilBuildupDampStrength;                         // 0x0F8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B4[0x2C];                                    // 0x0F90(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ProcRecoil_Trans;                                  // 0x0FBC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ProcRecoil_Rot;                                    // 0x0FC8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ProcRecoil_Trans_Buildup;                          // 0x0FD4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ProcRecoil_Rot_Buildup;                            // 0x0FE0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CurrentHighTimer;                                  // 0x0FEC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadHighTimer;                                   // 0x0FF0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireHighTimer;                                     // 0x0FF4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EquipHighTimer;                                    // 0x0FF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScopeMask;                                     // 0x0FFC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B5[0x3];                                     // 0x0FFD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAttachment(class UClass* Param_Class, bool bReplicateAttachment);
	void AddMagazineCountFromAttachments(float AddAmount);
	bool CanAddAttachment(class UClass* AttachmentClass);
	bool CanReload();
	void DisableGlimmer();
	void EnableGlimmer();
	class ULaserAttachment* GetLaserAttachment();
	class ULightAttachment* GetLightAttachment();
	struct FRotator GetRecoil();
	struct FRotator GetSpread();
	void OnAimDownSights(bool bWasAiming);
	void OnEndAimDownSights(bool bWasAiming);
	void OnFireAtBulletSpawn();
	void OnWeaponFired(const struct FRotator& Param_FireDirection);
	void OnWeaponFiredEnd();
	void OnWeaponFireModeChanged__DelegateSignature(EFireMode NewFireMode);
	void OnWeaponReloadComplete();
	void OnWeaponReloadStarted();
	void PlayFiringModeAnimation();
	void RemoveAttachment(bool bScopedAttachment, bool bMuzzleAttachment, bool bUnderbarrelAttachment, bool bOverbarrelAttachment, bool bStockAttachment, bool bGripAttachment, bool bIlluminatorAttachment, bool bAmmunitionAttachment);
	void ResetRecoilSettingsToDefault();
	void UpdateStoredAttachments(TSubclassOf<class UWeaponAttachment> Attachment);

	EWeaponUnderbarrelAnimationType GetUnderbarrelAnimationType() const;
	bool IsLessLethalWeapon() const;
	bool IsLethalWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseWeapon">();
	}
	static class ABaseWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseWeapon>();
	}
};
static_assert(alignof(ABaseWeapon) == 0x000010, "Wrong alignment on ABaseWeapon");
static_assert(sizeof(ABaseWeapon) == 0x001000, "Wrong size on ABaseWeapon");
static_assert(offsetof(ABaseWeapon, bPistolGrip) == 0x0009D0, "Member 'ABaseWeapon::bPistolGrip' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FiremodeBeforeSafe) == 0x0009D1, "Member 'ABaseWeapon::FiremodeBeforeSafe' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, CurrentAmmoType) == 0x0009D8, "Member 'ABaseWeapon::CurrentAmmoType' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AmmoDataTable) == 0x000B40, "Member 'ABaseWeapon::AmmoDataTable' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AmmunitionTypes) == 0x000B48, "Member 'ABaseWeapon::AmmunitionTypes' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, LoadoutFunctionLibrary) == 0x000B58, "Member 'ABaseWeapon::LoadoutFunctionLibrary' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BulletSpawn) == 0x000B60, "Member 'ABaseWeapon::BulletSpawn' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ShellSpawn) == 0x000B68, "Member 'ABaseWeapon::ShellSpawn' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ShellParticle) == 0x000B70, "Member 'ABaseWeapon::ShellParticle' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, Flashlight) == 0x000B78, "Member 'ABaseWeapon::Flashlight' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ScopeAttachment) == 0x000B80, "Member 'ABaseWeapon::ScopeAttachment' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, MuzzleAttachment) == 0x000B88, "Member 'ABaseWeapon::MuzzleAttachment' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, UnderbarrelAttachment) == 0x000B90, "Member 'ABaseWeapon::UnderbarrelAttachment' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, OverbarrelAttachment) == 0x000B98, "Member 'ABaseWeapon::OverbarrelAttachment' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, StockAttachment) == 0x000BA0, "Member 'ABaseWeapon::StockAttachment' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, GripAttachment) == 0x000BA8, "Member 'ABaseWeapon::GripAttachment' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, IlluminatorAttachment) == 0x000BB0, "Member 'ABaseWeapon::IlluminatorAttachment' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AmmunitionAttachment) == 0x000BB8, "Member 'ABaseWeapon::AmmunitionAttachment' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSAudioComponent) == 0x000BC0, "Member 'ABaseWeapon::ADSAudioComponent' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSEndAudioComponent) == 0x000BC8, "Member 'ABaseWeapon::ADSEndAudioComponent' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSAudioComponents) == 0x000BD0, "Member 'ABaseWeapon::ADSAudioComponents' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSEndAudioComponents) == 0x000BF8, "Member 'ABaseWeapon::ADSEndAudioComponents' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AttachmentPoints) == 0x000C24, "Member 'ABaseWeapon::AttachmentPoints' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bSupressed) == 0x000C28, "Member 'ABaseWeapon::bSupressed' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, OnFireModeChanged) == 0x000C38, "Member 'ABaseWeapon::OnFireModeChanged' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, CurrentFireMode) == 0x000C48, "Member 'ABaseWeapon::CurrentFireMode' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, DefaultFireMode) == 0x000C49, "Member 'ABaseWeapon::DefaultFireMode' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableFireModes) == 0x000C50, "Member 'ABaseWeapon::AvailableFireModes' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BurstBulletCount) == 0x000C60, "Member 'ABaseWeapon::BurstBulletCount' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bHasSafeMode) == 0x000C64, "Member 'ABaseWeapon::bHasSafeMode' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AddedMagazineCountFromAttachments) == 0x000C68, "Member 'ABaseWeapon::AddedMagazineCountFromAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, Optics_UI_Socket) == 0x000C6C, "Member 'ABaseWeapon::Optics_UI_Socket' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, Grip_UI_Socket) == 0x000C74, "Member 'ABaseWeapon::Grip_UI_Socket' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, Muzzle_UI_Socket) == 0x000C7C, "Member 'ABaseWeapon::Muzzle_UI_Socket' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, Stock_UI_Socket) == 0x000C84, "Member 'ABaseWeapon::Stock_UI_Socket' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, Magazine_UI_Socket) == 0x000C8C, "Member 'ABaseWeapon::Magazine_UI_Socket' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSZoom) == 0x000C94, "Member 'ABaseWeapon::ADSZoom' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSZoomInSpeed) == 0x000C98, "Member 'ABaseWeapon::ADSZoomInSpeed' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSZoomOutSpeed) == 0x000C9C, "Member 'ABaseWeapon::ADSZoomOutSpeed' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, DefaultDamageType) == 0x000CA0, "Member 'ABaseWeapon::DefaultDamageType' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, DamageType) == 0x000CA8, "Member 'ABaseWeapon::DamageType' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FireCameraShake) == 0x000CB0, "Member 'ABaseWeapon::FireCameraShake' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FireCameraShakeInst) == 0x000CB8, "Member 'ABaseWeapon::FireCameraShakeInst' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, DamageOverRange) == 0x000CC0, "Member 'ABaseWeapon::DamageOverRange' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, Damage) == 0x000D48, "Member 'ABaseWeapon::Damage' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, DamageSeverityMultiplier) == 0x000D4C, "Member 'ABaseWeapon::DamageSeverityMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, DamageSeverityChance) == 0x000D50, "Member 'ABaseWeapon::DamageSeverityChance' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BleedoutDamageMultiplier) == 0x000D54, "Member 'ABaseWeapon::BleedoutDamageMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BleedoutDamageChance) == 0x000D58, "Member 'ABaseWeapon::BleedoutDamageChance' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, DefaultDamage) == 0x000D5C, "Member 'ABaseWeapon::DefaultDamage' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FireRate) == 0x000D60, "Member 'ABaseWeapon::FireRate' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, MinFireRateAI) == 0x000D64, "Member 'ABaseWeapon::MinFireRateAI' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, MaxFireRateAI) == 0x000D68, "Member 'ABaseWeapon::MaxFireRateAI' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BulletsFiredUntilFullyAccurate) == 0x000D6C, "Member 'ABaseWeapon::BulletsFiredUntilFullyAccurate' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ProjectileMovementSpeed) == 0x000D70, "Member 'ABaseWeapon::ProjectileMovementSpeed' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bArmorPiercing) == 0x000D74, "Member 'ABaseWeapon::bArmorPiercing' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ImpactEffects) == 0x000D78, "Member 'ABaseWeapon::ImpactEffects' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RicochetEffects) == 0x000D80, "Member 'ABaseWeapon::RicochetEffects' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RicochetParticleSystem) == 0x000D88, "Member 'ABaseWeapon::RicochetParticleSystem' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RicochetEvent) == 0x000D90, "Member 'ABaseWeapon::RicochetEvent' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, SpallingDecal) == 0x000D98, "Member 'ABaseWeapon::SpallingDecal' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, SpallingParticleSystem) == 0x000DA0, "Member 'ABaseWeapon::SpallingParticleSystem' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, SpallingEvent) == 0x000DA8, "Member 'ABaseWeapon::SpallingEvent' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ExitEffects) == 0x000DB0, "Member 'ABaseWeapon::ExitEffects' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, Wobble) == 0x000DB8, "Member 'ABaseWeapon::Wobble' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, InitialWobbleDelay) == 0x000DBC, "Member 'ABaseWeapon::InitialWobbleDelay' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAttachBulletOnHit) == 0x000DC0, "Member 'ABaseWeapon::bAttachBulletOnHit' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BulletPhysicsImpulseMultiplier) == 0x000DC4, "Member 'ABaseWeapon::BulletPhysicsImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bDestroyBulletOnHit) == 0x000DC8, "Member 'ABaseWeapon::bDestroyBulletOnHit' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BulletProjectileMesh) == 0x000DD0, "Member 'ABaseWeapon::BulletProjectileMesh' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FakeProjectileMeshStatic) == 0x000DD8, "Member 'ABaseWeapon::FakeProjectileMeshStatic' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BulletProjectileMeshStatic) == 0x000DE0, "Member 'ABaseWeapon::BulletProjectileMeshStatic' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BulletProjectileScale) == 0x000DE8, "Member 'ABaseWeapon::BulletProjectileScale' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ShellClass) == 0x000DF8, "Member 'ABaseWeapon::ShellClass' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ShellMesh) == 0x000E00, "Member 'ABaseWeapon::ShellMesh' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilPattern) == 0x000E08, "Member 'ABaseWeapon::RecoilPattern' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BulletDrag) == 0x000E1C, "Member 'ABaseWeapon::BulletDrag' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilInterpSpeed) == 0x000E20, "Member 'ABaseWeapon::RecoilInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSRecoilMultiplier) == 0x000E24, "Member 'ABaseWeapon::ADSRecoilMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSSpreadMultiplier) == 0x000E28, "Member 'ABaseWeapon::ADSSpreadMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilReturnRate) == 0x000E2C, "Member 'ABaseWeapon::RecoilReturnRate' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bIgnoreAmmoTypeSpread) == 0x000E30, "Member 'ABaseWeapon::bIgnoreAmmoTypeSpread' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, SpreadPattern) == 0x000E34, "Member 'ABaseWeapon::SpreadPattern' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, SpreadReturnRate) == 0x000E44, "Member 'ABaseWeapon::SpreadReturnRate' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, PendingSpread) == 0x000E48, "Member 'ABaseWeapon::PendingSpread' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FireDirection) == 0x000E54, "Member 'ABaseWeapon::FireDirection' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, GlimmerIntensity) == 0x000E60, "Member 'ABaseWeapon::GlimmerIntensity' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, SpawnProjectileCount) == 0x000E64, "Member 'ABaseWeapon::SpawnProjectileCount' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FirstShotRecoil) == 0x000E68, "Member 'ABaseWeapon::FirstShotRecoil' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FirstShotSpread) == 0x000E6C, "Member 'ABaseWeapon::FirstShotSpread' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FirstShotResetTime) == 0x000E70, "Member 'ABaseWeapon::FirstShotResetTime' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, VelocitySpreadMultiplier) == 0x000E74, "Member 'ABaseWeapon::VelocitySpreadMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, VelocityRecoilMultiplier) == 0x000E78, "Member 'ABaseWeapon::VelocityRecoilMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilMultiplierPitch) == 0x000E7C, "Member 'ABaseWeapon::RecoilMultiplierPitch' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilMultiplierYaw) == 0x000E80, "Member 'ABaseWeapon::RecoilMultiplierYaw' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RefireDelay) == 0x000E84, "Member 'ABaseWeapon::RefireDelay' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilReturnPercentage) == 0x000E88, "Member 'ABaseWeapon::RecoilReturnPercentage' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilReturnInterpSpeed) == 0x000E8C, "Member 'ABaseWeapon::RecoilReturnInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAcceptsScopeAttachments) == 0x000EBA, "Member 'ABaseWeapon::bAcceptsScopeAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAcceptsMuzzleAttachments) == 0x000EBB, "Member 'ABaseWeapon::bAcceptsMuzzleAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAcceptsUnderbarrelAttachments) == 0x000EBC, "Member 'ABaseWeapon::bAcceptsUnderbarrelAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAcceptsOverbarrelAttachments) == 0x000EBD, "Member 'ABaseWeapon::bAcceptsOverbarrelAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAcceptsStockAttachments) == 0x000EBE, "Member 'ABaseWeapon::bAcceptsStockAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAcceptsGripAttachments) == 0x000EBF, "Member 'ABaseWeapon::bAcceptsGripAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAcceptsIlluminatorAttachments) == 0x000EC0, "Member 'ABaseWeapon::bAcceptsIlluminatorAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAcceptsAmmunitionAttachments) == 0x000EC1, "Member 'ABaseWeapon::bAcceptsAmmunitionAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableScopeAttachments) == 0x000EC8, "Member 'ABaseWeapon::AvailableScopeAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableMuzzleAttachments) == 0x000ED8, "Member 'ABaseWeapon::AvailableMuzzleAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableUnderbarrelAttachments) == 0x000EE8, "Member 'ABaseWeapon::AvailableUnderbarrelAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableOverbarrelAttachments) == 0x000EF8, "Member 'ABaseWeapon::AvailableOverbarrelAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableStockAttachments) == 0x000F08, "Member 'ABaseWeapon::AvailableStockAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableGripAttachments) == 0x000F18, "Member 'ABaseWeapon::AvailableGripAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableIlluminatorAttachments) == 0x000F28, "Member 'ABaseWeapon::AvailableIlluminatorAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableAmmunitionAttachments) == 0x000F38, "Member 'ABaseWeapon::AvailableAmmunitionAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bCalculateProcRecoil) == 0x000F48, "Member 'ABaseWeapon::bCalculateProcRecoil' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilDampStrength) == 0x000F4C, "Member 'ABaseWeapon::RecoilDampStrength' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilFireTime) == 0x000F50, "Member 'ABaseWeapon::RecoilFireTime' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilFireStrength) == 0x000F54, "Member 'ABaseWeapon::RecoilFireStrength' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilFireStrengthFirst) == 0x000F58, "Member 'ABaseWeapon::RecoilFireStrengthFirst' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilAngleStrength) == 0x000F5C, "Member 'ABaseWeapon::RecoilAngleStrength' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilRandomness) == 0x000F60, "Member 'ABaseWeapon::RecoilRandomness' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilFireADSModifier) == 0x000F64, "Member 'ABaseWeapon::RecoilFireADSModifier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilAngleADSModifier) == 0x000F68, "Member 'ABaseWeapon::RecoilAngleADSModifier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilRotationBuildup) == 0x000F6C, "Member 'ABaseWeapon::RecoilRotationBuildup' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilPositionBuildup) == 0x000F78, "Member 'ABaseWeapon::RecoilPositionBuildup' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilBuildupADSModifier) == 0x000F84, "Member 'ABaseWeapon::RecoilBuildupADSModifier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilHasBuildup) == 0x000F88, "Member 'ABaseWeapon::RecoilHasBuildup' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilBuildupDampStrength) == 0x000F8C, "Member 'ABaseWeapon::RecoilBuildupDampStrength' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ProcRecoil_Trans) == 0x000FBC, "Member 'ABaseWeapon::ProcRecoil_Trans' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ProcRecoil_Rot) == 0x000FC8, "Member 'ABaseWeapon::ProcRecoil_Rot' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ProcRecoil_Trans_Buildup) == 0x000FD4, "Member 'ABaseWeapon::ProcRecoil_Trans_Buildup' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ProcRecoil_Rot_Buildup) == 0x000FE0, "Member 'ABaseWeapon::ProcRecoil_Rot_Buildup' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, CurrentHighTimer) == 0x000FEC, "Member 'ABaseWeapon::CurrentHighTimer' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ReloadHighTimer) == 0x000FF0, "Member 'ABaseWeapon::ReloadHighTimer' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FireHighTimer) == 0x000FF4, "Member 'ABaseWeapon::FireHighTimer' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, EquipHighTimer) == 0x000FF8, "Member 'ABaseWeapon::EquipHighTimer' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bUseScopeMask) == 0x000FFC, "Member 'ABaseWeapon::bUseScopeMask' has a wrong offset!");

// Class ReadyOrNot.BaseMagazineWeapon
// 0x0430 (0x1430 - 0x1000)
class ABaseMagazineWeapon : public ABaseWeapon
{
public:
	uint8                                         Pad_22B8[0x8];                                     // 0x1000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               MuzzleFlashParticleComponent;                      // 0x1008(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               MuzzleSmokeParticleComponent;                      // 0x1010(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               HeatSmokeParticleComponent;                        // 0x1018(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               RicochetParticleComponent;                         // 0x1020(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               RicochetParticleComponents[0x5];                   // 0x1028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22B9[0x20];                                    // 0x1050(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODAudioComponent*                    FiringAudioComp;                                   // 0x1070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CartridgeText;                                     // 0x1078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RPMText;                                           // 0x1088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BarrelLengthText;                                  // 0x1098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CapacityText;                                      // 0x10A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MuzzleVelocityText;                                // 0x10B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SupressionStrength;                                // 0x10C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BA[0x4];                                     // 0x10CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMatineeCameraShake>        SupressionCameraShake;                             // 0x10D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnNoTrail;                                     // 0x10D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BB[0x7];                                     // 0x10D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABulletTracer*>                  BulletTracers;                                     // 0x10E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ABaseShell*>                     SpawnedShells;                                     // 0x10F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponFire;                                      // 0x1100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponDryFire;                                   // 0x1110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BC[0x30];                                    // 0x1120(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bReloading;                                        // 0x1150(0x0001)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelReloading;                                  // 0x1151(0x0001)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitScan;                                          // 0x1152(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnTracer;                                      // 0x1153(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoSpawnTracerForFiringPlayer;                     // 0x1154(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BD[0xB];                                     // 0x1155(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MuzzleFlashParticleSocket;                         // 0x1160(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MuzzleSmokeParticleSocket;                         // 0x1168(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           GunTails_Handle;                                   // 0x1170(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowParticlesWhenFiring;                          // 0x1178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BE[0x7];                                     // 0x1179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                ArmorPiercingDamageType;                           // 0x1180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ProjectileAttachedParticle;                        // 0x1188(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawBlood;                                        // 0x1190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BF[0x7];                                     // 0x1191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABulletProjectile>          FakeBulletProjectile;                              // 0x1198(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABulletProjectile>          BulletProjectile;                                  // 0x11A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABulletProjectile>          ArmorPiercingBulletProjectile;                     // 0x11A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationDistance;                               // 0x11B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C0[0x4];                                     // 0x11B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            BreachShell;                                       // 0x11B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BeanbagShell;                                      // 0x11C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BuckShotShell;                                     // 0x11C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SlugShell;                                         // 0x11D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MagazineSocket;                                    // 0x11D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMagazine>                      Magazines;                                         // 0x11E0(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MagIndex;                                          // 0x11F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextMagIndex;                                      // 0x11F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HideBoneWhenNotReloading;                          // 0x11F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DesiredAmmoType;                                   // 0x1200(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInfiniteAmmo : 1;                                 // 0x1204(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_22C1[0x3];                                     // 0x1205(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         QueuedAmmoType;                                    // 0x1208(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBulletInChamberOnReload;                          // 0x120C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTacReloadWhenEmpty;                               // 0x120D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C2[0x2];                                     // 0x120E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmmoMax;                                           // 0x1210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockIntegrityMinDamage;                            // 0x1214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockIntegrityMaxDamage;                            // 0x1218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoseMagOnReload;                                  // 0x121C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnShell;                                       // 0x121D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C3[0x2];                                     // 0x121E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnShellDelay;                                   // 0x1220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C4[0x4];                                     // 0x1224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             ShellBounceFMODAudio;                              // 0x1228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C5[0x14];                                    // 0x1230(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpactDecalScale;                                  // 0x1244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AImpactEffect*                          ImpactEffects_Instance;                            // 0x1248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AImpactEffect*>                  SpawnedImpactEffects;                              // 0x1250(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   Magazine_HandSocket;                               // 0x1260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAmmoTypesOnHUD;                               // 0x1268(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C6[0x7];                                     // 0x1269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MoraleHighReloadTableOverride;                     // 0x1270(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MoraleMediumReloadTableOverride;                   // 0x1280(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MoraleLowReloadTableOverride;                      // 0x1290(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C7[0x8];                                     // 0x12A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABulletProjectile*                      LastSpawnedProjectile;                             // 0x12A8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C8[0x8];                                     // 0x12B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MagCheckOverrideSocket;                            // 0x12B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasVisibleMags;                                   // 0x12C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C9[0x3];                                     // 0x12C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Mag_01_Socket;                                     // 0x12C4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Mag_01_Bullets_Socket;                             // 0x12CC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Mag_01_Extra_Socket;                               // 0x12D4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22CA[0x4];                                     // 0x12DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   Mag_01_Comp;                                       // 0x12E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mag_01_Comp_TPOnly;                                // 0x12E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBulletsWhenEmpty;                             // 0x12F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22CB[0x7];                                     // 0x12F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   Mag_01_Bullets_Comp;                               // 0x12F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mag_01_Extra_Comp;                                 // 0x1300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mag_ReloadInterpFix_Comp;                          // 0x1308(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22CC[0x38];                                    // 0x1310(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            Mag_01_Static;                                     // 0x1348(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mag_01_FMJ_Bullets_Static;                         // 0x1350(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mag_01_HP_Bullets_Static;                          // 0x1358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mag_01_Extra_Static;                               // 0x1360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Mag_02_Socket;                                     // 0x1368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Mag_02_Bullets_Socket;                             // 0x1370(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Mag_02_Extra_Socket;                               // 0x1378(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mag_02_Comp;                                       // 0x1380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mag_02_Bullets_Comp;                               // 0x1388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mag_02_Extra_Comp;                                 // 0x1390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mag_02_Static;                                     // 0x1398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mag_02_FMJ_Bullets_Static;                         // 0x13A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mag_02_HP_Bullets_Static;                          // 0x13A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mag_02_Extra_Static;                               // 0x13B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFireLoopAnims;                                 // 0x13B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22CD[0x7];                                     // 0x13B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             MagCheckIcon_Empty;                                // 0x13C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MagCheckIcon_Full;                                 // 0x13C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DroppedMagazineHitEvent;                           // 0x13D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatPerShot;                                       // 0x13D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatThreshold;                                     // 0x13DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatMax;                                           // 0x13E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatDissipation;                                   // 0x13E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHeat;                                       // 0x13E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatMinimumTime;                                   // 0x13EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatTime;                                          // 0x13F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeatEffectPlayed;                                 // 0x13F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22CE[0x3];                                     // 0x13F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MagazineWeightFull;                                // 0x13F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagazineWeightEmpty;                               // 0x13FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagazineCountDefault;                              // 0x1400(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagazineCountMin;                                  // 0x1404(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagazineCountMax;                                  // 0x1408(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MagazineLabel;                                     // 0x140C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenDisassembled;                              // 0x1414(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22CF[0x3];                                     // 0x1415(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GunshotOcclusionMultiplier;                        // 0x1418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GunshotFullOcclusionDepth;                         // 0x141C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootingYellBias;                                  // 0x1420(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTwoHandedPistol;                                  // 0x1424(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeavyRifle;                                       // 0x1425(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D0[0x2];                                     // 0x1426(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RagdollImpulseMultiplier;                          // 0x1428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D1[0x4];                                     // 0x142C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_HitscanDebug(bool bSuccess, const struct FVector& Center, const struct FVector& Extent, const struct FVector& ImpactPoint);
	void FindNextMagIndex();
	float GetAmmoWeight(int32 Count);
	int32 GetMagazineCount();
	void GivenAmmoFromAmmoBag();
	void Multicast_HandleSupression();
	void Multicast_OnFire(const struct FVector_NetQuantize100& DirectionNet, const struct FVector_NetQuantize100& SpawnLoc, int32 Seed);
	void Multicast_PerformHitscan(struct FHitscanShot& HitscanShot, bool bLocalOnly, int32 Seed);
	void Multicast_SimulateFireForViewTargets(const struct FVector_NetQuantize100& DirectionNet, const struct FVector_NetQuantize100& SpawnLoc, int32 Seed);
	void Multicast_SpawnParticleEffects(bool bSkipAuthority, bool bSkipLocalOwner);
	void Multicast_SpawnShell(bool bOnlyLocallyControlled, bool bSkipLocallyControlled);
	void OnFire(const struct FRotator& Direction, const struct FVector& SpawnLoc);
	void OnNewFireModeAnimEvent(EFireMode NewFireMode);
	void OnReloadAnimEvent(EReloadAnimEvent Type);
	void OnWeaponFire__DelegateSignature(class ABaseMagazineWeapon* Weapon, bool bServer);
	void OnWeaponMagCheck__DelegateSignature(class ABaseMagazineWeapon* Weapon);
	void PlayBulletWhizz(float Pan);
	void PlaySound(class USoundCue* Cue);
	float RemoveAmmo(float Value);
	void ReplenishAmmo();
	void Server_AddMagazine(const struct FMagazine& Magazine);
	void Server_HitscanHit(struct FHitResult& HitResult, float Time, const struct FVector& TraceBegin, float Distance, float Penetration, int32 AmmoTypeIndex);
	void Server_NextMagazine();
	void Server_OnFire(const struct FRotator& Direction, const struct FVector& SpawnLoc, int32 Seed);
	void Server_SetCancelReloading(bool bNewValue);
	void Server_SetDesiredAmmoTypeIndex(int32 Param_Index);
	void Server_SetReloading(bool bIsReloading);
	void Server_SetTacticalReload(bool bIsTacticalReload);
	void SetMagazineCount(int32 Count, const TArray<class FName>& AmmoTypes);

	bool AllMagsEmpty() const;
	float GetAmmo() const;
	float GetAmmoInMagazine(int32 Param_Index) const;
	float GetCurrentAmmoPercentage() const;
	struct FMagazine GetCurrentMagazine() const;
	float GetMagazineAmmoPercentage(int32 MagazineIndex) const;
	class FText GetMagazineScreenName(struct FMagazine& Magazine) const;
	float GetNextAmmo() const;
	bool HasAmmo() const;
	bool HasAnyAmmo() const;
	bool HasAnyAmmoOfType(class FName AmmoType) const;
	bool InBurstMode() const;
	bool InFullAutoMode() const;
	bool InSafeMode() const;
	bool InSingleMode() const;
	bool IsPistolWithShield() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseMagazineWeapon">();
	}
	static class ABaseMagazineWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseMagazineWeapon>();
	}
};
static_assert(alignof(ABaseMagazineWeapon) == 0x000010, "Wrong alignment on ABaseMagazineWeapon");
static_assert(sizeof(ABaseMagazineWeapon) == 0x001430, "Wrong size on ABaseMagazineWeapon");
static_assert(offsetof(ABaseMagazineWeapon, MuzzleFlashParticleComponent) == 0x001008, "Member 'ABaseMagazineWeapon::MuzzleFlashParticleComponent' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MuzzleSmokeParticleComponent) == 0x001010, "Member 'ABaseMagazineWeapon::MuzzleSmokeParticleComponent' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, HeatSmokeParticleComponent) == 0x001018, "Member 'ABaseMagazineWeapon::HeatSmokeParticleComponent' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, RicochetParticleComponent) == 0x001020, "Member 'ABaseMagazineWeapon::RicochetParticleComponent' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, RicochetParticleComponents) == 0x001028, "Member 'ABaseMagazineWeapon::RicochetParticleComponents' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, FiringAudioComp) == 0x001070, "Member 'ABaseMagazineWeapon::FiringAudioComp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, CartridgeText) == 0x001078, "Member 'ABaseMagazineWeapon::CartridgeText' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, RPMText) == 0x001088, "Member 'ABaseMagazineWeapon::RPMText' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, BarrelLengthText) == 0x001098, "Member 'ABaseMagazineWeapon::BarrelLengthText' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, CapacityText) == 0x0010A8, "Member 'ABaseMagazineWeapon::CapacityText' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MuzzleVelocityText) == 0x0010B8, "Member 'ABaseMagazineWeapon::MuzzleVelocityText' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, SupressionStrength) == 0x0010C8, "Member 'ABaseMagazineWeapon::SupressionStrength' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, SupressionCameraShake) == 0x0010D0, "Member 'ABaseMagazineWeapon::SupressionCameraShake' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bSpawnNoTrail) == 0x0010D8, "Member 'ABaseMagazineWeapon::bSpawnNoTrail' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, BulletTracers) == 0x0010E0, "Member 'ABaseMagazineWeapon::BulletTracers' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, SpawnedShells) == 0x0010F0, "Member 'ABaseMagazineWeapon::SpawnedShells' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, OnWeaponFire) == 0x001100, "Member 'ABaseMagazineWeapon::OnWeaponFire' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, OnWeaponDryFire) == 0x001110, "Member 'ABaseMagazineWeapon::OnWeaponDryFire' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bReloading) == 0x001150, "Member 'ABaseMagazineWeapon::bReloading' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bCancelReloading) == 0x001151, "Member 'ABaseMagazineWeapon::bCancelReloading' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bHitScan) == 0x001152, "Member 'ABaseMagazineWeapon::bHitScan' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bSpawnTracer) == 0x001153, "Member 'ABaseMagazineWeapon::bSpawnTracer' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bNoSpawnTracerForFiringPlayer) == 0x001154, "Member 'ABaseMagazineWeapon::bNoSpawnTracerForFiringPlayer' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MuzzleFlashParticleSocket) == 0x001160, "Member 'ABaseMagazineWeapon::MuzzleFlashParticleSocket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MuzzleSmokeParticleSocket) == 0x001168, "Member 'ABaseMagazineWeapon::MuzzleSmokeParticleSocket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, GunTails_Handle) == 0x001170, "Member 'ABaseMagazineWeapon::GunTails_Handle' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bShowParticlesWhenFiring) == 0x001178, "Member 'ABaseMagazineWeapon::bShowParticlesWhenFiring' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, ArmorPiercingDamageType) == 0x001180, "Member 'ABaseMagazineWeapon::ArmorPiercingDamageType' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, ProjectileAttachedParticle) == 0x001188, "Member 'ABaseMagazineWeapon::ProjectileAttachedParticle' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bDrawBlood) == 0x001190, "Member 'ABaseMagazineWeapon::bDrawBlood' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, FakeBulletProjectile) == 0x001198, "Member 'ABaseMagazineWeapon::FakeBulletProjectile' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, BulletProjectile) == 0x0011A0, "Member 'ABaseMagazineWeapon::BulletProjectile' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, ArmorPiercingBulletProjectile) == 0x0011A8, "Member 'ABaseMagazineWeapon::ArmorPiercingBulletProjectile' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, PenetrationDistance) == 0x0011B0, "Member 'ABaseMagazineWeapon::PenetrationDistance' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, BreachShell) == 0x0011B8, "Member 'ABaseMagazineWeapon::BreachShell' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, BeanbagShell) == 0x0011C0, "Member 'ABaseMagazineWeapon::BeanbagShell' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, BuckShotShell) == 0x0011C8, "Member 'ABaseMagazineWeapon::BuckShotShell' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, SlugShell) == 0x0011D0, "Member 'ABaseMagazineWeapon::SlugShell' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagazineSocket) == 0x0011D8, "Member 'ABaseMagazineWeapon::MagazineSocket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Magazines) == 0x0011E0, "Member 'ABaseMagazineWeapon::Magazines' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagIndex) == 0x0011F0, "Member 'ABaseMagazineWeapon::MagIndex' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, NextMagIndex) == 0x0011F4, "Member 'ABaseMagazineWeapon::NextMagIndex' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, HideBoneWhenNotReloading) == 0x0011F8, "Member 'ABaseMagazineWeapon::HideBoneWhenNotReloading' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, DesiredAmmoType) == 0x001200, "Member 'ABaseMagazineWeapon::DesiredAmmoType' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, QueuedAmmoType) == 0x001208, "Member 'ABaseMagazineWeapon::QueuedAmmoType' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bBulletInChamberOnReload) == 0x00120C, "Member 'ABaseMagazineWeapon::bBulletInChamberOnReload' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bTacReloadWhenEmpty) == 0x00120D, "Member 'ABaseMagazineWeapon::bTacReloadWhenEmpty' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, AmmoMax) == 0x001210, "Member 'ABaseMagazineWeapon::AmmoMax' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, LockIntegrityMinDamage) == 0x001214, "Member 'ABaseMagazineWeapon::LockIntegrityMinDamage' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, LockIntegrityMaxDamage) == 0x001218, "Member 'ABaseMagazineWeapon::LockIntegrityMaxDamage' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bLoseMagOnReload) == 0x00121C, "Member 'ABaseMagazineWeapon::bLoseMagOnReload' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bSpawnShell) == 0x00121D, "Member 'ABaseMagazineWeapon::bSpawnShell' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, SpawnShellDelay) == 0x001220, "Member 'ABaseMagazineWeapon::SpawnShellDelay' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, ShellBounceFMODAudio) == 0x001228, "Member 'ABaseMagazineWeapon::ShellBounceFMODAudio' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, ImpactDecalScale) == 0x001244, "Member 'ABaseMagazineWeapon::ImpactDecalScale' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, ImpactEffects_Instance) == 0x001248, "Member 'ABaseMagazineWeapon::ImpactEffects_Instance' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, SpawnedImpactEffects) == 0x001250, "Member 'ABaseMagazineWeapon::SpawnedImpactEffects' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Magazine_HandSocket) == 0x001260, "Member 'ABaseMagazineWeapon::Magazine_HandSocket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bShowAmmoTypesOnHUD) == 0x001268, "Member 'ABaseMagazineWeapon::bShowAmmoTypesOnHUD' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MoraleHighReloadTableOverride) == 0x001270, "Member 'ABaseMagazineWeapon::MoraleHighReloadTableOverride' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MoraleMediumReloadTableOverride) == 0x001280, "Member 'ABaseMagazineWeapon::MoraleMediumReloadTableOverride' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MoraleLowReloadTableOverride) == 0x001290, "Member 'ABaseMagazineWeapon::MoraleLowReloadTableOverride' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, LastSpawnedProjectile) == 0x0012A8, "Member 'ABaseMagazineWeapon::LastSpawnedProjectile' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagCheckOverrideSocket) == 0x0012B8, "Member 'ABaseMagazineWeapon::MagCheckOverrideSocket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bHasVisibleMags) == 0x0012C0, "Member 'ABaseMagazineWeapon::bHasVisibleMags' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Socket) == 0x0012C4, "Member 'ABaseMagazineWeapon::Mag_01_Socket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Bullets_Socket) == 0x0012CC, "Member 'ABaseMagazineWeapon::Mag_01_Bullets_Socket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Extra_Socket) == 0x0012D4, "Member 'ABaseMagazineWeapon::Mag_01_Extra_Socket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Comp) == 0x0012E0, "Member 'ABaseMagazineWeapon::Mag_01_Comp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Comp_TPOnly) == 0x0012E8, "Member 'ABaseMagazineWeapon::Mag_01_Comp_TPOnly' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bShowBulletsWhenEmpty) == 0x0012F0, "Member 'ABaseMagazineWeapon::bShowBulletsWhenEmpty' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Bullets_Comp) == 0x0012F8, "Member 'ABaseMagazineWeapon::Mag_01_Bullets_Comp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Extra_Comp) == 0x001300, "Member 'ABaseMagazineWeapon::Mag_01_Extra_Comp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_ReloadInterpFix_Comp) == 0x001308, "Member 'ABaseMagazineWeapon::Mag_ReloadInterpFix_Comp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Static) == 0x001348, "Member 'ABaseMagazineWeapon::Mag_01_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_FMJ_Bullets_Static) == 0x001350, "Member 'ABaseMagazineWeapon::Mag_01_FMJ_Bullets_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_HP_Bullets_Static) == 0x001358, "Member 'ABaseMagazineWeapon::Mag_01_HP_Bullets_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Extra_Static) == 0x001360, "Member 'ABaseMagazineWeapon::Mag_01_Extra_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_Socket) == 0x001368, "Member 'ABaseMagazineWeapon::Mag_02_Socket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_Bullets_Socket) == 0x001370, "Member 'ABaseMagazineWeapon::Mag_02_Bullets_Socket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_Extra_Socket) == 0x001378, "Member 'ABaseMagazineWeapon::Mag_02_Extra_Socket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_Comp) == 0x001380, "Member 'ABaseMagazineWeapon::Mag_02_Comp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_Bullets_Comp) == 0x001388, "Member 'ABaseMagazineWeapon::Mag_02_Bullets_Comp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_Extra_Comp) == 0x001390, "Member 'ABaseMagazineWeapon::Mag_02_Extra_Comp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_Static) == 0x001398, "Member 'ABaseMagazineWeapon::Mag_02_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_FMJ_Bullets_Static) == 0x0013A0, "Member 'ABaseMagazineWeapon::Mag_02_FMJ_Bullets_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_HP_Bullets_Static) == 0x0013A8, "Member 'ABaseMagazineWeapon::Mag_02_HP_Bullets_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_Extra_Static) == 0x0013B0, "Member 'ABaseMagazineWeapon::Mag_02_Extra_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bUseFireLoopAnims) == 0x0013B8, "Member 'ABaseMagazineWeapon::bUseFireLoopAnims' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagCheckIcon_Empty) == 0x0013C0, "Member 'ABaseMagazineWeapon::MagCheckIcon_Empty' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagCheckIcon_Full) == 0x0013C8, "Member 'ABaseMagazineWeapon::MagCheckIcon_Full' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, DroppedMagazineHitEvent) == 0x0013D0, "Member 'ABaseMagazineWeapon::DroppedMagazineHitEvent' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, HeatPerShot) == 0x0013D8, "Member 'ABaseMagazineWeapon::HeatPerShot' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, HeatThreshold) == 0x0013DC, "Member 'ABaseMagazineWeapon::HeatThreshold' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, HeatMax) == 0x0013E0, "Member 'ABaseMagazineWeapon::HeatMax' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, HeatDissipation) == 0x0013E4, "Member 'ABaseMagazineWeapon::HeatDissipation' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, CurrentHeat) == 0x0013E8, "Member 'ABaseMagazineWeapon::CurrentHeat' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, HeatMinimumTime) == 0x0013EC, "Member 'ABaseMagazineWeapon::HeatMinimumTime' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, HeatTime) == 0x0013F0, "Member 'ABaseMagazineWeapon::HeatTime' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bHeatEffectPlayed) == 0x0013F4, "Member 'ABaseMagazineWeapon::bHeatEffectPlayed' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagazineWeightFull) == 0x0013F8, "Member 'ABaseMagazineWeapon::MagazineWeightFull' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagazineWeightEmpty) == 0x0013FC, "Member 'ABaseMagazineWeapon::MagazineWeightEmpty' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagazineCountDefault) == 0x001400, "Member 'ABaseMagazineWeapon::MagazineCountDefault' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagazineCountMin) == 0x001404, "Member 'ABaseMagazineWeapon::MagazineCountMin' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagazineCountMax) == 0x001408, "Member 'ABaseMagazineWeapon::MagazineCountMax' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagazineLabel) == 0x00140C, "Member 'ABaseMagazineWeapon::MagazineLabel' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bHasBeenDisassembled) == 0x001414, "Member 'ABaseMagazineWeapon::bHasBeenDisassembled' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, GunshotOcclusionMultiplier) == 0x001418, "Member 'ABaseMagazineWeapon::GunshotOcclusionMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, GunshotFullOcclusionDepth) == 0x00141C, "Member 'ABaseMagazineWeapon::GunshotFullOcclusionDepth' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, ShootingYellBias) == 0x001420, "Member 'ABaseMagazineWeapon::ShootingYellBias' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bTwoHandedPistol) == 0x001424, "Member 'ABaseMagazineWeapon::bTwoHandedPistol' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bHeavyRifle) == 0x001425, "Member 'ABaseMagazineWeapon::bHeavyRifle' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, RagdollImpulseMultiplier) == 0x001428, "Member 'ABaseMagazineWeapon::RagdollImpulseMultiplier' has a wrong offset!");

// Class ReadyOrNot.BaseMagPouch
// 0x0020 (0x09F0 - 0x09D0)
class ABaseMagPouch final  : public ABaseItem
{
public:
	class USkeletalMeshComponent*                 MagazineMesh;                                      // 0x09D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationAsset*                        OpenPouchAnim;                                     // 0x09D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationAsset*                        ClosedPouchAnim;                                   // 0x09E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MagSocket;                                         // 0x09E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ClosePouch();
	void HideMagazine();
	void OpenPouch();
	void ShowMagazine();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseMagPouch">();
	}
	static class ABaseMagPouch* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseMagPouch>();
	}
};
static_assert(alignof(ABaseMagPouch) == 0x000010, "Wrong alignment on ABaseMagPouch");
static_assert(sizeof(ABaseMagPouch) == 0x0009F0, "Wrong size on ABaseMagPouch");
static_assert(offsetof(ABaseMagPouch, MagazineMesh) == 0x0009D0, "Member 'ABaseMagPouch::MagazineMesh' has a wrong offset!");
static_assert(offsetof(ABaseMagPouch, OpenPouchAnim) == 0x0009D8, "Member 'ABaseMagPouch::OpenPouchAnim' has a wrong offset!");
static_assert(offsetof(ABaseMagPouch, ClosedPouchAnim) == 0x0009E0, "Member 'ABaseMagPouch::ClosedPouchAnim' has a wrong offset!");
static_assert(offsetof(ABaseMagPouch, MagSocket) == 0x0009E8, "Member 'ABaseMagPouch::MagSocket' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotCharacter
// 0x1170 (0x1630 - 0x04C0)
#pragma pack(push, 0x1)
class alignas(0x10) AReadyOrNotCharacter : public ACharacter
{
public:
	uint8                                         Pad_22D8[0x70];                                    // 0x04B8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 CustomizationFaceMesh;                             // 0x0528(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         CustomizationSkeletalMeshes;                       // 0x0530(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           CustomizationStaticMeshes;                         // 0x0540(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         CustomizationActors;                               // 0x0550(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FSavedCustomization                    Customization;                                     // 0x0560(0x00D0)(Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D9[0x50];                                    // 0x0630(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 MeshGearSlot;                                      // 0x0680(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InteractableComponent;                             // 0x0688(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectiveMarkerComponent*              PlayerMarkerComponent;                             // 0x0690(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 FaceMesh;                                          // 0x0698(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioPropagationComponent*         FMODAudioPropagationComp;                          // 0x06A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    FMODVoiceAudioComp;                                // 0x06A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterHealthComponent*              CharacterHealth;                                   // 0x06B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryComponent*                    InventoryComp;                                     // 0x06B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIPerceptionStimuliSourceComponent*    PerceptionStimuliComp;                             // 0x06C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGibComponent*                          GibComponent;                                      // 0x06C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicalAnimationComponent*            PhysicalAnimationComp;                             // 0x06D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkinnedDecalSampler*                   SkinnedDecalSampler;                               // 0x06D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URagdollComponent*                      RagdollComponent;                                  // 0x06E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22DA[0x3C];                                    // 0x06E8(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReplicatedControlRotation;                         // 0x0724(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterKilled;                                 // 0x0730(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterIncapacitated;                          // 0x0740(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponFire;                                      // 0x0750(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponDryFire;                                   // 0x0760(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerDowned;                                    // 0x0770(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPointDamageReceived;                             // 0x0780(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStunDamageReceived;                              // 0x0790(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerFreed;                                     // 0x07A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerHit;                                       // 0x07B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerArmorHit;                                  // 0x07C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ABaseItem*                              ThrownItem;                                        // 0x07D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGetupComplete;                                   // 0x07D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemThrown_FromAnimNotify;                       // 0x07E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoorLockPickBegin_FromAnimNotify;                // 0x07F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoorLockPickEnd_FromAnimNotify;                  // 0x0808(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoorChecked_FromAnimNotify;                      // 0x0818(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnC2Placed_FromAnimNotify;                         // 0x0828(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnC2Detonate_FromAnimNotify;                       // 0x0838(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTrapDisarmBegin_FromAnimNotify;                  // 0x0848(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTrapDisarmEnd_FromAnimNotify;                    // 0x0858(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMirrorDoorStarted_FromAnimNotify;                // 0x0868(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMirrorDoorFinished_FromAnimNotify;               // 0x0878(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStartDoorWedgePlacement_FromAnimNotify;          // 0x0888(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndDoorWedgePlacement_FromAnimNotify;            // 0x0898(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_22DB[0x30];                                    // 0x08A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterDamageEvent                  LastDamageEvent;                                   // 0x08D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_22DC[0x2];                                     // 0x0900(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBulletForceTransferred;                           // 0x0902(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22DD[0x1];                                     // 0x0903(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumBodyFallImpulse;                            // 0x0904(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRagdollSounds;                                  // 0x0908(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RagdollSoundsPlayed;                               // 0x090C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BodyFallEvent;                                     // 0x0910(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22DE[0x8];                                     // 0x0918(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundSource*                           BodyFallSoundSource;                               // 0x0920(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCapsuleCollisionRagdolled;                        // 0x0928(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCapsuleFloorAngleRagdolled;                       // 0x0929(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22DF[0x2];                                     // 0x092A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CapsuleCollisionRagdollTriggerThreshold;           // 0x092C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleFloorAngleRagdollTriggerThreshold;          // 0x0930(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleFloorAngleRagdollDelayThreshold;            // 0x0934(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendingAnim2Ragdoll;                             // 0x0938(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E0[0xF];                                     // 0x0939(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Anim2RagdollPelvisWakeUpTime;                      // 0x0948(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E1[0xC];                                     // 0x094C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundSource*                           VoiceSoundSource;                                  // 0x0958(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E2[0x1D0];                                   // 0x0960(0x01D0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBlendInPhysics;                                   // 0x0B30(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartBlendInIncapacitation;                       // 0x0B31(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendInIncapacitation;                            // 0x0B32(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E3[0x1];                                     // 0x0B33(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IncapacitationBlendTime;                           // 0x0B34(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncapacitationBlendOutTime;                        // 0x0B38(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E4[0x4];                                     // 0x0B3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          IncapacitationLoopAnim;                            // 0x0B40(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInterpAmount;                                 // 0x0B48(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E5[0xC];                                     // 0x0B4C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FinalBlendInTime;                                  // 0x0B58(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E6[0x4];                                     // 0x0B5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInAfterStartOfAnim;                           // 0x0B60(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsPreviewCharacter : 1;                           // 0x0B64(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_22E7[0xB];                                     // 0x0B65(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   ArrestedBy;                                        // 0x0B70(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   KilledBy;                                          // 0x0B78(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   IncapacitatedBy;                                   // 0x0B80(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterDeathReason                         DeathReason;                                       // 0x0B88(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E8[0x7];                                     // 0x0B89(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCharacterTakeDamage;                             // 0x0B90(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAIStunnedPlaySound;                              // 0x0BA0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStunnedEvent;                                    // 0x0BB0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStunnedEndedEvent;                               // 0x0BC0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMeleeHitTaken;                                   // 0x0BD0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FName>                           HeadBones;                                         // 0x0BE0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           UpperBody;                                         // 0x0BF0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_22E9[0x10];                                    // 0x0C00(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           LowerBody;                                         // 0x0C10(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           R_Leg;                                             // 0x0C20(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           L_Leg;                                             // 0x0C30(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           L_Foot;                                            // 0x0C40(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           R_Foot;                                            // 0x0C50(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           L_Arm;                                             // 0x0C60(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           R_Arm;                                             // 0x0C70(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           L_Hand;                                            // 0x0C80(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           R_Hand;                                            // 0x0C90(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bLowReadyPointUp;                                  // 0x0CA0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLowReadyPointDown;                                // 0x0CA1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22EA[0x2];                                     // 0x0CA2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowReadyDistance;                                  // 0x0CA4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22EB[0x8];                                     // 0x0CA8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCapsuleComponent*>              LowReadyIgnoredCapsules;                           // 0x0CB0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         bIsCrouching : 1;                                  // 0x0CC0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_22EC[0x3];                                     // 0x0CC1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QuickLeanAmount;                                   // 0x0CC4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanIntensity;                                // 0x0CC8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanInterpSpeed;                              // 0x0CCC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeLeanX;                                         // 0x0CD0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeLeanZ;                                         // 0x0CD4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreeLeaning;                                      // 0x0CD8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeaning;                                        // 0x0CD9(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaningLeft;                                      // 0x0CDA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaningRight;                                     // 0x0CDB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaningUp;                                        // 0x0CDC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaningDown;                                      // 0x0CDD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeanLeftToggle;                                   // 0x0CDE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLeanRightToggle;                                  // 0x0CDF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    LeanAudioComponent;                                // 0x0CE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             LeanAudioEvent;                                    // 0x0CE8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeanMovementValue;                                 // 0x0CF0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LeanPos_CurrentFrame;                              // 0x0CF4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LeanPos_LastFrame;                                 // 0x0D00(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESquadPosition                                SquadPosition;                                     // 0x0D0C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeamType                                     DefaultTeam;                                       // 0x0D0D(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22ED[0x2];                                     // 0x0D0E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             FPMeleeImpactFMODEvent;                            // 0x0D10(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             TPMeleeImpactFMODEvent;                            // 0x0D18(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        MeleeImpactParticle;                               // 0x0D20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMatineeCameraShake>        MeleeCameraShake;                                  // 0x0D28(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeleeRange;                                        // 0x0D30(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeleeDamage;                                       // 0x0D34(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   MeleeDamageType;                                   // 0x0D38(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPlayerArrested;                                  // 0x0D60(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerArrestStart;                               // 0x0D70(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerArrestedCanceled;                          // 0x0D80(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   PendingAutoReport;                                 // 0x0D90(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCarryArrestedAnimState                Rep_CarryArrestedAnimState;                        // 0x0D98(0x0008)(BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSurrendered;                                      // 0x0DA0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSurrenderComplete;                                // 0x0DA1(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22EE[0x16];                                    // 0x0DA2(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOrderedToRotateForArrest : 1;                     // 0x0DB8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_22EF[0x7];                                     // 0x0DB9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlacedZipcuffs*                        PlacedZipcuffs;                                    // 0x0DC0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APlacedZipcuffs>            SpawnedZipcuffsClass;                              // 0x0DC8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APlacedZipcuffs>            SpawnedFPZipcuffsClass;                            // 0x0DD0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ZipcuffBone;                                       // 0x0DD8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBeingCarried;                                   // 0x0DE0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCarryingDead;                                     // 0x0DE1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F0[0x6];                                     // 0x0DE2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   CarriedByCharacter;                                // 0x0DE8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   ThrownByCharacter;                                 // 0x0DF0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   PendingCarryCharacter;                             // 0x0DF8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   CurrentCarryCharacter;                             // 0x0E00(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASkeletalMeshActor*                     FakeCarryCharacterMesh;                            // 0x0E08(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentCarryConfirmTime;                           // 0x0E10(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F1[0x4];                                     // 0x0E14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          CarryMasterIdleLoop;                               // 0x0E18(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CarrySlaveIdleLoop;                                // 0x0E20(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCarryConfirmTime;                               // 0x0E28(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRagdollArrestConfirmTime;                       // 0x0E2C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentRagdollArrestConfirmTime;                   // 0x0E30(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F2[0x4];                                     // 0x0E34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   PendingRagdollArrestCharacter;                     // 0x0E38(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   CurrentRagdollArrestCharacter;                     // 0x0E40(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   LastCharacterMakingArrest;                         // 0x0E48(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   CurrentlyArresting;                                // 0x0E50(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingArrested;                                  // 0x0E58(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArrestComplete;                                   // 0x0E59(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArrestedAsRagdoll;                                // 0x0E5A(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArrestedAsRagdoll_Flipped;                        // 0x0E5B(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPairedInteractionPlaying;                       // 0x0E5C(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoTeamDamage;                                     // 0x0E5D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableInteraction;                               // 0x0E5E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrimed;                                           // 0x0E5F(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverarmThrow;                                     // 0x0E60(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F3[0x7];                                     // 0x0E61(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnQuickThrowStart;                                 // 0x0E68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnQuickThrowEnd;                                   // 0x0E78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCarryingChanged;                                 // 0x0E88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F4[0x1];                                     // 0x0E98(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsStrafing;                                       // 0x0E99(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F5[0x6];                                     // 0x0E9A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UAnimMontage*>      PlayedTableMontageMap3P;                           // 0x0EA0(0x0050)(NativeAccessSpecifierPublic)
	class FString                                 LastTableMontagePlayed;                            // 0x0EF0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F6[0x78];                                    // 0x0F00(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterLookOverride                 CharacterLookOverride;                             // 0x0F78(0x00D0)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FString                                 Rep_CharacterLookOverride;                         // 0x1048(0x0010)(Net, ZeroConstructor, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class ABaseArmour>, class USkeletalMesh*> ArmorOverrideMapTP;                                // 0x1058(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          Rep_BodyMesh;                                      // 0x10A8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          Rep_FaceMesh;                                      // 0x10B0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          Rep_FPMesh;                                        // 0x10B8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class UAnimMontage*, float>              AnimMontageCooldown;                               // 0x10C0(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UPoseAsset*                             CurrentFaceROM;                                    // 0x1110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimationBlockingTime;                             // 0x1118(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F7[0x24];                                    // 0x111C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class ATOCManager*                            TOCManager;                                        // 0x1140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMatineeCameraShake>        ReportToTOC_PVP_CameraShake;                       // 0x1148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 TOCLine;                                           // 0x1150(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SpeechCharacterName;                               // 0x1160(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F8[0x8];                                     // 0x1170(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasBeenReported;                                  // 0x1178(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F9[0x3];                                     // 0x1179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeakCooldown;                                     // 0x117C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ReportPlayerDeadFMODEvent;                         // 0x1180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ReportPlayerArrestedFMODEvent;                     // 0x1188(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ReportPlayerGeneralFMODEvent;                      // 0x1190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVoiceAudioStoppedDelegate;                       // 0x1198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_22FA[0x18];                                    // 0x11A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, float>                    SpeechCooldownMap;                                 // 0x11C0(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FMODVoiceLine2D;                                   // 0x1210(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FMODVoiceLineSpatalized;                           // 0x1218(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22FB[0x8];                                     // 0x1220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FSuppressionData>    BoneSuppressionAmount;                             // 0x1228(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBoneDamaged;                                     // 0x1278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBodyPartDamaged;                                 // 0x1288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bBodyHit : 1;                                      // 0x1298(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRightFootHit : 1;                                 // 0x1298(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLeftFootHit : 1;                                  // 0x1298(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlockedByBodyArmor : 1;                           // 0x1298(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlockedByHeadArmor : 1;                           // 0x1298(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_22FC[0x17];                                    // 0x1299(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGibAreas, float>                        DismembermentDamageMap;                            // 0x12B0(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class FName>                           DamageExcludedBones;                               // 0x1300(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_22FD[0x10];                                    // 0x1310(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GasDamageAccumulated;                              // 0x1320(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GasDamageDecay;                                    // 0x1324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22FE[0x8];                                     // 0x1328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bGodMode : 1;                                      // 0x1330(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bNoTarget;                                         // 0x1331(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22FF[0x6];                                     // 0x1332(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        ArmorImpactEffect;                                 // 0x1338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBloodData*                             Blood;                                             // 0x1340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABaseWeapon*>                    DamagedByWeapons;                                  // 0x1348(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2300[0x8];                                     // 0x1358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRepStunned;                                       // 0x1360(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStunType                                     RepStunnedWith;                                    // 0x1361(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2301[0x56];                                    // 0x1362(0x0056)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bHasEverBeenStunned : 1;                           // 0x13B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2302[0x17];                                    // 0x13B9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotCharacter*>           AITrackingMe;                                      // 0x13D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           DamagedByCharacters;                               // 0x13E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                OriginalSpawnLocation;                             // 0x13F0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2303[0x4];                                     // 0x13FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnEvidenceCollected;                               // 0x1400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2304[0x8];                                     // 0x1410(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PendingEvidence;                                   // 0x1418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCollectingEvidence;                             // 0x1420(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCollectionAnimHasTriggered;                       // 0x1421(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2305[0x6];                                     // 0x1422(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CollectingLoopAnim1P;                              // 0x1428(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           CollectingLoopAnim3P;                              // 0x1430(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ACollectedEvidenceActor>    CollectedEvidenceClass;                            // 0x1438(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             Reward;                                            // 0x1440(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterEmotion                             CurrentEmotion;                                    // 0x1448(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2306[0x3];                                     // 0x1449(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FacialAnimationOverrideTime;                       // 0x144C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FacialAnimationBlend;                              // 0x1450(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FacialAnimationBlendTarget;                        // 0x1454(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FacialAnimationBlendDecay;                         // 0x1458(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FacialAnimationPriority;                           // 0x145C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAiming;                                           // 0x1460(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovementLocked;                                   // 0x1461(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAimLocked;                                        // 0x1462(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActionsLocked;                                    // 0x1463(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bItemSelectionLocked;                              // 0x1464(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCommandMenuLocked;                                // 0x1465(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWeaponAttachmentsLocked;                          // 0x1466(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCantedSightLocked;                                // 0x1467(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADoor*                                  QueuedDoorToOpen;                                  // 0x1468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADoor*                                  QueuedDoorToClose;                                 // 0x1470(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADoor*                                  LastKickedDoor;                                    // 0x1478(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      DoorKickInteractionFront;                          // 0x1480(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      DoorKickInteractionBack;                           // 0x1488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      DoorKickFailureInteractionFront;                   // 0x1490(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      DoorKickFailureInteractionBack;                    // 0x1498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      DoorKickBreakInteractionFront;                     // 0x14A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      DoorKickBreakInteractionBack;                      // 0x14A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      CarryArrestedInteractionData;                      // 0x14B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      DropArrestedInteractionData;                       // 0x14B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      ThrowArrestedInteractionData;                      // 0x14C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             Event_OnItemPrimaryUse;                            // 0x14C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bNVGOn;                                            // 0x14D8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2307[0x7];                                     // 0x14D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnNightVisionGogglesToggled;                       // 0x14E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2308[0x28];                                    // 0x14F0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldPlayFootstepFoley;                          // 0x1518(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayEveryStep;                                    // 0x1519(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2309[0x6];                                     // 0x151A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AImpactEffect>              FootstepImpactEffectFast;                          // 0x1520(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AImpactEffect>              FootstepImpactEffectSlow;                          // 0x1528(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             CurrentFootstepFoleyEvent;                         // 0x1530(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             CurrentFootstepFoleyEventRemote;                   // 0x1538(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FootstepsLocal;                                    // 0x1540(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FootstepsRemote;                                   // 0x1548(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             MovementFoley;                                     // 0x1550(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MovementFoleySocket;                               // 0x1558(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsAsset*                          DefaultRagdollPhysAsset;                           // 0x1560(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsAsset*                          DefaultAlivePhysAsset;                             // 0x1568(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsAsset*                          CuffedRagdollPhysAsset;                            // 0x1570(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsAsset*                          Rep_ActiveRagdollPhysAsset;                        // 0x1578(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRelevant;                                       // 0x1580(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230A[0x7];                                     // 0x1581(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ANeutralizeSuspectByTag*                NeutralizeSuspectTag;                              // 0x1588(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UAnimMontage*>                   TorsoDeathAnims;                                   // 0x1590(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   HeadDeathAnims;                                    // 0x15A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   LeftArmDeathAnims;                                 // 0x15B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   RightArmDeathAnims;                                // 0x15C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   LeftLegDeathAnims;                                 // 0x15D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   RightLegDeathAnims;                                // 0x15E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CurrentDeathMontage;                               // 0x15F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayingDeathMontage : 1;                          // 0x15F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStartedPlayingDeath : 1;                          // 0x15F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	struct FRonReplicatedAcceleration             ReplicatedAcceleration;                            // 0x15F9(0x0003)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReplicatedMaxSpeed;                                // 0x15FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBlendRagdollNotifyActive;                       // 0x1600(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230B[0x3];                                     // 0x1601(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootstepOcclusionMultiplier;                       // 0x1604(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootstepFullOcclusionDepth;                        // 0x1608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230C[0xC];                                     // 0x160C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterSnapshot>             Snapshots;                                         // 0x1618(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static bool IsOnSameTeam(class AReadyOrNotCharacter* A, class AReadyOrNotCharacter* B);

	void ApplyDamageToBone(float* Damage, class FName& HitBone, struct FPointDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void Arrest(class AReadyOrNotCharacter* PlayerMakingArrest);
	void ArrestComplete(class AReadyOrNotCharacter* PlayerMakingArrest, class AZipcuffs* Zipcuffs);
	void BeginEvidenceCollection_COOP(class AActor* InEvidenceActor, class UInteractableComponent* CollectionInteractableComp, float CollectionTime);
	void CalculateLeanMovement(float DeltaTime);
	void CancelArrest(class AReadyOrNotCharacter* PlayerMakingArrest);
	void Client_OnBodyPartDamaged(bool bInHeadHit, bool bInBodyHit, bool bInLeftArmHit, bool bInRightArmHit, bool bInLeftLegHit, bool bInRightLegHit, bool bInLeftFootHit, bool bInRightFootHit);
	void Client_OnBoneDamaged(class FName& BoneHit);
	void Client_Play1PMontage(class UAnimMontage* NewMontage, float PlayRate);
	void Client_PlayFMODEvent2D(class UFMODEvent* Event);
	void Client_PlayMeleeImpactEffects();
	void Client_PlayScreenShake(TSubclassOf<class UMatineeCameraShake> CameraShake);
	void Client_SetControlRotation(const struct FRotator& NewRotation);
	void CollectPendingEvidence();
	void CompleteEvidenceCollection_COOP(class AActor* InEvidenceActor);
	bool DamageHitHead(struct FPointDamageEvent& DamageEvent);
	void DecreaseHealth(float Amount);
	void DepleteHealth();
	void DisableNightVisionGoggles();
	void DisableRagdoll();
	void EnableNightVisionGoggles();
	void EnableRagdoll(float Duration);
	void EndEvidenceCollection_COOP(class UInteractableComponent* CollectionInteractableComp);
	void EndPepperSprayed();
	void EndStun(EStunType StunType);
	void ForceMeshUsingOverride(class USkeletalMesh* InFPMesh, class USkeletalMesh* InTPMesh, class USkeletalMesh* InFaceMesh);
	float GetDeltaRotationToCharacter(class AReadyOrNotCharacter* Character);
	bool GetFMODFootstepParameters(int32* Stance, int32* Speed, int32* Surface);
	float GetLeanAmount(const struct FVector& Component, float* InOutPendingVal, float MaxValue);
	void Incapacitate();
	void IncreaseHealth(float Amount);
	bool IsCurrentlyFlashed();
	bool IsCurrentlySprayed();
	bool IsCurrentlyStung();
	bool IsOutside();
	bool IsPepperSprayedLocationValid(struct FHitResult& Hit, class APepperspray* Pepperspray);
	void KickDoor(class ADoor* Door);
	void Kill();
	void Lean(float Val);
	void LeanRight(float Val);
	void LeanUp(float Val);
	void LockAim();
	void LockAllActions();
	void LockCantedSight();
	void LockCommandMenu();
	void LockItemSelection();
	void LockMovement();
	void LockMovementAndActions();
	void LockWeaponAttachments();
	void Multicast_AddMoveIgnoreActor(class AReadyOrNotCharacter* MoveIgnoreCharacter, bool bAdd);
	void Multicast_ChangeFaceEmotion(ECharacterEmotion NewEmotion, float OverrideTime, float Blend, float BlendDecay, int32 Priority);
	void Multicast_DisableRagdoll();
	void Multicast_EnableRagdoll(float Duration);
	void Multicast_EnableRagdollBlendIn();
	void Multicast_InflictSuppression(const struct FSuppressionData& SuppressionData, TSubclassOf<class UMatineeCameraShake> CameraShake, bool bLessLethal);
	void Multicast_InflictSuppression_NoLineOfSight(const struct FSuppressionData& SuppressionData, TSubclassOf<class UMatineeCameraShake> CameraShake, bool bLessLethal);
	void Multicast_OnExplosiveVestDetonation();
	void Multicast_OnIncapacitated(class FName LastBone);
	void Multicast_OnKilled(class FName LastBoneHit, class AActor* DamageCauser);
	void Multicast_OnTargetReported();
	void Multicast_PauseAllAnims(bool bPaused);
	void Multicast_Play3PMontage(class UAnimMontage* NewMontage, float StartTime, float PlayRate);
	void Multicast_PlayDeathAnimation(class UAnimMontage* Montage);
	void Multicast_PlayMeleeImpactEffects(class UFMODEvent* ImpactSound, class UParticleSystem* ImpactParticle);
	void Multicast_PlayNonLocal3PMontage(class UAnimMontage* NewMontage);
	void Multicast_PlayRawVO(const class FString& SpecificFileName, const class FString& OverrideSpeakerName, bool bIgnoreIfAlreadyPlaying);
	void Multicast_SavePoseSnapshot(class FName& SnapshotName);
	void Multicast_SpawnArterialBloodEffects(const struct FHitResult& HitResult, class FName Artery);
	void Multicast_SpawnBloodEffects(const struct FHitResult& Hit, float WoundSize, class AController* HitInstigator);
	void Multicast_SpawnDismembermentEffects(EGibAreas GibArea, const struct FHitResult& HitResult);
	void Multicast_Stop1PMontage(class UAnimMontage* Montage, float BlendoutTime);
	void Multicast_Stop3PMontage(class UAnimMontage* Montage, float BlendoutTime);
	void Multicast_TakeDamage(float Damage, struct FDamageEvent& DamageEvent, class AReadyOrNotCharacter* InstigatorCharacter, class AActor* DamageCauser);
	void OnActorSpawned(class AActor* Actor);
	void OnArrest__DelegateSignature(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnArteryBleedParticleCollision(class FName EventName, float EmitterTime, int32 ParticleTime, const struct FVector& Location, const struct FVector& Velocity, const struct FVector& Direction, const struct FVector& Normal, class FName BoneName, class UPhysicalMaterial* PhysMat);
	void OnBodyFallAudioStop();
	void OnBodyPartDamaged__DelegateSignature(bool bHeadDamaged, bool bBodyDamaged, bool bLeftArmDamaged, bool bRightArmDamaged, bool bLeftLegDamaged, bool bRightLegDamaged, bool bLeftFootDamaged, bool bRightFootDamaged);
	void OnBoneDamaged__DelegateSignature(class FName BoneHit);
	void OnC2NotifyEvent__DelegateSignature();
	void OnCapsuleHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit);
	void OnCarryDropComplete(class AActor* Driver, class AActor* Slave);
	void OnCarryDropComplete_Driver(class AActor* Driver);
	void OnCarryDropComplete_Slave(class AActor* Slave);
	void OnCarryingChanged__DelegateSignature();
	void OnCarryPickupComplete(class AActor* Driver, class AActor* Slave);
	void OnCarryPickupComplete_Driver(class AActor* Driver);
	void OnCarryPickupComplete_Slave(class AActor* Slave);
	void OnCarryThrowComplete(class AActor* Driver, class AActor* Slave);
	void OnCarryThrowComplete_Driver(class AActor* Driver);
	void OnCarryThrowComplete_Slave(class AActor* Slave);
	void OnCharacterIncapacitated__DelegateSignature(class AReadyOrNotCharacter* IncapacitatedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnCharacterKilled__DelegateSignature(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnCharacterTakeDamage__DelegateSignature(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnDeadHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit);
	void OnDisarmTrapNotifyEvent__DelegateSignature();
	void OnDismembermentParticleCollision(class FName EventName, float EmitterTime, int32 ParticleTime, const struct FVector& Location, const struct FVector& Velocity, const struct FVector& Direction, const struct FVector& Normal, class FName BoneName, class UPhysicalMaterial* PhysMat);
	void OnDoorCheckedNotifyEvent__DelegateSignature();
	void OnDoorLockPickNotifyEvent__DelegateSignature();
	void OnDoorWedgePlacedNotifyEvent__DelegateSignature();
	void OnDowned__DelegateSignature(class AReadyOrNotCharacter* DownedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnEquippedWeaponDryFire(class ABaseMagazineWeapon* Weapon, bool bServer);
	void OnEquippedWeaponFire(class ABaseMagazineWeapon* Weapon, bool bServer);
	void OnEquippedWeaponMagCheck(class ABaseMagazineWeapon* Weapon);
	void OnEvidenceCollected__DelegateSignature(class AActor* Evidence);
	void OnFootstep__DelegateSignature();
	void OnFreed__DelegateSignature(class ACharacter* Freed, class ACharacter* Freer);
	void OnGetupComplete__DelegateSignature();
	void OnHealthDepleted();
	void OnIncapacitated(class AReadyOrNotCharacter* InstigatorCharacter);
	void OnItemEquipped(class ABaseItem* NewEquippedItem);
	void OnItemHolstered(class ABaseItem* HolsteredItem);
	void OnItemThrownNotifyEvent__DelegateSignature(class ABaseItem* InThrownItem);
	void OnItemUse__DelegateSignature(class AReadyOrNotCharacter* ItemOwner, class ABaseItem* Item);
	void OnKilled(class AReadyOrNotCharacter* InstigatorCharacter);
	void OnLeanEnd();
	void OnLeanStart();
	void OnMeleeHitTaken__DelegateSignature(class AReadyOrNotCharacter* InstigatorCharacter);
	void OnMeshHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit);
	void OnMirrorDoorNotifyEvent__DelegateSignature();
	void OnNightVisionGogglesToggled__DelegateSignature(class AReadyOrNotCharacter* Character, bool bOn);
	void OnPickupItemNotifyEvent__DelegateSignature();
	void OnPlayerHitEvent__DelegateSignature(float Damage, class FName HitBone);
	void OnPointDamage__DelegateSignature(float Damage, class AActor* Causer, class ACharacter* InstigatorCharacter, class ACharacter* HitCharacter, class UBulletDamageType* DamageEvent);
	void OnQuickthrowEnd__DelegateSignature(class ABaseItem* QuickThrowGrenade);
	void OnQuickthrowStart__DelegateSignature(class AReadyOrNotCharacter* Character, class ABaseItem* LastItemBeforeQuickThrow, class ABaseItem* QuickThrowGrenade);
	void OnRagdollBlendStop(class URagdollComponent* InRagdollComponent);
	void OnRagdollPhysBodyHit(class URagdollComponent* InRagdollComponent, const struct FVector& Impulse, struct FHitResult& Hit);
	void OnRagdollStart(class URagdollComponent* InRagdollComponent);
	void OnRep_ActiveRagdollPhysAsset();
	void OnRep_CharacterLookOverride();
	void OnRep_ControlRotation();
	void OnRep_CurrentCarryCharacterChanged();
	void OnRep_CurrentRagdollArrestCharacterChanged();
	void OnRep_Customization();
	void OnRep_MeshReplicated();
	void OnRep_ReplicatedAcceleration();
	void OnRep_Surrendered();
	void OnStunDamage__DelegateSignature(float Damage, class AActor* Causer, class ACharacter* InstigatorCharacter, class ACharacter* HitCharacter, class UStunDamage* DamageEvent);
	void OnStunned__DelegateSignature(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnStunnedEnded__DelegateSignature(EStunType StunType);
	void OnStunnedPlaySound__DelegateSignature(EStunType StunType, bool bIsImmune);
	void OnVoiceAudioStopped();
	void OnWeaponFire__DelegateSignature(class AReadyOrNotCharacter* Character, class ABaseMagazineWeapon* Weapon, const struct FVector& FireDirection);
	void OnYellExecute();
	bool OpenDoor(class ADoor* Door, bool bOpenDoor);
	void PickupEvidence(class AActor* InEvidence);
	void Play1PMontage(class UAnimMontage* NewMontage, float PlayRate);
	void Play1PMontageDeferred(class UAnimMontage* Montage, const class FString& AnimationName);
	void Play3PMontage(class UAnimMontage* NewMontage, float StartTime, float PlayRate);
	void Play3PMontageDeferred(class UAnimMontage* Montage, const class FString& AnimationName);
	class UAnimMontage* PlayMontageFromTable(const class FString& Animation);
	class UAnimMontage* PlayMontageFromTableWithIndex(const class FString& Animation, int32 Param_Index);
	class APairedInteractionDriver* PlayPairedInteraction(class UInteractionsData* InteractionData, class AActor* Driver, class AActor* Slave, class ABaseItem* OptionalItem);
	void PlayRadioSelectAnimation();
	void PlayRandomDebugConversation();
	void PlayRandomDebugVoiceLine(const class FString& Line);
	bool PlayRawVO(const class FString& VoiceLine, const class FString& OverrideSpeakerName, bool bIgnoreIfAlreadyPlaying);
	void PlayRawVOWithCooldown(const class FString& VoiceLine, float Cooldown, const class FString& OverrideSpeakerName);
	void PlayReportSpeech(const class FString& VoiceLine, const class FString& InTOCLine);
	void PlayROEViolateTOCResponse();
	void PlaySpecificDebugVoiceLine(const class FString& Filename);
	void PlayTOCResponse(const class FString& Line, bool bIsNetworked, ETOCPriority Priority, bool bCanPrefix, float Delay);
	void RagdollArrestTarget(class AReadyOrNotCharacter* RagdollCharacter);
	void RequestAnim2RagdollBlend(float Duration);
	void ResetHealth();
	void ResetPhysicsAsset();
	void Server_ApplyPointDamage(class AActor* DamagedActor, float BaseDamage, struct FVector& HitFromDirection, struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass);
	void Server_CarryArrestedTarget(class AReadyOrNotCharacter* ArrestedCharacter);
	void Server_ChangeTPMesh(class USkeletalMesh* Body, class USkeletalMesh* Face);
	void Server_CollectEvidence(class ABaseItem* Item);
	void Server_CollectEvidenceActor(class AEvidenceActor* InEvidenceActor);
	void Server_DoMelee();
	void Server_DoubleTapInteract(class UObject* Interactable, class UInteractableComponent* InInteractableComponent);
	void Server_DropArrestedTarget(class AReadyOrNotCharacter* ArrestedCharacter);
	void Server_EndInteract(class UObject* Interactable, class UInteractableComponent* InInteractableComponent);
	void Server_EndInteract_PrimaryUse(class UObject* Interactable, class UInteractableComponent* InInteractableComponent);
	void Server_Incapacitate();
	void Server_Interact(class UObject* Interactable, class UInteractableComponent* InInteractableComponent);
	void Server_Interact_PrimaryUse(class UObject* Interactable, class UInteractableComponent* InInteractableComponent);
	void Server_KickBreakQueuedDoor();
	void Server_KickFailQueuedDoor();
	void Server_KickQueuedDoor();
	void Server_Kill();
	void Server_MeleeInteract(class UObject* Interactable, class UInteractableComponent* InInteractableComponent);
	void Server_Play3PMontage(class UAnimMontage* NewMontage, float StartTime, float PlayRate);
	void Server_PlayNonLocal3PMontage(class UAnimMontage* NewMontage);
	void Server_PlayTOCConversation();
	void Server_RepNVGOn(bool bIsOn);
	void Server_ReportTarget(class AActor* Character);
	void Server_ReportToTOC(class AActor* Actor, bool bPlayAnimation, bool bTocResponse);
	void Server_ThrowArrestedTarget(class AReadyOrNotCharacter* ArrestedCharacter);
	void Server_UpdateLean(float QuickLean, float NewFreeLeanY, float NewFreeLeanZ);
	void Server_Yell();
	void SpawnBloodPool();
	class ACollectedEvidenceActor* SpawnEvidenceCollectionBag(const struct FTransform& SpawnTransform);
	void SpawnFootstepEffect();
	void StartBeingTasered(float PingStunDuration, class ATaser* WeaponUsed);
	void StartPepperSprayed(class APepperspray* PeppersprayUsed);
	void StartStun(EStunType StunType, class AActor* StunCauser);
	void StopFPAnimMontage(class UAnimMontage* AnimMontage, float BlendoutTime);
	void StopTPAnimMontage(class UAnimMontage* AnimMontage);
	void StopTPMontage(class UAnimMontage* AnimMontage, float BlendoutTime);
	void StopTPMontageFromTable(const class FString& Animation, float BlendoutTime);
	void TestPhysicalAnimationComponent();
	void ToggleFreeLean();
	void ToggleLeanLeft();
	void ToggleLeanRight();
	void ToggleNightvisionGoggles();
	void UnlockAim();
	void UnlockAllActions();
	void UnlockCantedSight();
	void UnlockCommandMenu();
	void UnlockItemSelection();
	void UnlockMovement();
	void UnlockMovementAndActions();
	void UnlockWeaponAttachments();
	void UpdateOverridesFromCharacterLookOverrideDataTable(const class FString& LookOverride);
	void VoiceAudioEvent__DelegateSignature(class AReadyOrNotCharacter* Speaker);

	bool AnyBodyPartHit() const;
	bool CanArrest() const;
	bool CanArrestRagdoll() const;
	bool CanBePickedUp() const;
	bool CanCarryCharacter(class AReadyOrNotCharacter* CharacterToPickup) const;
	bool CanDropCharacter(class AReadyOrNotCharacter* CharacterToDrop) const;
	bool CanMelee() const;
	bool CanYell() const;
	bool DoesMontageFromTableExist(const class FString& Animation) const;
	TArray<class AActor*> GetCollisionIgnoredActors() const;
	TArray<class UPrimitiveComponent*> GetCollisionIgnoredComponents() const;
	float GetCurrentHealth() const;
	float GetCurrentReviveHealth() const;
	float GetCurrentReviveTime() const;
	float GetCurrentStunDuration() const;
	float GetCurrentStunTime() const;
	EAnimWeaponType GetCurrentWeaponAnimType() const;
	class ABaseItem* GetEquippedItem() const;
	class ABaseMagazineWeapon* GetEquippedWeapon() const;
	class UCharacterHealthComponent* GetHealthComponent() const;
	EPlayerHealthStatus GetHealthStatus() const;
	class FString GetLastTableMontagePlayed() const;
	struct FLimbHealthData GetLimbHealth(ELimbType Limb) const;
	float GetMaxHealth() const;
	int32 GetMontageAnimCountFromTable(const class FString& Animation) const;
	class UAnimMontage* GetMontageFromTable(const class FString& Animation) const;
	class UAnimMontage* GetMontageFromTableWithIndex(const class FString& Animation, int32 Param_Index) const;
	TArray<class ABaseItem*> GetRemovedItems() const;
	float GetSpeakCooldown() const;
	class FString GetSpeechCharacterName() const;
	TArray<class FString> GetTableMontageQueue() const;
	ETeamType GetTeam() const;
	float GetTimeSinceLastBulletDamage() const;
	float GetTimeSinceLastStun() const;
	bool HasBeenReported() const;
	bool HasEverBeenStunned() const;
	bool HasLineOfSightTo(struct FVector& Location) const;
	bool HasRecentlyTakenDamage(float Tolerance) const;
	bool HasRecentlyTakenStunDamage(float Tolerance) const;
	bool Is3PMontagePlaying(class UAnimMontage* Montage) const;
	bool IsActive() const;
	bool IsActiveForMovement() const;
	bool IsAffectedByDamageType(class UDamageType* DamageType) const;
	bool IsAffectedByDamageTypeClass(TSubclassOf<class UDamageType> DamageType) const;
	bool IsAnimationBlocking() const;
	bool IsAnyLimbHit() const;
	bool IsAnyTableMontagePlaying(class FString* OutMontage) const;
	bool IsArrested() const;
	bool IsArrestedAndDead() const;
	bool IsArrestedAndIncapacitated() const;
	bool IsArrestedOrSurrendered() const;
	bool IsBeingArrested() const;
	bool IsBeingCarried() const;
	bool IsBeingThrown() const;
	bool IsCarried() const;
	bool IsCarrying() const;
	bool IsCivilian() const;
	bool IsCurrentlyGassed() const;
	bool IsCurrentlyTased() const;
	bool IsDeadNotUnconscious() const;
	bool IsDeadOrUnconscious() const;
	bool IsDowned() const;
	bool IsDropping() const;
	bool IsFullBodyMontagePlaying() const;
	bool IsFullHealth() const;
	bool IsGettingUp() const;
	bool IsHalfHealth() const;
	bool IsHealthDepleted() const;
	bool IsIncapacitated() const;
	bool IsInjured() const;
	bool IsInRagdoll() const;
	bool IsLimbBroken(ELimbType Limb) const;
	bool IsLimbHit(ELimbType Limb) const;
	bool IsLoadingTableMontage() const;
	bool IsLocalPlayer() const;
	bool IsLowHealth() const;
	bool IsMontagePlayingWithTimeRemaining(class UAnimMontage* Animation, float* TimeRemaining) const;
	bool IsMontageSlotPlaying(class FName SlotName) const;
	bool IsOnlyStunnedWithGas() const;
	bool IsOnSWATTeam() const;
	bool IsPepperSprayed() const;
	bool IsPlayingCarryAnims() const;
	bool IsPlayingNonInterruptibleMontage(const class FString& MontageNameTryingToBePlayed) const;
	bool IsPlayingRootMotionFromMontage() const;
	bool IsRagdollBlending() const;
	bool IsReloading() const;
	bool IsReviveHealthDepleted() const;
	bool IsSpeechTimerActive() const;
	bool IsStartling() const;
	bool IsStunned() const;
	bool IsStunnedWith(EStunType StunType) const;
	bool IsSurrenderComplete() const;
	bool IsSurrendered() const;
	bool IsSurrenderedFor(float Seconds) const;
	bool IsSuspect() const;
	bool IsTableMontage(class UAnimMontage* Montage) const;
	bool IsTableMontagePlaying(const class FString& Animation) const;
	bool IsTableMontagePlayingWithTimeRemaining(const class FString& Animation, float* TimeRemaining) const;
	bool IsUnconsciousNotDead() const;
	bool IsUpperBodyMontagePlaying() const;
	bool UsingReviveSystem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotCharacter">();
	}
	static class AReadyOrNotCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotCharacter>();
	}
};
#pragma pack(pop)
static_assert(alignof(AReadyOrNotCharacter) == 0x000010, "Wrong alignment on AReadyOrNotCharacter");
static_assert(sizeof(AReadyOrNotCharacter) == 0x001630, "Wrong size on AReadyOrNotCharacter");
static_assert(offsetof(AReadyOrNotCharacter, CustomizationFaceMesh) == 0x000528, "Member 'AReadyOrNotCharacter::CustomizationFaceMesh' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CustomizationSkeletalMeshes) == 0x000530, "Member 'AReadyOrNotCharacter::CustomizationSkeletalMeshes' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CustomizationStaticMeshes) == 0x000540, "Member 'AReadyOrNotCharacter::CustomizationStaticMeshes' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CustomizationActors) == 0x000550, "Member 'AReadyOrNotCharacter::CustomizationActors' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Customization) == 0x000560, "Member 'AReadyOrNotCharacter::Customization' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MeshGearSlot) == 0x000680, "Member 'AReadyOrNotCharacter::MeshGearSlot' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, InteractableComponent) == 0x000688, "Member 'AReadyOrNotCharacter::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PlayerMarkerComponent) == 0x000690, "Member 'AReadyOrNotCharacter::PlayerMarkerComponent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FaceMesh) == 0x000698, "Member 'AReadyOrNotCharacter::FaceMesh' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FMODAudioPropagationComp) == 0x0006A0, "Member 'AReadyOrNotCharacter::FMODAudioPropagationComp' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FMODVoiceAudioComp) == 0x0006A8, "Member 'AReadyOrNotCharacter::FMODVoiceAudioComp' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CharacterHealth) == 0x0006B0, "Member 'AReadyOrNotCharacter::CharacterHealth' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, InventoryComp) == 0x0006B8, "Member 'AReadyOrNotCharacter::InventoryComp' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PerceptionStimuliComp) == 0x0006C0, "Member 'AReadyOrNotCharacter::PerceptionStimuliComp' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, GibComponent) == 0x0006C8, "Member 'AReadyOrNotCharacter::GibComponent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PhysicalAnimationComp) == 0x0006D0, "Member 'AReadyOrNotCharacter::PhysicalAnimationComp' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, SkinnedDecalSampler) == 0x0006D8, "Member 'AReadyOrNotCharacter::SkinnedDecalSampler' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, RagdollComponent) == 0x0006E0, "Member 'AReadyOrNotCharacter::RagdollComponent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ReplicatedControlRotation) == 0x000724, "Member 'AReadyOrNotCharacter::ReplicatedControlRotation' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnCharacterKilled) == 0x000730, "Member 'AReadyOrNotCharacter::OnCharacterKilled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnCharacterIncapacitated) == 0x000740, "Member 'AReadyOrNotCharacter::OnCharacterIncapacitated' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnWeaponFire) == 0x000750, "Member 'AReadyOrNotCharacter::OnWeaponFire' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnWeaponDryFire) == 0x000760, "Member 'AReadyOrNotCharacter::OnWeaponDryFire' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnPlayerDowned) == 0x000770, "Member 'AReadyOrNotCharacter::OnPlayerDowned' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnPointDamageReceived) == 0x000780, "Member 'AReadyOrNotCharacter::OnPointDamageReceived' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnStunDamageReceived) == 0x000790, "Member 'AReadyOrNotCharacter::OnStunDamageReceived' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnPlayerFreed) == 0x0007A0, "Member 'AReadyOrNotCharacter::OnPlayerFreed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnPlayerHit) == 0x0007B0, "Member 'AReadyOrNotCharacter::OnPlayerHit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnPlayerArmorHit) == 0x0007C0, "Member 'AReadyOrNotCharacter::OnPlayerArmorHit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ThrownItem) == 0x0007D0, "Member 'AReadyOrNotCharacter::ThrownItem' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnGetupComplete) == 0x0007D8, "Member 'AReadyOrNotCharacter::OnGetupComplete' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnItemThrown_FromAnimNotify) == 0x0007E8, "Member 'AReadyOrNotCharacter::OnItemThrown_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnDoorLockPickBegin_FromAnimNotify) == 0x0007F8, "Member 'AReadyOrNotCharacter::OnDoorLockPickBegin_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnDoorLockPickEnd_FromAnimNotify) == 0x000808, "Member 'AReadyOrNotCharacter::OnDoorLockPickEnd_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnDoorChecked_FromAnimNotify) == 0x000818, "Member 'AReadyOrNotCharacter::OnDoorChecked_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnC2Placed_FromAnimNotify) == 0x000828, "Member 'AReadyOrNotCharacter::OnC2Placed_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnC2Detonate_FromAnimNotify) == 0x000838, "Member 'AReadyOrNotCharacter::OnC2Detonate_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnTrapDisarmBegin_FromAnimNotify) == 0x000848, "Member 'AReadyOrNotCharacter::OnTrapDisarmBegin_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnTrapDisarmEnd_FromAnimNotify) == 0x000858, "Member 'AReadyOrNotCharacter::OnTrapDisarmEnd_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnMirrorDoorStarted_FromAnimNotify) == 0x000868, "Member 'AReadyOrNotCharacter::OnMirrorDoorStarted_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnMirrorDoorFinished_FromAnimNotify) == 0x000878, "Member 'AReadyOrNotCharacter::OnMirrorDoorFinished_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnStartDoorWedgePlacement_FromAnimNotify) == 0x000888, "Member 'AReadyOrNotCharacter::OnStartDoorWedgePlacement_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnEndDoorWedgePlacement_FromAnimNotify) == 0x000898, "Member 'AReadyOrNotCharacter::OnEndDoorWedgePlacement_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LastDamageEvent) == 0x0008D8, "Member 'AReadyOrNotCharacter::LastDamageEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bBulletForceTransferred) == 0x000902, "Member 'AReadyOrNotCharacter::bBulletForceTransferred' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MinimumBodyFallImpulse) == 0x000904, "Member 'AReadyOrNotCharacter::MinimumBodyFallImpulse' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MaxRagdollSounds) == 0x000908, "Member 'AReadyOrNotCharacter::MaxRagdollSounds' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, RagdollSoundsPlayed) == 0x00090C, "Member 'AReadyOrNotCharacter::RagdollSoundsPlayed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, BodyFallEvent) == 0x000910, "Member 'AReadyOrNotCharacter::BodyFallEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, BodyFallSoundSource) == 0x000920, "Member 'AReadyOrNotCharacter::BodyFallSoundSource' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bCapsuleCollisionRagdolled) == 0x000928, "Member 'AReadyOrNotCharacter::bCapsuleCollisionRagdolled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bCapsuleFloorAngleRagdolled) == 0x000929, "Member 'AReadyOrNotCharacter::bCapsuleFloorAngleRagdolled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CapsuleCollisionRagdollTriggerThreshold) == 0x00092C, "Member 'AReadyOrNotCharacter::CapsuleCollisionRagdollTriggerThreshold' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CapsuleFloorAngleRagdollTriggerThreshold) == 0x000930, "Member 'AReadyOrNotCharacter::CapsuleFloorAngleRagdollTriggerThreshold' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CapsuleFloorAngleRagdollDelayThreshold) == 0x000934, "Member 'AReadyOrNotCharacter::CapsuleFloorAngleRagdollDelayThreshold' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bBlendingAnim2Ragdoll) == 0x000938, "Member 'AReadyOrNotCharacter::bBlendingAnim2Ragdoll' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Anim2RagdollPelvisWakeUpTime) == 0x000948, "Member 'AReadyOrNotCharacter::Anim2RagdollPelvisWakeUpTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, VoiceSoundSource) == 0x000958, "Member 'AReadyOrNotCharacter::VoiceSoundSource' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bBlendInPhysics) == 0x000B30, "Member 'AReadyOrNotCharacter::bBlendInPhysics' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bStartBlendInIncapacitation) == 0x000B31, "Member 'AReadyOrNotCharacter::bStartBlendInIncapacitation' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bBlendInIncapacitation) == 0x000B32, "Member 'AReadyOrNotCharacter::bBlendInIncapacitation' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, IncapacitationBlendTime) == 0x000B34, "Member 'AReadyOrNotCharacter::IncapacitationBlendTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, IncapacitationBlendOutTime) == 0x000B38, "Member 'AReadyOrNotCharacter::IncapacitationBlendOutTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, IncapacitationLoopAnim) == 0x000B40, "Member 'AReadyOrNotCharacter::IncapacitationLoopAnim' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, BlendInterpAmount) == 0x000B48, "Member 'AReadyOrNotCharacter::BlendInterpAmount' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FinalBlendInTime) == 0x000B58, "Member 'AReadyOrNotCharacter::FinalBlendInTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, BlendInAfterStartOfAnim) == 0x000B60, "Member 'AReadyOrNotCharacter::BlendInAfterStartOfAnim' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ArrestedBy) == 0x000B70, "Member 'AReadyOrNotCharacter::ArrestedBy' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, KilledBy) == 0x000B78, "Member 'AReadyOrNotCharacter::KilledBy' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, IncapacitatedBy) == 0x000B80, "Member 'AReadyOrNotCharacter::IncapacitatedBy' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DeathReason) == 0x000B88, "Member 'AReadyOrNotCharacter::DeathReason' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnCharacterTakeDamage) == 0x000B90, "Member 'AReadyOrNotCharacter::OnCharacterTakeDamage' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnAIStunnedPlaySound) == 0x000BA0, "Member 'AReadyOrNotCharacter::OnAIStunnedPlaySound' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnStunnedEvent) == 0x000BB0, "Member 'AReadyOrNotCharacter::OnStunnedEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnStunnedEndedEvent) == 0x000BC0, "Member 'AReadyOrNotCharacter::OnStunnedEndedEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnMeleeHitTaken) == 0x000BD0, "Member 'AReadyOrNotCharacter::OnMeleeHitTaken' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, HeadBones) == 0x000BE0, "Member 'AReadyOrNotCharacter::HeadBones' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, UpperBody) == 0x000BF0, "Member 'AReadyOrNotCharacter::UpperBody' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LowerBody) == 0x000C10, "Member 'AReadyOrNotCharacter::LowerBody' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, R_Leg) == 0x000C20, "Member 'AReadyOrNotCharacter::R_Leg' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, L_Leg) == 0x000C30, "Member 'AReadyOrNotCharacter::L_Leg' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, L_Foot) == 0x000C40, "Member 'AReadyOrNotCharacter::L_Foot' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, R_Foot) == 0x000C50, "Member 'AReadyOrNotCharacter::R_Foot' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, L_Arm) == 0x000C60, "Member 'AReadyOrNotCharacter::L_Arm' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, R_Arm) == 0x000C70, "Member 'AReadyOrNotCharacter::R_Arm' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, L_Hand) == 0x000C80, "Member 'AReadyOrNotCharacter::L_Hand' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, R_Hand) == 0x000C90, "Member 'AReadyOrNotCharacter::R_Hand' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bLowReadyPointUp) == 0x000CA0, "Member 'AReadyOrNotCharacter::bLowReadyPointUp' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bLowReadyPointDown) == 0x000CA1, "Member 'AReadyOrNotCharacter::bLowReadyPointDown' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LowReadyDistance) == 0x000CA4, "Member 'AReadyOrNotCharacter::LowReadyDistance' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LowReadyIgnoredCapsules) == 0x000CB0, "Member 'AReadyOrNotCharacter::LowReadyIgnoredCapsules' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, QuickLeanAmount) == 0x000CC4, "Member 'AReadyOrNotCharacter::QuickLeanAmount' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, QuickLeanIntensity) == 0x000CC8, "Member 'AReadyOrNotCharacter::QuickLeanIntensity' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, QuickLeanInterpSpeed) == 0x000CCC, "Member 'AReadyOrNotCharacter::QuickLeanInterpSpeed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FreeLeanX) == 0x000CD0, "Member 'AReadyOrNotCharacter::FreeLeanX' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FreeLeanZ) == 0x000CD4, "Member 'AReadyOrNotCharacter::FreeLeanZ' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bFreeLeaning) == 0x000CD8, "Member 'AReadyOrNotCharacter::bFreeLeaning' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bIsLeaning) == 0x000CD9, "Member 'AReadyOrNotCharacter::bIsLeaning' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bLeaningLeft) == 0x000CDA, "Member 'AReadyOrNotCharacter::bLeaningLeft' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bLeaningRight) == 0x000CDB, "Member 'AReadyOrNotCharacter::bLeaningRight' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bLeaningUp) == 0x000CDC, "Member 'AReadyOrNotCharacter::bLeaningUp' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bLeaningDown) == 0x000CDD, "Member 'AReadyOrNotCharacter::bLeaningDown' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bLeanLeftToggle) == 0x000CDE, "Member 'AReadyOrNotCharacter::bLeanLeftToggle' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bLeanRightToggle) == 0x000CDF, "Member 'AReadyOrNotCharacter::bLeanRightToggle' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LeanAudioComponent) == 0x000CE0, "Member 'AReadyOrNotCharacter::LeanAudioComponent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LeanAudioEvent) == 0x000CE8, "Member 'AReadyOrNotCharacter::LeanAudioEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LeanMovementValue) == 0x000CF0, "Member 'AReadyOrNotCharacter::LeanMovementValue' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LeanPos_CurrentFrame) == 0x000CF4, "Member 'AReadyOrNotCharacter::LeanPos_CurrentFrame' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LeanPos_LastFrame) == 0x000D00, "Member 'AReadyOrNotCharacter::LeanPos_LastFrame' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, SquadPosition) == 0x000D0C, "Member 'AReadyOrNotCharacter::SquadPosition' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DefaultTeam) == 0x000D0D, "Member 'AReadyOrNotCharacter::DefaultTeam' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FPMeleeImpactFMODEvent) == 0x000D10, "Member 'AReadyOrNotCharacter::FPMeleeImpactFMODEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, TPMeleeImpactFMODEvent) == 0x000D18, "Member 'AReadyOrNotCharacter::TPMeleeImpactFMODEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MeleeImpactParticle) == 0x000D20, "Member 'AReadyOrNotCharacter::MeleeImpactParticle' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MeleeCameraShake) == 0x000D28, "Member 'AReadyOrNotCharacter::MeleeCameraShake' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MeleeRange) == 0x000D30, "Member 'AReadyOrNotCharacter::MeleeRange' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MeleeDamage) == 0x000D34, "Member 'AReadyOrNotCharacter::MeleeDamage' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MeleeDamageType) == 0x000D38, "Member 'AReadyOrNotCharacter::MeleeDamageType' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnPlayerArrested) == 0x000D60, "Member 'AReadyOrNotCharacter::OnPlayerArrested' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnPlayerArrestStart) == 0x000D70, "Member 'AReadyOrNotCharacter::OnPlayerArrestStart' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnPlayerArrestedCanceled) == 0x000D80, "Member 'AReadyOrNotCharacter::OnPlayerArrestedCanceled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PendingAutoReport) == 0x000D90, "Member 'AReadyOrNotCharacter::PendingAutoReport' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Rep_CarryArrestedAnimState) == 0x000D98, "Member 'AReadyOrNotCharacter::Rep_CarryArrestedAnimState' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bSurrendered) == 0x000DA0, "Member 'AReadyOrNotCharacter::bSurrendered' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bSurrenderComplete) == 0x000DA1, "Member 'AReadyOrNotCharacter::bSurrenderComplete' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PlacedZipcuffs) == 0x000DC0, "Member 'AReadyOrNotCharacter::PlacedZipcuffs' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, SpawnedZipcuffsClass) == 0x000DC8, "Member 'AReadyOrNotCharacter::SpawnedZipcuffsClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, SpawnedFPZipcuffsClass) == 0x000DD0, "Member 'AReadyOrNotCharacter::SpawnedFPZipcuffsClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ZipcuffBone) == 0x000DD8, "Member 'AReadyOrNotCharacter::ZipcuffBone' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bIsBeingCarried) == 0x000DE0, "Member 'AReadyOrNotCharacter::bIsBeingCarried' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bCarryingDead) == 0x000DE1, "Member 'AReadyOrNotCharacter::bCarryingDead' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CarriedByCharacter) == 0x000DE8, "Member 'AReadyOrNotCharacter::CarriedByCharacter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ThrownByCharacter) == 0x000DF0, "Member 'AReadyOrNotCharacter::ThrownByCharacter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PendingCarryCharacter) == 0x000DF8, "Member 'AReadyOrNotCharacter::PendingCarryCharacter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentCarryCharacter) == 0x000E00, "Member 'AReadyOrNotCharacter::CurrentCarryCharacter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FakeCarryCharacterMesh) == 0x000E08, "Member 'AReadyOrNotCharacter::FakeCarryCharacterMesh' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentCarryConfirmTime) == 0x000E10, "Member 'AReadyOrNotCharacter::CurrentCarryConfirmTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CarryMasterIdleLoop) == 0x000E18, "Member 'AReadyOrNotCharacter::CarryMasterIdleLoop' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CarrySlaveIdleLoop) == 0x000E20, "Member 'AReadyOrNotCharacter::CarrySlaveIdleLoop' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MaxCarryConfirmTime) == 0x000E28, "Member 'AReadyOrNotCharacter::MaxCarryConfirmTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MaxRagdollArrestConfirmTime) == 0x000E2C, "Member 'AReadyOrNotCharacter::MaxRagdollArrestConfirmTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentRagdollArrestConfirmTime) == 0x000E30, "Member 'AReadyOrNotCharacter::CurrentRagdollArrestConfirmTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PendingRagdollArrestCharacter) == 0x000E38, "Member 'AReadyOrNotCharacter::PendingRagdollArrestCharacter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentRagdollArrestCharacter) == 0x000E40, "Member 'AReadyOrNotCharacter::CurrentRagdollArrestCharacter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LastCharacterMakingArrest) == 0x000E48, "Member 'AReadyOrNotCharacter::LastCharacterMakingArrest' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentlyArresting) == 0x000E50, "Member 'AReadyOrNotCharacter::CurrentlyArresting' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bIsBeingArrested) == 0x000E58, "Member 'AReadyOrNotCharacter::bIsBeingArrested' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bArrestComplete) == 0x000E59, "Member 'AReadyOrNotCharacter::bArrestComplete' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bArrestedAsRagdoll) == 0x000E5A, "Member 'AReadyOrNotCharacter::bArrestedAsRagdoll' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bArrestedAsRagdoll_Flipped) == 0x000E5B, "Member 'AReadyOrNotCharacter::bArrestedAsRagdoll_Flipped' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bIsPairedInteractionPlaying) == 0x000E5C, "Member 'AReadyOrNotCharacter::bIsPairedInteractionPlaying' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bNoTeamDamage) == 0x000E5D, "Member 'AReadyOrNotCharacter::bNoTeamDamage' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bDisableInteraction) == 0x000E5E, "Member 'AReadyOrNotCharacter::bDisableInteraction' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bPrimed) == 0x000E5F, "Member 'AReadyOrNotCharacter::bPrimed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bOverarmThrow) == 0x000E60, "Member 'AReadyOrNotCharacter::bOverarmThrow' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnQuickThrowStart) == 0x000E68, "Member 'AReadyOrNotCharacter::OnQuickThrowStart' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnQuickThrowEnd) == 0x000E78, "Member 'AReadyOrNotCharacter::OnQuickThrowEnd' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnCarryingChanged) == 0x000E88, "Member 'AReadyOrNotCharacter::OnCarryingChanged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bIsStrafing) == 0x000E99, "Member 'AReadyOrNotCharacter::bIsStrafing' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PlayedTableMontageMap3P) == 0x000EA0, "Member 'AReadyOrNotCharacter::PlayedTableMontageMap3P' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LastTableMontagePlayed) == 0x000EF0, "Member 'AReadyOrNotCharacter::LastTableMontagePlayed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CharacterLookOverride) == 0x000F78, "Member 'AReadyOrNotCharacter::CharacterLookOverride' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Rep_CharacterLookOverride) == 0x001048, "Member 'AReadyOrNotCharacter::Rep_CharacterLookOverride' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ArmorOverrideMapTP) == 0x001058, "Member 'AReadyOrNotCharacter::ArmorOverrideMapTP' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Rep_BodyMesh) == 0x0010A8, "Member 'AReadyOrNotCharacter::Rep_BodyMesh' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Rep_FaceMesh) == 0x0010B0, "Member 'AReadyOrNotCharacter::Rep_FaceMesh' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Rep_FPMesh) == 0x0010B8, "Member 'AReadyOrNotCharacter::Rep_FPMesh' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, AnimMontageCooldown) == 0x0010C0, "Member 'AReadyOrNotCharacter::AnimMontageCooldown' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentFaceROM) == 0x001110, "Member 'AReadyOrNotCharacter::CurrentFaceROM' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, AnimationBlockingTime) == 0x001118, "Member 'AReadyOrNotCharacter::AnimationBlockingTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, TOCManager) == 0x001140, "Member 'AReadyOrNotCharacter::TOCManager' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ReportToTOC_PVP_CameraShake) == 0x001148, "Member 'AReadyOrNotCharacter::ReportToTOC_PVP_CameraShake' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, TOCLine) == 0x001150, "Member 'AReadyOrNotCharacter::TOCLine' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, SpeechCharacterName) == 0x001160, "Member 'AReadyOrNotCharacter::SpeechCharacterName' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bHasBeenReported) == 0x001178, "Member 'AReadyOrNotCharacter::bHasBeenReported' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, SpeakCooldown) == 0x00117C, "Member 'AReadyOrNotCharacter::SpeakCooldown' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ReportPlayerDeadFMODEvent) == 0x001180, "Member 'AReadyOrNotCharacter::ReportPlayerDeadFMODEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ReportPlayerArrestedFMODEvent) == 0x001188, "Member 'AReadyOrNotCharacter::ReportPlayerArrestedFMODEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ReportPlayerGeneralFMODEvent) == 0x001190, "Member 'AReadyOrNotCharacter::ReportPlayerGeneralFMODEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnVoiceAudioStoppedDelegate) == 0x001198, "Member 'AReadyOrNotCharacter::OnVoiceAudioStoppedDelegate' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, SpeechCooldownMap) == 0x0011C0, "Member 'AReadyOrNotCharacter::SpeechCooldownMap' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FMODVoiceLine2D) == 0x001210, "Member 'AReadyOrNotCharacter::FMODVoiceLine2D' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FMODVoiceLineSpatalized) == 0x001218, "Member 'AReadyOrNotCharacter::FMODVoiceLineSpatalized' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, BoneSuppressionAmount) == 0x001228, "Member 'AReadyOrNotCharacter::BoneSuppressionAmount' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnBoneDamaged) == 0x001278, "Member 'AReadyOrNotCharacter::OnBoneDamaged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnBodyPartDamaged) == 0x001288, "Member 'AReadyOrNotCharacter::OnBodyPartDamaged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DismembermentDamageMap) == 0x0012B0, "Member 'AReadyOrNotCharacter::DismembermentDamageMap' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DamageExcludedBones) == 0x001300, "Member 'AReadyOrNotCharacter::DamageExcludedBones' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, GasDamageAccumulated) == 0x001320, "Member 'AReadyOrNotCharacter::GasDamageAccumulated' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, GasDamageDecay) == 0x001324, "Member 'AReadyOrNotCharacter::GasDamageDecay' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bNoTarget) == 0x001331, "Member 'AReadyOrNotCharacter::bNoTarget' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ArmorImpactEffect) == 0x001338, "Member 'AReadyOrNotCharacter::ArmorImpactEffect' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Blood) == 0x001340, "Member 'AReadyOrNotCharacter::Blood' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DamagedByWeapons) == 0x001348, "Member 'AReadyOrNotCharacter::DamagedByWeapons' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bRepStunned) == 0x001360, "Member 'AReadyOrNotCharacter::bRepStunned' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, RepStunnedWith) == 0x001361, "Member 'AReadyOrNotCharacter::RepStunnedWith' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, AITrackingMe) == 0x0013D0, "Member 'AReadyOrNotCharacter::AITrackingMe' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DamagedByCharacters) == 0x0013E0, "Member 'AReadyOrNotCharacter::DamagedByCharacters' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OriginalSpawnLocation) == 0x0013F0, "Member 'AReadyOrNotCharacter::OriginalSpawnLocation' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnEvidenceCollected) == 0x001400, "Member 'AReadyOrNotCharacter::OnEvidenceCollected' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PendingEvidence) == 0x001418, "Member 'AReadyOrNotCharacter::PendingEvidence' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bIsCollectingEvidence) == 0x001420, "Member 'AReadyOrNotCharacter::bIsCollectingEvidence' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bCollectionAnimHasTriggered) == 0x001421, "Member 'AReadyOrNotCharacter::bCollectionAnimHasTriggered' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CollectingLoopAnim1P) == 0x001428, "Member 'AReadyOrNotCharacter::CollectingLoopAnim1P' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CollectingLoopAnim3P) == 0x001430, "Member 'AReadyOrNotCharacter::CollectingLoopAnim3P' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CollectedEvidenceClass) == 0x001438, "Member 'AReadyOrNotCharacter::CollectedEvidenceClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Reward) == 0x001440, "Member 'AReadyOrNotCharacter::Reward' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentEmotion) == 0x001448, "Member 'AReadyOrNotCharacter::CurrentEmotion' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FacialAnimationOverrideTime) == 0x00144C, "Member 'AReadyOrNotCharacter::FacialAnimationOverrideTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FacialAnimationBlend) == 0x001450, "Member 'AReadyOrNotCharacter::FacialAnimationBlend' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FacialAnimationBlendTarget) == 0x001454, "Member 'AReadyOrNotCharacter::FacialAnimationBlendTarget' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FacialAnimationBlendDecay) == 0x001458, "Member 'AReadyOrNotCharacter::FacialAnimationBlendDecay' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FacialAnimationPriority) == 0x00145C, "Member 'AReadyOrNotCharacter::FacialAnimationPriority' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bAiming) == 0x001460, "Member 'AReadyOrNotCharacter::bAiming' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bMovementLocked) == 0x001461, "Member 'AReadyOrNotCharacter::bMovementLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bAimLocked) == 0x001462, "Member 'AReadyOrNotCharacter::bAimLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bActionsLocked) == 0x001463, "Member 'AReadyOrNotCharacter::bActionsLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bItemSelectionLocked) == 0x001464, "Member 'AReadyOrNotCharacter::bItemSelectionLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bCommandMenuLocked) == 0x001465, "Member 'AReadyOrNotCharacter::bCommandMenuLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bWeaponAttachmentsLocked) == 0x001466, "Member 'AReadyOrNotCharacter::bWeaponAttachmentsLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bCantedSightLocked) == 0x001467, "Member 'AReadyOrNotCharacter::bCantedSightLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, QueuedDoorToOpen) == 0x001468, "Member 'AReadyOrNotCharacter::QueuedDoorToOpen' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, QueuedDoorToClose) == 0x001470, "Member 'AReadyOrNotCharacter::QueuedDoorToClose' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LastKickedDoor) == 0x001478, "Member 'AReadyOrNotCharacter::LastKickedDoor' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DoorKickInteractionFront) == 0x001480, "Member 'AReadyOrNotCharacter::DoorKickInteractionFront' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DoorKickInteractionBack) == 0x001488, "Member 'AReadyOrNotCharacter::DoorKickInteractionBack' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DoorKickFailureInteractionFront) == 0x001490, "Member 'AReadyOrNotCharacter::DoorKickFailureInteractionFront' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DoorKickFailureInteractionBack) == 0x001498, "Member 'AReadyOrNotCharacter::DoorKickFailureInteractionBack' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DoorKickBreakInteractionFront) == 0x0014A0, "Member 'AReadyOrNotCharacter::DoorKickBreakInteractionFront' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DoorKickBreakInteractionBack) == 0x0014A8, "Member 'AReadyOrNotCharacter::DoorKickBreakInteractionBack' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CarryArrestedInteractionData) == 0x0014B0, "Member 'AReadyOrNotCharacter::CarryArrestedInteractionData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DropArrestedInteractionData) == 0x0014B8, "Member 'AReadyOrNotCharacter::DropArrestedInteractionData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ThrowArrestedInteractionData) == 0x0014C0, "Member 'AReadyOrNotCharacter::ThrowArrestedInteractionData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Event_OnItemPrimaryUse) == 0x0014C8, "Member 'AReadyOrNotCharacter::Event_OnItemPrimaryUse' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bNVGOn) == 0x0014D8, "Member 'AReadyOrNotCharacter::bNVGOn' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnNightVisionGogglesToggled) == 0x0014E0, "Member 'AReadyOrNotCharacter::OnNightVisionGogglesToggled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bShouldPlayFootstepFoley) == 0x001518, "Member 'AReadyOrNotCharacter::bShouldPlayFootstepFoley' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bPlayEveryStep) == 0x001519, "Member 'AReadyOrNotCharacter::bPlayEveryStep' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FootstepImpactEffectFast) == 0x001520, "Member 'AReadyOrNotCharacter::FootstepImpactEffectFast' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FootstepImpactEffectSlow) == 0x001528, "Member 'AReadyOrNotCharacter::FootstepImpactEffectSlow' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentFootstepFoleyEvent) == 0x001530, "Member 'AReadyOrNotCharacter::CurrentFootstepFoleyEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentFootstepFoleyEventRemote) == 0x001538, "Member 'AReadyOrNotCharacter::CurrentFootstepFoleyEventRemote' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FootstepsLocal) == 0x001540, "Member 'AReadyOrNotCharacter::FootstepsLocal' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FootstepsRemote) == 0x001548, "Member 'AReadyOrNotCharacter::FootstepsRemote' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MovementFoley) == 0x001550, "Member 'AReadyOrNotCharacter::MovementFoley' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MovementFoleySocket) == 0x001558, "Member 'AReadyOrNotCharacter::MovementFoleySocket' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DefaultRagdollPhysAsset) == 0x001560, "Member 'AReadyOrNotCharacter::DefaultRagdollPhysAsset' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DefaultAlivePhysAsset) == 0x001568, "Member 'AReadyOrNotCharacter::DefaultAlivePhysAsset' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CuffedRagdollPhysAsset) == 0x001570, "Member 'AReadyOrNotCharacter::CuffedRagdollPhysAsset' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Rep_ActiveRagdollPhysAsset) == 0x001578, "Member 'AReadyOrNotCharacter::Rep_ActiveRagdollPhysAsset' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bIsRelevant) == 0x001580, "Member 'AReadyOrNotCharacter::bIsRelevant' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, NeutralizeSuspectTag) == 0x001588, "Member 'AReadyOrNotCharacter::NeutralizeSuspectTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, TorsoDeathAnims) == 0x001590, "Member 'AReadyOrNotCharacter::TorsoDeathAnims' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, HeadDeathAnims) == 0x0015A0, "Member 'AReadyOrNotCharacter::HeadDeathAnims' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LeftArmDeathAnims) == 0x0015B0, "Member 'AReadyOrNotCharacter::LeftArmDeathAnims' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, RightArmDeathAnims) == 0x0015C0, "Member 'AReadyOrNotCharacter::RightArmDeathAnims' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LeftLegDeathAnims) == 0x0015D0, "Member 'AReadyOrNotCharacter::LeftLegDeathAnims' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, RightLegDeathAnims) == 0x0015E0, "Member 'AReadyOrNotCharacter::RightLegDeathAnims' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentDeathMontage) == 0x0015F0, "Member 'AReadyOrNotCharacter::CurrentDeathMontage' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ReplicatedAcceleration) == 0x0015F9, "Member 'AReadyOrNotCharacter::ReplicatedAcceleration' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ReplicatedMaxSpeed) == 0x0015FC, "Member 'AReadyOrNotCharacter::ReplicatedMaxSpeed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bIsBlendRagdollNotifyActive) == 0x001600, "Member 'AReadyOrNotCharacter::bIsBlendRagdollNotifyActive' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FootstepOcclusionMultiplier) == 0x001604, "Member 'AReadyOrNotCharacter::FootstepOcclusionMultiplier' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FootstepFullOcclusionDepth) == 0x001608, "Member 'AReadyOrNotCharacter::FootstepFullOcclusionDepth' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Snapshots) == 0x001618, "Member 'AReadyOrNotCharacter::Snapshots' has a wrong offset!");

// Class ReadyOrNot.CyberneticCharacter
// 0x0960 (0x1F90 - 0x1630)
class ACyberneticCharacter : public AReadyOrNotCharacter
{
public:
	uint8                                         Pad_234B[0x18];                                    // 0x1628(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  ClosestPawn;                                       // 0x1640(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234C[0x28];                                    // 0x1648(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VisibleSwatPercentage;                             // 0x1670(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234D[0x4];                                     // 0x1674(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URoNMoveStyleComponent*                 MoveStyle;                                         // 0x1678(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234E[0x24];                                    // 0x1680(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceComplianceStrength;                           // 0x16A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverDirection                               ActiveCoverDirection;                              // 0x16A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverAimType                                 ActiveCoverAimType;                                // 0x16A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverFireType                                ActiveCoverFireType;                               // 0x16AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234F[0x5];                                     // 0x16AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ActiveCoverFirePose;                               // 0x16B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ActiveCoverIdlePose;                               // 0x16B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACoverLandmark*                         CurrentCoverLandmarkInUse;                         // 0x16C0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACoverLandmark*                         LastCoverLandmarkUsed;                             // 0x16C8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWallHoleTraversal*                     CurrentWallHoleTraversalInUse;                     // 0x16D0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWallHoleTraversal*                     LastWallHoleTraversalUsed;                         // 0x16D8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2350[0x8];                                     // 0x16E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             VoiceLineEventMask;                                // 0x16E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2351[0x8];                                     // 0x16F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMeshComponent*>           SimulatingAttachedStaticMeshes;                    // 0x16F8(0x0010)(ExportObject, Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FAttachedMeshData>              AttachedMeshData;                                  // 0x1708(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FAttachedSkeletalMeshData>      AttachedSkeletalMeshData;                          // 0x1718(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x1728(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2352[0x27];                                    // 0x1729(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseItem*                              LastEquippedBreachItem;                            // 0x1750(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSurrendered;                                     // 0x1758(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFakeSurrendered;                                 // 0x1768(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpottedEnemy;                                    // 0x1778(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpottedFriendly;                                 // 0x1788(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpottedNeutral;                                  // 0x1798(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSensedActor;                                     // 0x17A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSensedCharacter;                                 // 0x17B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAIFinishSpawning;                                // 0x17C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2353[0x10];                                    // 0x17D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextRenderComponent*                   NoBuenoTextRender;                                 // 0x17E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbuseCount;                                        // 0x17F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2354[0x4];                                     // 0x17F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReasonsToSprint;                                   // 0x17F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReasonsToStandStill;                               // 0x1808(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReasonsToWalk;                                     // 0x1818(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCoverAnimStateMachineData             Rep_CoverAnimState;                                // 0x1828(0x0018)(BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	struct FHidingAnimStateMachineData            Rep_HidingAnimState;                               // 0x1840(0x0010)(BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	struct FHoleTraversalAnimStateMachineData     Rep_HoleTraversalAnimState;                        // 0x1850(0x0010)(BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              AimOffset;                                         // 0x1860(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2355[0x18];                                    // 0x1868(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AReadyOrNotCharacter*, int32>      MeleeCountMap;                                     // 0x1880(0x0050)(NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWorldBuildingActivity>> CivilianCowerActivities;                           // 0x18D0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         CivilianCowerActivityDuration;                     // 0x18E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2356[0x14];                                    // 0x18E4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class AAIFactionManager*                      FactionManager;                                    // 0x18F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2357[0xB0];                                    // 0x1900(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class AAISpawn*                               SpawnedFromSpawner;                                // 0x19B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECombatState                                  CombatState;                                       // 0x19B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2358[0x7];                                     // 0x19B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   RecentMeleeVictim;                                 // 0x19C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   PendingMeleeTarget;                                // 0x19C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEverShot;                                      // 0x19D0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2359[0x7];                                     // 0x19D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnWeaponForceFire_FromAnimNotify;                  // 0x19D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoorShotgunBreach_FromAnimNotify;                // 0x19E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoorKickBreach_FromAnimNotify;                   // 0x19F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoorRamBreach_FromAnimNotify;                    // 0x1A08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPendingItemThrown_FromAnimNotify;                // 0x1A18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ABaseItem*                              PendingThrownItem;                                 // 0x1A28(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAIFire;                                          // 0x1A30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCollectPendingEvidenceBegin_FromAnimNotify;      // 0x1A40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCollectPendingEvidenceEnd_FromAnimNotify;        // 0x1A50(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_235A[0x8];                                     // 0x1A60(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHeardOfficerYell;                                // 0x1A68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExitedSurrender;                                 // 0x1A78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_235B[0x4];                                     // 0x1A88(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SuppressionAmount;                                 // 0x1A8C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   BeingRestrainedBy;                                 // 0x1A90(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScoringComponent*                      ScoringComponent;                                  // 0x1A98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235C[0x8];                                     // 0x1AA0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIArchetypeData*                       Archetype;                                         // 0x1AA8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x1AB0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235D[0x4];                                     // 0x1ABC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIArchetypeData*                       DefaultSuspectArchetype;                           // 0x1AC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIArchetypeData*                       DefaultCivilianArchetype;                          // 0x1AC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActivityRouteCollection               ActivityRouteCollection;                           // 0x1AD0(0x0020)(Edit, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	struct FVector                                Rep_AimOffsetFocalPoint;                           // 0x1AF0(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Rep_FocalPoint;                                    // 0x1AFC(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Rep_HeadFocalPoint;                                // 0x1B08(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235E[0x4];                                     // 0x1B14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Rep_FocalActor;                                    // 0x1B18(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLOSToFocalPoint;                               // 0x1B20(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHeardYellFromOfficer : 1;                         // 0x1B21(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_235F[0x2];                                     // 0x1B22(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceHeardOfficerYell;                         // 0x1B24(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastAggressiveForce;                      // 0x1B28(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrestedTime;                                      // 0x1B2C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFemale;                                           // 0x1B30(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChild;                                            // 0x1B31(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2360[0x6];                                     // 0x1B32(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           LastGetUpMontage;                                  // 0x1B38(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRecoveringFromRagdoll : 1;                        // 0x1B40(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsKnockedOut : 1;                                 // 0x1B40(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsPlayingDead : 1;                                // 0x1B40(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2361[0x3];                                     // 0x1B41(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeHiding;                                        // 0x1B44(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimePlayingDead;                                   // 0x1B48(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastPlayDead;                             // 0x1B4C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceAtLastCoverLandmark;                      // 0x1B50(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastSeenCharacterWhilstHiding;            // 0x1B54(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceSeenCharacterNotLookingWhilstHiding;      // 0x1B58(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEverSeenCharacterWhilstHiding;                 // 0x1B5C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2362[0x3];                                     // 0x1B5D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   CharacterSeenWhilstHiding;                         // 0x1B60(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCharacterAnimData*           Unarmed_Calm_AD;                                   // 0x1B68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCharacterAnimData*           Unarmed_Sr_AD;                                     // 0x1B70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCharacterAnimData*           Unarmed_Ar_AD;                                     // 0x1B78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCharacterAnimData*           Unarmed_Ar_Crouch_AD;                              // 0x1B80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCharacterAnimData*           Unarmed_Alert_AD;                                  // 0x1B88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCharacterAnimData*           Rifle_AD;                                          // 0x1B90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCharacterAnimData*           Pistol_AD;                                         // 0x1B98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCharacterAnimData*           Pistol_OneHanded_AD;                               // 0x1BA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   AvoidingCharacter;                                 // 0x1BA8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIMoveDataBlock                       MoveDataOverride;                                  // 0x1BB0(0x0098)(NativeAccessSpecifierPublic)
	struct FAIMoveDataBlock                       CurMoveDataBlock;                                  // 0x1C48(0x0098)(Edit, NativeAccessSpecifierPublic)
	struct FAIMovementStyleData                   MovementStyleData;                                 // 0x1CE0(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2363[0x4];                                     // 0x1D20(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Stress;                                            // 0x1D24(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingStress;                                    // 0x1D28(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastShot;                                 // 0x1D2C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceArrest;                                   // 0x1D30(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPlayedSurrenderAnim;                           // 0x1D34(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFakeSurrender;                                  // 0x1D35(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEverFakeSurrendered;                           // 0x1D36(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinishedEquippingLoadout;                         // 0x1D37(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinishedEquippingArmour;                          // 0x1D38(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceFiringEnabled;                               // 0x1D39(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2364[0x6];                                     // 0x1D3A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterMesh                         CharacterMeshData;                                 // 0x1D40(0x0088)(Net, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2365[0x8];                                     // 0x1DC8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAimedAt;                                         // 0x1DD0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2366[0x8];                                     // 0x1DE0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAimingAtTarget : 1;                               // 0x1DE8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasEverAimedAtTarget : 1;                         // 0x1DE8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsFleeing : 1;                                    // 0x1DE8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsExitingLandmark : 1;                            // 0x1DE8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawingWeapon : 1;                                // 0x1DE8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPickingUpWeapon : 1;                              // 0x1DE8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasDamagedSWATTeam : 1;                           // 0x1DE8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHitScannedFriendly : 1;                           // 0x1DE8(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDiedWhilstTraversingHole : 1;                     // 0x1DE9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDiedWhilstHiding : 1;                             // 0x1DE9(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsRaisingWeapon : 1;                              // 0x1DE9(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsLoweringWeapon : 1;                             // 0x1DE9(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2367[0x2];                                     // 0x1DEA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawingWeaponTime;                                 // 0x1DEC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickingUpWeaponTime;                               // 0x1DF0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RaisingWeaponTime;                                 // 0x1DF4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoweringWeaponTime;                                // 0x1DF8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             CachedHitScanResult;                               // 0x1DFC(0x0088)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2368[0x4];                                     // 0x1E84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWorldBuildingAnimState                Rep_WorldBuildingAnimState;                        // 0x1E88(0x0010)(BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	struct FTakeHostageAnimState                  Rep_TakeHostageAnimState;                          // 0x1E98(0x0018)(BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2369[0x8];                                     // 0x1EB0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          HostageMasterIdleLoop;                             // 0x1EB8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HostageSlaveIdleLoop;                              // 0x1EC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   TakenHostageBy;                                    // 0x1EC8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_236A[0x2C];                                    // 0x1ED0(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSurrendered;                                   // 0x1EFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsComplying : 1;                                  // 0x1F00(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsWaiting : 1;                                    // 0x1F00(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_236B[0x3];                                     // 0x1F01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PepperSprayAbuseLevel;                             // 0x1F04(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastTasered;                              // 0x1F08(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TimesTasered;                                      // 0x1F0C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RagdollMeshLocation;                               // 0x1F10(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RagdollMeshRotation;                               // 0x1F1C(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_236C[0x4];                                     // 0x1F28(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HesitationTime;                                    // 0x1F2C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_236D[0x28];                                    // 0x1F30(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocalPointInterpSpeed;                             // 0x1F58(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             FocalPointInterpCurve;                             // 0x1F5C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             AimOffsetInterpCurve;                              // 0x1F5D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_236E[0x2];                                     // 0x1F5E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocusTurnSpeed;                                    // 0x1F60(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnDegreesPerSecond;                              // 0x1F64(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorRotationInterpStandingSpeed;                  // 0x1F68(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorRotationInterpMovingSpeed;                    // 0x1F6C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetInterpSpeed;                              // 0x1F70(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_236F[0x4];                                     // 0x1F74(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              EscapeGasQuery;                                    // 0x1F78(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASafeZoneVolume*                        LastUsedSafeZone;                                  // 0x1F80(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetComponent*                       DebugAISelectionWidget;                            // 0x1F88(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AIFinishedSpawningDelegate__DelegateSignature();
	void DecreaseStress(float Amount);
	void DrawWeapon();
	void FakeSurrender();
	void ForceFireGun(float Chance);
	void IncreaseStress(float Amount);
	void Knockout(float Duration, bool bPlayVO);
	void Multicast_PlayArmourHitEffects(class ABaseArmour* Armour, const struct FHitResult& Hit, class AController* HitInstigator);
	void Multicast_SendCharacterMeshData(const struct FCharacterMesh& RPC_CharacterMeshData);
	void OnAIFire__DelegateSignature(class ACyberneticCharacter* AICharacter, class ABaseMagazineWeapon* MagazineWeapon, const struct FVector& FireDirection);
	void OnAimedAt__DelegateSignature(class ACyberneticCharacter* Character, class AReadyOrNotCharacter* Target);
	void OnCollectPendingEvidenceNotify__DelegateSignature();
	void OnDoorBreachNotifyEvent__DelegateSignature();
	void OnExitedSurrender__DelegateSignature(class ACyberneticCharacter* Character, ESurrenderExitType ExitType);
	void OnGetupAfterRagdollComplete();
	void OnHeardOfficerYellSignature__DelegateSignature(class AReadyOrNotCharacter* Shouter, bool bLOS);
	void OnOfficerShouted(class AReadyOrNotCharacter* Shouter, bool bLOS);
	void OnRep_AttachedMeshData();
	void OnRep_AttachedSkeletalMeshData();
	void OnRep_CharacterMeshData();
	void OnRep_SimulatingAttachedStaticMeshes();
	void OnSensedActor__DelegateSignature(class AActor* Actor);
	void OnSensedCharacter__DelegateSignature(class AReadyOrNotCharacter* Character);
	void OnSpottedCharacter__DelegateSignature(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Character);
	void OnSurrendered__DelegateSignature(class AReadyOrNotCharacter* Character);
	void OnWeaponForceFireNotifyEvent__DelegateSignature();
	void PlayBarkOrStartConversation(const class FString& SpeechRow, bool bHasSharedCooldown, float Cooldown);
	void PlayDead(float Duration, bool bPlayVO);
	class UAnimMontage* PlayMontageFromTableWithFocalPoint(const class FString& Animation, struct FVector& FocalPoint);
	class UAnimMontage* PlayMontageFromTableWithIndexWithFocalPoint(const class FString& Animation, int32 Param_Index, struct FVector& FocalPoint);
	bool PlayMontageWithFocalPoint(class UAnimMontage* Montage, struct FVector& FocalPoint);
	void PlayShootingWeaponConversation();
	void StopPlayingDead();
	void Surrender();
	bool SurrenderExit(ESurrenderExitType ExitType, const struct FVector& FocalPoint);

	bool CanEverSuicide() const;
	bool CanExitSurrender() const;
	ESurrenderExitType DetermineSurrenderExitType() const;
	class UAIArchetypeData* GetAIArchetype() const;
	class ABaseArmour* GetArmour() const;
	class ACyberneticController* GetCyberneticsController() const;
	TArray<struct FDebugData> GetDebugInfoOnROE() const;
	struct FVector GetFocalPoint() const;
	float GetHesitationTime() const;
	struct FRotator GetLookAtRotation(float YawLimit, float PitchLimit) const;
	float GetVisibleSWATPercentage() const;
	bool HasDamagedSWAT() const;
	bool HasLineOfSightToCharacter(class AReadyOrNotCharacter* InCharacter) const;
	bool IsActiveForCombat() const;
	bool IsArrestCapable(class APlayerCharacter* PlayerCharacter) const;
	bool IsBeginningHostageTake() const;
	bool IsBeingTakenHostage() const;
	bool IsDamagedByLessLethal() const;
	bool IsDamagedByLethal() const;
	bool IsEndingHostageTake() const;
	bool IsExitingSurrender() const;
	bool IsFiringFromCover() const;
	bool IsHesitating() const;
	bool IsHesitatingFor(float Seconds) const;
	bool IsHiding() const;
	bool IsLoweringWeapon() const;
	bool IsMovingToCover() const;
	bool IsMovingToLandmarkCover() const;
	bool IsPlayingDead() const;
	bool IsPlayingStunAnimation() const;
	bool IsRaisingWeapon() const;
	bool IsSameFaction(class ACyberneticCharacter* OtherAI) const;
	bool IsTakingCover() const;
	bool IsTakingCoverAtLandmark() const;
	bool IsTakingHostage() const;
	bool IsUnjustifiedUseOfForce(class AReadyOrNotCharacter* Aggressor, class ABaseItem* ForceWeapon, class UDamageType* ForceUsed) const;
	bool IsWearingExplosiveVest() const;
	bool IsWearingHeadArmor() const;
	bool WasRecentlyYelledAt(float Seconds) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CyberneticCharacter">();
	}
	static class ACyberneticCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACyberneticCharacter>();
	}
};
static_assert(alignof(ACyberneticCharacter) == 0x000010, "Wrong alignment on ACyberneticCharacter");
static_assert(sizeof(ACyberneticCharacter) == 0x001F90, "Wrong size on ACyberneticCharacter");
static_assert(offsetof(ACyberneticCharacter, ClosestPawn) == 0x001640, "Member 'ACyberneticCharacter::ClosestPawn' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, VisibleSwatPercentage) == 0x001670, "Member 'ACyberneticCharacter::VisibleSwatPercentage' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, MoveStyle) == 0x001678, "Member 'ACyberneticCharacter::MoveStyle' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ForceComplianceStrength) == 0x0016A4, "Member 'ACyberneticCharacter::ForceComplianceStrength' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ActiveCoverDirection) == 0x0016A8, "Member 'ACyberneticCharacter::ActiveCoverDirection' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ActiveCoverAimType) == 0x0016A9, "Member 'ACyberneticCharacter::ActiveCoverAimType' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ActiveCoverFireType) == 0x0016AA, "Member 'ACyberneticCharacter::ActiveCoverFireType' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ActiveCoverFirePose) == 0x0016B0, "Member 'ACyberneticCharacter::ActiveCoverFirePose' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ActiveCoverIdlePose) == 0x0016B8, "Member 'ACyberneticCharacter::ActiveCoverIdlePose' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CurrentCoverLandmarkInUse) == 0x0016C0, "Member 'ACyberneticCharacter::CurrentCoverLandmarkInUse' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, LastCoverLandmarkUsed) == 0x0016C8, "Member 'ACyberneticCharacter::LastCoverLandmarkUsed' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CurrentWallHoleTraversalInUse) == 0x0016D0, "Member 'ACyberneticCharacter::CurrentWallHoleTraversalInUse' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, LastWallHoleTraversalUsed) == 0x0016D8, "Member 'ACyberneticCharacter::LastWallHoleTraversalUsed' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, VoiceLineEventMask) == 0x0016E8, "Member 'ACyberneticCharacter::VoiceLineEventMask' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, SimulatingAttachedStaticMeshes) == 0x0016F8, "Member 'ACyberneticCharacter::SimulatingAttachedStaticMeshes' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, AttachedMeshData) == 0x001708, "Member 'ACyberneticCharacter::AttachedMeshData' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, AttachedSkeletalMeshData) == 0x001718, "Member 'ACyberneticCharacter::AttachedSkeletalMeshData' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bIsMoving) == 0x001728, "Member 'ACyberneticCharacter::bIsMoving' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, LastEquippedBreachItem) == 0x001750, "Member 'ACyberneticCharacter::LastEquippedBreachItem' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnSurrendered) == 0x001758, "Member 'ACyberneticCharacter::OnSurrendered' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnFakeSurrendered) == 0x001768, "Member 'ACyberneticCharacter::OnFakeSurrendered' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnSpottedEnemy) == 0x001778, "Member 'ACyberneticCharacter::OnSpottedEnemy' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnSpottedFriendly) == 0x001788, "Member 'ACyberneticCharacter::OnSpottedFriendly' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnSpottedNeutral) == 0x001798, "Member 'ACyberneticCharacter::OnSpottedNeutral' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnSensedActor) == 0x0017A8, "Member 'ACyberneticCharacter::OnSensedActor' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnSensedCharacter) == 0x0017B8, "Member 'ACyberneticCharacter::OnSensedCharacter' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnAIFinishSpawning) == 0x0017C8, "Member 'ACyberneticCharacter::OnAIFinishSpawning' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, NoBuenoTextRender) == 0x0017E8, "Member 'ACyberneticCharacter::NoBuenoTextRender' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, AbuseCount) == 0x0017F0, "Member 'ACyberneticCharacter::AbuseCount' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ReasonsToSprint) == 0x0017F8, "Member 'ACyberneticCharacter::ReasonsToSprint' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ReasonsToStandStill) == 0x001808, "Member 'ACyberneticCharacter::ReasonsToStandStill' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ReasonsToWalk) == 0x001818, "Member 'ACyberneticCharacter::ReasonsToWalk' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_CoverAnimState) == 0x001828, "Member 'ACyberneticCharacter::Rep_CoverAnimState' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_HidingAnimState) == 0x001840, "Member 'ACyberneticCharacter::Rep_HidingAnimState' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_HoleTraversalAnimState) == 0x001850, "Member 'ACyberneticCharacter::Rep_HoleTraversalAnimState' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, AimOffset) == 0x001860, "Member 'ACyberneticCharacter::AimOffset' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, MeleeCountMap) == 0x001880, "Member 'ACyberneticCharacter::MeleeCountMap' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CivilianCowerActivities) == 0x0018D0, "Member 'ACyberneticCharacter::CivilianCowerActivities' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CivilianCowerActivityDuration) == 0x0018E0, "Member 'ACyberneticCharacter::CivilianCowerActivityDuration' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, FactionManager) == 0x0018F8, "Member 'ACyberneticCharacter::FactionManager' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, SpawnedFromSpawner) == 0x0019B0, "Member 'ACyberneticCharacter::SpawnedFromSpawner' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CombatState) == 0x0019B8, "Member 'ACyberneticCharacter::CombatState' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, RecentMeleeVictim) == 0x0019C0, "Member 'ACyberneticCharacter::RecentMeleeVictim' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, PendingMeleeTarget) == 0x0019C8, "Member 'ACyberneticCharacter::PendingMeleeTarget' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bHasEverShot) == 0x0019D0, "Member 'ACyberneticCharacter::bHasEverShot' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnWeaponForceFire_FromAnimNotify) == 0x0019D8, "Member 'ACyberneticCharacter::OnWeaponForceFire_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnDoorShotgunBreach_FromAnimNotify) == 0x0019E8, "Member 'ACyberneticCharacter::OnDoorShotgunBreach_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnDoorKickBreach_FromAnimNotify) == 0x0019F8, "Member 'ACyberneticCharacter::OnDoorKickBreach_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnDoorRamBreach_FromAnimNotify) == 0x001A08, "Member 'ACyberneticCharacter::OnDoorRamBreach_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnPendingItemThrown_FromAnimNotify) == 0x001A18, "Member 'ACyberneticCharacter::OnPendingItemThrown_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, PendingThrownItem) == 0x001A28, "Member 'ACyberneticCharacter::PendingThrownItem' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnAIFire) == 0x001A30, "Member 'ACyberneticCharacter::OnAIFire' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnCollectPendingEvidenceBegin_FromAnimNotify) == 0x001A40, "Member 'ACyberneticCharacter::OnCollectPendingEvidenceBegin_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnCollectPendingEvidenceEnd_FromAnimNotify) == 0x001A50, "Member 'ACyberneticCharacter::OnCollectPendingEvidenceEnd_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnHeardOfficerYell) == 0x001A68, "Member 'ACyberneticCharacter::OnHeardOfficerYell' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnExitedSurrender) == 0x001A78, "Member 'ACyberneticCharacter::OnExitedSurrender' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, SuppressionAmount) == 0x001A8C, "Member 'ACyberneticCharacter::SuppressionAmount' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, BeingRestrainedBy) == 0x001A90, "Member 'ACyberneticCharacter::BeingRestrainedBy' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ScoringComponent) == 0x001A98, "Member 'ACyberneticCharacter::ScoringComponent' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Archetype) == 0x001AA8, "Member 'ACyberneticCharacter::Archetype' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, SpawnLocation) == 0x001AB0, "Member 'ACyberneticCharacter::SpawnLocation' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, DefaultSuspectArchetype) == 0x001AC0, "Member 'ACyberneticCharacter::DefaultSuspectArchetype' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, DefaultCivilianArchetype) == 0x001AC8, "Member 'ACyberneticCharacter::DefaultCivilianArchetype' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ActivityRouteCollection) == 0x001AD0, "Member 'ACyberneticCharacter::ActivityRouteCollection' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_AimOffsetFocalPoint) == 0x001AF0, "Member 'ACyberneticCharacter::Rep_AimOffsetFocalPoint' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_FocalPoint) == 0x001AFC, "Member 'ACyberneticCharacter::Rep_FocalPoint' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_HeadFocalPoint) == 0x001B08, "Member 'ACyberneticCharacter::Rep_HeadFocalPoint' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_FocalActor) == 0x001B18, "Member 'ACyberneticCharacter::Rep_FocalActor' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bHasLOSToFocalPoint) == 0x001B20, "Member 'ACyberneticCharacter::bHasLOSToFocalPoint' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceHeardOfficerYell) == 0x001B24, "Member 'ACyberneticCharacter::TimeSinceHeardOfficerYell' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceLastAggressiveForce) == 0x001B28, "Member 'ACyberneticCharacter::TimeSinceLastAggressiveForce' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ArrestedTime) == 0x001B2C, "Member 'ACyberneticCharacter::ArrestedTime' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bFemale) == 0x001B30, "Member 'ACyberneticCharacter::bFemale' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bChild) == 0x001B31, "Member 'ACyberneticCharacter::bChild' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, LastGetUpMontage) == 0x001B38, "Member 'ACyberneticCharacter::LastGetUpMontage' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeHiding) == 0x001B44, "Member 'ACyberneticCharacter::TimeHiding' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimePlayingDead) == 0x001B48, "Member 'ACyberneticCharacter::TimePlayingDead' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceLastPlayDead) == 0x001B4C, "Member 'ACyberneticCharacter::TimeSinceLastPlayDead' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceAtLastCoverLandmark) == 0x001B50, "Member 'ACyberneticCharacter::TimeSinceAtLastCoverLandmark' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceLastSeenCharacterWhilstHiding) == 0x001B54, "Member 'ACyberneticCharacter::TimeSinceLastSeenCharacterWhilstHiding' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceSeenCharacterNotLookingWhilstHiding) == 0x001B58, "Member 'ACyberneticCharacter::TimeSinceSeenCharacterNotLookingWhilstHiding' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bHasEverSeenCharacterWhilstHiding) == 0x001B5C, "Member 'ACyberneticCharacter::bHasEverSeenCharacterWhilstHiding' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CharacterSeenWhilstHiding) == 0x001B60, "Member 'ACyberneticCharacter::CharacterSeenWhilstHiding' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Unarmed_Calm_AD) == 0x001B68, "Member 'ACyberneticCharacter::Unarmed_Calm_AD' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Unarmed_Sr_AD) == 0x001B70, "Member 'ACyberneticCharacter::Unarmed_Sr_AD' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Unarmed_Ar_AD) == 0x001B78, "Member 'ACyberneticCharacter::Unarmed_Ar_AD' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Unarmed_Ar_Crouch_AD) == 0x001B80, "Member 'ACyberneticCharacter::Unarmed_Ar_Crouch_AD' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Unarmed_Alert_AD) == 0x001B88, "Member 'ACyberneticCharacter::Unarmed_Alert_AD' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rifle_AD) == 0x001B90, "Member 'ACyberneticCharacter::Rifle_AD' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Pistol_AD) == 0x001B98, "Member 'ACyberneticCharacter::Pistol_AD' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Pistol_OneHanded_AD) == 0x001BA0, "Member 'ACyberneticCharacter::Pistol_OneHanded_AD' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, AvoidingCharacter) == 0x001BA8, "Member 'ACyberneticCharacter::AvoidingCharacter' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, MoveDataOverride) == 0x001BB0, "Member 'ACyberneticCharacter::MoveDataOverride' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CurMoveDataBlock) == 0x001C48, "Member 'ACyberneticCharacter::CurMoveDataBlock' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, MovementStyleData) == 0x001CE0, "Member 'ACyberneticCharacter::MovementStyleData' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Stress) == 0x001D24, "Member 'ACyberneticCharacter::Stress' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, StartingStress) == 0x001D28, "Member 'ACyberneticCharacter::StartingStress' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceLastShot) == 0x001D2C, "Member 'ACyberneticCharacter::TimeSinceLastShot' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceArrest) == 0x001D30, "Member 'ACyberneticCharacter::TimeSinceArrest' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bHasPlayedSurrenderAnim) == 0x001D34, "Member 'ACyberneticCharacter::bHasPlayedSurrenderAnim' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bIsFakeSurrender) == 0x001D35, "Member 'ACyberneticCharacter::bIsFakeSurrender' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bHasEverFakeSurrendered) == 0x001D36, "Member 'ACyberneticCharacter::bHasEverFakeSurrendered' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bFinishedEquippingLoadout) == 0x001D37, "Member 'ACyberneticCharacter::bFinishedEquippingLoadout' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bFinishedEquippingArmour) == 0x001D38, "Member 'ACyberneticCharacter::bFinishedEquippingArmour' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bForceFiringEnabled) == 0x001D39, "Member 'ACyberneticCharacter::bForceFiringEnabled' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CharacterMeshData) == 0x001D40, "Member 'ACyberneticCharacter::CharacterMeshData' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnAimedAt) == 0x001DD0, "Member 'ACyberneticCharacter::OnAimedAt' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, DrawingWeaponTime) == 0x001DEC, "Member 'ACyberneticCharacter::DrawingWeaponTime' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, PickingUpWeaponTime) == 0x001DF0, "Member 'ACyberneticCharacter::PickingUpWeaponTime' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, RaisingWeaponTime) == 0x001DF4, "Member 'ACyberneticCharacter::RaisingWeaponTime' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, LoweringWeaponTime) == 0x001DF8, "Member 'ACyberneticCharacter::LoweringWeaponTime' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CachedHitScanResult) == 0x001DFC, "Member 'ACyberneticCharacter::CachedHitScanResult' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_WorldBuildingAnimState) == 0x001E88, "Member 'ACyberneticCharacter::Rep_WorldBuildingAnimState' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_TakeHostageAnimState) == 0x001E98, "Member 'ACyberneticCharacter::Rep_TakeHostageAnimState' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, HostageMasterIdleLoop) == 0x001EB8, "Member 'ACyberneticCharacter::HostageMasterIdleLoop' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, HostageSlaveIdleLoop) == 0x001EC0, "Member 'ACyberneticCharacter::HostageSlaveIdleLoop' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TakenHostageBy) == 0x001EC8, "Member 'ACyberneticCharacter::TakenHostageBy' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSurrendered) == 0x001EFC, "Member 'ACyberneticCharacter::TimeSurrendered' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, PepperSprayAbuseLevel) == 0x001F04, "Member 'ACyberneticCharacter::PepperSprayAbuseLevel' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceLastTasered) == 0x001F08, "Member 'ACyberneticCharacter::TimeSinceLastTasered' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimesTasered) == 0x001F0C, "Member 'ACyberneticCharacter::TimesTasered' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, RagdollMeshLocation) == 0x001F10, "Member 'ACyberneticCharacter::RagdollMeshLocation' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, RagdollMeshRotation) == 0x001F1C, "Member 'ACyberneticCharacter::RagdollMeshRotation' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, HesitationTime) == 0x001F2C, "Member 'ACyberneticCharacter::HesitationTime' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, FocalPointInterpSpeed) == 0x001F58, "Member 'ACyberneticCharacter::FocalPointInterpSpeed' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, FocalPointInterpCurve) == 0x001F5C, "Member 'ACyberneticCharacter::FocalPointInterpCurve' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, AimOffsetInterpCurve) == 0x001F5D, "Member 'ACyberneticCharacter::AimOffsetInterpCurve' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, FocusTurnSpeed) == 0x001F60, "Member 'ACyberneticCharacter::FocusTurnSpeed' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TurnDegreesPerSecond) == 0x001F64, "Member 'ACyberneticCharacter::TurnDegreesPerSecond' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ActorRotationInterpStandingSpeed) == 0x001F68, "Member 'ACyberneticCharacter::ActorRotationInterpStandingSpeed' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ActorRotationInterpMovingSpeed) == 0x001F6C, "Member 'ACyberneticCharacter::ActorRotationInterpMovingSpeed' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, AimOffsetInterpSpeed) == 0x001F70, "Member 'ACyberneticCharacter::AimOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, EscapeGasQuery) == 0x001F78, "Member 'ACyberneticCharacter::EscapeGasQuery' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, LastUsedSafeZone) == 0x001F80, "Member 'ACyberneticCharacter::LastUsedSafeZone' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, DebugAISelectionWidget) == 0x001F88, "Member 'ACyberneticCharacter::DebugAISelectionWidget' has a wrong offset!");

// Class ReadyOrNot.SuspectCharacter
// 0x0010 (0x1FA0 - 0x1F90)
class ASuspectCharacter : public ACyberneticCharacter
{
public:
	uint8                                         Pad_2381[0x10];                                    // 0x1F90(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuspectCharacter">();
	}
	static class ASuspectCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASuspectCharacter>();
	}
};
static_assert(alignof(ASuspectCharacter) == 0x000010, "Wrong alignment on ASuspectCharacter");
static_assert(sizeof(ASuspectCharacter) == 0x001FA0, "Wrong size on ASuspectCharacter");

// Class ReadyOrNot.ReadyOrNotGameplayEffect
// 0x0030 (0x0058 - 0x0028)
class UReadyOrNotGameplayEffect : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnGameplayEffectExpired;                           // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorld*                                 World;                                             // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2382[0x10];                                    // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyEffect();
	void ApplyEffectFor(float Seconds);
	void Initialize(class AActor* InActor);
	void Multicast_ApplyEffect();
	void Multicast_ApplyEffectFor(float Seconds);
	void Multicast_Initialize(class AActor* InActor);
	void Multicast_ResetEffect();
	void OnEffectExpired();
	void ResetEffect();
	void Server_ApplyEffect(bool bMulticast);
	void Server_ApplyEffectFor(float Seconds, bool bMulticast);
	void Server_Initialize(class AActor* InActor, bool bMulticast);
	void Server_ResetEffect(bool bMulticast);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotGameplayEffect">();
	}
	static class UReadyOrNotGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotGameplayEffect>();
	}
};
static_assert(alignof(UReadyOrNotGameplayEffect) == 0x000008, "Wrong alignment on UReadyOrNotGameplayEffect");
static_assert(sizeof(UReadyOrNotGameplayEffect) == 0x000058, "Wrong size on UReadyOrNotGameplayEffect");
static_assert(offsetof(UReadyOrNotGameplayEffect, OnGameplayEffectExpired) == 0x000028, "Member 'UReadyOrNotGameplayEffect::OnGameplayEffectExpired' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameplayEffect, Actor) == 0x000038, "Member 'UReadyOrNotGameplayEffect::Actor' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameplayEffect, World) == 0x000040, "Member 'UReadyOrNotGameplayEffect::World' has a wrong offset!");

// Class ReadyOrNot.BasePlayerEffect
// 0x0008 (0x0060 - 0x0058)
class UBasePlayerEffect : public UReadyOrNotGameplayEffect
{
public:
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePlayerEffect">();
	}
	static class UBasePlayerEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePlayerEffect>();
	}
};
static_assert(alignof(UBasePlayerEffect) == 0x000008, "Wrong alignment on UBasePlayerEffect");
static_assert(sizeof(UBasePlayerEffect) == 0x000060, "Wrong size on UBasePlayerEffect");
static_assert(offsetof(UBasePlayerEffect, PlayerCharacter) == 0x000058, "Member 'UBasePlayerEffect::PlayerCharacter' has a wrong offset!");

// Class ReadyOrNot.BaseProfile
// 0x0248 (0x0270 - 0x0028)
class UBaseProfile : public USaveGame
{
public:
	int32                                         BaseVersion;                                       // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2385[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSavedLoadout>                  Loadouts;                                          // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseItem>, struct FSavedWeaponAttachmentData> AttachmentSaveMap;                                 // 0x0040(0x0050)(NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseWeapon>, struct FStoredWeaponAttachments> LoadoutAttachmentSaveMap;                          // 0x0090(0x0050)(NativeAccessSpecifierPublic)
	TMap<EItemType, TSubclassOf<class ABaseItem>> SavedWeaponClassOfTypeMap;                         // 0x00E0(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseWeapon>, EFireMode> WeaponClassToDefaultFireModeMap;                   // 0x0130(0x0050)(NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseItem>, struct FSavedWeaponPreset> WeaponToWeaponPresetsMap;                          // 0x0180(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, struct FSavedLoadout>     LoadoutPresetMap;                                  // 0x01D0(0x0050)(NativeAccessSpecifierPublic)
	TMap<EEquippingSwat, struct FSavedCustomization> Customizations;                                    // 0x0220(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseProfile">();
	}
	static class UBaseProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseProfile>();
	}
};
static_assert(alignof(UBaseProfile) == 0x000008, "Wrong alignment on UBaseProfile");
static_assert(sizeof(UBaseProfile) == 0x000270, "Wrong size on UBaseProfile");
static_assert(offsetof(UBaseProfile, BaseVersion) == 0x000028, "Member 'UBaseProfile::BaseVersion' has a wrong offset!");
static_assert(offsetof(UBaseProfile, Loadouts) == 0x000030, "Member 'UBaseProfile::Loadouts' has a wrong offset!");
static_assert(offsetof(UBaseProfile, AttachmentSaveMap) == 0x000040, "Member 'UBaseProfile::AttachmentSaveMap' has a wrong offset!");
static_assert(offsetof(UBaseProfile, LoadoutAttachmentSaveMap) == 0x000090, "Member 'UBaseProfile::LoadoutAttachmentSaveMap' has a wrong offset!");
static_assert(offsetof(UBaseProfile, SavedWeaponClassOfTypeMap) == 0x0000E0, "Member 'UBaseProfile::SavedWeaponClassOfTypeMap' has a wrong offset!");
static_assert(offsetof(UBaseProfile, WeaponClassToDefaultFireModeMap) == 0x000130, "Member 'UBaseProfile::WeaponClassToDefaultFireModeMap' has a wrong offset!");
static_assert(offsetof(UBaseProfile, WeaponToWeaponPresetsMap) == 0x000180, "Member 'UBaseProfile::WeaponToWeaponPresetsMap' has a wrong offset!");
static_assert(offsetof(UBaseProfile, LoadoutPresetMap) == 0x0001D0, "Member 'UBaseProfile::LoadoutPresetMap' has a wrong offset!");
static_assert(offsetof(UBaseProfile, Customizations) == 0x000220, "Member 'UBaseProfile::Customizations' has a wrong offset!");

// Class ReadyOrNot.CursorWidget
// 0x0000 (0x0260 - 0x0260)
class UCursorWidget : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CursorWidget">();
	}
	static class UCursorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCursorWidget>();
	}
};
static_assert(alignof(UCursorWidget) == 0x000008, "Wrong alignment on UCursorWidget");
static_assert(sizeof(UCursorWidget) == 0x000260, "Wrong size on UCursorWidget");

// Class ReadyOrNot.BaseRadialMenuScript
// 0x0040 (0x0068 - 0x0028)
class UBaseRadialMenuScript : public UObject
{
public:
	TSoftObjectPtr<class UTexture2D>              RadialMenuIcon;                                    // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URadialWidgetBase*                      RadialMenuOwner;                                   // 0x0050(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 Actor;                                             // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorld*                                 World;                                             // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ExecuteScript();
	void Initialize(class URadialWidgetBase* InRadialMenuOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseRadialMenuScript">();
	}
	static class UBaseRadialMenuScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseRadialMenuScript>();
	}
};
static_assert(alignof(UBaseRadialMenuScript) == 0x000008, "Wrong alignment on UBaseRadialMenuScript");
static_assert(sizeof(UBaseRadialMenuScript) == 0x000068, "Wrong size on UBaseRadialMenuScript");
static_assert(offsetof(UBaseRadialMenuScript, RadialMenuIcon) == 0x000028, "Member 'UBaseRadialMenuScript::RadialMenuIcon' has a wrong offset!");
static_assert(offsetof(UBaseRadialMenuScript, RadialMenuOwner) == 0x000050, "Member 'UBaseRadialMenuScript::RadialMenuOwner' has a wrong offset!");
static_assert(offsetof(UBaseRadialMenuScript, Actor) == 0x000058, "Member 'UBaseRadialMenuScript::Actor' has a wrong offset!");
static_assert(offsetof(UBaseRadialMenuScript, World) == 0x000060, "Member 'UBaseRadialMenuScript::World' has a wrong offset!");

// Class ReadyOrNot.ThrownChemlight
// 0x0060 (0x04C0 - 0x0460)
class AThrownChemlight : public AThrownItem
{
public:
	class UPointLightComponent*                   LightSource;                                       // 0x0460(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ChemlightColor;                                    // 0x0468(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmissiveBrightness;                                // 0x0478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightIntensity;                                    // 0x047C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialGlowSpeed;                                  // 0x0480(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightDimSpeed;                                     // 0x0484(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyedDimSpeed;                                 // 0x0488(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDimTime;                                      // 0x048C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalLifeTime;                                     // 0x0490(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2386[0x4];                                     // 0x0494(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DestroyedDecal;                                    // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightZOffset;                                      // 0x04A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightAdditionalHeight;                             // 0x04A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyedDecalSize;                                // 0x04A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2387[0xC];                                     // 0x04AC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               ChemlightMaterialInstance;                         // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrownChemlight">();
	}
	static class AThrownChemlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThrownChemlight>();
	}
};
static_assert(alignof(AThrownChemlight) == 0x000008, "Wrong alignment on AThrownChemlight");
static_assert(sizeof(AThrownChemlight) == 0x0004C0, "Wrong size on AThrownChemlight");
static_assert(offsetof(AThrownChemlight, LightSource) == 0x000460, "Member 'AThrownChemlight::LightSource' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, ChemlightColor) == 0x000468, "Member 'AThrownChemlight::ChemlightColor' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, EmissiveBrightness) == 0x000478, "Member 'AThrownChemlight::EmissiveBrightness' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, LightIntensity) == 0x00047C, "Member 'AThrownChemlight::LightIntensity' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, InitialGlowSpeed) == 0x000480, "Member 'AThrownChemlight::InitialGlowSpeed' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, LightDimSpeed) == 0x000484, "Member 'AThrownChemlight::LightDimSpeed' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, DestroyedDimSpeed) == 0x000488, "Member 'AThrownChemlight::DestroyedDimSpeed' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, StartDimTime) == 0x00048C, "Member 'AThrownChemlight::StartDimTime' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, TotalLifeTime) == 0x000490, "Member 'AThrownChemlight::TotalLifeTime' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, DestroyedDecal) == 0x000498, "Member 'AThrownChemlight::DestroyedDecal' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, LightZOffset) == 0x0004A0, "Member 'AThrownChemlight::LightZOffset' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, LightAdditionalHeight) == 0x0004A4, "Member 'AThrownChemlight::LightAdditionalHeight' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, DestroyedDecalSize) == 0x0004A8, "Member 'AThrownChemlight::DestroyedDecalSize' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, ChemlightMaterialInstance) == 0x0004B8, "Member 'AThrownChemlight::ChemlightMaterialInstance' has a wrong offset!");

// Class ReadyOrNot.BaseShell
// 0x0038 (0x02A0 - 0x0268)
class ABaseShell : public APooledActor
{
public:
	class UStaticMeshComponent*                   ShellMesh;                                         // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       MID_ShellMesh;                                     // 0x0270(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EShellType                                    ShellType;                                         // 0x0280(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2388[0x7];                                     // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             ShellBounceFMODAudio;                              // 0x0288(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShellNormalizeMax;                                 // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShellNormalizeMin;                                 // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2389[0x8];                                     // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseShell">();
	}
	static class ABaseShell* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseShell>();
	}
};
static_assert(alignof(ABaseShell) == 0x000008, "Wrong alignment on ABaseShell");
static_assert(sizeof(ABaseShell) == 0x0002A0, "Wrong size on ABaseShell");
static_assert(offsetof(ABaseShell, ShellMesh) == 0x000268, "Member 'ABaseShell::ShellMesh' has a wrong offset!");
static_assert(offsetof(ABaseShell, MID_ShellMesh) == 0x000270, "Member 'ABaseShell::MID_ShellMesh' has a wrong offset!");
static_assert(offsetof(ABaseShell, ShellType) == 0x000280, "Member 'ABaseShell::ShellType' has a wrong offset!");
static_assert(offsetof(ABaseShell, ShellBounceFMODAudio) == 0x000288, "Member 'ABaseShell::ShellBounceFMODAudio' has a wrong offset!");
static_assert(offsetof(ABaseShell, ShellNormalizeMax) == 0x000290, "Member 'ABaseShell::ShellNormalizeMax' has a wrong offset!");
static_assert(offsetof(ABaseShell, ShellNormalizeMin) == 0x000294, "Member 'ABaseShell::ShellNormalizeMin' has a wrong offset!");

// Class ReadyOrNot.CustomizationTattoo
// 0x0058 (0x01C8 - 0x0170)
class UCustomizationTattoo final  : public UCustomizationDataBase
{
public:
	TSoftObjectPtr<class UTexture2D>              TattooTexture;                                     // 0x0170(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCustomizationMaterialSlot             ArmSlotOverride;                                   // 0x0198(0x0030)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationTattoo">();
	}
	static class UCustomizationTattoo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationTattoo>();
	}
};
static_assert(alignof(UCustomizationTattoo) == 0x000008, "Wrong alignment on UCustomizationTattoo");
static_assert(sizeof(UCustomizationTattoo) == 0x0001C8, "Wrong size on UCustomizationTattoo");
static_assert(offsetof(UCustomizationTattoo, TattooTexture) == 0x000170, "Member 'UCustomizationTattoo::TattooTexture' has a wrong offset!");
static_assert(offsetof(UCustomizationTattoo, ArmSlotOverride) == 0x000198, "Member 'UCustomizationTattoo::ArmSlotOverride' has a wrong offset!");

// Class ReadyOrNot.BaseTriggerable
// 0x0018 (0x0238 - 0x0220)
class ABaseTriggerable final  : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActivate;                                         // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_238B[0x3];                                     // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActivateDelay;                                     // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeactivateDelay;                                   // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0234(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_238C[0x3];                                     // 0x0235(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Activate();
	void Deactivate();
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseTriggerable">();
	}
	static class ABaseTriggerable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseTriggerable>();
	}
};
static_assert(alignof(ABaseTriggerable) == 0x000008, "Wrong alignment on ABaseTriggerable");
static_assert(sizeof(ABaseTriggerable) == 0x000238, "Wrong size on ABaseTriggerable");
static_assert(offsetof(ABaseTriggerable, SceneComponent) == 0x000220, "Member 'ABaseTriggerable::SceneComponent' has a wrong offset!");
static_assert(offsetof(ABaseTriggerable, bActivate) == 0x000228, "Member 'ABaseTriggerable::bActivate' has a wrong offset!");
static_assert(offsetof(ABaseTriggerable, ActivateDelay) == 0x00022C, "Member 'ABaseTriggerable::ActivateDelay' has a wrong offset!");
static_assert(offsetof(ABaseTriggerable, DeactivateDelay) == 0x000230, "Member 'ABaseTriggerable::DeactivateDelay' has a wrong offset!");
static_assert(offsetof(ABaseTriggerable, bIsActive) == 0x000234, "Member 'ABaseTriggerable::bIsActive' has a wrong offset!");

// Class ReadyOrNot.CTFTriggerBox
// 0x0008 (0x0230 - 0x0228)
class ACTFTriggerBox final  : public ATriggerBox
{
public:
	class UTextRenderComponent*                   TextRender;                                        // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool FulfillsRequirements();
	void OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CTFTriggerBox">();
	}
	static class ACTFTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACTFTriggerBox>();
	}
};
static_assert(alignof(ACTFTriggerBox) == 0x000008, "Wrong alignment on ACTFTriggerBox");
static_assert(sizeof(ACTFTriggerBox) == 0x000230, "Wrong size on ACTFTriggerBox");
static_assert(offsetof(ACTFTriggerBox, TextRender) == 0x000228, "Member 'ACTFTriggerBox::TextRender' has a wrong offset!");

// Class ReadyOrNot.BeanbagDamageType
// 0x0000 (0x0620 - 0x0620)
class UBeanbagDamageType : public UStunDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BeanbagDamageType">();
	}
	static class UBeanbagDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBeanbagDamageType>();
	}
};
static_assert(alignof(UBeanbagDamageType) == 0x000010, "Wrong alignment on UBeanbagDamageType");
static_assert(sizeof(UBeanbagDamageType) == 0x000620, "Wrong size on UBeanbagDamageType");

// Class ReadyOrNot.BleedComponent
// 0x0020 (0x00D0 - 0x00B0)
class UBleedComponent final  : public UActorComponent
{
public:
	class UFMODEvent*                             BleedEvent;                                        // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBleeding;                                       // 0x00B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238D[0x7];                                     // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTempStopBleeding;                                 // 0x00C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238E[0x3];                                     // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HealCount;                                         // 0x00C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238F[0x8];                                     // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoHeal();
	void StartBleeding();
	void StopBleeding();

	bool CanHeal() const;
	float GetBleedTime() const;
	float GetHealCount() const;
	bool IsBleeding() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BleedComponent">();
	}
	static class UBleedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBleedComponent>();
	}
};
static_assert(alignof(UBleedComponent) == 0x000008, "Wrong alignment on UBleedComponent");
static_assert(sizeof(UBleedComponent) == 0x0000D0, "Wrong size on UBleedComponent");
static_assert(offsetof(UBleedComponent, BleedEvent) == 0x0000B0, "Member 'UBleedComponent::BleedEvent' has a wrong offset!");
static_assert(offsetof(UBleedComponent, bIsBleeding) == 0x0000B8, "Member 'UBleedComponent::bIsBleeding' has a wrong offset!");
static_assert(offsetof(UBleedComponent, bTempStopBleeding) == 0x0000C0, "Member 'UBleedComponent::bTempStopBleeding' has a wrong offset!");
static_assert(offsetof(UBleedComponent, HealCount) == 0x0000C4, "Member 'UBleedComponent::HealCount' has a wrong offset!");

// Class ReadyOrNot.CustomizationCharacter
// 0x00A8 (0x0218 - 0x0170)
class UCustomizationCharacter final  : public UCustomizationDataBase
{
public:
	TSoftObjectPtr<class USkeletalMesh>           HeadMesh;                                          // 0x0170(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      ArmsMaterial;                                      // 0x0198(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPoseAsset>              FaceROM;                                           // 0x01C0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HairMaterialIndex;                                 // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2390[0x4];                                     // 0x01EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              ProfileImage;                                      // 0x01F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationCharacter">();
	}
	static class UCustomizationCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationCharacter>();
	}
};
static_assert(alignof(UCustomizationCharacter) == 0x000008, "Wrong alignment on UCustomizationCharacter");
static_assert(sizeof(UCustomizationCharacter) == 0x000218, "Wrong size on UCustomizationCharacter");
static_assert(offsetof(UCustomizationCharacter, HeadMesh) == 0x000170, "Member 'UCustomizationCharacter::HeadMesh' has a wrong offset!");
static_assert(offsetof(UCustomizationCharacter, ArmsMaterial) == 0x000198, "Member 'UCustomizationCharacter::ArmsMaterial' has a wrong offset!");
static_assert(offsetof(UCustomizationCharacter, FaceROM) == 0x0001C0, "Member 'UCustomizationCharacter::FaceROM' has a wrong offset!");
static_assert(offsetof(UCustomizationCharacter, HairMaterialIndex) == 0x0001E8, "Member 'UCustomizationCharacter::HairMaterialIndex' has a wrong offset!");
static_assert(offsetof(UCustomizationCharacter, ProfileImage) == 0x0001F0, "Member 'UCustomizationCharacter::ProfileImage' has a wrong offset!");

// Class ReadyOrNot.BleedDamageType
// 0x0000 (0x0040 - 0x0040)
class UBleedDamageType final  : public UDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BleedDamageType">();
	}
	static class UBleedDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBleedDamageType>();
	}
};
static_assert(alignof(UBleedDamageType) == 0x000008, "Wrong alignment on UBleedDamageType");
static_assert(sizeof(UBleedDamageType) == 0x000040, "Wrong size on UBleedDamageType");

// Class ReadyOrNot.BlendRagdollAnimNotifyState
// 0x0040 (0x0070 - 0x0030)
class UBlendRagdollAnimNotifyState final  : public UAnimNotifyState
{
public:
	float                                         TotalBlendDuration;                                // 0x0030(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentBlendAmount;                                // 0x0034(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisWakeUpTime;                                  // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2391[0x1];                                     // 0x003C(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUsePhysicalAnimComp;                              // 0x003D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2392[0x2];                                     // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPhysicalAnimationData                 PhysicalAnimData;                                  // 0x0040(0x0024)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2393[0xC];                                     // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlendRagdollAnimNotifyState">();
	}
	static class UBlendRagdollAnimNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlendRagdollAnimNotifyState>();
	}
};
static_assert(alignof(UBlendRagdollAnimNotifyState) == 0x000008, "Wrong alignment on UBlendRagdollAnimNotifyState");
static_assert(sizeof(UBlendRagdollAnimNotifyState) == 0x000070, "Wrong size on UBlendRagdollAnimNotifyState");
static_assert(offsetof(UBlendRagdollAnimNotifyState, TotalBlendDuration) == 0x000030, "Member 'UBlendRagdollAnimNotifyState::TotalBlendDuration' has a wrong offset!");
static_assert(offsetof(UBlendRagdollAnimNotifyState, CurrentBlendAmount) == 0x000034, "Member 'UBlendRagdollAnimNotifyState::CurrentBlendAmount' has a wrong offset!");
static_assert(offsetof(UBlendRagdollAnimNotifyState, PelvisWakeUpTime) == 0x000038, "Member 'UBlendRagdollAnimNotifyState::PelvisWakeUpTime' has a wrong offset!");
static_assert(offsetof(UBlendRagdollAnimNotifyState, bUsePhysicalAnimComp) == 0x00003D, "Member 'UBlendRagdollAnimNotifyState::bUsePhysicalAnimComp' has a wrong offset!");
static_assert(offsetof(UBlendRagdollAnimNotifyState, PhysicalAnimData) == 0x000040, "Member 'UBlendRagdollAnimNotifyState::PhysicalAnimData' has a wrong offset!");

// Class ReadyOrNot.CustomPhysicalMaterial
// 0x0008 (0x0088 - 0x0080)
class UCustomPhysicalMaterial final  : public UPhysicalMaterial
{
public:
	float                                         FullOcclusionDepth;                                // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2394[0x4];                                     // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomPhysicalMaterial">();
	}
	static class UCustomPhysicalMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomPhysicalMaterial>();
	}
};
static_assert(alignof(UCustomPhysicalMaterial) == 0x000008, "Wrong alignment on UCustomPhysicalMaterial");
static_assert(sizeof(UCustomPhysicalMaterial) == 0x000088, "Wrong size on UCustomPhysicalMaterial");
static_assert(offsetof(UCustomPhysicalMaterial, FullOcclusionDepth) == 0x000080, "Member 'UCustomPhysicalMaterial::FullOcclusionDepth' has a wrong offset!");

// Class ReadyOrNot.BloodData
// 0x0240 (0x0270 - 0x0030)
class UBloodData final  : public UDataAsset
{
public:
	uint8                                         Pad_2395[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             Splatters;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         SplatterMaxTraceDistance;                          // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SplatterSizeRange;                                 // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2396[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             AnimatedSplatters;                                 // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AAnimatedDecal>             AnimatedDecalClass;                                // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AnimatedSplatterBones;                             // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AnimatedSplatterMaxDistance;                       // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AnimatedSplatterSizeRange;                         // 0x0084(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimatedBloodTimescale;                            // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     AnimatedBloodCurve;                                // 0x0090(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             HeadshotSplatters;                                 // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UStaticMesh*                            HeadshotDecalMesh;                                 // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           HeadshotSplatterBones;                             // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         HeadshotMaxSplatterDistance;                       // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HeadshotSplatterSizeRange;                         // 0x0144(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2397[0x4];                                     // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UParticleSystem*>                HitEntryParticles;                                 // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        SkinnedDecalImageCount;                            // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SkinnedDecalSizeRange;                             // 0x0164(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2398[0x4];                                     // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArteryData>                    Arteries;                                          // 0x0170(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UParticleSystem*>                ArteryParticles;                                   // 0x0180(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             ArteryParticleCollisionDecals;                     // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ArteryParticleCollisionChance;                     // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ArteryParticleCollisionSizeRange;                  // 0x01A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2399[0x4];                                     // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UParticleSystem*>                DismembermentParticles;                            // 0x01B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             DismembermentParticleCollisionDecals;              // 0x01C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DismembermentParticleCollisionChance;              // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DismembermentParticleCollisionSizeRange;           // 0x01D4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239A[0x4];                                     // 0x01DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGibData                               GibData;                                           // 0x01E0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ABloodPool>                 BloodPoolClass;                                    // 0x0210(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloodPoolSpawnDelay;                               // 0x0218(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BloodPoolSpawnBone;                                // 0x021C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239B[0x4];                                     // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstance*>              BigSplatterDecals;                                 // 0x0228(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AExplosionGibs>             Gibs;                                              // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BigSplatterTraceDistance;                          // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BigSplatterDecalSize;                              // 0x0244(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             HitEvent;                                          // 0x0250(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DeadHitEvent;                                      // 0x0258(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             GoreEvent;                                         // 0x0260(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             HeadshotEvent;                                     // 0x0268(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodData">();
	}
	static class UBloodData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodData>();
	}
};
static_assert(alignof(UBloodData) == 0x000008, "Wrong alignment on UBloodData");
static_assert(sizeof(UBloodData) == 0x000270, "Wrong size on UBloodData");
static_assert(offsetof(UBloodData, Splatters) == 0x000038, "Member 'UBloodData::Splatters' has a wrong offset!");
static_assert(offsetof(UBloodData, SplatterMaxTraceDistance) == 0x000048, "Member 'UBloodData::SplatterMaxTraceDistance' has a wrong offset!");
static_assert(offsetof(UBloodData, SplatterSizeRange) == 0x00004C, "Member 'UBloodData::SplatterSizeRange' has a wrong offset!");
static_assert(offsetof(UBloodData, AnimatedSplatters) == 0x000058, "Member 'UBloodData::AnimatedSplatters' has a wrong offset!");
static_assert(offsetof(UBloodData, AnimatedDecalClass) == 0x000068, "Member 'UBloodData::AnimatedDecalClass' has a wrong offset!");
static_assert(offsetof(UBloodData, AnimatedSplatterBones) == 0x000070, "Member 'UBloodData::AnimatedSplatterBones' has a wrong offset!");
static_assert(offsetof(UBloodData, AnimatedSplatterMaxDistance) == 0x000080, "Member 'UBloodData::AnimatedSplatterMaxDistance' has a wrong offset!");
static_assert(offsetof(UBloodData, AnimatedSplatterSizeRange) == 0x000084, "Member 'UBloodData::AnimatedSplatterSizeRange' has a wrong offset!");
static_assert(offsetof(UBloodData, AnimatedBloodTimescale) == 0x00008C, "Member 'UBloodData::AnimatedBloodTimescale' has a wrong offset!");
static_assert(offsetof(UBloodData, AnimatedBloodCurve) == 0x000090, "Member 'UBloodData::AnimatedBloodCurve' has a wrong offset!");
static_assert(offsetof(UBloodData, HeadshotSplatters) == 0x000118, "Member 'UBloodData::HeadshotSplatters' has a wrong offset!");
static_assert(offsetof(UBloodData, HeadshotDecalMesh) == 0x000128, "Member 'UBloodData::HeadshotDecalMesh' has a wrong offset!");
static_assert(offsetof(UBloodData, HeadshotSplatterBones) == 0x000130, "Member 'UBloodData::HeadshotSplatterBones' has a wrong offset!");
static_assert(offsetof(UBloodData, HeadshotMaxSplatterDistance) == 0x000140, "Member 'UBloodData::HeadshotMaxSplatterDistance' has a wrong offset!");
static_assert(offsetof(UBloodData, HeadshotSplatterSizeRange) == 0x000144, "Member 'UBloodData::HeadshotSplatterSizeRange' has a wrong offset!");
static_assert(offsetof(UBloodData, HitEntryParticles) == 0x000150, "Member 'UBloodData::HitEntryParticles' has a wrong offset!");
static_assert(offsetof(UBloodData, SkinnedDecalImageCount) == 0x000160, "Member 'UBloodData::SkinnedDecalImageCount' has a wrong offset!");
static_assert(offsetof(UBloodData, SkinnedDecalSizeRange) == 0x000164, "Member 'UBloodData::SkinnedDecalSizeRange' has a wrong offset!");
static_assert(offsetof(UBloodData, Arteries) == 0x000170, "Member 'UBloodData::Arteries' has a wrong offset!");
static_assert(offsetof(UBloodData, ArteryParticles) == 0x000180, "Member 'UBloodData::ArteryParticles' has a wrong offset!");
static_assert(offsetof(UBloodData, ArteryParticleCollisionDecals) == 0x000190, "Member 'UBloodData::ArteryParticleCollisionDecals' has a wrong offset!");
static_assert(offsetof(UBloodData, ArteryParticleCollisionChance) == 0x0001A0, "Member 'UBloodData::ArteryParticleCollisionChance' has a wrong offset!");
static_assert(offsetof(UBloodData, ArteryParticleCollisionSizeRange) == 0x0001A4, "Member 'UBloodData::ArteryParticleCollisionSizeRange' has a wrong offset!");
static_assert(offsetof(UBloodData, DismembermentParticles) == 0x0001B0, "Member 'UBloodData::DismembermentParticles' has a wrong offset!");
static_assert(offsetof(UBloodData, DismembermentParticleCollisionDecals) == 0x0001C0, "Member 'UBloodData::DismembermentParticleCollisionDecals' has a wrong offset!");
static_assert(offsetof(UBloodData, DismembermentParticleCollisionChance) == 0x0001D0, "Member 'UBloodData::DismembermentParticleCollisionChance' has a wrong offset!");
static_assert(offsetof(UBloodData, DismembermentParticleCollisionSizeRange) == 0x0001D4, "Member 'UBloodData::DismembermentParticleCollisionSizeRange' has a wrong offset!");
static_assert(offsetof(UBloodData, GibData) == 0x0001E0, "Member 'UBloodData::GibData' has a wrong offset!");
static_assert(offsetof(UBloodData, BloodPoolClass) == 0x000210, "Member 'UBloodData::BloodPoolClass' has a wrong offset!");
static_assert(offsetof(UBloodData, BloodPoolSpawnDelay) == 0x000218, "Member 'UBloodData::BloodPoolSpawnDelay' has a wrong offset!");
static_assert(offsetof(UBloodData, BloodPoolSpawnBone) == 0x00021C, "Member 'UBloodData::BloodPoolSpawnBone' has a wrong offset!");
static_assert(offsetof(UBloodData, BigSplatterDecals) == 0x000228, "Member 'UBloodData::BigSplatterDecals' has a wrong offset!");
static_assert(offsetof(UBloodData, Gibs) == 0x000238, "Member 'UBloodData::Gibs' has a wrong offset!");
static_assert(offsetof(UBloodData, BigSplatterTraceDistance) == 0x000240, "Member 'UBloodData::BigSplatterTraceDistance' has a wrong offset!");
static_assert(offsetof(UBloodData, BigSplatterDecalSize) == 0x000244, "Member 'UBloodData::BigSplatterDecalSize' has a wrong offset!");
static_assert(offsetof(UBloodData, HitEvent) == 0x000250, "Member 'UBloodData::HitEvent' has a wrong offset!");
static_assert(offsetof(UBloodData, DeadHitEvent) == 0x000258, "Member 'UBloodData::DeadHitEvent' has a wrong offset!");
static_assert(offsetof(UBloodData, GoreEvent) == 0x000260, "Member 'UBloodData::GoreEvent' has a wrong offset!");
static_assert(offsetof(UBloodData, HeadshotEvent) == 0x000268, "Member 'UBloodData::HeadshotEvent' has a wrong offset!");

// Class ReadyOrNot.BloodPool
// 0x0008 (0x0228 - 0x0220)
class ABloodPool : public AActor
{
public:
	class UDecalComponent*                        Decal;                                             // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodPool">();
	}
	static class ABloodPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABloodPool>();
	}
};
static_assert(alignof(ABloodPool) == 0x000008, "Wrong alignment on ABloodPool");
static_assert(sizeof(ABloodPool) == 0x000228, "Wrong size on ABloodPool");
static_assert(offsetof(ABloodPool, Decal) == 0x000220, "Member 'ABloodPool::Decal' has a wrong offset!");

// Class ReadyOrNot.LoadoutItem
// 0x0058 (0x0080 - 0x0028)
class ULoadoutItem : public UObject
{
public:
	class FText                                   Name_LoadoutItem;                                  // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0058(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutItem">();
	}
	static class ULoadoutItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutItem>();
	}
};
static_assert(alignof(ULoadoutItem) == 0x000008, "Wrong alignment on ULoadoutItem");
static_assert(sizeof(ULoadoutItem) == 0x000080, "Wrong size on ULoadoutItem");
static_assert(offsetof(ULoadoutItem, Name_LoadoutItem) == 0x000028, "Member 'ULoadoutItem::Name_LoadoutItem' has a wrong offset!");
static_assert(offsetof(ULoadoutItem, Description) == 0x000040, "Member 'ULoadoutItem::Description' has a wrong offset!");
static_assert(offsetof(ULoadoutItem, Icon) == 0x000058, "Member 'ULoadoutItem::Icon' has a wrong offset!");

// Class ReadyOrNot.LoadoutEquipment
// 0x0008 (0x0088 - 0x0080)
class ULoadoutEquipment : public ULoadoutItem
{
public:
	TSubclassOf<class ABaseItem>                  Class_LoadoutEquipment;                            // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutEquipment">();
	}
	static class ULoadoutEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutEquipment>();
	}
};
static_assert(alignof(ULoadoutEquipment) == 0x000008, "Wrong alignment on ULoadoutEquipment");
static_assert(sizeof(ULoadoutEquipment) == 0x000088, "Wrong size on ULoadoutEquipment");
static_assert(offsetof(ULoadoutEquipment, Class_LoadoutEquipment) == 0x000080, "Member 'ULoadoutEquipment::Class_LoadoutEquipment' has a wrong offset!");

// Class ReadyOrNot.BombActor
// 0x0070 (0x0290 - 0x0220)
class ABombActor final  : public AActor
{
public:
	uint8                                         Pad_239C[0x10];                                    // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnBombDefused;                                     // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 InteractableComponent;                             // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ExplosionParticleComponent;                        // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultitoolUseTime;                                  // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionRadius;                                   // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBombState                                    BombState;                                         // 0x0260(0x0001)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239D[0x3];                                     // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeUntilExplodes;                                 // 0x0264(0x0004)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPVPBombOnly;                                      // 0x0268(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239E[0x7];                                     // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             BombTickEvent;                                     // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BombExplodeEvent;                                  // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239F[0x8];                                     // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundSource*                           BombSoundSource;                                   // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Explode();
	EBombState GetBombState();
	float GetTimeUntilExplodes();
	void Multicast_PlayBombExplodeSFX();
	void OnBombDefusedSignature__DelegateSignature(class ABombActor* DefusedBomb);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BombActor">();
	}
	static class ABombActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABombActor>();
	}
};
static_assert(alignof(ABombActor) == 0x000008, "Wrong alignment on ABombActor");
static_assert(sizeof(ABombActor) == 0x000290, "Wrong size on ABombActor");
static_assert(offsetof(ABombActor, OnBombDefused) == 0x000230, "Member 'ABombActor::OnBombDefused' has a wrong offset!");
static_assert(offsetof(ABombActor, StaticMeshComponent) == 0x000240, "Member 'ABombActor::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ABombActor, InteractableComponent) == 0x000248, "Member 'ABombActor::InteractableComponent' has a wrong offset!");
static_assert(offsetof(ABombActor, ExplosionParticleComponent) == 0x000250, "Member 'ABombActor::ExplosionParticleComponent' has a wrong offset!");
static_assert(offsetof(ABombActor, MultitoolUseTime) == 0x000258, "Member 'ABombActor::MultitoolUseTime' has a wrong offset!");
static_assert(offsetof(ABombActor, ExplosionRadius) == 0x00025C, "Member 'ABombActor::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(ABombActor, BombState) == 0x000260, "Member 'ABombActor::BombState' has a wrong offset!");
static_assert(offsetof(ABombActor, TimeUntilExplodes) == 0x000264, "Member 'ABombActor::TimeUntilExplodes' has a wrong offset!");
static_assert(offsetof(ABombActor, bPVPBombOnly) == 0x000268, "Member 'ABombActor::bPVPBombOnly' has a wrong offset!");
static_assert(offsetof(ABombActor, BombTickEvent) == 0x000270, "Member 'ABombActor::BombTickEvent' has a wrong offset!");
static_assert(offsetof(ABombActor, BombExplodeEvent) == 0x000278, "Member 'ABombActor::BombExplodeEvent' has a wrong offset!");
static_assert(offsetof(ABombActor, BombSoundSource) == 0x000288, "Member 'ABombActor::BombSoundSource' has a wrong offset!");

// Class ReadyOrNot.ScoringComponent
// 0x00A0 (0x0150 - 0x00B0)
class UScoringComponent final  : public UActorComponent
{
public:
	uint8                                         bEnabled : 1;                                      // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_23A0[0x7];                                     // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScoreData                             ScoringData;                                       // 0x00B8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    ScoreGroup;                                        // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   ScoreGroupName;                                    // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectiveLevel                               ObjectiveLevel;                                    // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAutoAddToScorePool : 1;                           // 0x0101(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bShowPopupOnTakeAllScoresWithNoChange;             // 0x0102(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A1[0x45];                                    // 0x0103(0x0045)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ScoreGroupDataTable;                               // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	int32 GetScore(class FText& ScoreName) const;
	int32 GetTotalScore(bool bOnlyEnabled, bool bOnlyGiven) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScoringComponent">();
	}
	static class UScoringComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScoringComponent>();
	}
};
static_assert(alignof(UScoringComponent) == 0x000008, "Wrong alignment on UScoringComponent");
static_assert(sizeof(UScoringComponent) == 0x000150, "Wrong size on UScoringComponent");
static_assert(offsetof(UScoringComponent, ScoringData) == 0x0000B8, "Member 'UScoringComponent::ScoringData' has a wrong offset!");
static_assert(offsetof(UScoringComponent, ScoreGroup) == 0x0000E8, "Member 'UScoringComponent::ScoreGroup' has a wrong offset!");
static_assert(offsetof(UScoringComponent, ScoreGroupName) == 0x0000F8, "Member 'UScoringComponent::ScoreGroupName' has a wrong offset!");
static_assert(offsetof(UScoringComponent, ObjectiveLevel) == 0x000100, "Member 'UScoringComponent::ObjectiveLevel' has a wrong offset!");
static_assert(offsetof(UScoringComponent, bShowPopupOnTakeAllScoresWithNoChange) == 0x000102, "Member 'UScoringComponent::bShowPopupOnTakeAllScoresWithNoChange' has a wrong offset!");
static_assert(offsetof(UScoringComponent, ScoreGroupDataTable) == 0x000148, "Member 'UScoringComponent::ScoreGroupDataTable' has a wrong offset!");

// Class ReadyOrNot.TestInputBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTestInputBlueprintFunctionLibrary final  : public UBlueprintFunctionLibrary
{
public:
	static void RonApplyInputAction(class UObject* Context, class FName& ActionName, EInputEvent InputEventType);
	static void RonApplyInputAxis(class UObject* Context, class FName& AxisName, float AxisValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestInputBlueprintFunctionLibrary">();
	}
	static class UTestInputBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestInputBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UTestInputBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UTestInputBlueprintFunctionLibrary");
static_assert(sizeof(UTestInputBlueprintFunctionLibrary) == 0x000028, "Wrong size on UTestInputBlueprintFunctionLibrary");

// Class ReadyOrNot.CustomizationBlueprint
// 0x0038 (0x01A8 - 0x0170)
class UCustomizationBlueprint final  : public UCustomizationDataBase
{
public:
	TSoftClassPtr<class UClass>                   BlueprintClass;                                    // 0x0170(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickInThirdPerson;                                // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A6[0x3];                                     // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Socket;                                            // 0x019C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A7[0x4];                                     // 0x01A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationBlueprint">();
	}
	static class UCustomizationBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationBlueprint>();
	}
};
static_assert(alignof(UCustomizationBlueprint) == 0x000008, "Wrong alignment on UCustomizationBlueprint");
static_assert(sizeof(UCustomizationBlueprint) == 0x0001A8, "Wrong size on UCustomizationBlueprint");
static_assert(offsetof(UCustomizationBlueprint, BlueprintClass) == 0x000170, "Member 'UCustomizationBlueprint::BlueprintClass' has a wrong offset!");
static_assert(offsetof(UCustomizationBlueprint, bTickInThirdPerson) == 0x000198, "Member 'UCustomizationBlueprint::bTickInThirdPerson' has a wrong offset!");
static_assert(offsetof(UCustomizationBlueprint, Socket) == 0x00019C, "Member 'UCustomizationBlueprint::Socket' has a wrong offset!");

// Class ReadyOrNot.BpGameplayHelperLib
// 0x0000 (0x0028 - 0x0028)
class UBpGameplayHelperLib final  : public UBlueprintFunctionLibrary
{
public:
	static void AddDefaultItemsToPlayer(class AReadyOrNotCharacter* Player);
	static void AttachMagazinesToWeapon(TSubclassOf<class ABaseMagazineWeapon> WeaponClass, class ABaseMagazineWeapon* Weapon);
	static struct FPointDamageEvent CastToPointDamageEvent(const struct FDamageEvent& DamageEvent, EStructureCastPathway* Branches);
	static struct FRadialDamageEvent CastToRadialDamageEvent(const struct FDamageEvent& DamageEvent, EStructureCastPathway* Branches);
	static void ChangeLocalization(const class FString& Target);
	static class FString ConvertDegreeIntoLetter(float Degrees);
	static class FString ConvertFloatToStringMinutes(float Val);
	static class FString ConvertFloatToStringMinutes_Detail(float Val);
	static EWeaponType ConvertItemTypeToWeaponType(EItemType ItemType);
	static struct FVector2D ConvertSquareVectorToCircle(const struct FVector2D& SquareVector);
	static EItemType ConvertWeaponTypeToItemType(EWeaponType WeaponType);
	static void DeleteLoadout(const class FString& LoadoutName);
	static void DisableInteractionCompForController(class UInteractableComponent* InteractableComponent, class APlayerController* InPlayerController);
	static void DisableInteractionFor(class AActor* InInteractableActor, class APlayerCharacter* InPlayerCharacter);
	static void DisableInteractionForController(class AActor* InInteractableActor, class APlayerController* InPlayerCharacter);
	static void EnableInteractionCompForController(class UInteractableComponent* InteractableComponent, class APlayerController* InPlayerController);
	static void EnableInteractionFor(class AActor* InInteractableActor, class APlayerCharacter* InPlayerCharacter);
	static void EnableInteractionForController(class AActor* InInteractableActor, class APlayerController* InPlayerCharacter);
	static bool EquipLoadoutOnPlayer(const struct FSavedLoadout& Loadout, class AReadyOrNotCharacter* EquipPlayer, const struct FLoadoutEquipOptions& LoadoutEquipOptions);
	static class APlayerCharacter* FindClosestDeadGuyInRadius(const struct FVector& Origin, class AActor* Causer, float Radius, bool bIncludeUnconscious);
	static class FString GetAdditionalBugReportInformation(class APlayerController* PC);
	static class UDataTable* GetAILookupDataTable();
	static class UDataTable* GetAmmoLookupDataTable();
	static struct FAnimatedIcon GetAnimatedIconFromTable(class FName RowName, bool* bSuccess);
	static class UDataTable* GetAnimatedIconLookupDataTable();
	static int32 GetAttachmentPointsRemaining(const struct FSavedLoadout& Loadout);
	static bool GetBounceLightEnabled(bool* bBounceLightEnabled);
	static class FString GetBuildDate();
	static class FString GetBuildTime();
	static class UCampaignData* GetCampaignData();
	static class UDataTable* GetCharacterLookOverrideDataTable();
	static class ACivilianCharacter* GetClosestActiveCivilian(struct FVector& Location, float Distance, bool bMustHaveTarget);
	static class ASuspectCharacter* GetClosestActiveSuspect(struct FVector& Location, float Distance, bool bMustHaveTarget);
	static class UDataTable* GetConversationLookupDataTable();
	static ECOOPMode GetCoopModeFromModeName(const class FString& InCoopName);
	static class UReadyOrNotProfile* GetCurrentProfile(class UWorld* WorldContext);
	static float GetDistanceBetweenActors(class AActor* Actor1, class AActor* Actor2);
	static float GetDistanceBetweenActors2D(class AActor* Actor1, class AActor* Actor2);
	static class FString GetDMOAddress();
	static class FString GetDMOGameMode();
	static ETeamType GetDMOTeamType();
	static class UDataTable* GetDoorLookupDataTable();
	static class APlayerCharacter* GetFirstAlivePlayerControlledCharacter(class UWorld* WorldContext);
	static class UUserWidget* GetFirstWidgetFromViewport(const class FString& WidgetName);
	static bool GetFlashlightShadows(bool* bFlashLightShadows);
	static bool GetFoV(float* FOV);
	static bool GetFreelookSensitivity(float* Sensitivity);
	static void GetFriendlyMapAndModeFromName(const class FString& InUrl, class FString* OutInternalMapName, class FString* OutFriendlyMap, class FString* OutFriendlyMode);
	static class FString GetFriendlyModeFromECoopMode(ECOOPMode InCoopMode);
	static class UReadyOrNotGameInstance* GetGameInstance(class UWorld* WorldContext);
	static class UDataTable* GetGameModeSettingsLookupDataTable();
	static bool GetGamepadAimSensitivity(float* GamepadAimSensitivity);
	static bool GetGamepadInverted(bool* bInvertVertical, bool* bInvertHorizontal);
	static bool GetGamepadLookSensitivity(float* GamepadLookSensitivity);
	static bool GetHitmarkerSfxEnabled(bool* bHitmarkerSfxEnabled);
	static class UHumanCharacterHUD_V2* GetHUDWidget();
	static class UDataTable* GetInputKeyGamepadIconLookupDataTable();
	static class UItemData* GetItemData(class UWorld* WorldContext);
	static bool GetLastConnectedServerIP(class FString* IP);
	static struct FLevelDataLookupTable GetLevelData(class UWorld* WorldContext);
	static class UDataTable* GetLevelLookupDataTable();
	static TArray<struct FLevelDataLookupTable> GetLevels();
	static class UReadyOrNotSaveGame* GetLoadGameInstance(const class FString& LoadSlotName);
	static class UTexture2D* GetLoadingScreenLevelImage(const class FString& Level);
	static bool GetLoadoutNames(TArray<class FString>* LoadoutNames);
	static class FString GetLoadURLFromData(const struct FLevelDataLookupTable& LookUp);
	static bool GetLocalization(class FString* Target);
	static class AReadyOrNotPlayerState* GetLocalPlayerState(class UWorld* World);
	static class ULookupData* GetLookupData();
	static struct FLevelDataLookupTable GetMapDetailsFromName(const class FString& MapName);
	static class AMapStatisticsSystem* GetMapStatistics(class UWorld* WorldContext);
	static bool GetMicInputGain(float* MicInputGain);
	static bool GetMouseInverted(bool* bInvertVertical, bool* bInvertHorizontal);
	static bool GetMouseSensitivity(float* MouseSensitvity);
	static class UDataTable* GetMoveStyleDataTable();
	static class UReadyOrNotMultiplayerProfile* GetMultiplayerProfile(const class FString& LoadSlotName);
	static class UMusicData* GetMusicData(class UWorld* WorldContext);
	static class UDataTable* GetPairedInteractionDataTable();
	static class UPenetrationData* GetPenetrationData();
	static class FString GetProjectName();
	static class FString GetProjectVersion();
	static int32 GetProjectVersionAsInt();
	static bool GetRandomLoadingScreenTip(class FText* Tip);
	static class UDataSingleton* GetRoNData();
	static class UReadyOrNotGameInstance* GetRONGameInstance();
	static bool GetSendMapStatistics(bool* bSendMapStatistics);
	static bool GetShellLifetime(float* ShellLifeTime);
	static bool GetShowControls(bool* bShowControls);
	static bool GetShowFPS(bool* bShowFPS);
	static class UDataTable* GetSpeechLookupDataTable(const class FString& Speaker);
	static class UDataTable* GetSuspectArmourDataTable();
	static class UDataTable* GetTrapLookupDataTable();
	static bool GetUseMeshpainting(bool* bUseMeshPainting);
	static bool GetVoiceType(EVoiceType* OutVoiceType);
	static bool GetVolumes(float* MasterVolume, float* UIVolume, float* SFXVolume, float* MusicVolume, float* VOIPVolume);
	static class UWidgetsData* GetWidgetData();
	static struct FWidgetLookupData GetWidgetDataFromLookupData(const class FString& WidgetName, bool bWarnIfMissing);
	static TArray<class UUserWidget*> GetWidgetsFromViewport(const class FString& WidgetName);
	static class UWorld* GetWorldBP(class APlayerController* PC);
	static class UWorld* GetWorldStatic();
	static bool HasLineOfSight(class AActor* Observer, class AActor* B);
	static bool HasLineOfSightExt(class AActor* Observer, class AActor* B, struct FHitResult* HitResult);
	static bool HasLineOfSightLoc(class UWorld* WorldContext, const struct FVector& A, const struct FVector& B, const TArray<class AActor*>& IgnoredActors, ECollisionChannel CollisionChannel);
	static bool HasWidgetInViewport(const class FString& WidgetName);
	static bool IsCommanderMode(class UObject* WorldContextObject);
	static bool IsConsole(class UObject* WorldContextObject);
	static bool IsCOOPSupported(const struct FLevelDataLookupTable& LookupTable);
	static bool IsDLCLocked(TSubclassOf<class ABaseItem> Item);
	static bool IsDMOBuild();
	static bool IsDMOMatchMake();
	static bool IsDMOPVPOnly();
	static bool IsEditorBuild();
	static bool IsEnemy(ETeamType TeamOne, ETeamType TeamTwo);
	static bool IsFriendly(class AReadyOrNotGameState* GameState, ETeamType TeamOne, ETeamType TeamTwo);
	static bool IsFriendlyWithMe(class AReadyOrNotGameState* GameState, ETeamType TeamType);
	static bool IsInPublicLobbyCooldown(float* SecondsRemaining);
	static bool IsIronmanMode(class UObject* WorldContextObject);
	static bool IsLeadPlayer(class UObject* WorldContextObject);
	static bool IsLobby(class UObject* WorldContextObject);
	static bool IsMultiplayer(class UObject* WorldContextObject);
	static bool IsObjectiveTarget(class AReadyOrNotCharacter* Target, class AReadyOrNotCharacter* LocalPlayer);
	static bool IsPreMissionBriefingBeforeLoadout();
	static bool IsPvPSupported(const struct FLevelDataLookupTable& LookupTable);
	static bool IsRTXDMOBuild();
	static bool IsShippingBuild();
	static bool IsShowHUDEnabled();
	static bool IsSupporterOnlyBuild();
	static bool IsWidgetOfClassInViewport(class UObject* WorldContextObject, TSubclassOf<class UUserWidget> WidgetClass);
	static bool Load2DReload(bool* b2DReload);
	static bool LoadColorblindMode(EColorVisionDeficiency* ColorVisionDeficiency);
	static bool LoadColorblindStrength(float* ColorblindStrength);
	static bool LoadControlScheme(bool* UsingAlternateControls);
	static bool LoadCurvedHUD(bool* bCurvedHUD);
	static void LoadCustomizationLevels(class UWorld* WorldContext);
	static bool LoadDefaultCommands(ESwatCommand* DefaultCommand, ESwatCommand* DefaultDoorUnknownCommand, ESwatCommand* DefaultDoorOpenCommand, ESwatCommand* DefaultDoorLockedCommand, ESwatCommand* DefaultDoorUnlockedCommand);
	static bool LoadDefaultCommandsAsOption(int32* DefaultCommandOption, int32* DefaultDoorUnknownCommandOption, int32* DefaultDoorOpenCommandOption, int32* DefaultDoorLockedCommandOption, int32* DefaultDoorUnlockedCommandOption);
	static bool LoadDefaultDoorLockedCommand(ESwatCommand* DefaultDoorLockedCommand, int32* DefaultDoorLockedCommandIndex);
	static bool LoadDefaultDoorOpenCommand(ESwatCommand* DefaultDoorOpenCommand, int32* DefaultDoorOpenCommandIndex);
	static bool LoadDefaultDoorUnknownCommand(ESwatCommand* DefaultDoorUnknownCommand, int32* DefaultDoorUnknownCommandIndex);
	static bool LoadDefaultDoorUnlockedCommand(ESwatCommand* DefaultDoorUnlockedCommand, int32* DefaultDoorUnlockedCommandIndex);
	static void LoadDefaultLoadout(struct FSavedLoadout* OutLoadout, const class FString& LoadoutName);
	static bool LoadDefaultSurfaceCommand(ESwatCommand* DefaultCommand, int32* DefaultCommandIndex);
	static bool LoadEmptyMagReloadSettings(EEmptyMagReloadType* EmptyMagReloadType);
	static bool LoadFireModeDisplayOption(int32* FireModeDisplayOption);
	static bool LoadGrenadeSettings(EGrenadeThrowSettingType* GrenadeThrowType);
	static bool LoadHighlightWeapons(bool* bHighlightWeapons);
	static bool LoadHoldCrouch(bool* HoldCrouch);
	static bool LoadHotkeyHintSetting(bool* bShowHotkeyHint);
	static bool LoadHUDSettings(bool* bShowHUD, bool* bCurvedHUD, bool* bShowCompass, bool* bShowWeaponHUD, bool* bShowMagazineHUD, bool* bShowChat, bool* bSwayHUD, bool* b2DReload, float* IconScale, float* QuickThrowScale, int32* FireModeDisplayOption, bool* bShowPlayerNames, bool* bShowButtonPrompts);
	static bool LoadIconScale(float* IconScale);
	static bool LoadItemSelectionStyleSettings(EItemSelectionInterfaceType* ItemSelectionInterface);
	static class ULicenseSave* LoadLicenseSave();
	static bool LoadLoadout(struct FSavedLoadout* Loadout, const class FString& LoadoutName);
	static bool LoadLoadoutAndEquipPlayer(struct FSavedLoadout* Loadout, class AReadyOrNotCharacter* EquipPlayer, const class FString& LoadoutName);
	static bool LoadLowReadyStyle(bool* bUseHighReady);
	static bool LoadMaxShellsInWorld(int32* MaxShells);
	static bool LoadMirrorAntiAliasEnabled(bool* bShowAntiAlias);
	static bool LoadMirrorDecalsEnabled(bool* bShowDecals);
	static bool LoadMirrorDynamicShadowsEnabled(bool* bShowDynamicShadows);
	static bool LoadMirrorEnabledOnlyInLobby(bool* bEnabled);
	static bool LoadMirrorReflectionEnabled(bool* bEnabled);
	static bool LoadMirrorResolutionScale(float* ResolutionScale);
	static bool LoadNVGStyle(ENVGStyle* NVGStyle);
	static bool LoadOptiwandViewMode(EOptiwandViewMode* OptiwandViewMode);
	static bool LoadPiPFPS(bool* bEnabled, float* FPS);
	static bool LoadPiPResolutionScale(float* ResolutionScale);
	static bool LoadQuickThrowScale(float* QuickThrowScale);
	static bool LoadReplayEnabled(bool* bReplayEnabled);
	static bool LoadSafeZoneSettings(float* SafeZoneX, float* SafeZoneY);
	static bool LoadScoreReadoutSetting(EScoreReadoutMode* OutScoreReadoutMode);
	static bool LoadSelectedAudioDevice(class FString* OutAudioDevice);
	static bool LoadServersideChecksum(bool* bServerSideChecksumEnabled);
	static bool LoadShotgunSettings(EShotgunReloadType* ShotgunReloadType);
	static bool LoadShowButtonPrompts(bool* bShowButtonPrompts);
	static bool LoadShowChat(bool* bShowChat);
	static bool LoadShowCommandContextHintSetting(bool* bShowCommandContextHint);
	static bool LoadShowCompass(bool* bShowCompass);
	static bool LoadShowHealthIconSetting(bool* bShowHealthIcons);
	static bool LoadShowHesitationBarSetting(bool* bShowHesitationBar);
	static bool LoadShowHUD(bool* bShowHUD);
	static bool LoadShowHUDSetting(bool* bShowHUD);
	static bool LoadShowMagazineHUD(bool* bShowMagazineHUD);
	static bool LoadShowMultiplayerNames(bool* bShowMultiplayerNames);
	static bool LoadShowPlayerIconSetting(bool* bShowPlayerIcon);
	static bool LoadShowPlayerNamesSetting(bool* bShowPlayerNames);
	static bool LoadShowTeamStatus(bool* bShowTeamStatus);
	static bool LoadShowWeaponHUD(bool* ShowWeaponHUD);
	static bool LoadSubtitlesBackgroundOpacity(float* SubtitlesBackgroundOpacity);
	static bool LoadSubtitlesEnabled(bool* bEnableSubtitles);
	static bool LoadSubtitlesLocale(class FString* SubtitlesLocale);
	static bool LoadSubtitlesSize(ESubtitlesSize* SubtitlesSize);
	static bool LoadSubtitlesSpeed(float* SubtitlesSpeed);
	static bool LoadSwayHUD(bool* bSwayHUD);
	static bool LoadTeamViewFPSSetting(bool* bEnabled, int32* TeamViewFPS);
	static bool LoadToggleADS(bool* ToggleADS);
	static bool LoadTogglePS5Gyro(bool* TogglePS5Gyro);
	static bool LoadWorldSpaceActionPrompts(bool* bWorldSpaceActionPrompts);
	static bool LoadZoomADSSetting(bool* bZoomADS);
	static void PlayInterfaceSound(class UWorld* WorldContext, EInterfaceSoundType SoundClass);
	static bool ReloadSettings();
	static void RemoveWidgetFromViewport(const class FString& WidgetName);
	static bool Save2DReload(bool b2DReload);
	static bool SaveColorblindMode(EColorVisionDeficiency ColorVisionDeficiency);
	static bool SaveColorblindStrength(float ColorblindStrength);
	static bool SaveControlScheme(bool UsingAlternateControls);
	static bool SaveCurvedHUD(bool bCurvedHUD);
	static bool SaveDefaultCommand(ESwatCommand DefaultCommand, ESwatCommand DefaultDoorUnknownCommand, ESwatCommand DefaultDoorOpenCommand, ESwatCommand DefaultDoorLockedCommand, ESwatCommand DefaultDoorUnlockedCommand);
	static bool SaveDefaultCommandAsOption(int32 DefaultCommandOption, int32 DefaultDoorUnknownCommandOption, int32 DefaultDoorOpenCommandOption, int32 DefaultDoorLockedCommandOption, int32 DefaultDoorUnlockedCommandOption);
	static bool SaveDefaultDoorLockedCommand(ESwatCommand DefaultDoorLockedCommand, int32 DefaultDoorLockedCommandIndex);
	static bool SaveDefaultDoorOpenCommand(ESwatCommand DefaultDoorOpenCommand, int32 DefaultDoorOpenCommandIndex);
	static bool SaveDefaultDoorUnknownCommand(ESwatCommand DefaultDoorUnknownCommand, int32 DefaultDoorUnknownCommandIndex);
	static bool SaveDefaultDoorUnlockedCommand(ESwatCommand DefaultDoorUnlockedCommand, int32 DefaultDoorUnlockedCommandIndex);
	static bool SaveDefaultSurfaceCommand(ESwatCommand DefaultCommand, int32 DefaultCommandIndex);
	static bool SaveEmptyMagReloadSettings(EEmptyMagReloadType EmptyMagReloadType);
	static bool SaveFireModeDisplayOption(int32 FireModeDisplayOption);
	static bool SaveGrenadeSettings(EGrenadeThrowSettingType GrenadeThrowType);
	static bool SaveHighlightWeapons(bool bHighlightWeapons);
	static bool SaveHitmarkerSfxEnabled(bool bHitmarkerSfxEnabled);
	static bool SaveHoldCrouch(bool HoldCrouch);
	static bool SaveHotkeyHintSetting(bool bShowHotkeyHint);
	static bool SaveHUDSettings(bool bShowHUD, bool bCurvedHUD, bool bShowCompass, bool ShowWeaponHUD, bool bShowMagazineHUD, bool bShowChat, bool bSwayHUD, bool b2DReload, float IconScale, float QuickThrowScale, int32 FireModeDisplayOption, bool bShowMultiplayerNames, bool bShowButtonPrompts);
	static bool SaveIconScale(float IconScale);
	static bool SaveItemSelectionStyleSettings(EItemSelectionInterfaceType ItemSelectionInterface);
	static bool SaveKeybinds();
	static void SaveLicenseSave(class ULicenseSave* LevelStats);
	static bool SaveLoadout(const struct FSavedLoadout& Loadout, const class FString& LoadoutName);
	static bool SaveLowReadyStyle(bool bUseHighReady);
	static bool SaveMasterVolume(float Volume);
	static bool SaveMaxShellsInWorld(int32 NewMaxShells);
	static bool SaveMirrorAntiAliasEnabled(bool bShowAntiAlias);
	static bool SaveMirrorDecalsEnabled(bool bShowDecals);
	static bool SaveMirrorDynamicShadowsEnabled(bool bShowDynamicShadows);
	static bool SaveMirrorEnabledOnlyInLobby(bool bEnabled);
	static bool SaveMirrorReflectionEnabled(bool bEnabled);
	static bool SaveMirrorResolutionScale(float ResolutionScale);
	static bool SaveMusicVolume(float Volume);
	static bool SaveNVGStyle(ENVGStyle NewNVGStyle);
	static bool SaveOptiwandViewMode(EOptiwandViewMode OptiwandViewMode);
	static bool SavePiPFPS(bool bEnabled, float FPS);
	static bool SavePiPResolutionScale(float ResolutionScale);
	static bool SaveQuickThrowScale(float QuickThrowScale);
	static bool SaveReplayEnabled(bool bReplayEnabled);
	static bool SaveSafeZoneSettings(float SafeZoneX, float SafeZoneY);
	static bool SaveScoreReadoutSetting(EScoreReadoutMode InScoreReadoutMode);
	static bool SaveSelectedAudioDevice(const class FString& InAudioDevice);
	static bool SaveServersideChecksum(bool bServerSideChecksumEnabled);
	static bool SaveSettings();
	static bool SaveSFXVolume(float Volume);
	static bool SaveShotgunSettings(EShotgunReloadType ShotgunReloadType);
	static bool SaveShowButtonPrompts(bool bShowButtonPrompts);
	static bool SaveShowChat(bool bShowChat);
	static bool SaveShowCommandContextHintSetting(bool bShowCommandContextHint);
	static bool SaveShowCompass(bool bShowCompass);
	static bool SaveShowHealthIconSetting(bool bShowHealthIcons);
	static bool SaveShowHesitationBarSetting(bool bShowHesitationBar);
	static bool SaveShowHUD(bool bShowHUD);
	static bool SaveShowHUDSetting(bool bShowHUD);
	static bool SaveShowMagazineHUD(bool bShowMagazineHUD);
	static bool SaveShowMultiplayerNames(bool bShowMultiplayerNames);
	static bool SaveShowPlayerIconSetting(bool bShowPlayerIcon);
	static bool SaveShowTeamStatus(bool bShowTeamStatus);
	static bool SaveShowWeaponHUD(bool ShowWeaponHUD);
	static bool SaveSubtitlesBackgroundOpacity(float SubtitlesBackgroundOpacity);
	static bool SaveSubtitlesEnabled(bool bEnableSubtitles);
	static bool SaveSubtitlesLocale(const class FString& SubtitlesLocale);
	static bool SaveSubtitlesSize(ESubtitlesSize SubtitlesSize);
	static bool SaveSubtitlesSpeed(float SubtitlesSpeed);
	static bool SaveSwayHUD(bool bSwayHUD);
	static bool SaveTeamViewSetting(bool bEnabled, int32 TeamViewFPS);
	static bool SaveToggleADS(bool ToggleADS);
	static bool SaveTogglePS5Gyro(bool TogglePS5Gyro);
	static bool SaveUIVolume(float Volume);
	static bool SaveVOIPVolume(float Volume);
	static bool SaveWorldSpaceActionPrompts(bool bWorldSpaceActionPrompts);
	static bool SaveZoomADSSetting(bool bZoomADS);
	static bool SetBounceLightEnabled(bool bBounceLightEnabled);
	static bool SetFlashlightShadows(bool bFlashLightShadows);
	static bool SetFoV(float FOV);
	static bool SetFreelookSensitivity(float Sensitivity);
	static bool SetGamepadAimSensitivity(float GamepadAimSensitivity);
	static bool SetGamepadInverted(bool bInvertVertical, bool bInvertHorizontal);
	static bool SetGamepadLookSensitivity(float GamepadLookSensitivity);
	static bool SetLastConnectedServerIP(const class FString& IP);
	static bool SetMicInputGain(float MicInputGain);
	static bool SetMouseInverted(bool bInvertVertical, bool bInvertHorizontal);
	static bool SetMouseSensitivity(float MouseSensitivity);
	static bool SetPublicLobbyCooldown(int32 Seconds);
	static bool SetSendMapStatistics(bool bSendMapStatistics);
	static bool SetShellLifetime(float ShellLifeTime);
	static bool SetShowControls(bool bShowControls);
	static bool SetShowFPS(bool bShowFPS);
	static bool SetUseMeshpainting(bool bUseMeshPainting);
	static void SetVoiceType(EVoiceType InVoiceType);
	static void ToggleFriendlyNameplates();
	static void ToggleGrenadeDrawDebug();
	static void UnloadCustomizationLevels(class UWorld* WorldContext);
	static void UpdateInteractableComponentsWorldSpaceActionPrompts(class UObject* WorldContextObject, bool bEnableWorldSpaceActionPrompts);

	void ShowLoadoutOnMeshes(const struct FSavedLoadout& Loadout, class USkeletalMeshComponent* BodyMesh, class USkeletalMeshComponent* HeadMesh, class USkeletalMeshComponent* ArmorMesh, class USkeletalMeshComponent* ItemMesh, class UStaticMeshComponent* ItemMagMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BpGameplayHelperLib">();
	}
	static class UBpGameplayHelperLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBpGameplayHelperLib>();
	}
};
static_assert(alignof(UBpGameplayHelperLib) == 0x000008, "Wrong alignment on UBpGameplayHelperLib");
static_assert(sizeof(UBpGameplayHelperLib) == 0x000028, "Wrong size on UBpGameplayHelperLib");

// Class ReadyOrNot.ReadyOrNotSaveGame
// 0x0068 (0x0090 - 0x0028)
class UReadyOrNotSaveGame final  : public USaveGame
{
public:
	class FString                                 SaveSlotName;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UserIndex;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2422[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETeamType, TSubclassOf<class USkinComponent>> SkinSaveMap;                                       // 0x0040(0x0050)(BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UReadyOrNotSaveGame* CreateDefaultSavegame(const class FString& LoadSlotName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotSaveGame">();
	}
	static class UReadyOrNotSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotSaveGame>();
	}
};
static_assert(alignof(UReadyOrNotSaveGame) == 0x000008, "Wrong alignment on UReadyOrNotSaveGame");
static_assert(sizeof(UReadyOrNotSaveGame) == 0x000090, "Wrong size on UReadyOrNotSaveGame");
static_assert(offsetof(UReadyOrNotSaveGame, SaveSlotName) == 0x000028, "Member 'UReadyOrNotSaveGame::SaveSlotName' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSaveGame, UserIndex) == 0x000038, "Member 'UReadyOrNotSaveGame::UserIndex' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSaveGame, SkinSaveMap) == 0x000040, "Member 'UReadyOrNotSaveGame::SkinSaveMap' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotSessionData
// 0x00B8 (0x00E0 - 0x0028)
class UReadyOrNotSessionData final  : public USaveGame
{
public:
	class FString                                 SaveSlotName;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UserIndex;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2423[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, int32>                    SavedTeamKillData;                                 // 0x0040(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            BanReasonData;                                     // 0x0090(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotSessionData">();
	}
	static class UReadyOrNotSessionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotSessionData>();
	}
};
static_assert(alignof(UReadyOrNotSessionData) == 0x000008, "Wrong alignment on UReadyOrNotSessionData");
static_assert(sizeof(UReadyOrNotSessionData) == 0x0000E0, "Wrong size on UReadyOrNotSessionData");
static_assert(offsetof(UReadyOrNotSessionData, SaveSlotName) == 0x000028, "Member 'UReadyOrNotSessionData::SaveSlotName' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSessionData, UserIndex) == 0x000038, "Member 'UReadyOrNotSessionData::UserIndex' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSessionData, SavedTeamKillData) == 0x000040, "Member 'UReadyOrNotSessionData::SavedTeamKillData' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSessionData, BanReasonData) == 0x000090, "Member 'UReadyOrNotSessionData::BanReasonData' has a wrong offset!");

// Class ReadyOrNot.TugOfWarGM
// 0x0040 (0x0810 - 0x07D0)
class ATugOfWarGM final  : public AReadyOrNotGameMode_PVP
{
public:
	TArray<class APlayerCharacter*>               ArrestedBlueCharacters;                            // 0x07D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class APlayerCharacter*>               ArrestedRedCharacters;                             // 0x07E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFMODEvent*                             TOWVictorySound;                                   // 0x07F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchLoopMusic;                                    // 0x07F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchStartMusic;                                   // 0x0800(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchEndMusic;                                     // 0x0808(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TugOfWarGM">();
	}
	static class ATugOfWarGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATugOfWarGM>();
	}
};
static_assert(alignof(ATugOfWarGM) == 0x000010, "Wrong alignment on ATugOfWarGM");
static_assert(sizeof(ATugOfWarGM) == 0x000810, "Wrong size on ATugOfWarGM");
static_assert(offsetof(ATugOfWarGM, ArrestedBlueCharacters) == 0x0007D0, "Member 'ATugOfWarGM::ArrestedBlueCharacters' has a wrong offset!");
static_assert(offsetof(ATugOfWarGM, ArrestedRedCharacters) == 0x0007E0, "Member 'ATugOfWarGM::ArrestedRedCharacters' has a wrong offset!");
static_assert(offsetof(ATugOfWarGM, TOWVictorySound) == 0x0007F0, "Member 'ATugOfWarGM::TOWVictorySound' has a wrong offset!");
static_assert(offsetof(ATugOfWarGM, MatchLoopMusic) == 0x0007F8, "Member 'ATugOfWarGM::MatchLoopMusic' has a wrong offset!");
static_assert(offsetof(ATugOfWarGM, MatchStartMusic) == 0x000800, "Member 'ATugOfWarGM::MatchStartMusic' has a wrong offset!");
static_assert(offsetof(ATugOfWarGM, MatchEndMusic) == 0x000808, "Member 'ATugOfWarGM::MatchEndMusic' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotModData
// 0x0038 (0x0060 - 0x0028)
class UReadyOrNotModData final  : public USaveGame
{
public:
	class FString                                 SaveSlotName;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UserIndex;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2424[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 DisabledMods;                                      // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int64>                                 ErroredMods;                                       // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotModData">();
	}
	static class UReadyOrNotModData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotModData>();
	}
};
static_assert(alignof(UReadyOrNotModData) == 0x000008, "Wrong alignment on UReadyOrNotModData");
static_assert(sizeof(UReadyOrNotModData) == 0x000060, "Wrong size on UReadyOrNotModData");
static_assert(offsetof(UReadyOrNotModData, SaveSlotName) == 0x000028, "Member 'UReadyOrNotModData::SaveSlotName' has a wrong offset!");
static_assert(offsetof(UReadyOrNotModData, UserIndex) == 0x000038, "Member 'UReadyOrNotModData::UserIndex' has a wrong offset!");
static_assert(offsetof(UReadyOrNotModData, DisabledMods) == 0x000040, "Member 'UReadyOrNotModData::DisabledMods' has a wrong offset!");
static_assert(offsetof(UReadyOrNotModData, ErroredMods) == 0x000050, "Member 'UReadyOrNotModData::ErroredMods' has a wrong offset!");

// Class ReadyOrNot.DeployableSpawnComponent
// 0x0010 (0x0210 - 0x0200)
class UDeployableSpawnComponent final  : public USceneComponent
{
public:
	TSubclassOf<class AActor>                     ItemClass;                                         // 0x01F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DeployableLabel;                                   // 0x0200(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2425[0x8];                                     // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MutateSpawnedDeployable(class AActor* SpawnedDeployable);
	bool TrySpawnComponent(bool ShouldSpawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployableSpawnComponent">();
	}
	static class UDeployableSpawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployableSpawnComponent>();
	}
};
static_assert(alignof(UDeployableSpawnComponent) == 0x000010, "Wrong alignment on UDeployableSpawnComponent");
static_assert(sizeof(UDeployableSpawnComponent) == 0x000210, "Wrong size on UDeployableSpawnComponent");
static_assert(offsetof(UDeployableSpawnComponent, ItemClass) == 0x0001F8, "Member 'UDeployableSpawnComponent::ItemClass' has a wrong offset!");
static_assert(offsetof(UDeployableSpawnComponent, DeployableLabel) == 0x000200, "Member 'UDeployableSpawnComponent::DeployableLabel' has a wrong offset!");

// Class ReadyOrNot.BpVideoSettingsLib
// 0x0000 (0x0028 - 0x0028)
class UBpVideoSettingsLib final  : public UBlueprintFunctionLibrary
{
public:
	static bool ChangeScreenResolution(int32 Width, int32 Height, EWindowMode NewWindowMode);
	static void ForceReloadSettings();
	static class FText GenerateDlssQualityString(int32 Quality);
	static class FText GenerateFSRQualityString(int32 Quality);
	static class FText GenerateQualityString(int32 Quality);
	static bool GetAntiAliasingQuality(int32* AntiAliasing);
	static EWindowMode GetCurrentScreenMode();
	static class FString GetCurrentScreenResolution();
	static bool GetDepthOfFieldSetting(bool* bDoFEnabled);
	static bool GetDlssFrameGenerationSetting(int32* Setting);
	static bool GetDlssQuality(int32* Quality);
	static bool GetEffectsQuality(int32* Effects);
	static bool GetFrameRateLimit(int32* FrameRateLimit, bool* bEnabled);
	static bool GetFSRQuality(int32* Quality);
	static int32 GetGraphicsPresetIndex();
	static bool GetInterfaceAspectRatio(float* OutAspectRatio);
	static bool GetMotionBlurEnabled(bool* bEnabled);
	static bool GetMotionBlurStrength(float* Strength);
	static bool GetOverallVideoQuality(int32* Quality);
	static bool GetPerObjectShadowsEnabled(bool* bPerObjectShadowsEnabled);
	static bool GetPostProcessQuality(int32* PostProcess);
	static bool GetRaytracingSettings(bool* bRTXEnabled, bool* bRTXReflectionsEnabled, bool* bRTXShadowsEnabled, bool* bRTXAmbientOcclusionEnabled, bool* bRTXGlobalIllumination, bool* bRTXTranslucency);
	static bool GetReflexEnabled(uint8* ReflexMode, bool* bFlashIndicatorEnabled);
	static void GetReflexLatency(bool* bGameToRenderLatencyEnabled, float* GametoRenderLatency, bool* bGameLatencyEnabled, float* GameLatencyInMS, bool* bRenderLatencyEnabled, float* RenderLatencyInMS);
	static bool GetReflexLatencyOptions(bool* bGameToRenderLatencyEnabled, bool* bGameLatencyEnabled, bool* bRenderLatencyEnabled);
	static bool GetResolutionScaling(float* ResolutionScaling);
	static bool GetShadowQuality(int32* Shadow);
	static bool GetSupportedScreenResolutions(TArray<class FString>* Resolutions);
	static bool GetTextureQuality(int32* Texture);
	static bool GetVideoQualitySettings(int32* AntiAliasing, int32* Effects, int32* PostProcess, float* ResolutionScaling, int32* Shadow, int32* Texture, int32* ViewDistance);
	static bool GetVideoQualitySettingsAsString(class FText* OverallSetting, class FText* AntiAliasing, class FText* Effects, class FText* PostProcess, class FText* Shadow, class FText* Texture, class FText* ViewDistance);
	static bool GetViewDistanceQuality(int32* ViewDistance);
	static bool GetVSyncEnabled(bool* bEnabled);
	static bool GetWorldDecalsEnabled(bool* bEnabled, float* FadeDistance, float* Density);
	static bool IsDlssFrameGenerationSupported();
	static bool IsNvidiaReflexEnabled();
	static bool SaveVideoModeAndQuality();
	static bool SetDepthofFieldSetting(bool bDoFEnabled);
	static bool SetDlssFrameGenerationSetting(int32 Setting);
	static bool SetDlssQuality(int32 Quality);
	static bool SetFrameRateLimit(int32 FrameRateLimit, bool bEnabled);
	static bool SetFSRQuality(int32 Quality);
	static bool SetGraphicsPresetIndex(int32 GraphicsPresetIndex);
	static bool SetInterfaceAspectRatio(float InAspectRatio);
	static bool SetMotionBlurEnabled(bool bEnabled);
	static bool SetMotionBlurStrength(float Strength);
	static bool SetOverallVideoQuality(int32 Quality);
	static bool SetPerObjectShadowsEnabled(bool bPerObjectShadowsEnabled);
	static bool SetRaytracingSettings(bool bRTXEnabled, bool bRTXReflectionsEnabled, bool bRTXShadowsEnabled, bool bRTXAmbientOcclusionEnabled, bool bRTXGlobalIllumination, bool bRTXTranslucency);
	static bool SetReflexEnabled(uint8 ReflexMode, bool bFlashIndicatorEnabled);
	static bool SetReflexLatencyOptions(bool bGameToRenderLatencyEnabled, bool bGameLatencyEnabled, bool bRenderLatencyEnabled);
	static bool SetScreenResolution(int32 Width, int32 Height, EWindowMode NewWindowMode);
	static bool SetVideoQualitySettings(int32 AntiAliasing, int32 Effects, int32 PostProcess, float ResolutionScaling, int32 Shadow, int32 Texture, int32 ViewDistance);
	static bool SetVSyncEnabled(bool bEnabled);
	static bool SetWorldDecalEnabled(bool bEnabled, float FadeDistance, float Density);
	static bool SupportsRayTracing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BpVideoSettingsLib">();
	}
	static class UBpVideoSettingsLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBpVideoSettingsLib>();
	}
};
static_assert(alignof(UBpVideoSettingsLib) == 0x000008, "Wrong alignment on UBpVideoSettingsLib");
static_assert(sizeof(UBpVideoSettingsLib) == 0x000028, "Wrong size on UBpVideoSettingsLib");

// Class ReadyOrNot.BpWidgetLib
// 0x0000 (0x0028 - 0x0028)
class UBpWidgetLib final  : public UBlueprintFunctionLibrary
{
public:
	static class FText ChangeStringTableTextKey(class FText Target, const class FString& NewKey);
	static void DrawLinesWithCenteredOffset(struct FPaintContext& Context, TArray<struct FVector2D>& Points, const struct FLinearColor& Tint, bool bAntiAlias, float Thickness, const struct FVector2D& Offset, const struct FVector2D& Center, float Scale);
	static void DrawLinesWithThickness(struct FPaintContext& Context, TArray<struct FVector2D>& Points, const struct FLinearColor& Tint, bool bAntiAlias, float Thickness, const struct FVector2D& Offset);
	static void DrawLineWithCenteredOffset(struct FPaintContext& Context, const struct FVector2D& PositionA, const struct FVector2D& PositionB, const struct FLinearColor& Tint, bool bAntiAlias, float Thickness, const struct FVector2D& Offset, const struct FVector2D& Center, float Scale);
	static void DrawLineWithThickness(struct FPaintContext& Context, const struct FVector2D& PositionA, const struct FVector2D& PositionB, const struct FLinearColor& Tint, bool bAntiAlias, float Thickness, const struct FVector2D& Offset);
	static struct FVector2D GetNormalizedClick(struct FGeometry& InGeometry, struct FPointerEvent& InMouseEvent);
	static class ATablet* GetPlayerTablet(class UObject* WorldContextObject);
	static bool IsWorldTearingDown(class UObject* WorldContextObject);
	static void PlayEventFromTablet(class UObject* WorldContextObject, class UFMODEvent* Event);
	static bool PostBugReport(const class FString& Summary, const class FString& Description, const class FString& Category);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BpWidgetLib">();
	}
	static class UBpWidgetLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBpWidgetLib>();
	}
};
static_assert(alignof(UBpWidgetLib) == 0x000008, "Wrong alignment on UBpWidgetLib");
static_assert(sizeof(UBpWidgetLib) == 0x000028, "Wrong size on UBpWidgetLib");

// Class ReadyOrNot.DebugDisplayWidget
// 0x0000 (0x0260 - 0x0260)
class UDebugDisplayWidget : public UUserWidget
{
public:
	int32 AddDebugText(const class FString& NewText);
	void SetDebugText(int32 ID, const class FString& NewText);
	void SetDebugTitle(const class FString& NewTitle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugDisplayWidget">();
	}
	static class UDebugDisplayWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugDisplayWidget>();
	}
};
static_assert(alignof(UDebugDisplayWidget) == 0x000008, "Wrong alignment on UDebugDisplayWidget");
static_assert(sizeof(UDebugDisplayWidget) == 0x000260, "Wrong size on UDebugDisplayWidget");

// Class ReadyOrNot.Shotgun
// 0x0070 (0x14A0 - 0x1430)
class AShotgun : public ABaseMagazineWeapon
{
public:
	uint8                                         bIsSawnOff : 1;                                    // 0x1430(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2456[0x3];                                     // 0x1431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxShells;                                         // 0x1434(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 Shells;                                            // 0x1438(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<int32>                                 OriginalShellCounts;                               // 0x1448(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MaxShellsInWeapon;                                 // 0x1458(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShellsPerSlot;                                     // 0x145C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShellWeight;                                       // 0x1460(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2457[0x4];                                     // 0x1464(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            CurrentShellMesh;                                  // 0x1468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTapReload;                                        // 0x1470(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2458[0x7];                                     // 0x1471(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FShotgunVisuals                        ShotgunVisuals;                                    // 0x1478(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bBlockingFireAnimation;                            // 0x1488(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2459[0x3];                                     // 0x1489(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShellsInRack;                                      // 0x148C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UShellRackShellComponent*>       ShellMeshComponents;                               // 0x1490(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void CheckReloadSettings();
	void FinishedLoadingShellFromRack();
	void LoadNextShellInRack();
	void OnRep_ShellsReplicated();
	void PlayReloadLoop();
	void RefreshEntireShellRack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Shotgun">();
	}
	static class AShotgun* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShotgun>();
	}
};
static_assert(alignof(AShotgun) == 0x000010, "Wrong alignment on AShotgun");
static_assert(sizeof(AShotgun) == 0x0014A0, "Wrong size on AShotgun");
static_assert(offsetof(AShotgun, MaxShells) == 0x001434, "Member 'AShotgun::MaxShells' has a wrong offset!");
static_assert(offsetof(AShotgun, Shells) == 0x001438, "Member 'AShotgun::Shells' has a wrong offset!");
static_assert(offsetof(AShotgun, OriginalShellCounts) == 0x001448, "Member 'AShotgun::OriginalShellCounts' has a wrong offset!");
static_assert(offsetof(AShotgun, MaxShellsInWeapon) == 0x001458, "Member 'AShotgun::MaxShellsInWeapon' has a wrong offset!");
static_assert(offsetof(AShotgun, ShellsPerSlot) == 0x00145C, "Member 'AShotgun::ShellsPerSlot' has a wrong offset!");
static_assert(offsetof(AShotgun, ShellWeight) == 0x001460, "Member 'AShotgun::ShellWeight' has a wrong offset!");
static_assert(offsetof(AShotgun, CurrentShellMesh) == 0x001468, "Member 'AShotgun::CurrentShellMesh' has a wrong offset!");
static_assert(offsetof(AShotgun, bTapReload) == 0x001470, "Member 'AShotgun::bTapReload' has a wrong offset!");
static_assert(offsetof(AShotgun, ShotgunVisuals) == 0x001478, "Member 'AShotgun::ShotgunVisuals' has a wrong offset!");
static_assert(offsetof(AShotgun, bBlockingFireAnimation) == 0x001488, "Member 'AShotgun::bBlockingFireAnimation' has a wrong offset!");
static_assert(offsetof(AShotgun, ShellsInRack) == 0x00148C, "Member 'AShotgun::ShellsInRack' has a wrong offset!");
static_assert(offsetof(AShotgun, ShellMeshComponents) == 0x001490, "Member 'AShotgun::ShellMeshComponents' has a wrong offset!");

// Class ReadyOrNot.BreachingShotgun
// 0x0000 (0x14A0 - 0x14A0)
class ABreachingShotgun : public AShotgun
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreachingShotgun">();
	}
	static class ABreachingShotgun* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABreachingShotgun>();
	}
};
static_assert(alignof(ABreachingShotgun) == 0x000010, "Wrong alignment on ABreachingShotgun");
static_assert(sizeof(ABreachingShotgun) == 0x0014A0, "Wrong size on ABreachingShotgun");

// Class ReadyOrNot.LoadoutCustomization
// 0x0078 (0x00F8 - 0x0080)
class ULoadoutCustomization final  : public ULoadoutItem
{
public:
	class UCustomizationDataBase*                 Asset;                                             // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Variant;                                           // 0x0088(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      VariantIcon;                                       // 0x00A0(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Blocked;                                           // 0x00C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_245A[0x7];                                     // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RequirementsText;                                  // 0x00D0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class ULoadoutCustomization*>          Children;                                          // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	ECustomizationType GetCustomizationType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutCustomization">();
	}
	static class ULoadoutCustomization* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutCustomization>();
	}
};
static_assert(alignof(ULoadoutCustomization) == 0x000008, "Wrong alignment on ULoadoutCustomization");
static_assert(sizeof(ULoadoutCustomization) == 0x0000F8, "Wrong size on ULoadoutCustomization");
static_assert(offsetof(ULoadoutCustomization, Asset) == 0x000080, "Member 'ULoadoutCustomization::Asset' has a wrong offset!");
static_assert(offsetof(ULoadoutCustomization, Variant) == 0x000088, "Member 'ULoadoutCustomization::Variant' has a wrong offset!");
static_assert(offsetof(ULoadoutCustomization, VariantIcon) == 0x0000A0, "Member 'ULoadoutCustomization::VariantIcon' has a wrong offset!");
static_assert(offsetof(ULoadoutCustomization, Blocked) == 0x0000C8, "Member 'ULoadoutCustomization::Blocked' has a wrong offset!");
static_assert(offsetof(ULoadoutCustomization, RequirementsText) == 0x0000D0, "Member 'ULoadoutCustomization::RequirementsText' has a wrong offset!");
static_assert(offsetof(ULoadoutCustomization, Children) == 0x0000E8, "Member 'ULoadoutCustomization::Children' has a wrong offset!");

// Class ReadyOrNot.BreakableGlass
// 0x0008 (0x0228 - 0x0220)
class ABreakableGlass final  : public AActor
{
public:
	bool                                          bCanSoundPass;                                     // 0x0220(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_245B[0x7];                                     // 0x0221(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConvertHitAndExecute(const struct FHitResult& Hit, float Damage);
	void DestructibleHit(const struct FVector& Location);
	void FirstHitPositionObject(int32 FirstPositionBox, int32 TextureY, int32 TextureX, const struct FVector& HitPosition, const struct FVector& ObjectiveDirection, float DamageRadius, bool bFirstHitCanBreakIt, float CharacterVelocityToBreak);
	void Multicast_ConvertHitAndExecute(int32 FirstPositionBox, int32 TextureX, int32 TextureY, const struct FVector_NetQuantize& HitPosition, const struct FVector_NetQuantize& Direction, float Damage);
	void Multicast_DestructibleHit(const struct FVector_NetQuantize& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreakableGlass">();
	}
	static class ABreakableGlass* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABreakableGlass>();
	}
};
static_assert(alignof(ABreakableGlass) == 0x000008, "Wrong alignment on ABreakableGlass");
static_assert(sizeof(ABreakableGlass) == 0x000228, "Wrong size on ABreakableGlass");
static_assert(offsetof(ABreakableGlass, bCanSoundPass) == 0x000220, "Member 'ABreakableGlass::bCanSoundPass' has a wrong offset!");

// Class ReadyOrNot.BriefingWidget
// 0x0058 (0x02D0 - 0x0278)
class UBriefingWidget : public UBaseWidget
{
public:
	uint8                                         Pad_245D[0x58];                                    // 0x0278(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoesLevelHaveMissionAudio(const class FString& AudioName, bool* bHasMissionAudio);
	void GetBioDetails(const struct FCharacterBio& Bio, TArray<struct FCriminalRecord>* RapSheet, class UTexture2D** ProfileImage, class FString* OutDescription, class FString* OutBioText);
	void GetBios(EBioType BioType, TArray<struct FCharacterBio>* OutBios);
	void GetBriefing(struct FMissionAudio* OutBriefing);
	void GetLevelNickname(class FString* OutNickname);
	void GetWhiteboardObjectiveText(class FString* OutString);
	void GetWhiteboardTimelineAsString(class FString* OutString);
	void MoveCameraToMouseCursor(const struct FPointerEvent& PointerEvent);
	void PlayMissionAudio(const class FString& AudioName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BriefingWidget">();
	}
	static class UBriefingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBriefingWidget>();
	}
};
static_assert(alignof(UBriefingWidget) == 0x000008, "Wrong alignment on UBriefingWidget");
static_assert(sizeof(UBriefingWidget) == 0x0002D0, "Wrong size on UBriefingWidget");

// Class ReadyOrNot.MissionEnd
// 0x0000 (0x0320 - 0x0320)
class UMissionEnd : public UCommonActivatableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionEnd">();
	}
	static class UMissionEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionEnd>();
	}
};
static_assert(alignof(UMissionEnd) == 0x000008, "Wrong alignment on UMissionEnd");
static_assert(sizeof(UMissionEnd) == 0x000320, "Wrong size on UMissionEnd");

// Class ReadyOrNot.ExfilActor
// 0x0020 (0x0240 - 0x0220)
class AExfilActor final  : public AActor
{
public:
	uint8                                         Pad_2460[0x10];                                    // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   BaseMesh;                                          // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2461[0x8];                                     // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExfilActor">();
	}
	static class AExfilActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExfilActor>();
	}
};
static_assert(alignof(AExfilActor) == 0x000008, "Wrong alignment on AExfilActor");
static_assert(sizeof(AExfilActor) == 0x000240, "Wrong size on AExfilActor");
static_assert(offsetof(AExfilActor, BaseMesh) == 0x000230, "Member 'AExfilActor::BaseMesh' has a wrong offset!");

// Class ReadyOrNot.PageWidget
// 0x0000 (0x0320 - 0x0320)
class UPageWidget : public UCommonActivatableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PageWidget">();
	}
	static class UPageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPageWidget>();
	}
};
static_assert(alignof(UPageWidget) == 0x000008, "Wrong alignment on UPageWidget");
static_assert(sizeof(UPageWidget) == 0x000320, "Wrong size on UPageWidget");

// Class ReadyOrNot.PageFooter
// 0x0050 (0x0370 - 0x0320)
class UPageFooter : public UPageWidget
{
public:
	TMap<class FString, struct FScreenFooterEntry> FooterEntries;                                     // 0x0320(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void GetInputActionData(const struct FDataTableRowHandle& InputActionRow, class FText* ActionName, struct FKey* ActionKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PageFooter">();
	}
	static class UPageFooter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPageFooter>();
	}
};
static_assert(alignof(UPageFooter) == 0x000008, "Wrong alignment on UPageFooter");
static_assert(sizeof(UPageFooter) == 0x000370, "Wrong size on UPageFooter");
static_assert(offsetof(UPageFooter, FooterEntries) == 0x000320, "Member 'UPageFooter::FooterEntries' has a wrong offset!");

// Class ReadyOrNot.BringOrderToChaos
// 0x0000 (0x02A8 - 0x02A8)
class ABringOrderToChaos final  : public AObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BringOrderToChaos">();
	}
	static class ABringOrderToChaos* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABringOrderToChaos>();
	}
};
static_assert(alignof(ABringOrderToChaos) == 0x000008, "Wrong alignment on ABringOrderToChaos");
static_assert(sizeof(ABringOrderToChaos) == 0x0002A8, "Wrong size on ABringOrderToChaos");

// Class ReadyOrNot.TrainingGM
// 0x0080 (0x07F0 - 0x0770)
class ATrainingGM final  : public AReadyOrNotGameMode
{
public:
	TArray<class AReadyOrNotPlayerController*>    InitalizedPlayerControllers;                       // 0x0770(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UCommanderProfile*                      CommanderProfile;                                  // 0x0780(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2462[0x8];                                     // 0x0788(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTrainingEnded;                                   // 0x0790(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class FString                                 SwatSpawnTag;                                      // 0x07A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACyberneticCharacter>       SWATAIClass;                                       // 0x07B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AAIController>              FriendlyAIController;                              // 0x07B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASWATCharacter*>                 SpawnedSWATAI;                                     // 0x07C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActivityTriggerVolume*>         ActiveTriggerVolumes;                              // 0x07D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class ACheckpointActivityTriggerVolume*       CurrentCheckpoint;                                 // 0x07E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2463[0x8];                                     // 0x07E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FriendlyAIKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnTrainingEnded__DelegateSignature(bool bSuccess);
	void RemoveAllSpawnedAI();
	void SpawnPolice(bool bSpawnWithPlayer);
	void TrainingEnd(bool bSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainingGM">();
	}
	static class ATrainingGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrainingGM>();
	}
};
static_assert(alignof(ATrainingGM) == 0x000010, "Wrong alignment on ATrainingGM");
static_assert(sizeof(ATrainingGM) == 0x0007F0, "Wrong size on ATrainingGM");
static_assert(offsetof(ATrainingGM, InitalizedPlayerControllers) == 0x000770, "Member 'ATrainingGM::InitalizedPlayerControllers' has a wrong offset!");
static_assert(offsetof(ATrainingGM, CommanderProfile) == 0x000780, "Member 'ATrainingGM::CommanderProfile' has a wrong offset!");
static_assert(offsetof(ATrainingGM, OnTrainingEnded) == 0x000790, "Member 'ATrainingGM::OnTrainingEnded' has a wrong offset!");
static_assert(offsetof(ATrainingGM, SwatSpawnTag) == 0x0007A0, "Member 'ATrainingGM::SwatSpawnTag' has a wrong offset!");
static_assert(offsetof(ATrainingGM, SWATAIClass) == 0x0007B0, "Member 'ATrainingGM::SWATAIClass' has a wrong offset!");
static_assert(offsetof(ATrainingGM, FriendlyAIController) == 0x0007B8, "Member 'ATrainingGM::FriendlyAIController' has a wrong offset!");
static_assert(offsetof(ATrainingGM, SpawnedSWATAI) == 0x0007C0, "Member 'ATrainingGM::SpawnedSWATAI' has a wrong offset!");
static_assert(offsetof(ATrainingGM, ActiveTriggerVolumes) == 0x0007D0, "Member 'ATrainingGM::ActiveTriggerVolumes' has a wrong offset!");
static_assert(offsetof(ATrainingGM, CurrentCheckpoint) == 0x0007E0, "Member 'ATrainingGM::CurrentCheckpoint' has a wrong offset!");

// Class ReadyOrNot.BuildingTrigger
// 0x0098 (0x02C0 - 0x0228)
class ABuildingTrigger : public ATriggerBox
{
public:
	int32                                         NumberOfFloors;                                    // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAuto : 1;                                         // 0x022C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUniformFloorSpacing : 1;                          // 0x022C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2464[0x3];                                     // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpacingBetweenFloors;                              // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2465[0x4];                                     // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 SpacingPerFloor;                                   // 0x0238(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FText                                   BuildingName;                                      // 0x0248(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class FString>                    FloorNumberToFloorName;                            // 0x0260(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBuildingFloor>                 GeneratedFloors;                                   // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void GenerateFloors();
	void OnBuildingEnter(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnBuildingExit(class AActor* OverlappedActor, class AActor* OtherActor);

	struct FVector GetFloorLocation(int32 FloorNumber) const;
	int32 GetFloorNumberFromActorLocation(class AActor* Actor) const;
	bool IsActorOnFloor(class AActor* Actor, int32 FloorNumber) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTrigger">();
	}
	static class ABuildingTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingTrigger>();
	}
};
static_assert(alignof(ABuildingTrigger) == 0x000008, "Wrong alignment on ABuildingTrigger");
static_assert(sizeof(ABuildingTrigger) == 0x0002C0, "Wrong size on ABuildingTrigger");
static_assert(offsetof(ABuildingTrigger, NumberOfFloors) == 0x000228, "Member 'ABuildingTrigger::NumberOfFloors' has a wrong offset!");
static_assert(offsetof(ABuildingTrigger, SpacingBetweenFloors) == 0x000230, "Member 'ABuildingTrigger::SpacingBetweenFloors' has a wrong offset!");
static_assert(offsetof(ABuildingTrigger, SpacingPerFloor) == 0x000238, "Member 'ABuildingTrigger::SpacingPerFloor' has a wrong offset!");
static_assert(offsetof(ABuildingTrigger, BuildingName) == 0x000248, "Member 'ABuildingTrigger::BuildingName' has a wrong offset!");
static_assert(offsetof(ABuildingTrigger, FloorNumberToFloorName) == 0x000260, "Member 'ABuildingTrigger::FloorNumberToFloorName' has a wrong offset!");
static_assert(offsetof(ABuildingTrigger, GeneratedFloors) == 0x0002B0, "Member 'ABuildingTrigger::GeneratedFloors' has a wrong offset!");

// Class ReadyOrNot.DestructibleVehicleBodyPart
// 0x0010 (0x04F0 - 0x04E0)
class UDestructibleVehicleBodyPart final  : public UStaticMeshComponent
{
public:
	bool                                          bCanBeShotOff;                                     // 0x04E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2468[0x3];                                     // 0x04E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x04E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBroken;                                           // 0x04E8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2469[0x7];                                     // 0x04E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleVehicleBodyPart">();
	}
	static class UDestructibleVehicleBodyPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestructibleVehicleBodyPart>();
	}
};
static_assert(alignof(UDestructibleVehicleBodyPart) == 0x000010, "Wrong alignment on UDestructibleVehicleBodyPart");
static_assert(sizeof(UDestructibleVehicleBodyPart) == 0x0004F0, "Wrong size on UDestructibleVehicleBodyPart");
static_assert(offsetof(UDestructibleVehicleBodyPart, bCanBeShotOff) == 0x0004E0, "Member 'UDestructibleVehicleBodyPart::bCanBeShotOff' has a wrong offset!");
static_assert(offsetof(UDestructibleVehicleBodyPart, Health) == 0x0004E4, "Member 'UDestructibleVehicleBodyPart::Health' has a wrong offset!");
static_assert(offsetof(UDestructibleVehicleBodyPart, bBroken) == 0x0004E8, "Member 'UDestructibleVehicleBodyPart::bBroken' has a wrong offset!");

// Class ReadyOrNot.BuildingTrigger_Incrimination
// 0x0010 (0x02D0 - 0x02C0)
class ABuildingTrigger_Incrimination final  : public ABuildingTrigger
{
public:
	TArray<class AIncriminationClueSpawnPoint*>   ClueSpawnPoints;                                   // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTrigger_Incrimination">();
	}
	static class ABuildingTrigger_Incrimination* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingTrigger_Incrimination>();
	}
};
static_assert(alignof(ABuildingTrigger_Incrimination) == 0x000008, "Wrong alignment on ABuildingTrigger_Incrimination");
static_assert(sizeof(ABuildingTrigger_Incrimination) == 0x0002D0, "Wrong size on ABuildingTrigger_Incrimination");
static_assert(offsetof(ABuildingTrigger_Incrimination, ClueSpawnPoints) == 0x0002C0, "Member 'ABuildingTrigger_Incrimination::ClueSpawnPoints' has a wrong offset!");

// Class ReadyOrNot.BulletDamageType
// 0x0030 (0x0070 - 0x0040)
class UBulletDamageType : public UDamageType
{
public:
	TSubclassOf<class UUserWidget>                HitVisuals;                                        // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        HitShake;                                          // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArmorPiercing;                                    // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNonLethal;                                        // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_246A[0x2];                                     // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AggressionChangeInAI;                              // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadDamageMultiplier;                              // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperBodyDamageMultiplier;                         // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerBodyDamageMultiplier;                         // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmDamageMultiplier;                               // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegDamageMultiplier;                               // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootDamageMultiplier;                              // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletDamageType">();
	}
	static class UBulletDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBulletDamageType>();
	}
};
static_assert(alignof(UBulletDamageType) == 0x000008, "Wrong alignment on UBulletDamageType");
static_assert(sizeof(UBulletDamageType) == 0x000070, "Wrong size on UBulletDamageType");
static_assert(offsetof(UBulletDamageType, HitVisuals) == 0x000040, "Member 'UBulletDamageType::HitVisuals' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, HitShake) == 0x000048, "Member 'UBulletDamageType::HitShake' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, bArmorPiercing) == 0x000050, "Member 'UBulletDamageType::bArmorPiercing' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, bNonLethal) == 0x000051, "Member 'UBulletDamageType::bNonLethal' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, AggressionChangeInAI) == 0x000054, "Member 'UBulletDamageType::AggressionChangeInAI' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, HeadDamageMultiplier) == 0x000058, "Member 'UBulletDamageType::HeadDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, UpperBodyDamageMultiplier) == 0x00005C, "Member 'UBulletDamageType::UpperBodyDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, LowerBodyDamageMultiplier) == 0x000060, "Member 'UBulletDamageType::LowerBodyDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, ArmDamageMultiplier) == 0x000064, "Member 'UBulletDamageType::ArmDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, LegDamageMultiplier) == 0x000068, "Member 'UBulletDamageType::LegDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, FootDamageMultiplier) == 0x00006C, "Member 'UBulletDamageType::FootDamageMultiplier' has a wrong offset!");

// Class ReadyOrNot.SuspectArmour
// 0x0090 (0x0AD0 - 0x0A40)
class ASuspectArmour : public ABaseArmour
{
public:
	struct FSuspectArmourData                     ArmourData;                                        // 0x0A40(0x0070)(Net, RepNotify, NativeAccessSpecifierPrivate)
	float                                         Durability;                                        // 0x0AB0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_246B[0x4];                                     // 0x0AB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             BlockedSoundEvent;                                 // 0x0AB8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             PenetratedSoundEvent;                              // 0x0AC0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_246C[0x8];                                     // 0x0AC8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ArmourData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuspectArmour">();
	}
	static class ASuspectArmour* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASuspectArmour>();
	}
};
static_assert(alignof(ASuspectArmour) == 0x000010, "Wrong alignment on ASuspectArmour");
static_assert(sizeof(ASuspectArmour) == 0x000AD0, "Wrong size on ASuspectArmour");
static_assert(offsetof(ASuspectArmour, ArmourData) == 0x000A40, "Member 'ASuspectArmour::ArmourData' has a wrong offset!");
static_assert(offsetof(ASuspectArmour, Durability) == 0x000AB0, "Member 'ASuspectArmour::Durability' has a wrong offset!");
static_assert(offsetof(ASuspectArmour, BlockedSoundEvent) == 0x000AB8, "Member 'ASuspectArmour::BlockedSoundEvent' has a wrong offset!");
static_assert(offsetof(ASuspectArmour, PenetratedSoundEvent) == 0x000AC0, "Member 'ASuspectArmour::PenetratedSoundEvent' has a wrong offset!");

// Class ReadyOrNot.Projectile
// 0x0038 (0x0258 - 0x0220)
class AProjectile : public AActor
{
public:
	class UBulletProjectileMovementComponent*     MovementComp;                                      // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       CollisionComp;                                     // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_246D[0x10];                                    // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             ProjectileHitSound;                                // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_246E[0x8];                                     // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AImpactEffect>              ImpactEffectsClass;                                // 0x0250(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Multicast_SpawnImpactEffects(const struct FHitResult& Hit, TSubclassOf<class AImpactEffect> EffectsClass, float DecalScale, bool bExitImpact, bool bArmorImpact);
	void OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile">();
	}
	static class AProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile>();
	}
};
static_assert(alignof(AProjectile) == 0x000008, "Wrong alignment on AProjectile");
static_assert(sizeof(AProjectile) == 0x000258, "Wrong size on AProjectile");
static_assert(offsetof(AProjectile, MovementComp) == 0x000220, "Member 'AProjectile::MovementComp' has a wrong offset!");
static_assert(offsetof(AProjectile, CollisionComp) == 0x000228, "Member 'AProjectile::CollisionComp' has a wrong offset!");
static_assert(offsetof(AProjectile, ProjectileHitSound) == 0x000240, "Member 'AProjectile::ProjectileHitSound' has a wrong offset!");
static_assert(offsetof(AProjectile, ImpactEffectsClass) == 0x000250, "Member 'AProjectile::ImpactEffectsClass' has a wrong offset!");

// Class ReadyOrNot.TeamDeathmatchGS
// 0x0000 (0x07E0 - 0x07E0)
class ATeamDeathmatchGS final  : public AReadyOrNotGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamDeathmatchGS">();
	}
	static class ATeamDeathmatchGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeamDeathmatchGS>();
	}
};
static_assert(alignof(ATeamDeathmatchGS) == 0x000008, "Wrong alignment on ATeamDeathmatchGS");
static_assert(sizeof(ATeamDeathmatchGS) == 0x0007E0, "Wrong size on ATeamDeathmatchGS");

// Class ReadyOrNot.DamageProjectile
// 0x0020 (0x0278 - 0x0258)
class ADamageProjectile : public AProjectile
{
public:
	uint8                                         Pad_2471[0xC];                                     // 0x0258(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Damage;                                            // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             HitMarker;                                         // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageProjectile">();
	}
	static class ADamageProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADamageProjectile>();
	}
};
static_assert(alignof(ADamageProjectile) == 0x000008, "Wrong alignment on ADamageProjectile");
static_assert(sizeof(ADamageProjectile) == 0x000278, "Wrong size on ADamageProjectile");
static_assert(offsetof(ADamageProjectile, Damage) == 0x000264, "Member 'ADamageProjectile::Damage' has a wrong offset!");
static_assert(offsetof(ADamageProjectile, DamageType) == 0x000268, "Member 'ADamageProjectile::DamageType' has a wrong offset!");
static_assert(offsetof(ADamageProjectile, HitMarker) == 0x000270, "Member 'ADamageProjectile::HitMarker' has a wrong offset!");

// Class ReadyOrNot.EvidenceExtractionDevice
// 0x0020 (0x0240 - 0x0220)
class AEvidenceExtractionDevice : public AActor
{
public:
	uint8                                         Pad_2472[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InteractableComponent;                             // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EvidenceExtractionTime;                            // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2473[0x4];                                     // 0x023C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TryExtractEvidence(class APlayerCharacter* EvidencePossessor);

	bool CanCollectEvidence() const;
	bool CanStartExtraction() const;
	bool HasEvidenceToExtract() const;
	bool IsExtracting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvidenceExtractionDevice">();
	}
	static class AEvidenceExtractionDevice* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEvidenceExtractionDevice>();
	}
};
static_assert(alignof(AEvidenceExtractionDevice) == 0x000008, "Wrong alignment on AEvidenceExtractionDevice");
static_assert(sizeof(AEvidenceExtractionDevice) == 0x000240, "Wrong size on AEvidenceExtractionDevice");
static_assert(offsetof(AEvidenceExtractionDevice, StaticMeshComponent) == 0x000228, "Member 'AEvidenceExtractionDevice::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEvidenceExtractionDevice, InteractableComponent) == 0x000230, "Member 'AEvidenceExtractionDevice::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AEvidenceExtractionDevice, EvidenceExtractionTime) == 0x000238, "Member 'AEvidenceExtractionDevice::EvidenceExtractionTime' has a wrong offset!");

// Class ReadyOrNot.EvidenceExtractionDevice_Incrim
// 0x0028 (0x0268 - 0x0240)
class AEvidenceExtractionDevice_Incrim final  : public AEvidenceExtractionDevice
{
public:
	class UObjectiveMarkerComponent*              ObjectiveMarkerComponent;                          // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectiveMarkerComponent*              ObjectiveMarkerComponent_WayPoint;                 // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapActorComponent*                     MapActorComponent;                                 // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MapSectionName;                                    // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvidenceExtractionDevice_Incrim">();
	}
	static class AEvidenceExtractionDevice_Incrim* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEvidenceExtractionDevice_Incrim>();
	}
};
static_assert(alignof(AEvidenceExtractionDevice_Incrim) == 0x000008, "Wrong alignment on AEvidenceExtractionDevice_Incrim");
static_assert(sizeof(AEvidenceExtractionDevice_Incrim) == 0x000268, "Wrong size on AEvidenceExtractionDevice_Incrim");
static_assert(offsetof(AEvidenceExtractionDevice_Incrim, ObjectiveMarkerComponent) == 0x000240, "Member 'AEvidenceExtractionDevice_Incrim::ObjectiveMarkerComponent' has a wrong offset!");
static_assert(offsetof(AEvidenceExtractionDevice_Incrim, ObjectiveMarkerComponent_WayPoint) == 0x000248, "Member 'AEvidenceExtractionDevice_Incrim::ObjectiveMarkerComponent_WayPoint' has a wrong offset!");
static_assert(offsetof(AEvidenceExtractionDevice_Incrim, MapActorComponent) == 0x000250, "Member 'AEvidenceExtractionDevice_Incrim::MapActorComponent' has a wrong offset!");
static_assert(offsetof(AEvidenceExtractionDevice_Incrim, MapSectionName) == 0x000258, "Member 'AEvidenceExtractionDevice_Incrim::MapSectionName' has a wrong offset!");

// Class ReadyOrNot.BulletProjectile
// 0x00F0 (0x0368 - 0x0278)
class ABulletProjectile : public ADamageProjectile
{
public:
	class UStaticMeshComponent*                   BulletMesh;                                        // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2474[0x18];                                    // 0x0280(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseItem*                              FiredFromWeapon;                                   // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       FiredFromPlayer;                                   // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitAngleMultiplier;                                // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequiredAngleToDeflect;                            // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentageToDeflect;                               // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeflectionAmount;                                  // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2475[0x8];                                     // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedLossMultiplierPerSurface;                     // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageLossMultiplierPerSurface;                    // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityRequiredToRespawn;                         // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawBlood;                                        // 0x02CC(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2476[0xF];                                     // 0x02CD(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BulletProjectileScale;                             // 0x02DC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalScale;                                        // 0x02E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectedByGravity;                                // 0x02EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2477[0x3];                                     // 0x02ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              BulletWizzSound;                                   // 0x02F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumDistanceForWizz;                            // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequiredSpeedForWizz;                              // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugLineSize;                                     // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2478[0x4];                                     // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AImpactEffect>              ExitEffects;                                       // 0x0308(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AImpactEffect>              RicochetEffects;                                   // 0x0310(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        RichochetParticle;                                 // 0x0318(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorPiercing;                                     // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyOnHit;                                     // 0x0324(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachOnHit;                                      // 0x0325(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2479[0x2];                                     // 0x0326(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialSpeed;                                      // 0x0328(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialLocation;                                   // 0x032C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwningActor;                                       // 0x0338(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockIntegrityDamage;                               // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_247A[0x4];                                     // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                InitialDamageType;                                 // 0x0348(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Drag;                                              // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Wobble;                                            // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialWobbleDelay;                                // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsImpulseMultiplier;                          // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_247B[0x1];                                     // 0x0364(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanPenetrate;                                     // 0x0365(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerValidated;                                  // 0x0366(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_247C[0x1];                                     // 0x0367(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_ApplyForceToHitObjects(struct FHitResult& Hit, const struct FVector& Velocity);
	void Multicast_AttachToComponent(const struct FVector& NewLocation, class USceneComponent* Component, class FName BoneName);
	void Multicast_OnRespawnProjectile(const struct FVector_NetQuantize100& RespawnLocation, const struct FVector_NetQuantize100& RespawnRotation, float NewSpeed, float NewDamage, EProjectileReaction ProjectileReaction);
	void Multicast_SimulatePhysics(bool bSimulate);
	void OnDeflect(const struct FHitResult& DeflectionHit);
	void OnMeshHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit);
	void OnProjectileValidated();
	void OnRep_UpdateMesh();
	void OnRespawnProjectile(const struct FVector& RespawnLocation, const struct FRotator& RespawnRotation, float NewSpeed, float NewDamage, EProjectileReaction ProjectileReaction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletProjectile">();
	}
	static class ABulletProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABulletProjectile>();
	}
};
static_assert(alignof(ABulletProjectile) == 0x000008, "Wrong alignment on ABulletProjectile");
static_assert(sizeof(ABulletProjectile) == 0x000368, "Wrong size on ABulletProjectile");
static_assert(offsetof(ABulletProjectile, BulletMesh) == 0x000278, "Member 'ABulletProjectile::BulletMesh' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, FiredFromWeapon) == 0x000298, "Member 'ABulletProjectile::FiredFromWeapon' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, FiredFromPlayer) == 0x0002A0, "Member 'ABulletProjectile::FiredFromPlayer' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, HitAngleMultiplier) == 0x0002A8, "Member 'ABulletProjectile::HitAngleMultiplier' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, RequiredAngleToDeflect) == 0x0002AC, "Member 'ABulletProjectile::RequiredAngleToDeflect' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, PercentageToDeflect) == 0x0002B0, "Member 'ABulletProjectile::PercentageToDeflect' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, DeflectionAmount) == 0x0002B4, "Member 'ABulletProjectile::DeflectionAmount' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, SpeedLossMultiplierPerSurface) == 0x0002C0, "Member 'ABulletProjectile::SpeedLossMultiplierPerSurface' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, DamageLossMultiplierPerSurface) == 0x0002C4, "Member 'ABulletProjectile::DamageLossMultiplierPerSurface' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, VelocityRequiredToRespawn) == 0x0002C8, "Member 'ABulletProjectile::VelocityRequiredToRespawn' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, bDrawBlood) == 0x0002CC, "Member 'ABulletProjectile::bDrawBlood' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, BulletProjectileScale) == 0x0002DC, "Member 'ABulletProjectile::BulletProjectileScale' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, DecalScale) == 0x0002E8, "Member 'ABulletProjectile::DecalScale' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, bAffectedByGravity) == 0x0002EC, "Member 'ABulletProjectile::bAffectedByGravity' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, BulletWizzSound) == 0x0002F0, "Member 'ABulletProjectile::BulletWizzSound' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, MinimumDistanceForWizz) == 0x0002F8, "Member 'ABulletProjectile::MinimumDistanceForWizz' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, RequiredSpeedForWizz) == 0x0002FC, "Member 'ABulletProjectile::RequiredSpeedForWizz' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, DebugLineSize) == 0x000300, "Member 'ABulletProjectile::DebugLineSize' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, ExitEffects) == 0x000308, "Member 'ABulletProjectile::ExitEffects' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, RicochetEffects) == 0x000310, "Member 'ABulletProjectile::RicochetEffects' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, RichochetParticle) == 0x000318, "Member 'ABulletProjectile::RichochetParticle' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, ArmorPiercing) == 0x000320, "Member 'ABulletProjectile::ArmorPiercing' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, bDestroyOnHit) == 0x000324, "Member 'ABulletProjectile::bDestroyOnHit' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, bAttachOnHit) == 0x000325, "Member 'ABulletProjectile::bAttachOnHit' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, InitialSpeed) == 0x000328, "Member 'ABulletProjectile::InitialSpeed' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, InitialLocation) == 0x00032C, "Member 'ABulletProjectile::InitialLocation' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, OwningActor) == 0x000338, "Member 'ABulletProjectile::OwningActor' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, LockIntegrityDamage) == 0x000340, "Member 'ABulletProjectile::LockIntegrityDamage' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, InitialDamageType) == 0x000348, "Member 'ABulletProjectile::InitialDamageType' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, LifeSpan) == 0x000350, "Member 'ABulletProjectile::LifeSpan' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, Drag) == 0x000354, "Member 'ABulletProjectile::Drag' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, Wobble) == 0x000358, "Member 'ABulletProjectile::Wobble' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, InitialWobbleDelay) == 0x00035C, "Member 'ABulletProjectile::InitialWobbleDelay' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, PhysicsImpulseMultiplier) == 0x000360, "Member 'ABulletProjectile::PhysicsImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, bCanPenetrate) == 0x000365, "Member 'ABulletProjectile::bCanPenetrate' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, bServerValidated) == 0x000366, "Member 'ABulletProjectile::bServerValidated' has a wrong offset!");

// Class ReadyOrNot.BulletProjectileMovementComponent
// 0x0010 (0x01E0 - 0x01D0)
class UBulletProjectileMovementComponent final  : public UProjectileMovementComponent
{
public:
	bool                                          bReduceFrictionAfterFirstBounce;                   // 0x01D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2481[0x3];                                     // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FrictionAfterFirstBounce;                          // 0x01D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2482[0x8];                                     // 0x01D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletProjectileMovementComponent">();
	}
	static class UBulletProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBulletProjectileMovementComponent>();
	}
};
static_assert(alignof(UBulletProjectileMovementComponent) == 0x000008, "Wrong alignment on UBulletProjectileMovementComponent");
static_assert(sizeof(UBulletProjectileMovementComponent) == 0x0001E0, "Wrong size on UBulletProjectileMovementComponent");
static_assert(offsetof(UBulletProjectileMovementComponent, bReduceFrictionAfterFirstBounce) == 0x0001D0, "Member 'UBulletProjectileMovementComponent::bReduceFrictionAfterFirstBounce' has a wrong offset!");
static_assert(offsetof(UBulletProjectileMovementComponent, FrictionAfterFirstBounce) == 0x0001D4, "Member 'UBulletProjectileMovementComponent::FrictionAfterFirstBounce' has a wrong offset!");

// Class ReadyOrNot.Meleeable
// 0x0000 (0x0028 - 0x0028)
class IMeleeable final  : public IInterface
{
public:
	void OnMelee(class AReadyOrNotCharacter* Attacker, const struct FHitResult& Hit);

	class UParticleSystem* GetMeleeImpactParticle() const;
	class UFMODEvent* GetMeleeImpactSound() const;
	bool ShouldPlayMeleeEffectsLocally() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Meleeable">();
	}
	static class IMeleeable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMeleeable>();
	}
};
static_assert(alignof(IMeleeable) == 0x000008, "Wrong alignment on IMeleeable");
static_assert(sizeof(IMeleeable) == 0x000028, "Wrong size on IMeleeable");

// Class ReadyOrNot.WallHoleTraversal
// 0x01A0 (0x03C0 - 0x0220)
class AWallHoleTraversal final  : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnabled : 1;                                      // 0x0228(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2483[0x7];                                     // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name_WallHoleTraversal;                            // 0x0230(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AStaticMeshActor>> IgnoredMeshActors;                                 // 0x0240(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         CooldownAfterUse;                                  // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavLinkProxyDistance;                              // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2484[0x8];                                     // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             EntryTriggerBoxTransform;                          // 0x0260(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                EntryTriggerBoxExtent;                             // 0x0290(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2485[0x4];                                     // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ExitTriggerBoxTransform;                           // 0x02A0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ExitTriggerBoxExtent;                              // 0x02D0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2486[0x4];                                     // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           EntryAnim;                                         // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LoopAnim;                                          // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ExitAnim;                                          // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AAIController*                          OccupiedByController;                              // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANavLinkProxy*                          NavLinkProxy;                                      // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AController*, float>               CooldownMap;                                       // 0x0308(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2487[0x68];                                    // 0x0358(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCooldownFor(class AController* InController, float InCooldownTime);
	void TestForMeshes();

	bool IsCooldownActiveFor(class AController* InController) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WallHoleTraversal">();
	}
	static class AWallHoleTraversal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWallHoleTraversal>();
	}
};
static_assert(alignof(AWallHoleTraversal) == 0x000010, "Wrong alignment on AWallHoleTraversal");
static_assert(sizeof(AWallHoleTraversal) == 0x0003C0, "Wrong size on AWallHoleTraversal");
static_assert(offsetof(AWallHoleTraversal, SceneComponent) == 0x000220, "Member 'AWallHoleTraversal::SceneComponent' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, Name_WallHoleTraversal) == 0x000230, "Member 'AWallHoleTraversal::Name_WallHoleTraversal' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, IgnoredMeshActors) == 0x000240, "Member 'AWallHoleTraversal::IgnoredMeshActors' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, CooldownAfterUse) == 0x000250, "Member 'AWallHoleTraversal::CooldownAfterUse' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, NavLinkProxyDistance) == 0x000254, "Member 'AWallHoleTraversal::NavLinkProxyDistance' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, EntryTriggerBoxTransform) == 0x000260, "Member 'AWallHoleTraversal::EntryTriggerBoxTransform' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, EntryTriggerBoxExtent) == 0x000290, "Member 'AWallHoleTraversal::EntryTriggerBoxExtent' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, ExitTriggerBoxTransform) == 0x0002A0, "Member 'AWallHoleTraversal::ExitTriggerBoxTransform' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, ExitTriggerBoxExtent) == 0x0002D0, "Member 'AWallHoleTraversal::ExitTriggerBoxExtent' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, EntryAnim) == 0x0002E0, "Member 'AWallHoleTraversal::EntryAnim' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, LoopAnim) == 0x0002E8, "Member 'AWallHoleTraversal::LoopAnim' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, ExitAnim) == 0x0002F0, "Member 'AWallHoleTraversal::ExitAnim' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, OccupiedByController) == 0x0002F8, "Member 'AWallHoleTraversal::OccupiedByController' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, NavLinkProxy) == 0x000300, "Member 'AWallHoleTraversal::NavLinkProxy' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, CooldownMap) == 0x000308, "Member 'AWallHoleTraversal::CooldownMap' has a wrong offset!");

// Class ReadyOrNot.BulletTracer
// 0x0040 (0x0260 - 0x0220)
class ABulletTracer final  : public AActor
{
public:
	class USceneComponent*                        RootComp;                                          // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248A[0x20];                                    // 0x0228(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               ParticleComponent;                                 // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        TracerParticle;                                    // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        SmokeParticle;                                     // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletTracer">();
	}
	static class ABulletTracer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABulletTracer>();
	}
};
static_assert(alignof(ABulletTracer) == 0x000008, "Wrong alignment on ABulletTracer");
static_assert(sizeof(ABulletTracer) == 0x000260, "Wrong size on ABulletTracer");
static_assert(offsetof(ABulletTracer, RootComp) == 0x000220, "Member 'ABulletTracer::RootComp' has a wrong offset!");
static_assert(offsetof(ABulletTracer, ParticleComponent) == 0x000248, "Member 'ABulletTracer::ParticleComponent' has a wrong offset!");
static_assert(offsetof(ABulletTracer, TracerParticle) == 0x000250, "Member 'ABulletTracer::TracerParticle' has a wrong offset!");
static_assert(offsetof(ABulletTracer, SmokeParticle) == 0x000258, "Member 'ABulletTracer::SmokeParticle' has a wrong offset!");

// Class ReadyOrNot.C2Explosive
// 0x00B0 (0x0A80 - 0x09D0)
class AC2Explosive : public ABaseItem
{
public:
	bool                                          bIsValidPlacement;                                 // 0x09D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248B[0x3];                                     // 0x09D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             LastGoodPlacement;                                 // 0x09D4(0x0088)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_248C[0x4];                                     // 0x0A5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlacedC2Explosive*                     LastPlacedC2Explosive;                             // 0x0A60(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlacementDistance;                              // 0x0A68(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248D[0x4];                                     // 0x0A6C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentActorPlacement;                             // 0x0A70(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APlacedC2Explosive>         PlacedC2Class;                                     // 0x0A78(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Client_C2PlacementFinished();
	void Multicast_StartPlaceC2Explosive();
	void OnRep_LastPlacedC2Explosive();
	void Server_FinishC2Placement();
	void Server_StartC2Placement(class AActor* Actor);

	void EquipDetonator(bool bFromExplosives) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"C2Explosive">();
	}
	static class AC2Explosive* GetDefaultObj()
	{
		return GetDefaultObjImpl<AC2Explosive>();
	}
};
static_assert(alignof(AC2Explosive) == 0x000010, "Wrong alignment on AC2Explosive");
static_assert(sizeof(AC2Explosive) == 0x000A80, "Wrong size on AC2Explosive");
static_assert(offsetof(AC2Explosive, bIsValidPlacement) == 0x0009D0, "Member 'AC2Explosive::bIsValidPlacement' has a wrong offset!");
static_assert(offsetof(AC2Explosive, LastGoodPlacement) == 0x0009D4, "Member 'AC2Explosive::LastGoodPlacement' has a wrong offset!");
static_assert(offsetof(AC2Explosive, LastPlacedC2Explosive) == 0x000A60, "Member 'AC2Explosive::LastPlacedC2Explosive' has a wrong offset!");
static_assert(offsetof(AC2Explosive, MaxPlacementDistance) == 0x000A68, "Member 'AC2Explosive::MaxPlacementDistance' has a wrong offset!");
static_assert(offsetof(AC2Explosive, CurrentActorPlacement) == 0x000A70, "Member 'AC2Explosive::CurrentActorPlacement' has a wrong offset!");
static_assert(offsetof(AC2Explosive, PlacedC2Class) == 0x000A78, "Member 'AC2Explosive::PlacedC2Class' has a wrong offset!");

// Class ReadyOrNot.ObituaryData
// 0x0060 (0x0090 - 0x0030)
class UObituaryData final  : public UDataAsset
{
public:
	TMap<class FName, struct FObituaryForBone>    PointDeathMessages;                                // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FText>                           DefaultBulletDeathText;                            // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObituaryData">();
	}
	static class UObituaryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObituaryData>();
	}
};
static_assert(alignof(UObituaryData) == 0x000008, "Wrong alignment on UObituaryData");
static_assert(sizeof(UObituaryData) == 0x000090, "Wrong size on UObituaryData");
static_assert(offsetof(UObituaryData, PointDeathMessages) == 0x000030, "Member 'UObituaryData::PointDeathMessages' has a wrong offset!");
static_assert(offsetof(UObituaryData, DefaultBulletDeathText) == 0x000080, "Member 'UObituaryData::DefaultBulletDeathText' has a wrong offset!");

// Class ReadyOrNot.DisarmStandaloneTrapActivity
// 0x0018 (0x01C0 - 0x01A8)
class UDisarmStandaloneTrapActivity final  : public UBaseActivity
{
public:
	class ATrapActor*                             TrapToDisarm;                                      // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248E[0x10];                                    // 0x01B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterDisarmStage();
	void EnterGetInPositionStage();
	void OnTrapDisarmed();
	void OnTrapTriggered(class ATrapActor* Trap, class AReadyOrNotCharacter* TriggeredBy);

	bool CanPerformDisarm() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisarmStandaloneTrapActivity">();
	}
	static class UDisarmStandaloneTrapActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisarmStandaloneTrapActivity>();
	}
};
static_assert(alignof(UDisarmStandaloneTrapActivity) == 0x000008, "Wrong alignment on UDisarmStandaloneTrapActivity");
static_assert(sizeof(UDisarmStandaloneTrapActivity) == 0x0001C0, "Wrong size on UDisarmStandaloneTrapActivity");
static_assert(offsetof(UDisarmStandaloneTrapActivity, TrapToDisarm) == 0x0001A8, "Member 'UDisarmStandaloneTrapActivity::TrapToDisarm' has a wrong offset!");

// Class ReadyOrNot.CachedAnimDataLibrary
// 0x0000 (0x0028 - 0x0028)
class UCachedAnimDataLibrary final  : public UBlueprintFunctionLibrary
{
public:
	static float StateMachine_GetGlobalWeight(class UAnimInstance* InAnimInstance, struct FCachedAnimStateData& CachedAnimStateData);
	static float StateMachine_GetLocalWeight(class UAnimInstance* InAnimInstance, struct FCachedAnimStateData& CachedAnimStateData);
	static bool StateMachine_IsStateRelevant(class UAnimInstance* InAnimInstance, struct FCachedAnimStateData& CachedAnimStateData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CachedAnimDataLibrary">();
	}
	static class UCachedAnimDataLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCachedAnimDataLibrary>();
	}
};
static_assert(alignof(UCachedAnimDataLibrary) == 0x000008, "Wrong alignment on UCachedAnimDataLibrary");
static_assert(sizeof(UCachedAnimDataLibrary) == 0x000028, "Wrong size on UCachedAnimDataLibrary");

// Class ReadyOrNot.MusicSequencerBase
// 0x0008 (0x0228 - 0x0220)
class AMusicSequencerBase : public AActor
{
public:
	class USceneComponent*                        Scene;                                             // 0x0220(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Multicast_ResetAudio();
	void Multicast_StartTransitioningToState(EMusicState NewState);
	void Multicast_StopAudio();
	void OnAudioReset();
	void OnStartedTransitioningToState(EMusicState NewState);
	void OnStoppedAudio();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicSequencerBase">();
	}
	static class AMusicSequencerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMusicSequencerBase>();
	}
};
static_assert(alignof(AMusicSequencerBase) == 0x000008, "Wrong alignment on AMusicSequencerBase");
static_assert(sizeof(AMusicSequencerBase) == 0x000228, "Wrong size on AMusicSequencerBase");
static_assert(offsetof(AMusicSequencerBase, Scene) == 0x000220, "Member 'AMusicSequencerBase::Scene' has a wrong offset!");

// Class ReadyOrNot.DestructibleVehicleParticleComponent
// 0x0000 (0x0470 - 0x0470)
class UDestructibleVehicleParticleComponent final  : public UArrowComponent
{
public:
	class UParticleSystem*                        ParticleSystem;                                    // 0x0468(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleVehicleParticleComponent">();
	}
	static class UDestructibleVehicleParticleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestructibleVehicleParticleComponent>();
	}
};
static_assert(alignof(UDestructibleVehicleParticleComponent) == 0x000010, "Wrong alignment on UDestructibleVehicleParticleComponent");
static_assert(sizeof(UDestructibleVehicleParticleComponent) == 0x000470, "Wrong size on UDestructibleVehicleParticleComponent");
static_assert(offsetof(UDestructibleVehicleParticleComponent, ParticleSystem) == 0x000468, "Member 'UDestructibleVehicleParticleComponent::ParticleSystem' has a wrong offset!");

// Class ReadyOrNot.CampaignData
// 0x0058 (0x0088 - 0x0030)
class UCampaignData final  : public UDataAsset
{
public:
	class FText                                   CampaignTitle;                                     // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CampaignAuthor;                                    // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CampaignDescription;                               // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<class FString>                         Levels;                                            // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampaignData">();
	}
	static class UCampaignData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCampaignData>();
	}
};
static_assert(alignof(UCampaignData) == 0x000008, "Wrong alignment on UCampaignData");
static_assert(sizeof(UCampaignData) == 0x000088, "Wrong size on UCampaignData");
static_assert(offsetof(UCampaignData, CampaignTitle) == 0x000030, "Member 'UCampaignData::CampaignTitle' has a wrong offset!");
static_assert(offsetof(UCampaignData, CampaignAuthor) == 0x000048, "Member 'UCampaignData::CampaignAuthor' has a wrong offset!");
static_assert(offsetof(UCampaignData, CampaignDescription) == 0x000060, "Member 'UCampaignData::CampaignDescription' has a wrong offset!");
static_assert(offsetof(UCampaignData, Levels) == 0x000078, "Member 'UCampaignData::Levels' has a wrong offset!");

// Class ReadyOrNot.SearchAndSecureActivity
// 0x0060 (0x0208 - 0x01A8)
class USearchAndSecureActivity final  : public UBaseActivity
{
public:
	FMulticastInlineDelegateProperty_             OnSearchComplete;                                  // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2490[0x10];                                    // 0x01B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  BreachDoor;                                        // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2491[0x20];                                    // 0x01D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         AllSecurables;                                     // 0x01F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 ClosestSecurable;                                  // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchAndSecureActivity">();
	}
	static class USearchAndSecureActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchAndSecureActivity>();
	}
};
static_assert(alignof(USearchAndSecureActivity) == 0x000008, "Wrong alignment on USearchAndSecureActivity");
static_assert(sizeof(USearchAndSecureActivity) == 0x000208, "Wrong size on USearchAndSecureActivity");
static_assert(offsetof(USearchAndSecureActivity, OnSearchComplete) == 0x0001A8, "Member 'USearchAndSecureActivity::OnSearchComplete' has a wrong offset!");
static_assert(offsetof(USearchAndSecureActivity, BreachDoor) == 0x0001C8, "Member 'USearchAndSecureActivity::BreachDoor' has a wrong offset!");
static_assert(offsetof(USearchAndSecureActivity, AllSecurables) == 0x0001F0, "Member 'USearchAndSecureActivity::AllSecurables' has a wrong offset!");
static_assert(offsetof(USearchAndSecureActivity, ClosestSecurable) == 0x000200, "Member 'USearchAndSecureActivity::ClosestSecurable' has a wrong offset!");

// Class ReadyOrNot.CanIssueCommandOn
// 0x0000 (0x0028 - 0x0028)
class ICanIssueCommandOn final  : public IInterface
{
public:
	bool CanIssueCommand() const;
	class AActor* GetCommandActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanIssueCommandOn">();
	}
	static class ICanIssueCommandOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanIssueCommandOn>();
	}
};
static_assert(alignof(ICanIssueCommandOn) == 0x000008, "Wrong alignment on ICanIssueCommandOn");
static_assert(sizeof(ICanIssueCommandOn) == 0x000028, "Wrong size on ICanIssueCommandOn");

// Class ReadyOrNot.CanPlaceC2On
// 0x0000 (0x0028 - 0x0028)
class ICanPlaceC2On final  : public IInterface
{
public:
	void C2StartPlacement(class AC2Explosive* C2);
	void C2StopPlacement(class AC2Explosive* C2);
	bool CanPlaceC2OnNow(class APlayerCharacter* C2Owner, class AC2Explosive* C2, const struct FHitResult& Hit);
	struct FVector GetPlacementLocation(const struct FHitResult& TraceHit);
	struct FRotator GetPlacementRotation(const struct FHitResult& TraceHit);
	void OnC2Detonated(class APlacedC2Explosive* C2);
	void OnC2Removed(class APlacedC2Explosive* C2);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanPlaceC2On">();
	}
	static class ICanPlaceC2On* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanPlaceC2On>();
	}
};
static_assert(alignof(ICanPlaceC2On) == 0x000008, "Wrong alignment on ICanPlaceC2On");
static_assert(sizeof(ICanPlaceC2On) == 0x000028, "Wrong size on ICanPlaceC2On");

// Class ReadyOrNot.MissionSelectWidget
// 0x0020 (0x0340 - 0x0320)
class UMissionSelectWidget : public UCommonActivatableWidget
{
public:
	TArray<class FName>                           DefaultMaps;                                       // 0x0320(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ULevelData*>                     CachedLevelDatas;                                  // 0x0330(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void CloseMissionSelect();
	const TArray<class ULevelData*> GetLevelDataList();
	void PreviewMission(class ULevelData* LevelData);
	void SelectMission(class ULevelData* LevelData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionSelectWidget">();
	}
	static class UMissionSelectWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionSelectWidget>();
	}
};
static_assert(alignof(UMissionSelectWidget) == 0x000008, "Wrong alignment on UMissionSelectWidget");
static_assert(sizeof(UMissionSelectWidget) == 0x000340, "Wrong size on UMissionSelectWidget");
static_assert(offsetof(UMissionSelectWidget, DefaultMaps) == 0x000320, "Member 'UMissionSelectWidget::DefaultMaps' has a wrong offset!");
static_assert(offsetof(UMissionSelectWidget, CachedLevelDatas) == 0x000330, "Member 'UMissionSelectWidget::CachedLevelDatas' has a wrong offset!");

// Class ReadyOrNot.DoorInteractionActivity
// 0x0050 (0x01F8 - 0x01A8)
class UDoorInteractionActivity : public UBaseActivity
{
public:
	class ADoor*                                  Door;                                              // 0x01A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CommandLocation;                                   // 0x01B0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginalLocation;                                  // 0x01BC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReturnToPositionAfterInteraction : 1;             // 0x01C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisablePlayerDoorInteraction : 1;                 // 0x01C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2493[0x7];                                     // 0x01C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InteractionAnimation;                              // 0x01D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           InteractionAnimMontage;                            // 0x01E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2494[0x10];                                    // 0x01E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterGetInPositionStage();
	void EnterInteractStage();
	void EnterReturnStage();
	void ExitGetInPositionStage();
	void ExitInteractStage();
	void ExitReturnStage();
	void OnDoorBroken();
	void OnDoorClosed();
	void OnDoorMovementBlocked();
	void OnDoorOpened();
	void OnInteractionBegin();
	void OnInteractionEnd();
	void PerformGetInPositionStage(float DeltaTime, float Uptime);
	void PerformInteractStage(float DeltaTime, float Uptime);
	void TickReturnStage(float DeltaTime, float Uptime);

	bool CanInteract() const;
	bool CanReturn() const;
	bool ShouldGetInPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorInteractionActivity">();
	}
	static class UDoorInteractionActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoorInteractionActivity>();
	}
};
static_assert(alignof(UDoorInteractionActivity) == 0x000008, "Wrong alignment on UDoorInteractionActivity");
static_assert(sizeof(UDoorInteractionActivity) == 0x0001F8, "Wrong size on UDoorInteractionActivity");
static_assert(offsetof(UDoorInteractionActivity, Door) == 0x0001A8, "Member 'UDoorInteractionActivity::Door' has a wrong offset!");
static_assert(offsetof(UDoorInteractionActivity, CommandLocation) == 0x0001B0, "Member 'UDoorInteractionActivity::CommandLocation' has a wrong offset!");
static_assert(offsetof(UDoorInteractionActivity, OriginalLocation) == 0x0001BC, "Member 'UDoorInteractionActivity::OriginalLocation' has a wrong offset!");
static_assert(offsetof(UDoorInteractionActivity, InteractionAnimation) == 0x0001D0, "Member 'UDoorInteractionActivity::InteractionAnimation' has a wrong offset!");
static_assert(offsetof(UDoorInteractionActivity, InteractionAnimMontage) == 0x0001E0, "Member 'UDoorInteractionActivity::InteractionAnimMontage' has a wrong offset!");

// Class ReadyOrNot.CanUse
// 0x0000 (0x0028 - 0x0028)
class ICanUse final  : public IInterface
{
public:
	bool CanUse(class APlayerCharacter* User);
	void EndUse(class APlayerCharacter* User);
	class FText GetUseButtonPromptText();
	class USceneComponent* GetUseIconBoltComponent();
	TArray<class USceneComponent*> GetUseViewComponents();
	bool IsAvailableForUse();
	bool OverridesUseButtonPromptText();
	bool PlaysUseIconComplete();
	bool StartUse(class APlayerCharacter* User);
	bool UsesHoldButtonPrompt();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanUse">();
	}
	static class ICanUse* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanUse>();
	}
};
static_assert(alignof(ICanUse) == 0x000008, "Wrong alignment on ICanUse");
static_assert(sizeof(ICanUse) == 0x000028, "Wrong size on ICanUse");

// Class ReadyOrNot.MunitionsSlot
// 0x0078 (0x0300 - 0x0288)
class UMunitionsSlot : public UCommonUserWidget
{
public:
	int32                                         SlotCount;                                         // 0x0288(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2497[0x4];                                     // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHorizontalBox*                         ElementContainer;                                  // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotGameState*                   Gs;                                                // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasElementsPrevious;                              // 0x02A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasElementsNext;                                  // 0x02A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2498[0x6];                                     // 0x02A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UReadyOrNotLoadoutManager*              LoadoutFunctionLibrary;                            // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PrimaryAmmoIcon;                                   // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SecondaryAmmoIcon;                                 // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             GrenadeIcon;                                       // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             C2ChargeIcon;                                      // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             WedgeIcon;                                         // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PepperSprayIcon;                                   // 0x02D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             LockpickGunIcon;                                   // 0x02E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             TaserIcon;                                         // 0x02E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ABaseItem>>          SlotItems;                                         // 0x02F0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void CreateElement(class UTexture2D* Icon, int32 Amount, bool bIsAmmoElement, class FText& AmmoType);
	void CreateSeparator(bool bShouldCreateSeparator);
	void SetGrenadeSlot();
	void SetPrimaryAmmoSlot();
	void SetSecondaryAmmoSlot();
	void SetTacticalSlot();
	void UpdateElementContainer();
	void UpdateSlotCount();
	void UpdateSlotText(int32 CurrentSlots, int32 MaxSlots);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MunitionsSlot">();
	}
	static class UMunitionsSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMunitionsSlot>();
	}
};
static_assert(alignof(UMunitionsSlot) == 0x000008, "Wrong alignment on UMunitionsSlot");
static_assert(sizeof(UMunitionsSlot) == 0x000300, "Wrong size on UMunitionsSlot");
static_assert(offsetof(UMunitionsSlot, SlotCount) == 0x000288, "Member 'UMunitionsSlot::SlotCount' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, ElementContainer) == 0x000290, "Member 'UMunitionsSlot::ElementContainer' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, Gs) == 0x000298, "Member 'UMunitionsSlot::Gs' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, bHasElementsPrevious) == 0x0002A0, "Member 'UMunitionsSlot::bHasElementsPrevious' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, bHasElementsNext) == 0x0002A1, "Member 'UMunitionsSlot::bHasElementsNext' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, LoadoutFunctionLibrary) == 0x0002A8, "Member 'UMunitionsSlot::LoadoutFunctionLibrary' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, PrimaryAmmoIcon) == 0x0002B0, "Member 'UMunitionsSlot::PrimaryAmmoIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, SecondaryAmmoIcon) == 0x0002B8, "Member 'UMunitionsSlot::SecondaryAmmoIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, GrenadeIcon) == 0x0002C0, "Member 'UMunitionsSlot::GrenadeIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, C2ChargeIcon) == 0x0002C8, "Member 'UMunitionsSlot::C2ChargeIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, WedgeIcon) == 0x0002D0, "Member 'UMunitionsSlot::WedgeIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, PepperSprayIcon) == 0x0002D8, "Member 'UMunitionsSlot::PepperSprayIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, LockpickGunIcon) == 0x0002E0, "Member 'UMunitionsSlot::LockpickGunIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, TaserIcon) == 0x0002E8, "Member 'UMunitionsSlot::TaserIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, SlotItems) == 0x0002F0, "Member 'UMunitionsSlot::SlotItems' has a wrong offset!");

// Class ReadyOrNot.DisarmC2Activity
// 0x0010 (0x01B8 - 0x01A8)
class UDisarmC2Activity final  : public UBaseActivity
{
public:
	class APlacedC2Explosive*                     PlacedC2;                                          // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_249A[0x8];                                     // 0x01B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisarmC2Activity">();
	}
	static class UDisarmC2Activity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisarmC2Activity>();
	}
};
static_assert(alignof(UDisarmC2Activity) == 0x000008, "Wrong alignment on UDisarmC2Activity");
static_assert(sizeof(UDisarmC2Activity) == 0x0001B8, "Wrong size on UDisarmC2Activity");
static_assert(offsetof(UDisarmC2Activity, PlacedC2) == 0x0001A8, "Member 'UDisarmC2Activity::PlacedC2' has a wrong offset!");

// Class ReadyOrNot.MatchTimeRemainingWidget
// 0x0010 (0x0288 - 0x0278)
class UMatchTimeRemainingWidget final  : public UBaseWidget
{
public:
	class UTextBlock*                             MatchTimeRemaining_Text;                           // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RoundTimeRemaining;                                // 0x0280(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_249B[0x4];                                     // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchTimeRemainingWidget">();
	}
	static class UMatchTimeRemainingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchTimeRemainingWidget>();
	}
};
static_assert(alignof(UMatchTimeRemainingWidget) == 0x000008, "Wrong alignment on UMatchTimeRemainingWidget");
static_assert(sizeof(UMatchTimeRemainingWidget) == 0x000288, "Wrong size on UMatchTimeRemainingWidget");
static_assert(offsetof(UMatchTimeRemainingWidget, MatchTimeRemaining_Text) == 0x000278, "Member 'UMatchTimeRemainingWidget::MatchTimeRemaining_Text' has a wrong offset!");
static_assert(offsetof(UMatchTimeRemainingWidget, RoundTimeRemaining) == 0x000280, "Member 'UMatchTimeRemainingWidget::RoundTimeRemaining' has a wrong offset!");

// Class ReadyOrNot.CanUseMultitoolOn
// 0x0000 (0x0028 - 0x0028)
class ICanUseMultitoolOn final  : public IInterface
{
public:
	bool CanCancelMultitoolAction();
	bool CanUseMultitoolNow(class AReadyOrNotCharacter* ToolOwner, class AMultitool* Tool, const struct FHitResult& TraceHit);
	void Client_FinishedUsingMultitool(class AReadyOrNotCharacter* ToolOwner);
	float GetMultitoolUseTime();
	EMultitoolFunctions GetMultitoolUseType();
	void Server_FinishedUsingMultitool(class AReadyOrNotCharacter* ToolOwner);

	bool ShouldOperate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanUseMultitoolOn">();
	}
	static class ICanUseMultitoolOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanUseMultitoolOn>();
	}
};
static_assert(alignof(ICanUseMultitoolOn) == 0x000008, "Wrong alignment on ICanUseMultitoolOn");
static_assert(sizeof(ICanUseMultitoolOn) == 0x000028, "Wrong size on ICanUseMultitoolOn");

// Class ReadyOrNot.TutorialWidget
// 0x0080 (0x03A0 - 0x0320)
class UTutorialWidget : public UCommonActivatableWidget
{
public:
	bool                                          bShowFooter;                                       // 0x0320(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsingGamepad;                                     // 0x0321(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_249D[0x7E];                                    // 0x0322(0x007E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideMainWidget();
	void OnInputMethodChanged(ECommonInputType InputMethod);
	void RefreshWidget();
	void SetData(struct FTutorialWidgetData& InData);
	void ShowMainWidget();

	class FText GetDescription() const;
	class FText GetTitle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialWidget">();
	}
	static class UTutorialWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialWidget>();
	}
};
static_assert(alignof(UTutorialWidget) == 0x000008, "Wrong alignment on UTutorialWidget");
static_assert(sizeof(UTutorialWidget) == 0x0003A0, "Wrong size on UTutorialWidget");
static_assert(offsetof(UTutorialWidget, bShowFooter) == 0x000320, "Member 'UTutorialWidget::bShowFooter' has a wrong offset!");
static_assert(offsetof(UTutorialWidget, bUsingGamepad) == 0x000321, "Member 'UTutorialWidget::bUsingGamepad' has a wrong offset!");

// Class ReadyOrNot.CaptureTheFlagGM
// 0x0040 (0x0810 - 0x07D0)
class ACaptureTheFlagGM final  : public AReadyOrNotGameMode_PVP
{
public:
	FMulticastInlineDelegateProperty_             OnFlagCaptured;                                    // 0x07D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFlagDropped;                                     // 0x07E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class ACTF_Flag>                  FlagClassToSpawn;                                  // 0x07F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACTF_Flag*                              Flag;                                              // 0x07F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_249E[0x10];                                    // 0x0800(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CaptureFlag(class ACTF_Flag* CapturedFlag, class APlayerCharacter* NewFlagBearer);
	class ACTF_FlagSpawnPoint* ChooseFlagSpawnPoint();
	void DropFlag();
	void OnFlagBearerKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnFlagCapturedSignature__DelegateSignature(class APlayerCharacter* CapturedByCharacter, ETeamType CpaturedByTeam);
	void OnFlagDroppedSignature__DelegateSignature(class APlayerCharacter* DroppedByCharacter, ETeamType DroppedByTeam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptureTheFlagGM">();
	}
	static class ACaptureTheFlagGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACaptureTheFlagGM>();
	}
};
static_assert(alignof(ACaptureTheFlagGM) == 0x000010, "Wrong alignment on ACaptureTheFlagGM");
static_assert(sizeof(ACaptureTheFlagGM) == 0x000810, "Wrong size on ACaptureTheFlagGM");
static_assert(offsetof(ACaptureTheFlagGM, OnFlagCaptured) == 0x0007D0, "Member 'ACaptureTheFlagGM::OnFlagCaptured' has a wrong offset!");
static_assert(offsetof(ACaptureTheFlagGM, OnFlagDropped) == 0x0007E0, "Member 'ACaptureTheFlagGM::OnFlagDropped' has a wrong offset!");
static_assert(offsetof(ACaptureTheFlagGM, FlagClassToSpawn) == 0x0007F0, "Member 'ACaptureTheFlagGM::FlagClassToSpawn' has a wrong offset!");
static_assert(offsetof(ACaptureTheFlagGM, Flag) == 0x0007F8, "Member 'ACaptureTheFlagGM::Flag' has a wrong offset!");

// Class ReadyOrNot.DoorBreachActivity
// 0x0020 (0x0218 - 0x01F8)
class UDoorBreachActivity : public UDoorInteractionActivity
{
public:
	class ABaseItem*                              BreachItem;                                        // 0x01F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBreachFinished;                                  // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_24A1[0x8];                                     // 0x0210(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterBreachedStage();
	void ExitBreachedStage();
	void FinishDoorBreach();
	void OnBreacherKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnBreachFinished__DelegateSignature(class UBaseActivity* Activity, class ACyberneticController* Controller);
	void TickBreachedStage(float DeltaTime, float Uptime);

	bool IsBreachFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorBreachActivity">();
	}
	static class UDoorBreachActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoorBreachActivity>();
	}
};
static_assert(alignof(UDoorBreachActivity) == 0x000008, "Wrong alignment on UDoorBreachActivity");
static_assert(sizeof(UDoorBreachActivity) == 0x000218, "Wrong size on UDoorBreachActivity");
static_assert(offsetof(UDoorBreachActivity, BreachItem) == 0x0001F8, "Member 'UDoorBreachActivity::BreachItem' has a wrong offset!");
static_assert(offsetof(UDoorBreachActivity, OnBreachFinished) == 0x000200, "Member 'UDoorBreachActivity::OnBreachFinished' has a wrong offset!");

// Class ReadyOrNot.ShotgunDoorActivity
// 0x0008 (0x0220 - 0x0218)
class UShotgunDoorActivity final  : public UDoorBreachActivity
{
public:
	uint8                                         Pad_24A2[0x8];                                     // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDoorKicked();
	void OnDoorShotgunned();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShotgunDoorActivity">();
	}
	static class UShotgunDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShotgunDoorActivity>();
	}
};
static_assert(alignof(UShotgunDoorActivity) == 0x000008, "Wrong alignment on UShotgunDoorActivity");
static_assert(sizeof(UShotgunDoorActivity) == 0x000220, "Wrong size on UShotgunDoorActivity");

// Class ReadyOrNot.CaptureTheFlagGS
// 0x0018 (0x07F8 - 0x07E0)
class ACaptureTheFlagGS final  : public AReadyOrNotGameState
{
public:
	class ACTF_Flag*                              Flag;                                              // 0x07E0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       FlagBearer;                                        // 0x07E8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     FlagBearerTeam;                                    // 0x07F0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFlagCaptured : 1;                                 // 0x07F1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGameWon : 1;                                      // 0x07F1(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_24A3[0x6];                                     // 0x07F2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_FlagStatus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptureTheFlagGS">();
	}
	static class ACaptureTheFlagGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACaptureTheFlagGS>();
	}
};
static_assert(alignof(ACaptureTheFlagGS) == 0x000008, "Wrong alignment on ACaptureTheFlagGS");
static_assert(sizeof(ACaptureTheFlagGS) == 0x0007F8, "Wrong size on ACaptureTheFlagGS");
static_assert(offsetof(ACaptureTheFlagGS, Flag) == 0x0007E0, "Member 'ACaptureTheFlagGS::Flag' has a wrong offset!");
static_assert(offsetof(ACaptureTheFlagGS, FlagBearer) == 0x0007E8, "Member 'ACaptureTheFlagGS::FlagBearer' has a wrong offset!");
static_assert(offsetof(ACaptureTheFlagGS, FlagBearerTeam) == 0x0007F0, "Member 'ACaptureTheFlagGS::FlagBearerTeam' has a wrong offset!");

// Class ReadyOrNot.Challenge
// 0x0048 (0x0070 - 0x0028)
class UChallenge : public UObject
{
public:
	class FText                                   ChallengeName;                                     // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ChallengeDescription;                              // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   ChallengeProgressName;                             // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengeProgressCurrent;                          // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengeProgressMax;                              // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenChallenge;                                  // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChallengeComplete;                                // 0x0069(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLevelSpecificChallenge;                           // 0x006A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24A4[0x5];                                     // 0x006B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecrementChallengeProgress(int32 DecrementBy);
	void IncrementChallengeProgress(int32 IncrementBy);
	void OnChallengeAchieved();
	void OnChallengeInit(class AReadyOrNotGameState* Gs);
	void ResetChallengeProgress();
	void UpdateFromProfile(class UReadyOrNotProfile* Profile);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Challenge">();
	}
	static class UChallenge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallenge>();
	}
};
static_assert(alignof(UChallenge) == 0x000008, "Wrong alignment on UChallenge");
static_assert(sizeof(UChallenge) == 0x000070, "Wrong size on UChallenge");
static_assert(offsetof(UChallenge, ChallengeName) == 0x000028, "Member 'UChallenge::ChallengeName' has a wrong offset!");
static_assert(offsetof(UChallenge, ChallengeDescription) == 0x000040, "Member 'UChallenge::ChallengeDescription' has a wrong offset!");
static_assert(offsetof(UChallenge, ChallengeProgressName) == 0x000058, "Member 'UChallenge::ChallengeProgressName' has a wrong offset!");
static_assert(offsetof(UChallenge, ChallengeProgressCurrent) == 0x000060, "Member 'UChallenge::ChallengeProgressCurrent' has a wrong offset!");
static_assert(offsetof(UChallenge, ChallengeProgressMax) == 0x000064, "Member 'UChallenge::ChallengeProgressMax' has a wrong offset!");
static_assert(offsetof(UChallenge, bHiddenChallenge) == 0x000068, "Member 'UChallenge::bHiddenChallenge' has a wrong offset!");
static_assert(offsetof(UChallenge, bChallengeComplete) == 0x000069, "Member 'UChallenge::bChallengeComplete' has a wrong offset!");
static_assert(offsetof(UChallenge, bLevelSpecificChallenge) == 0x00006A, "Member 'UChallenge::bLevelSpecificChallenge' has a wrong offset!");

// Class ReadyOrNot.DoorwayWithoutDoor
// 0x0008 (0x0228 - 0x0220)
class ADoorwayWithoutDoor : public AActor
{
public:
	class UDoorwayComponent*                      Doorway;                                           // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FVector GetDoorSize() const;
	class UDoorwayComponent* GetDoorway() const;
	bool IsPointInFrontOfDoorway(const struct FVector& Point) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorwayWithoutDoor">();
	}
	static class ADoorwayWithoutDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoorwayWithoutDoor>();
	}
};
static_assert(alignof(ADoorwayWithoutDoor) == 0x000008, "Wrong alignment on ADoorwayWithoutDoor");
static_assert(sizeof(ADoorwayWithoutDoor) == 0x000228, "Wrong size on ADoorwayWithoutDoor");
static_assert(offsetof(ADoorwayWithoutDoor, Doorway) == 0x000220, "Member 'ADoorwayWithoutDoor::Doorway' has a wrong offset!");

// Class ReadyOrNot.ChallengeManager
// 0x0018 (0x0048 - 0x0030)
class UChallengeManager final  : public UWorldSubsystem
{
public:
	TArray<class UChallenge*>                     Challenges;                                        // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UReadyOrNotProfile*                     Profile;                                           // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void InitChallenges(class AReadyOrNotGameState* GameState, const struct FLevelDataLookupTable& LevelData);
	void SaveChallenges();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeManager">();
	}
	static class UChallengeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallengeManager>();
	}
};
static_assert(alignof(UChallengeManager) == 0x000008, "Wrong alignment on UChallengeManager");
static_assert(sizeof(UChallengeManager) == 0x000048, "Wrong size on UChallengeManager");
static_assert(offsetof(UChallengeManager, Challenges) == 0x000030, "Member 'UChallengeManager::Challenges' has a wrong offset!");
static_assert(offsetof(UChallengeManager, Profile) == 0x000040, "Member 'UChallengeManager::Profile' has a wrong offset!");

// Class ReadyOrNot.CharacterCustomizationPortal
// 0x0068 (0x0288 - 0x0220)
class ACharacterCustomizationPortal final  : public AActor
{
public:
	uint8                                         Pad_24A6[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   CustomizationCharacter;                            // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractableComponent*                 InteractableComponent;                             // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBillboardComponent*                    BillboardComponent;                                // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArrowComponent*                        CharacterSpawnPoint;                               // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24A7[0x10];                                    // 0x0248(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMeshComponent*>           CompsToOutline;                                    // 0x0258(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class ULightComponent*>                LightsToEnable;                                    // 0x0268(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class FName                                   LightActorsOfTag;                                  // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasLocked;                                        // 0x0280(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24A8[0x7];                                     // 0x0281(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void GetAllCompatibleBodies(class FName InHead, TArray<class FName>* OutBodies);
	static void GetAllCompatibleHeads(class FName InBody, TArray<class FName>* OutHeads);
	static bool GetCharacterLookOverride(class FName Head, class FName Body, struct FCharacterLookOverride* OutCharacterLookOverride);
	static bool GetCurrentCharacterLookOverride(class FName* OutHead, class FName* OutBody);
	static void GetCustomizationEntries(TArray<struct FCharacterPersonalizationData>* OutHeads, TArray<struct FCharacterPersonalizationData>* OutBodys);
	static bool IsDLCLocked(const struct FCharacterPersonalizationData& Data);
	static bool SaveCharacterLookOverride(class FName InHead, class FName InBody);

	void UpdateCharacterLookOverride(class FName Head, class FName Body);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCustomizationPortal">();
	}
	static class ACharacterCustomizationPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterCustomizationPortal>();
	}
};
static_assert(alignof(ACharacterCustomizationPortal) == 0x000008, "Wrong alignment on ACharacterCustomizationPortal");
static_assert(sizeof(ACharacterCustomizationPortal) == 0x000288, "Wrong size on ACharacterCustomizationPortal");
static_assert(offsetof(ACharacterCustomizationPortal, CustomizationCharacter) == 0x000228, "Member 'ACharacterCustomizationPortal::CustomizationCharacter' has a wrong offset!");
static_assert(offsetof(ACharacterCustomizationPortal, InteractableComponent) == 0x000230, "Member 'ACharacterCustomizationPortal::InteractableComponent' has a wrong offset!");
static_assert(offsetof(ACharacterCustomizationPortal, BillboardComponent) == 0x000238, "Member 'ACharacterCustomizationPortal::BillboardComponent' has a wrong offset!");
static_assert(offsetof(ACharacterCustomizationPortal, CharacterSpawnPoint) == 0x000240, "Member 'ACharacterCustomizationPortal::CharacterSpawnPoint' has a wrong offset!");
static_assert(offsetof(ACharacterCustomizationPortal, CompsToOutline) == 0x000258, "Member 'ACharacterCustomizationPortal::CompsToOutline' has a wrong offset!");
static_assert(offsetof(ACharacterCustomizationPortal, LightsToEnable) == 0x000268, "Member 'ACharacterCustomizationPortal::LightsToEnable' has a wrong offset!");
static_assert(offsetof(ACharacterCustomizationPortal, LightActorsOfTag) == 0x000278, "Member 'ACharacterCustomizationPortal::LightActorsOfTag' has a wrong offset!");
static_assert(offsetof(ACharacterCustomizationPortal, bHasLocked) == 0x000280, "Member 'ACharacterCustomizationPortal::bHasLocked' has a wrong offset!");

// Class ReadyOrNot.DestructibleVehicle
// 0x01B8 (0x03D8 - 0x0220)
class ADestructibleVehicle final  : public AActor
{
public:
	bool                                          bComplexVehicle;                                   // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLightsOn;                                         // 0x0221(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24AD[0x6];                                     // 0x0222(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             BodyImpactEvent;                                   // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BodyBreakEvent;                                    // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToCauseAlarmOnDamage;                        // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlarmPlayLength;                                   // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlarmHeadLightsFlashInterval;                      // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToCauseAirbagToDeployOnDamage;               // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        AirbagParticle;                                    // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             AirbagEvent;                                       // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlassHealth;                                       // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlassDamageToApply;                                // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              RandomShatteredGlassMaterial;                      // 0x0260(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFMODEvent*                             GlassImpactEvent;                                  // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             GlassBreakEvent;                                   // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollAmountOnTireDamage;                            // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchAmountOnTireDamage;                           // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinkAmountOnTireDamage;                            // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TireDeflationInterpSpeed;                          // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             TireDeflateEvent;                                  // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            FlatTireMesh;                                      // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSimplifiedLights;                              // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24AE[0x7];                                     // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstance*                      SimplifiedLightsOnMaterial;                        // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      SimplifiedLightsOffMaterial;                       // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      FrontLightsOnMaterial;                             // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      FrontLightsOffMaterial;                            // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      RearLightsOnMaterial;                              // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      RearLightsOffMaterial;                             // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SimplifiedLightsMaterialIndex;                     // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrontLeftLightsMaterialIndex;                      // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrontRightLightsMaterialIndex;                     // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RearLightsMaterialIndex;                           // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24AF[0x1C];                                    // 0x02E8(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLeftLightDestroyed;                               // 0x0304(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRightLightDestroyed;                              // 0x0305(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFrontLeftTireDestroyed;                           // 0x0306(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFrontRightTireDestroyed;                          // 0x0307(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRearLeftTireDestroyed;                            // 0x0308(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRearRightTireDestroyed;                           // 0x0309(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24B0[0x6];                                     // 0x030A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UDestructibleVehicleGlassComponent*, float> GlassHealthMap;                                    // 0x0310(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24B1[0x18];                                    // 0x0360(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   CarBody;                                           // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   AirBag;                                            // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        AirBagEffects;                                     // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   FrontLeftTire;                                     // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   FrontRightTire;                                    // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RearLeftTire;                                      // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RearRightTire;                                     // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       LeftLightCollision;                                // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       RightLightCollision;                               // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpotLightComponent*                    LeftHeadLight;                                     // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpotLightComponent*                    RightHeadLight;                                    // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    AlarmAudio;                                        // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void FlashHeadLights();
	void Multicast_BreakBodyPart(class UDestructibleVehicleBodyPart* BodyPart);
	void Multicast_BreakGlass(class UDestructibleVehicleGlassComponent* Glass);
	void Multicast_DeployCarFeatures(bool bAirbag, bool bCarAlarm, bool bDisableLeftLight, bool bDisableRightLight);
	void Multicast_PlayAudioEvent(class UFMODEvent* Event, const struct FVector_NetQuantize& Location);
	void Multicast_PlayTireDestroyedEffects(class UStaticMeshComponent* TireMesh);
	void Multicast_ShatterGlass(class UDestructibleVehicleGlassComponent* Glass);
	void StopCarAlarm();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleVehicle">();
	}
	static class ADestructibleVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADestructibleVehicle>();
	}
};
static_assert(alignof(ADestructibleVehicle) == 0x000008, "Wrong alignment on ADestructibleVehicle");
static_assert(sizeof(ADestructibleVehicle) == 0x0003D8, "Wrong size on ADestructibleVehicle");
static_assert(offsetof(ADestructibleVehicle, bComplexVehicle) == 0x000220, "Member 'ADestructibleVehicle::bComplexVehicle' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, bLightsOn) == 0x000221, "Member 'ADestructibleVehicle::bLightsOn' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, BodyImpactEvent) == 0x000228, "Member 'ADestructibleVehicle::BodyImpactEvent' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, BodyBreakEvent) == 0x000230, "Member 'ADestructibleVehicle::BodyBreakEvent' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, ChanceToCauseAlarmOnDamage) == 0x000238, "Member 'ADestructibleVehicle::ChanceToCauseAlarmOnDamage' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, AlarmPlayLength) == 0x00023C, "Member 'ADestructibleVehicle::AlarmPlayLength' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, AlarmHeadLightsFlashInterval) == 0x000240, "Member 'ADestructibleVehicle::AlarmHeadLightsFlashInterval' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, ChanceToCauseAirbagToDeployOnDamage) == 0x000244, "Member 'ADestructibleVehicle::ChanceToCauseAirbagToDeployOnDamage' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, AirbagParticle) == 0x000248, "Member 'ADestructibleVehicle::AirbagParticle' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, AirbagEvent) == 0x000250, "Member 'ADestructibleVehicle::AirbagEvent' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, GlassHealth) == 0x000258, "Member 'ADestructibleVehicle::GlassHealth' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, GlassDamageToApply) == 0x00025C, "Member 'ADestructibleVehicle::GlassDamageToApply' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RandomShatteredGlassMaterial) == 0x000260, "Member 'ADestructibleVehicle::RandomShatteredGlassMaterial' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, GlassImpactEvent) == 0x000270, "Member 'ADestructibleVehicle::GlassImpactEvent' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, GlassBreakEvent) == 0x000278, "Member 'ADestructibleVehicle::GlassBreakEvent' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RollAmountOnTireDamage) == 0x000280, "Member 'ADestructibleVehicle::RollAmountOnTireDamage' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, PitchAmountOnTireDamage) == 0x000284, "Member 'ADestructibleVehicle::PitchAmountOnTireDamage' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, SinkAmountOnTireDamage) == 0x000288, "Member 'ADestructibleVehicle::SinkAmountOnTireDamage' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, TireDeflationInterpSpeed) == 0x00028C, "Member 'ADestructibleVehicle::TireDeflationInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, TireDeflateEvent) == 0x000290, "Member 'ADestructibleVehicle::TireDeflateEvent' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, FlatTireMesh) == 0x000298, "Member 'ADestructibleVehicle::FlatTireMesh' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, bUseSimplifiedLights) == 0x0002A0, "Member 'ADestructibleVehicle::bUseSimplifiedLights' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, SimplifiedLightsOnMaterial) == 0x0002A8, "Member 'ADestructibleVehicle::SimplifiedLightsOnMaterial' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, SimplifiedLightsOffMaterial) == 0x0002B0, "Member 'ADestructibleVehicle::SimplifiedLightsOffMaterial' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, FrontLightsOnMaterial) == 0x0002B8, "Member 'ADestructibleVehicle::FrontLightsOnMaterial' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, FrontLightsOffMaterial) == 0x0002C0, "Member 'ADestructibleVehicle::FrontLightsOffMaterial' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RearLightsOnMaterial) == 0x0002C8, "Member 'ADestructibleVehicle::RearLightsOnMaterial' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RearLightsOffMaterial) == 0x0002D0, "Member 'ADestructibleVehicle::RearLightsOffMaterial' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, SimplifiedLightsMaterialIndex) == 0x0002D8, "Member 'ADestructibleVehicle::SimplifiedLightsMaterialIndex' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, FrontLeftLightsMaterialIndex) == 0x0002DC, "Member 'ADestructibleVehicle::FrontLeftLightsMaterialIndex' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, FrontRightLightsMaterialIndex) == 0x0002E0, "Member 'ADestructibleVehicle::FrontRightLightsMaterialIndex' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RearLightsMaterialIndex) == 0x0002E4, "Member 'ADestructibleVehicle::RearLightsMaterialIndex' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, bLeftLightDestroyed) == 0x000304, "Member 'ADestructibleVehicle::bLeftLightDestroyed' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, bRightLightDestroyed) == 0x000305, "Member 'ADestructibleVehicle::bRightLightDestroyed' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, bFrontLeftTireDestroyed) == 0x000306, "Member 'ADestructibleVehicle::bFrontLeftTireDestroyed' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, bFrontRightTireDestroyed) == 0x000307, "Member 'ADestructibleVehicle::bFrontRightTireDestroyed' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, bRearLeftTireDestroyed) == 0x000308, "Member 'ADestructibleVehicle::bRearLeftTireDestroyed' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, bRearRightTireDestroyed) == 0x000309, "Member 'ADestructibleVehicle::bRearRightTireDestroyed' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, GlassHealthMap) == 0x000310, "Member 'ADestructibleVehicle::GlassHealthMap' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, CarBody) == 0x000378, "Member 'ADestructibleVehicle::CarBody' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, AirBag) == 0x000380, "Member 'ADestructibleVehicle::AirBag' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, AirBagEffects) == 0x000388, "Member 'ADestructibleVehicle::AirBagEffects' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, FrontLeftTire) == 0x000390, "Member 'ADestructibleVehicle::FrontLeftTire' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, FrontRightTire) == 0x000398, "Member 'ADestructibleVehicle::FrontRightTire' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RearLeftTire) == 0x0003A0, "Member 'ADestructibleVehicle::RearLeftTire' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RearRightTire) == 0x0003A8, "Member 'ADestructibleVehicle::RearRightTire' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, LeftLightCollision) == 0x0003B0, "Member 'ADestructibleVehicle::LeftLightCollision' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RightLightCollision) == 0x0003B8, "Member 'ADestructibleVehicle::RightLightCollision' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, LeftHeadLight) == 0x0003C0, "Member 'ADestructibleVehicle::LeftHeadLight' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RightHeadLight) == 0x0003C8, "Member 'ADestructibleVehicle::RightHeadLight' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, AlarmAudio) == 0x0003D0, "Member 'ADestructibleVehicle::AlarmAudio' has a wrong offset!");

// Class ReadyOrNot.HealthComponent
// 0x0000 (0x0108 - 0x0108)
class UHealthComponent : public UResourceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthComponent">();
	}
	static class UHealthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthComponent>();
	}
};
static_assert(alignof(UHealthComponent) == 0x000008, "Wrong alignment on UHealthComponent");
static_assert(sizeof(UHealthComponent) == 0x000108, "Wrong size on UHealthComponent");

// Class ReadyOrNot.CharacterHealthComponent
// 0x0190 (0x0298 - 0x0108)
class UCharacterHealthComponent final  : public UHealthComponent
{
public:
	FMulticastInlineDelegateProperty_             OnLimbFullHealth;                                  // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLimbLowHealth;                                   // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLimbNoHealth;                                    // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLimbBroken;                                      // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLimbFullTickets;                                 // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLimbNoTickets;                                   // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EPlayerHealthStatus                           HealthStatus;                                      // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnableIncapacitation : 1;                         // 0x0169(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_24B3[0x2];                                     // 0x016A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IncapacitationHealthMultiplier;                    // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLimbHealthData                        RightLeg;                                          // 0x0170(0x0034)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLimbHealthData                        LeftLeg;                                           // 0x01A4(0x0034)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLimbHealthData                        RightArm;                                          // 0x01D8(0x0034)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLimbHealthData                        LeftArm;                                           // 0x020C(0x0034)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLimbHealthData                        Head;                                              // 0x0240(0x0034)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bUnlimitedRevives : 1;                             // 0x0274(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_24B4[0x3];                                     // 0x0275(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxRevives;                                        // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReviveTime;                                        // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReviveTimeDecrement;                               // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReviveOperatingTime;                               // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxReviveHealth;                                   // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RemainingRevives;                                  // 0x028C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RemainingReviveTime;                               // 0x0290(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RemainingReviveHealth;                             // 0x0294(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static bool IsLimbEqualTo(struct FLimbHealthData& InLimbHealthData, struct FLimbHealthData& OtherLimbHealthData);

	void DecreaseLimbHealth(ELimbType& Limb, float Amount);
	void DecreaseLimbTickets(ELimbType& Limb, int32 Amount);
	void DecreaseRevive();
	void DecreaseReviveHealth(float Amount);
	bool HalfMaxLimbHealth(ELimbType& Limb);
	void IncreaseLimbHealth(ELimbType& Limb, float Amount);
	void IncreaseLimbTickets(ELimbType& Limb, int32 Amount);
	void IncreaseRevive();
	void IncreaseReviveHealth(float Amount);
	void OnLimbBrokenSignature__DelegateSignature(ELimbType Limb);
	void OnLimbFullHealthSignature__DelegateSignature(ELimbType Limb);
	void OnLimbFullTicketsSignature__DelegateSignature(ELimbType Limb);
	void OnLimbLowHealthSignature__DelegateSignature(ELimbType AffectedLimb, float LimbHealth);
	void OnLimbNoHealthSignature__DelegateSignature(ELimbType Limb);
	void OnLimbNoTicketsRemainingSignature__DelegateSignature(ELimbType Limb);
	void ResetAllLimbHealth();
	void ResetAllLimbTickets();
	void ResetLimbHealth(ELimbType& Limb);
	void ResetLimbTickets(ELimbType& Limb);
	void ResetReviveHealth();
	void ResetRevives();
	void Server_DecreaseLimbHealth(ELimbType& Limb, float Amount);
	void Server_DecreaseLimbTickets(ELimbType& Limb, int32 Amount);
	void Server_DecreaseRevive();
	void Server_DecreaseReviveHealth(float Amount);
	void Server_HalfMaxLimbHealth(ELimbType& Limb);
	void Server_IncreaseLimbHealth(ELimbType& Limb, float Amount);
	void Server_IncreaseLimbTickets(ELimbType& Limb, int32 Amount);
	void Server_IncreaseRevive();
	void Server_IncreaseReviveHealth(float Amount);
	void Server_ResetAllLimbHealth();
	void Server_ResetAllLimbTickets();
	void Server_ResetLimbHealth(ELimbType& Limb);
	void Server_ResetLimbTickets(ELimbType& Limb);
	void Server_ResetReviveHealth();
	void Server_ResetRevives();
	void Server_SetCurrentLimbHealthToMax(ELimbType& Limb);
	void Server_SetHealthStatus(EPlayerHealthStatus NewHealthStatus);
	void Server_SetLimbHealth(ELimbType& Limb, float NewHealthAmount);
	void Server_SetMaxLimbHealth(ELimbType& Limb, float NewMaxHealth);
	void Server_SetRemainingRevives(int32 NewRemainingRevives);
	void Server_SetReviveHealth(float NewReviveHealth);
	void Server_UpdatePreviousLimbHealth(ELimbType& Limb);
	void Server_UseAllRemainingLimbTickets(ELimbType& Limb);
	void SetCurrentLimbHealthToMax(ELimbType& Limb);
	void SetHealthStatus(EPlayerHealthStatus NewHealthStatus);
	void SetLimbHealth(ELimbType& Limb, float NewHealthAmount);
	void SetMaxLimbHealth(ELimbType& Limb, float NewMaxHealth);
	void SetRemainingRevives(int32 NewRemainingRevives);
	void SetReviveHealth(float NewReviveHealth);
	void UpdatePreviousLimbHealth(ELimbType& Limb);
	void UseAllLimbTickets(ELimbType& Limb);

	bool CanUseReviveSystem() const;
	TArray<ELimbType> GetBrokenLimbs() const;
	struct FLimbHealthData GetHeadHealth_Copy() const;
	EPlayerHealthStatus GetHealthStatus() const;
	float GetIncapacitationHealthMultiplier() const;
	struct FLimbHealthData GetLeftArmHealth_Copy() const;
	struct FLimbHealthData GetLeftLegHealth_Copy() const;
	struct FLimbHealthData GetLimb_Copy(ELimbType& Limb) const;
	float GetMaxReviveHealth() const;
	int32 GetMaxRevives() const;
	float GetRemainingReviveHealth() const;
	int32 GetRemainingRevives() const;
	float GetRemainingReviveTime() const;
	float GetReviveOperatingTime() const;
	struct FLimbHealthData GetRightArmHealth_Copy() const;
	struct FLimbHealthData GetRightLegHealth_Copy() const;
	bool IsAnyLimbAtNoHealth(ELimbType* OutLimbType) const;
	bool IsAnyLimbBelowFullHealth(ELimbType* OutLimbType) const;
	bool IsAnyLimbBroken(ELimbType* OutLimbType) const;
	bool IsIncapacitated() const;
	bool IsIncapacitationEnabled() const;
	bool IsLimbBroken(ELimbType& Limb) const;
	bool IsLimbFullHealth(ELimbType& Limb) const;
	bool IsLimbHealthAbove(ELimbType& Limb, float HealthValue) const;
	bool IsLimbHealthAt(ELimbType& Limb, float HealthValue) const;
	bool IsLimbHealthAtOrAbove(ELimbType& Limb, float HealthValue) const;
	bool IsLimbHealthAtOrBelow(ELimbType& Limb, float HealthValue) const;
	bool IsLimbHealthBelow(ELimbType& Limb, float HealthValue) const;
	bool IsLimbLowHealth(ELimbType& Limb) const;
	bool IsLimbNoHealth(ELimbType& Limb) const;
	bool IsReviveHealthDepleted() const;
	bool IsUsingUnlimitedRevives() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterHealthComponent">();
	}
	static class UCharacterHealthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterHealthComponent>();
	}
};
static_assert(alignof(UCharacterHealthComponent) == 0x000008, "Wrong alignment on UCharacterHealthComponent");
static_assert(sizeof(UCharacterHealthComponent) == 0x000298, "Wrong size on UCharacterHealthComponent");
static_assert(offsetof(UCharacterHealthComponent, OnLimbFullHealth) == 0x000108, "Member 'UCharacterHealthComponent::OnLimbFullHealth' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, OnLimbLowHealth) == 0x000118, "Member 'UCharacterHealthComponent::OnLimbLowHealth' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, OnLimbNoHealth) == 0x000128, "Member 'UCharacterHealthComponent::OnLimbNoHealth' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, OnLimbBroken) == 0x000138, "Member 'UCharacterHealthComponent::OnLimbBroken' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, OnLimbFullTickets) == 0x000148, "Member 'UCharacterHealthComponent::OnLimbFullTickets' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, OnLimbNoTickets) == 0x000158, "Member 'UCharacterHealthComponent::OnLimbNoTickets' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, HealthStatus) == 0x000168, "Member 'UCharacterHealthComponent::HealthStatus' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, IncapacitationHealthMultiplier) == 0x00016C, "Member 'UCharacterHealthComponent::IncapacitationHealthMultiplier' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, RightLeg) == 0x000170, "Member 'UCharacterHealthComponent::RightLeg' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, LeftLeg) == 0x0001A4, "Member 'UCharacterHealthComponent::LeftLeg' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, RightArm) == 0x0001D8, "Member 'UCharacterHealthComponent::RightArm' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, LeftArm) == 0x00020C, "Member 'UCharacterHealthComponent::LeftArm' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, Head) == 0x000240, "Member 'UCharacterHealthComponent::Head' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, MaxRevives) == 0x000278, "Member 'UCharacterHealthComponent::MaxRevives' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, ReviveTime) == 0x00027C, "Member 'UCharacterHealthComponent::ReviveTime' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, ReviveTimeDecrement) == 0x000280, "Member 'UCharacterHealthComponent::ReviveTimeDecrement' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, ReviveOperatingTime) == 0x000284, "Member 'UCharacterHealthComponent::ReviveOperatingTime' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, MaxReviveHealth) == 0x000288, "Member 'UCharacterHealthComponent::MaxReviveHealth' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, RemainingRevives) == 0x00028C, "Member 'UCharacterHealthComponent::RemainingRevives' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, RemainingReviveTime) == 0x000290, "Member 'UCharacterHealthComponent::RemainingReviveTime' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, RemainingReviveHealth) == 0x000294, "Member 'UCharacterHealthComponent::RemainingReviveHealth' has a wrong offset!");

// Class ReadyOrNot.KickDoorActivity
// 0x0008 (0x0220 - 0x0218)
class UKickDoorActivity final  : public UDoorBreachActivity
{
public:
	uint8                                         Pad_24CE[0x8];                                     // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDoorKicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KickDoorActivity">();
	}
	static class UKickDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKickDoorActivity>();
	}
};
static_assert(alignof(UKickDoorActivity) == 0x000008, "Wrong alignment on UKickDoorActivity");
static_assert(sizeof(UKickDoorActivity) == 0x000220, "Wrong size on UKickDoorActivity");

// Class ReadyOrNot.ReactionInterestPoint
// 0x0008 (0x0228 - 0x0220)
class AReactionInterestPoint final  : public AActor
{
public:
	class UBillboardComponent*                    BillboardComponent;                                // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReactionInterestPoint">();
	}
	static class AReactionInterestPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReactionInterestPoint>();
	}
};
static_assert(alignof(AReactionInterestPoint) == 0x000008, "Wrong alignment on AReactionInterestPoint");
static_assert(sizeof(AReactionInterestPoint) == 0x000228, "Wrong size on AReactionInterestPoint");
static_assert(offsetof(AReactionInterestPoint, BillboardComponent) == 0x000220, "Member 'AReactionInterestPoint::BillboardComponent' has a wrong offset!");

// Class ReadyOrNot.LevelData
// 0x00F0 (0x0118 - 0x0028)
class ULevelData final  : public UObject
{
public:
	TSoftObjectPtr<class UWorld>                  LevelPreview;                                      // 0x0028(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocked;                                         // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24CF[0x3];                                     // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBasicLevelStats                       LevelStats;                                        // 0x0054(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   LevelName;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LevelFriendlyName;                                 // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LevelNickname;                                     // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              LevelImage;                                        // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LevelDescription;                                  // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LevelLocation;                                     // 0x00D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LevelTimeOfDay;                                    // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FEntryPoint>                    EntryPoints;                                       // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelData">();
	}
	static class ULevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelData>();
	}
};
static_assert(alignof(ULevelData) == 0x000008, "Wrong alignment on ULevelData");
static_assert(sizeof(ULevelData) == 0x000118, "Wrong size on ULevelData");
static_assert(offsetof(ULevelData, LevelPreview) == 0x000028, "Member 'ULevelData::LevelPreview' has a wrong offset!");
static_assert(offsetof(ULevelData, bIsLocked) == 0x000050, "Member 'ULevelData::bIsLocked' has a wrong offset!");
static_assert(offsetof(ULevelData, LevelStats) == 0x000054, "Member 'ULevelData::LevelStats' has a wrong offset!");
static_assert(offsetof(ULevelData, LevelName) == 0x000060, "Member 'ULevelData::LevelName' has a wrong offset!");
static_assert(offsetof(ULevelData, LevelFriendlyName) == 0x000068, "Member 'ULevelData::LevelFriendlyName' has a wrong offset!");
static_assert(offsetof(ULevelData, LevelNickname) == 0x000080, "Member 'ULevelData::LevelNickname' has a wrong offset!");
static_assert(offsetof(ULevelData, LevelImage) == 0x000098, "Member 'ULevelData::LevelImage' has a wrong offset!");
static_assert(offsetof(ULevelData, LevelDescription) == 0x0000C0, "Member 'ULevelData::LevelDescription' has a wrong offset!");
static_assert(offsetof(ULevelData, LevelLocation) == 0x0000D8, "Member 'ULevelData::LevelLocation' has a wrong offset!");
static_assert(offsetof(ULevelData, LevelTimeOfDay) == 0x0000F0, "Member 'ULevelData::LevelTimeOfDay' has a wrong offset!");
static_assert(offsetof(ULevelData, EntryPoints) == 0x000108, "Member 'ULevelData::EntryPoints' has a wrong offset!");

// Class ReadyOrNot.CharacterReactionVolume
// 0x00A8 (0x0300 - 0x0258)
class ACharacterReactionVolume final  : public AVolume
{
public:
	TArray<class FString>                         PossibleVoiceLines;                                // 0x0258(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseStealthVoiceLines;                             // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D0[0x7];                                     // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         PossibleStealthVoiceLines;                         // 0x0270(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseEligibleSpeakersOnly;                          // 0x0280(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D1[0x7];                                     // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         EligibleSpeakers;                                  // 0x0288(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseSpecificVoiceLines;                            // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D2[0x3];                                     // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InspectTimeBeforeReaction;                         // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenReactionAttempts;                       // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeWithoutCombat;                                 // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxReactions;                                      // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VolumeTag;                                         // 0x02AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwatOnly;                                         // 0x02B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D3[0x3];                                     // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReactionInterestPoint*>         InterestPoints;                                    // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           OverlappingCharacters;                             // 0x02C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24D4[0x28];                                    // 0x02D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttemptReaction();
	void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnTaggedVolumeTriggered(class ACharacterReactionVolume* Volume, class FName Tag);
	void PlayReaction(class AReadyOrNotCharacter* Character);
	void ReactionLengthReady(float Length);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterReactionVolume">();
	}
	static class ACharacterReactionVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterReactionVolume>();
	}
};
static_assert(alignof(ACharacterReactionVolume) == 0x000008, "Wrong alignment on ACharacterReactionVolume");
static_assert(sizeof(ACharacterReactionVolume) == 0x000300, "Wrong size on ACharacterReactionVolume");
static_assert(offsetof(ACharacterReactionVolume, PossibleVoiceLines) == 0x000258, "Member 'ACharacterReactionVolume::PossibleVoiceLines' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, bUseStealthVoiceLines) == 0x000268, "Member 'ACharacterReactionVolume::bUseStealthVoiceLines' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, PossibleStealthVoiceLines) == 0x000270, "Member 'ACharacterReactionVolume::PossibleStealthVoiceLines' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, bUseEligibleSpeakersOnly) == 0x000280, "Member 'ACharacterReactionVolume::bUseEligibleSpeakersOnly' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, EligibleSpeakers) == 0x000288, "Member 'ACharacterReactionVolume::EligibleSpeakers' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, bUseSpecificVoiceLines) == 0x000298, "Member 'ACharacterReactionVolume::bUseSpecificVoiceLines' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, InspectTimeBeforeReaction) == 0x00029C, "Member 'ACharacterReactionVolume::InspectTimeBeforeReaction' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, TimeBetweenReactionAttempts) == 0x0002A0, "Member 'ACharacterReactionVolume::TimeBetweenReactionAttempts' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, TimeWithoutCombat) == 0x0002A4, "Member 'ACharacterReactionVolume::TimeWithoutCombat' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, MaxReactions) == 0x0002A8, "Member 'ACharacterReactionVolume::MaxReactions' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, VolumeTag) == 0x0002AC, "Member 'ACharacterReactionVolume::VolumeTag' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, bSwatOnly) == 0x0002B4, "Member 'ACharacterReactionVolume::bSwatOnly' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, InterestPoints) == 0x0002B8, "Member 'ACharacterReactionVolume::InterestPoints' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, OverlappingCharacters) == 0x0002C8, "Member 'ACharacterReactionVolume::OverlappingCharacters' has a wrong offset!");

// Class ReadyOrNot.CharacterStatusWidget
// 0x0010 (0x0330 - 0x0320)
class UCharacterStatusWidget : public UCommonActivatableWidget
{
public:
	TArray<class UCharacterProxy*>                CharacterProxies;                                  // 0x0320(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	const TArray<class UCharacterProxy*> GetCharacterProxies();
	void OnCharacterAdded(class UCharacterProxy* CharacterProxy);
	void OnCharacterRemoved(class UCharacterProxy* CharacterProxy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStatusWidget">();
	}
	static class UCharacterStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStatusWidget>();
	}
};
static_assert(alignof(UCharacterStatusWidget) == 0x000008, "Wrong alignment on UCharacterStatusWidget");
static_assert(sizeof(UCharacterStatusWidget) == 0x000330, "Wrong size on UCharacterStatusWidget");
static_assert(offsetof(UCharacterStatusWidget, CharacterProxies) == 0x000320, "Member 'UCharacterStatusWidget::CharacterProxies' has a wrong offset!");

// Class ReadyOrNot.PepperGasCloud
// 0x0020 (0x0240 - 0x0220)
class APepperGasCloud : public AActor
{
public:
	uint8                                         Pad_24D5[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               GasParticleSystem;                                 // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GasRadius;                                         // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGasPoints;                                      // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D6[0x4];                                     // 0x023C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PepperGasCloud">();
	}
	static class APepperGasCloud* GetDefaultObj()
	{
		return GetDefaultObjImpl<APepperGasCloud>();
	}
};
static_assert(alignof(APepperGasCloud) == 0x000008, "Wrong alignment on APepperGasCloud");
static_assert(sizeof(APepperGasCloud) == 0x000240, "Wrong size on APepperGasCloud");
static_assert(offsetof(APepperGasCloud, GasParticleSystem) == 0x000228, "Member 'APepperGasCloud::GasParticleSystem' has a wrong offset!");
static_assert(offsetof(APepperGasCloud, GasRadius) == 0x000230, "Member 'APepperGasCloud::GasRadius' has a wrong offset!");
static_assert(offsetof(APepperGasCloud, LifeTime) == 0x000234, "Member 'APepperGasCloud::LifeTime' has a wrong offset!");
static_assert(offsetof(APepperGasCloud, MaxGasPoints) == 0x000238, "Member 'APepperGasCloud::MaxGasPoints' has a wrong offset!");

// Class ReadyOrNot.CharacterProxy
// 0x0020 (0x0048 - 0x0028)
class UCharacterProxy : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnStatusUpdated;                                   // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLoadoutUpdated;                                  // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class FText GetFirstName();
	float GetHealth();
	TSoftObjectPtr<class UTexture2D> GetImage();
	struct FRosterLoadout GetLoadout();
	class FText GetName();
	int32 GetNumber();
	class FText GetStatus();
	ETeamType GetTeam();
	class URosterTrait* GetTrait(bool* bIsUnlocked);
	bool IsLocalPlayer();
	bool IsPlayer();
	void OnCharacterUpdated__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterProxy">();
	}
	static class UCharacterProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterProxy>();
	}
};
static_assert(alignof(UCharacterProxy) == 0x000008, "Wrong alignment on UCharacterProxy");
static_assert(sizeof(UCharacterProxy) == 0x000048, "Wrong size on UCharacterProxy");
static_assert(offsetof(UCharacterProxy, OnStatusUpdated) == 0x000028, "Member 'UCharacterProxy::OnStatusUpdated' has a wrong offset!");
static_assert(offsetof(UCharacterProxy, OnLoadoutUpdated) == 0x000038, "Member 'UCharacterProxy::OnLoadoutUpdated' has a wrong offset!");

// Class ReadyOrNot.LaunchGrenadeThroughDoorActivity
// 0x0018 (0x0230 - 0x0218)
class ULaunchGrenadeThroughDoorActivity final  : public UDoorBreachActivity
{
public:
	FMulticastInlineDelegateProperty_             OnLauncherReady;                                   // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D8[0x8];                                     // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LaunchGrenadeThroughDoorActivity">();
	}
	static class ULaunchGrenadeThroughDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULaunchGrenadeThroughDoorActivity>();
	}
};
static_assert(alignof(ULaunchGrenadeThroughDoorActivity) == 0x000008, "Wrong alignment on ULaunchGrenadeThroughDoorActivity");
static_assert(sizeof(ULaunchGrenadeThroughDoorActivity) == 0x000230, "Wrong size on ULaunchGrenadeThroughDoorActivity");
static_assert(offsetof(ULaunchGrenadeThroughDoorActivity, OnLauncherReady) == 0x000218, "Member 'ULaunchGrenadeThroughDoorActivity::OnLauncherReady' has a wrong offset!");

// Class ReadyOrNot.Headwear
// 0x0B30 (0x1570 - 0x0A40)
#pragma pack(push, 0x1)
class alignas(0x10) AHeadwear : public ABaseArmour
{
public:
	bool                                          bHasHelmet;                                        // 0x0A40(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D9[0x3];                                     // 0x0A41(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Durability;                                        // 0x0A44(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReduction;                                   // 0x0A48(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RicochetChance;                                    // 0x0A4C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             RicochetEvent;                                     // 0x0A50(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProtectsAgainstInstantKnockout;                   // 0x0A58(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMaskVoiceFilter;                               // 0x0A59(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24DA[0x6];                                     // 0x0A5A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             VoiceLineEventOverrideSpatalized;                  // 0x0A60(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             VoiceLineEventOverrideLocal;                       // 0x0A68(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                MaskOverlay;                                       // 0x0A70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnablePostProcess;                                // 0x0A78(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24DB[0x7];                                     // 0x0A79(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   MaskPostProcess;                                   // 0x0A80(0x0560)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPostProcessSettings                   MaskSupressionPostProcess;                         // 0x0FE0(0x0560)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bOverrideBreathingSound;                           // 0x1540(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24DC[0x7];                                     // 0x1541(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundCue*>                      OverriddenBreathingSounds;                         // 0x1548(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         GapBetweenBreaths;                                 // 0x1558(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnedOverlay;                                   // 0x155C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24DD[0x3];                                     // 0x155D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            SpawnedMaskOverlay;                                // 0x1560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Headwear">();
	}
	static class AHeadwear* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHeadwear>();
	}
};
#pragma pack(pop)
static_assert(alignof(AHeadwear) == 0x000010, "Wrong alignment on AHeadwear");
static_assert(sizeof(AHeadwear) == 0x001570, "Wrong size on AHeadwear");
static_assert(offsetof(AHeadwear, bHasHelmet) == 0x000A40, "Member 'AHeadwear::bHasHelmet' has a wrong offset!");
static_assert(offsetof(AHeadwear, Durability) == 0x000A44, "Member 'AHeadwear::Durability' has a wrong offset!");
static_assert(offsetof(AHeadwear, DamageReduction) == 0x000A48, "Member 'AHeadwear::DamageReduction' has a wrong offset!");
static_assert(offsetof(AHeadwear, RicochetChance) == 0x000A4C, "Member 'AHeadwear::RicochetChance' has a wrong offset!");
static_assert(offsetof(AHeadwear, RicochetEvent) == 0x000A50, "Member 'AHeadwear::RicochetEvent' has a wrong offset!");
static_assert(offsetof(AHeadwear, bProtectsAgainstInstantKnockout) == 0x000A58, "Member 'AHeadwear::bProtectsAgainstInstantKnockout' has a wrong offset!");
static_assert(offsetof(AHeadwear, bUseMaskVoiceFilter) == 0x000A59, "Member 'AHeadwear::bUseMaskVoiceFilter' has a wrong offset!");
static_assert(offsetof(AHeadwear, VoiceLineEventOverrideSpatalized) == 0x000A60, "Member 'AHeadwear::VoiceLineEventOverrideSpatalized' has a wrong offset!");
static_assert(offsetof(AHeadwear, VoiceLineEventOverrideLocal) == 0x000A68, "Member 'AHeadwear::VoiceLineEventOverrideLocal' has a wrong offset!");
static_assert(offsetof(AHeadwear, MaskOverlay) == 0x000A70, "Member 'AHeadwear::MaskOverlay' has a wrong offset!");
static_assert(offsetof(AHeadwear, bEnablePostProcess) == 0x000A78, "Member 'AHeadwear::bEnablePostProcess' has a wrong offset!");
static_assert(offsetof(AHeadwear, MaskPostProcess) == 0x000A80, "Member 'AHeadwear::MaskPostProcess' has a wrong offset!");
static_assert(offsetof(AHeadwear, MaskSupressionPostProcess) == 0x000FE0, "Member 'AHeadwear::MaskSupressionPostProcess' has a wrong offset!");
static_assert(offsetof(AHeadwear, bOverrideBreathingSound) == 0x001540, "Member 'AHeadwear::bOverrideBreathingSound' has a wrong offset!");
static_assert(offsetof(AHeadwear, OverriddenBreathingSounds) == 0x001548, "Member 'AHeadwear::OverriddenBreathingSounds' has a wrong offset!");
static_assert(offsetof(AHeadwear, GapBetweenBreaths) == 0x001558, "Member 'AHeadwear::GapBetweenBreaths' has a wrong offset!");
static_assert(offsetof(AHeadwear, bSpawnedOverlay) == 0x00155C, "Member 'AHeadwear::bSpawnedOverlay' has a wrong offset!");
static_assert(offsetof(AHeadwear, SpawnedMaskOverlay) == 0x001560, "Member 'AHeadwear::SpawnedMaskOverlay' has a wrong offset!");

// Class ReadyOrNot.NightvisionGoggles
// 0x05B0 (0x1B20 - 0x1570)
class ANightvisionGoggles : public AHeadwear
{
public:
	class UUserWidget*                            SpawnedWidget;                                     // 0x1568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Green_LUT;                                         // 0x1570(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             White_LUT;                                         // 0x1578(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           GlobalMaterialParameters;                          // 0x1580(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NVGGlobalParameterName;                            // 0x1588(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                NightVisionFirstPersonWidget;                      // 0x1590(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24DE[0x8];                                     // 0x1598(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   NightVisionPostProcess;                            // 0x15A0(0x0560)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bNVGOn;                                            // 0x1B00(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTogglingNVG;                                      // 0x1B01(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24DF[0x6];                                     // 0x1B02(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UDamageType>>        BlockDamageTypesWhileActive;                       // 0x1B08(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_24E0[0x8];                                     // 0x1B18(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyNightvisionWidget();
	void OnNightvisionActivated();
	void OnNightvisionDeactivated();
	void Server_SetTogglingNVG(bool bNewTogglingNVG);
	void SpawnNightvisionWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NightvisionGoggles">();
	}
	static class ANightvisionGoggles* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANightvisionGoggles>();
	}
};
static_assert(alignof(ANightvisionGoggles) == 0x000010, "Wrong alignment on ANightvisionGoggles");
static_assert(sizeof(ANightvisionGoggles) == 0x001B20, "Wrong size on ANightvisionGoggles");
static_assert(offsetof(ANightvisionGoggles, SpawnedWidget) == 0x001568, "Member 'ANightvisionGoggles::SpawnedWidget' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, Green_LUT) == 0x001570, "Member 'ANightvisionGoggles::Green_LUT' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, White_LUT) == 0x001578, "Member 'ANightvisionGoggles::White_LUT' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, GlobalMaterialParameters) == 0x001580, "Member 'ANightvisionGoggles::GlobalMaterialParameters' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, NVGGlobalParameterName) == 0x001588, "Member 'ANightvisionGoggles::NVGGlobalParameterName' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, NightVisionFirstPersonWidget) == 0x001590, "Member 'ANightvisionGoggles::NightVisionFirstPersonWidget' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, NightVisionPostProcess) == 0x0015A0, "Member 'ANightvisionGoggles::NightVisionPostProcess' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, bNVGOn) == 0x001B00, "Member 'ANightvisionGoggles::bNVGOn' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, bTogglingNVG) == 0x001B01, "Member 'ANightvisionGoggles::bTogglingNVG' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, BlockDamageTypesWhileActive) == 0x001B08, "Member 'ANightvisionGoggles::BlockDamageTypesWhileActive' has a wrong offset!");

// Class ReadyOrNot.PlayerCharacterProxy
// 0x0008 (0x0050 - 0x0048)
class UPlayerCharacterProxy final  : public UCharacterProxy
{
public:
	class APlayerState*                           PlayerState;                                       // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCharacterProxy">();
	}
	static class UPlayerCharacterProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCharacterProxy>();
	}
};
static_assert(alignof(UPlayerCharacterProxy) == 0x000008, "Wrong alignment on UPlayerCharacterProxy");
static_assert(sizeof(UPlayerCharacterProxy) == 0x000050, "Wrong size on UPlayerCharacterProxy");
static_assert(offsetof(UPlayerCharacterProxy, PlayerState) == 0x000048, "Member 'UPlayerCharacterProxy::PlayerState' has a wrong offset!");

// Class ReadyOrNot.CoopCharacterProxy
// 0x0008 (0x0050 - 0x0048)
class UCoopCharacterProxy final  : public UCharacterProxy
{
public:
	class ASWATCharacter*                         SWATCharacter;                                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoopCharacterProxy">();
	}
	static class UCoopCharacterProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoopCharacterProxy>();
	}
};
static_assert(alignof(UCoopCharacterProxy) == 0x000008, "Wrong alignment on UCoopCharacterProxy");
static_assert(sizeof(UCoopCharacterProxy) == 0x000050, "Wrong size on UCoopCharacterProxy");
static_assert(offsetof(UCoopCharacterProxy, SWATCharacter) == 0x000048, "Member 'UCoopCharacterProxy::SWATCharacter' has a wrong offset!");

// Class ReadyOrNot.DoorBlockerVolume
// 0x0010 (0x0230 - 0x0220)
class ADoorBlockerVolume final  : public AActor
{
public:
	class UBoxComponent*                          Bounds;                                            // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNavModifierComponent*                  NavModifierComponent;                              // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorBlockerVolume">();
	}
	static class ADoorBlockerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoorBlockerVolume>();
	}
};
static_assert(alignof(ADoorBlockerVolume) == 0x000008, "Wrong alignment on ADoorBlockerVolume");
static_assert(sizeof(ADoorBlockerVolume) == 0x000230, "Wrong size on ADoorBlockerVolume");
static_assert(offsetof(ADoorBlockerVolume, Bounds) == 0x000220, "Member 'ADoorBlockerVolume::Bounds' has a wrong offset!");
static_assert(offsetof(ADoorBlockerVolume, NavModifierComponent) == 0x000228, "Member 'ADoorBlockerVolume::NavModifierComponent' has a wrong offset!");

// Class ReadyOrNot.ChargeCombatMove
// 0x0000 (0x01D8 - 0x01D8)
class UChargeCombatMove final  : public UBaseCombatMoveActivity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeCombatMove">();
	}
	static class UChargeCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeCombatMove>();
	}
};
static_assert(alignof(UChargeCombatMove) == 0x000008, "Wrong alignment on UChargeCombatMove");
static_assert(sizeof(UChargeCombatMove) == 0x0001D8, "Wrong size on UChargeCombatMove");

// Class ReadyOrNot.CheckpointActivityTriggerVolume
// 0x0000 (0x02D8 - 0x02D8)
class ACheckpointActivityTriggerVolume final  : public AActivityTriggerVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckpointActivityTriggerVolume">();
	}
	static class ACheckpointActivityTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACheckpointActivityTriggerVolume>();
	}
};
static_assert(alignof(ACheckpointActivityTriggerVolume) == 0x000008, "Wrong alignment on ACheckpointActivityTriggerVolume");
static_assert(sizeof(ACheckpointActivityTriggerVolume) == 0x0002D8, "Wrong size on ACheckpointActivityTriggerVolume");

// Class ReadyOrNot.OnlineActivityManager
// 0x0030 (0x0058 - 0x0028)
class UOnlineActivityManager final  : public UObject
{
public:
	uint8                                         Pad_24E1[0x30];                                    // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineActivityManager">();
	}
	static class UOnlineActivityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineActivityManager>();
	}
};
static_assert(alignof(UOnlineActivityManager) == 0x000008, "Wrong alignment on UOnlineActivityManager");
static_assert(sizeof(UOnlineActivityManager) == 0x000058, "Wrong size on UOnlineActivityManager");

// Class ReadyOrNot.CSGasDamageType
// 0x0000 (0x0620 - 0x0620)
class UCSGasDamageType : public UStunDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGasDamageType">();
	}
	static class UCSGasDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGasDamageType>();
	}
};
static_assert(alignof(UCSGasDamageType) == 0x000010, "Wrong alignment on UCSGasDamageType");
static_assert(sizeof(UCSGasDamageType) == 0x000620, "Wrong size on UCSGasDamageType");

// Class ReadyOrNot.Chemlight
// 0x0040 (0x0A10 - 0x09D0)
class AChemlight : public ABaseItem
{
public:
	uint8                                         Pad_24E2[0x10];                                    // 0x09D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAmmoComponent*                         Ammo;                                              // 0x09E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketSpawnName;                                   // 0x09E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24E3[0x20];                                    // 0x09F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelThrow();
	void Multicast_SpawnThrownChemlight();
	void NormalThrow();
	void OnChemlightThrown();
	void QuickThrow();
	void Server_SpawnThrownChemlight();
	void SetFPMeshHidden(bool bFPMeshHidden);

	bool CanThrow() const;
	int32 GetRemainingAmmo() const;
	bool IsPlayingChemlightThrowAnimations() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Chemlight">();
	}
	static class AChemlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChemlight>();
	}
};
static_assert(alignof(AChemlight) == 0x000010, "Wrong alignment on AChemlight");
static_assert(sizeof(AChemlight) == 0x000A10, "Wrong size on AChemlight");
static_assert(offsetof(AChemlight, Ammo) == 0x0009E0, "Member 'AChemlight::Ammo' has a wrong offset!");
static_assert(offsetof(AChemlight, SocketSpawnName) == 0x0009E8, "Member 'AChemlight::SocketSpawnName' has a wrong offset!");

// Class ReadyOrNot.ScriptedDialogue
// 0x0060 (0x0090 - 0x0030)
class UScriptedDialogue final  : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             DialogueFinished;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AReadyOrNotCharacter*                   Character;                                         // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundSource*                           VoiceSoundSource;                                  // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24E4[0x38];                                    // 0x0058(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UScriptedDialogue* Start2DScriptedDialogue(class UObject* Param_WorldContextObject, class UFMODEvent* Event, const class FString& Speaker, const class FString& VoiceLine, class FName SpeakerTag);
	static class UScriptedDialogue* StartCharacterScriptedDialogue(class AReadyOrNotCharacter* Param_Character, const class FString& VoiceLine);

	void HandleDialogueFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptedDialogue">();
	}
	static class UScriptedDialogue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptedDialogue>();
	}
};
static_assert(alignof(UScriptedDialogue) == 0x000008, "Wrong alignment on UScriptedDialogue");
static_assert(sizeof(UScriptedDialogue) == 0x000090, "Wrong size on UScriptedDialogue");
static_assert(offsetof(UScriptedDialogue, DialogueFinished) == 0x000030, "Member 'UScriptedDialogue::DialogueFinished' has a wrong offset!");
static_assert(offsetof(UScriptedDialogue, WorldContextObject) == 0x000040, "Member 'UScriptedDialogue::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UScriptedDialogue, Character) == 0x000048, "Member 'UScriptedDialogue::Character' has a wrong offset!");
static_assert(offsetof(UScriptedDialogue, VoiceSoundSource) == 0x000050, "Member 'UScriptedDialogue::VoiceSoundSource' has a wrong offset!");

// Class ReadyOrNot.DynamicInteractableWorldItem
// 0x00A0 (0x02C0 - 0x0220)
class ADynamicInteractableWorldItem final  : public AActor
{
public:
	uint8                                         Pad_24E5[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRestartOnToggle;                                  // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanToggleIfDestroyed;                             // 0x0229(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bItemOn;                                           // 0x022A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bItemDestroyed;                                    // 0x022B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24E6[0x4];                                     // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 InteractableComponent;                             // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    InteractAudioFMOD;                                 // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    IntactRunningAudioFMOD1;                           // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    DestroyedRunningAudioFMOD;                         // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    ImpactAudioFMOD;                                   // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             IntactOnMaterials;                                 // 0x0258(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             IntactOffMaterials;                                // 0x0268(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             DestroyedOnMaterials;                              // 0x0278(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             DestroyedOffMaterials;                             // 0x0288(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ItemMesh;                                          // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            PostDestructionMesh;                               // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ImpactParticle;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PhysicsImpactDecal;                                // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PhysicsImpactDecalScale;                           // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24E7[0x4];                                     // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_DestroyItem();
	void Multicast_ItemStateToggle();
	void OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, struct FHitResult& Hit);
	void OnItemDestroyed();
	void OnItemStateToggled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicInteractableWorldItem">();
	}
	static class ADynamicInteractableWorldItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicInteractableWorldItem>();
	}
};
static_assert(alignof(ADynamicInteractableWorldItem) == 0x000008, "Wrong alignment on ADynamicInteractableWorldItem");
static_assert(sizeof(ADynamicInteractableWorldItem) == 0x0002C0, "Wrong size on ADynamicInteractableWorldItem");
static_assert(offsetof(ADynamicInteractableWorldItem, bRestartOnToggle) == 0x000228, "Member 'ADynamicInteractableWorldItem::bRestartOnToggle' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, bCanToggleIfDestroyed) == 0x000229, "Member 'ADynamicInteractableWorldItem::bCanToggleIfDestroyed' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, bItemOn) == 0x00022A, "Member 'ADynamicInteractableWorldItem::bItemOn' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, bItemDestroyed) == 0x00022B, "Member 'ADynamicInteractableWorldItem::bItemDestroyed' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, InteractableComponent) == 0x000230, "Member 'ADynamicInteractableWorldItem::InteractableComponent' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, InteractAudioFMOD) == 0x000238, "Member 'ADynamicInteractableWorldItem::InteractAudioFMOD' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, IntactRunningAudioFMOD1) == 0x000240, "Member 'ADynamicInteractableWorldItem::IntactRunningAudioFMOD1' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, DestroyedRunningAudioFMOD) == 0x000248, "Member 'ADynamicInteractableWorldItem::DestroyedRunningAudioFMOD' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, ImpactAudioFMOD) == 0x000250, "Member 'ADynamicInteractableWorldItem::ImpactAudioFMOD' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, IntactOnMaterials) == 0x000258, "Member 'ADynamicInteractableWorldItem::IntactOnMaterials' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, IntactOffMaterials) == 0x000268, "Member 'ADynamicInteractableWorldItem::IntactOffMaterials' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, DestroyedOnMaterials) == 0x000278, "Member 'ADynamicInteractableWorldItem::DestroyedOnMaterials' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, DestroyedOffMaterials) == 0x000288, "Member 'ADynamicInteractableWorldItem::DestroyedOffMaterials' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, ItemMesh) == 0x000298, "Member 'ADynamicInteractableWorldItem::ItemMesh' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, PostDestructionMesh) == 0x0002A0, "Member 'ADynamicInteractableWorldItem::PostDestructionMesh' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, ImpactParticle) == 0x0002A8, "Member 'ADynamicInteractableWorldItem::ImpactParticle' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, PhysicsImpactDecal) == 0x0002B0, "Member 'ADynamicInteractableWorldItem::PhysicsImpactDecal' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, PhysicsImpactDecalScale) == 0x0002B8, "Member 'ADynamicInteractableWorldItem::PhysicsImpactDecalScale' has a wrong offset!");

// Class ReadyOrNot.CivilianCharacter
// 0x0000 (0x1F90 - 0x1F90)
class ACivilianCharacter : public ACyberneticCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CivilianCharacter">();
	}
	static class ACivilianCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACivilianCharacter>();
	}
};
static_assert(alignof(ACivilianCharacter) == 0x000010, "Wrong alignment on ACivilianCharacter");
static_assert(sizeof(ACivilianCharacter) == 0x001F90, "Wrong size on ACivilianCharacter");

// Class ReadyOrNot.CTF_Flag
// 0x0028 (0x0248 - 0x0220)
class ACTF_Flag final  : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   FlagMeshComponent;                                 // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          CaptureBoxComponent;                               // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectiveMarkerComponent*              ObjectiveMarkerComponent;                          // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BoneToAttach;                                      // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFlagBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void ResetFlagTransforms();

	class FName GetBoneToAttachName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CTF_Flag">();
	}
	static class ACTF_Flag* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACTF_Flag>();
	}
};
static_assert(alignof(ACTF_Flag) == 0x000008, "Wrong alignment on ACTF_Flag");
static_assert(sizeof(ACTF_Flag) == 0x000248, "Wrong size on ACTF_Flag");
static_assert(offsetof(ACTF_Flag, SceneComponent) == 0x000220, "Member 'ACTF_Flag::SceneComponent' has a wrong offset!");
static_assert(offsetof(ACTF_Flag, FlagMeshComponent) == 0x000228, "Member 'ACTF_Flag::FlagMeshComponent' has a wrong offset!");
static_assert(offsetof(ACTF_Flag, CaptureBoxComponent) == 0x000230, "Member 'ACTF_Flag::CaptureBoxComponent' has a wrong offset!");
static_assert(offsetof(ACTF_Flag, ObjectiveMarkerComponent) == 0x000238, "Member 'ACTF_Flag::ObjectiveMarkerComponent' has a wrong offset!");
static_assert(offsetof(ACTF_Flag, BoneToAttach) == 0x000240, "Member 'ACTF_Flag::BoneToAttach' has a wrong offset!");

// Class ReadyOrNot.CivilianCombatActivity
// 0x0008 (0x0428 - 0x0420)
class UCivilianCombatActivity final  : public UBaseCombatActivity
{
public:
	class UCivilianFleeCombatMove*                CivilianFleeCombatMove;                            // 0x0420(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CivilianCombatActivity">();
	}
	static class UCivilianCombatActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCivilianCombatActivity>();
	}
};
static_assert(alignof(UCivilianCombatActivity) == 0x000008, "Wrong alignment on UCivilianCombatActivity");
static_assert(sizeof(UCivilianCombatActivity) == 0x000428, "Wrong size on UCivilianCombatActivity");
static_assert(offsetof(UCivilianCombatActivity, CivilianFleeCombatMove) == 0x000420, "Member 'UCivilianCombatActivity::CivilianFleeCombatMove' has a wrong offset!");

// Class ReadyOrNot.DropWeaponAnimNotify
// 0x0000 (0x0038 - 0x0038)
class UDropWeaponAnimNotify final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropWeaponAnimNotify">();
	}
	static class UDropWeaponAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDropWeaponAnimNotify>();
	}
};
static_assert(alignof(UDropWeaponAnimNotify) == 0x000008, "Wrong alignment on UDropWeaponAnimNotify");
static_assert(sizeof(UDropWeaponAnimNotify) == 0x000038, "Wrong size on UDropWeaponAnimNotify");

// Class ReadyOrNot.CivilianController
// 0x0000 (0x08D8 - 0x08D8)
class ACivilianController : public ACyberneticController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CivilianController">();
	}
	static class ACivilianController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACivilianController>();
	}
};
static_assert(alignof(ACivilianController) == 0x000008, "Wrong alignment on ACivilianController");
static_assert(sizeof(ACivilianController) == 0x0008D8, "Wrong size on ACivilianController");

// Class ReadyOrNot.NavigationSplinePathPreview
// 0x0080 (0x02A0 - 0x0220)
class ANavigationSplinePathPreview final  : public AActor
{
public:
	float                                         PathPointDistanceThreshold;                        // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PathPointSubStep;                                  // 0x0224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDrawRawPath : 1;                                  // 0x0228(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawRawPathPoints : 1;                            // 0x0228(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawSmoothedPath : 1;                             // 0x0228(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawSmoothedPathPoints : 1;                       // 0x0228(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawSmoothedPathPointsDetail : 1;                 // 0x0228(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_24EA[0x3];                                     // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathLineThickness;                                 // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24EB[0x70];                                    // 0x0230(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationSplinePathPreview">();
	}
	static class ANavigationSplinePathPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavigationSplinePathPreview>();
	}
};
static_assert(alignof(ANavigationSplinePathPreview) == 0x000008, "Wrong alignment on ANavigationSplinePathPreview");
static_assert(sizeof(ANavigationSplinePathPreview) == 0x0002A0, "Wrong size on ANavigationSplinePathPreview");
static_assert(offsetof(ANavigationSplinePathPreview, PathPointDistanceThreshold) == 0x000220, "Member 'ANavigationSplinePathPreview::PathPointDistanceThreshold' has a wrong offset!");
static_assert(offsetof(ANavigationSplinePathPreview, PathPointSubStep) == 0x000224, "Member 'ANavigationSplinePathPreview::PathPointSubStep' has a wrong offset!");
static_assert(offsetof(ANavigationSplinePathPreview, PathLineThickness) == 0x00022C, "Member 'ANavigationSplinePathPreview::PathLineThickness' has a wrong offset!");

// Class ReadyOrNot.CivilianFleeCombatMove
// 0x0008 (0x01E0 - 0x01D8)
class UCivilianFleeCombatMove final  : public UBaseCombatMoveActivity
{
public:
	uint8                                         Pad_24EC[0x8];                                     // 0x01D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CivilianFleeCombatMove">();
	}
	static class UCivilianFleeCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCivilianFleeCombatMove>();
	}
};
static_assert(alignof(UCivilianFleeCombatMove) == 0x000008, "Wrong alignment on UCivilianFleeCombatMove");
static_assert(sizeof(UCivilianFleeCombatMove) == 0x0001E0, "Wrong size on UCivilianFleeCombatMove");

// Class ReadyOrNot.EnvQueryContext_GasSources
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_GasSources final  : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_GasSources">();
	}
	static class UEnvQueryContext_GasSources* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_GasSources>();
	}
};
static_assert(alignof(UEnvQueryContext_GasSources) == 0x000008, "Wrong alignment on UEnvQueryContext_GasSources");
static_assert(sizeof(UEnvQueryContext_GasSources) == 0x000028, "Wrong size on UEnvQueryContext_GasSources");

// Class ReadyOrNot.ClearWeaponAnimNotify
// 0x0000 (0x0038 - 0x0038)
class UClearWeaponAnimNotify final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClearWeaponAnimNotify">();
	}
	static class UClearWeaponAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClearWeaponAnimNotify>();
	}
};
static_assert(alignof(UClearWeaponAnimNotify) == 0x000008, "Wrong alignment on UClearWeaponAnimNotify");
static_assert(sizeof(UClearWeaponAnimNotify) == 0x000038, "Wrong size on UClearWeaponAnimNotify");

// Class ReadyOrNot.Collectable
// 0x0058 (0x0278 - 0x0220)
class ACollectable final  : public AActor
{
public:
	uint8                                         Pad_24ED[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemName;                                          // 0x0228(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ItemDescription;                                   // 0x0240(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FName>                           RequiredTags;                                      // 0x0258(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UProgressionRequirement*>        RequiredProgression;                               // 0x0268(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Collectable">();
	}
	static class ACollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectable>();
	}
};
static_assert(alignof(ACollectable) == 0x000008, "Wrong alignment on ACollectable");
static_assert(sizeof(ACollectable) == 0x000278, "Wrong size on ACollectable");
static_assert(offsetof(ACollectable, ItemName) == 0x000228, "Member 'ACollectable::ItemName' has a wrong offset!");
static_assert(offsetof(ACollectable, ItemDescription) == 0x000240, "Member 'ACollectable::ItemDescription' has a wrong offset!");
static_assert(offsetof(ACollectable, RequiredTags) == 0x000258, "Member 'ACollectable::RequiredTags' has a wrong offset!");
static_assert(offsetof(ACollectable, RequiredProgression) == 0x000268, "Member 'ACollectable::RequiredProgression' has a wrong offset!");

// Class ReadyOrNot.DynamicWorldItem
// 0x0038 (0x0258 - 0x0220)
class ADynamicWorldItem final  : public AActor
{
public:
	class UStaticMeshComponent*                   ItemMesh;                                          // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ImpactParticle;                                    // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    ImpactAudioFMOD;                                   // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            PostImpactMesh;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PostImpactMaterial;                                // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PhysicsImpactDecal;                                // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PhysicsImpactDecalScale;                           // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bItemDestroyed;                                    // 0x0254(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24EE[0x3];                                     // 0x0255(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_DestroyItem();
	void OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, struct FHitResult& Hit);
	void OnItemDestroyed();
	void OnRep_ItemDestroyed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicWorldItem">();
	}
	static class ADynamicWorldItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicWorldItem>();
	}
};
static_assert(alignof(ADynamicWorldItem) == 0x000008, "Wrong alignment on ADynamicWorldItem");
static_assert(sizeof(ADynamicWorldItem) == 0x000258, "Wrong size on ADynamicWorldItem");
static_assert(offsetof(ADynamicWorldItem, ItemMesh) == 0x000220, "Member 'ADynamicWorldItem::ItemMesh' has a wrong offset!");
static_assert(offsetof(ADynamicWorldItem, ImpactParticle) == 0x000228, "Member 'ADynamicWorldItem::ImpactParticle' has a wrong offset!");
static_assert(offsetof(ADynamicWorldItem, ImpactAudioFMOD) == 0x000230, "Member 'ADynamicWorldItem::ImpactAudioFMOD' has a wrong offset!");
static_assert(offsetof(ADynamicWorldItem, PostImpactMesh) == 0x000238, "Member 'ADynamicWorldItem::PostImpactMesh' has a wrong offset!");
static_assert(offsetof(ADynamicWorldItem, PostImpactMaterial) == 0x000240, "Member 'ADynamicWorldItem::PostImpactMaterial' has a wrong offset!");
static_assert(offsetof(ADynamicWorldItem, PhysicsImpactDecal) == 0x000248, "Member 'ADynamicWorldItem::PhysicsImpactDecal' has a wrong offset!");
static_assert(offsetof(ADynamicWorldItem, PhysicsImpactDecalScale) == 0x000250, "Member 'ADynamicWorldItem::PhysicsImpactDecalScale' has a wrong offset!");
static_assert(offsetof(ADynamicWorldItem, bItemDestroyed) == 0x000254, "Member 'ADynamicWorldItem::bItemDestroyed' has a wrong offset!");

// Class ReadyOrNot.CollectableViewController
// 0x0088 (0x02A8 - 0x0220)
class ACollectableViewController final  : public AActor
{
public:
	float                                         RotationSpeed;                                     // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScaleLevels;                                       // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleSpeed;                                        // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumScale;                                      // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumScale;                                      // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalFOV;                                       // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           CameraActor;                                       // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnPointActor;                                   // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACollectable*                           CollectableActor;                                  // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotPlayerController*            CurrentController;                                 // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCollectableWidget*                     CollectableWidget;                                 // 0x0258(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F0[0x8];                                     // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADirectionalLight*>              HiddenDirectionalLights;                           // 0x0268(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ASkyLight*>                      HiddenSkyLights;                                   // 0x0278(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class APostProcessVolume*>             HiddenPostProcessVolumes;                          // 0x0288(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AExponentialHeightFog*>          HiddenExponentialHeightFogs;                       // 0x0298(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectableViewController">();
	}
	static class ACollectableViewController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectableViewController>();
	}
};
static_assert(alignof(ACollectableViewController) == 0x000008, "Wrong alignment on ACollectableViewController");
static_assert(sizeof(ACollectableViewController) == 0x0002A8, "Wrong size on ACollectableViewController");
static_assert(offsetof(ACollectableViewController, RotationSpeed) == 0x000220, "Member 'ACollectableViewController::RotationSpeed' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, ScaleLevels) == 0x000224, "Member 'ACollectableViewController::ScaleLevels' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, ScaleSpeed) == 0x000228, "Member 'ACollectableViewController::ScaleSpeed' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, MinimumScale) == 0x00022C, "Member 'ACollectableViewController::MinimumScale' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, MaximumScale) == 0x000230, "Member 'ACollectableViewController::MaximumScale' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, VerticalFOV) == 0x000234, "Member 'ACollectableViewController::VerticalFOV' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, CameraActor) == 0x000238, "Member 'ACollectableViewController::CameraActor' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, SpawnPointActor) == 0x000240, "Member 'ACollectableViewController::SpawnPointActor' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, CollectableActor) == 0x000248, "Member 'ACollectableViewController::CollectableActor' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, CurrentController) == 0x000250, "Member 'ACollectableViewController::CurrentController' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, CollectableWidget) == 0x000258, "Member 'ACollectableViewController::CollectableWidget' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, HiddenDirectionalLights) == 0x000268, "Member 'ACollectableViewController::HiddenDirectionalLights' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, HiddenSkyLights) == 0x000278, "Member 'ACollectableViewController::HiddenSkyLights' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, HiddenPostProcessVolumes) == 0x000288, "Member 'ACollectableViewController::HiddenPostProcessVolumes' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, HiddenExponentialHeightFogs) == 0x000298, "Member 'ACollectableViewController::HiddenExponentialHeightFogs' has a wrong offset!");

// Class ReadyOrNot.StingerDamageType
// 0x0000 (0x0620 - 0x0620)
class UStingerDamageType : public UStunDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StingerDamageType">();
	}
	static class UStingerDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStingerDamageType>();
	}
};
static_assert(alignof(UStingerDamageType) == 0x000010, "Wrong alignment on UStingerDamageType");
static_assert(sizeof(UStingerDamageType) == 0x000620, "Wrong size on UStingerDamageType");

// Class ReadyOrNot.CollectableViewer
// 0x0020 (0x0240 - 0x0220)
class ACollectableViewer final  : public AActor
{
public:
	uint8                                         Pad_24F1[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACollectable>               CollectableClass;                                  // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 InteractableComponent;                             // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACollectableViewController*             ViewController;                                    // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectableViewer">();
	}
	static class ACollectableViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectableViewer>();
	}
};
static_assert(alignof(ACollectableViewer) == 0x000008, "Wrong alignment on ACollectableViewer");
static_assert(sizeof(ACollectableViewer) == 0x000240, "Wrong size on ACollectableViewer");
static_assert(offsetof(ACollectableViewer, CollectableClass) == 0x000228, "Member 'ACollectableViewer::CollectableClass' has a wrong offset!");
static_assert(offsetof(ACollectableViewer, InteractableComponent) == 0x000230, "Member 'ACollectableViewer::InteractableComponent' has a wrong offset!");
static_assert(offsetof(ACollectableViewer, ViewController) == 0x000238, "Member 'ACollectableViewer::ViewController' has a wrong offset!");

// Class ReadyOrNot.CollectableWidget
// 0x0008 (0x0328 - 0x0320)
class UCollectableWidget : public UCommonActivatableWidget
{
public:
	class ACollectableViewController*             ParentController;                                  // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CloseCollectableWidget();
	void SetItem(class ACollectable* Collectable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectableWidget">();
	}
	static class UCollectableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectableWidget>();
	}
};
static_assert(alignof(UCollectableWidget) == 0x000008, "Wrong alignment on UCollectableWidget");
static_assert(sizeof(UCollectableWidget) == 0x000328, "Wrong size on UCollectableWidget");
static_assert(offsetof(UCollectableWidget, ParentController) == 0x000320, "Member 'UCollectableWidget::ParentController' has a wrong offset!");

// Class ReadyOrNot.PauseMenu_Wrapper
// 0x0020 (0x02A8 - 0x0288)
class UPauseMenu_Wrapper : public UCommonUserWidget
{
public:
	class UCommonActivatableWidgetStack*          WidgetStack;                                       // 0x0288(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCommonActivatableWidget*               PauseMenu;                                         // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPauseMenuClosed;                                 // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ClosePauseMenu();
	void OpenPauseMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PauseMenu_Wrapper">();
	}
	static class UPauseMenu_Wrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPauseMenu_Wrapper>();
	}
};
static_assert(alignof(UPauseMenu_Wrapper) == 0x000008, "Wrong alignment on UPauseMenu_Wrapper");
static_assert(sizeof(UPauseMenu_Wrapper) == 0x0002A8, "Wrong size on UPauseMenu_Wrapper");
static_assert(offsetof(UPauseMenu_Wrapper, WidgetStack) == 0x000288, "Member 'UPauseMenu_Wrapper::WidgetStack' has a wrong offset!");
static_assert(offsetof(UPauseMenu_Wrapper, PauseMenu) == 0x000290, "Member 'UPauseMenu_Wrapper::PauseMenu' has a wrong offset!");
static_assert(offsetof(UPauseMenu_Wrapper, OnPauseMenuClosed) == 0x000298, "Member 'UPauseMenu_Wrapper::OnPauseMenuClosed' has a wrong offset!");

// Class ReadyOrNot.UnmannedVehicle
// 0x0048 (0x02C8 - 0x0280)
class AUnmannedVehicle : public APawn
{
public:
	uint8                                         Pad_24F2[0x8];                                     // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       Pilot;                                             // 0x0288(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Health;                                            // 0x0290(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDead;                                             // 0x0294(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24F3[0x3];                                     // 0x0295(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHealth;                                         // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F4[0x4];                                     // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   VehicleTabletName;                                 // 0x02A0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class AHUD>                       PreviousHUD;                                       // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AHUD>                       VehicleHUD;                                        // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AssumeTabletControl(class APlayerCharacter* TabletOwner);
	bool CanControlWithTablet(class APlayerCharacter* TabletOwner);
	bool CanTabletViewMe(class APlayerCharacter* TabletOwner, class AReadyOrNotGameState* GameState);
	void Die(class AController* EventInstigator, class AActor* DamageCauser);
	float GetHealth();
	class APlayerCharacter* GetPilot();
	class FText GetTabletNameText();
	class USceneComponent* GetTabletViewComponent();
	ETeamType GetTabletViewTeamColor();
	void HideActorsForTabletView(class USceneCaptureComponent2D* Component);
	bool IsAlive();
	void OnDeath(class AController* EventInstigator, class AActor* DamageCauser);
	void Server_StartPiloting(class AReadyOrNotPlayerController* NewController);
	void Server_StopPiloting(class AReadyOrNotPlayerController* CallingController);
	float TakeDamage(float Damage, struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnmannedVehicle">();
	}
	static class AUnmannedVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnmannedVehicle>();
	}
};
static_assert(alignof(AUnmannedVehicle) == 0x000008, "Wrong alignment on AUnmannedVehicle");
static_assert(sizeof(AUnmannedVehicle) == 0x0002C8, "Wrong size on AUnmannedVehicle");
static_assert(offsetof(AUnmannedVehicle, Pilot) == 0x000288, "Member 'AUnmannedVehicle::Pilot' has a wrong offset!");
static_assert(offsetof(AUnmannedVehicle, Health) == 0x000290, "Member 'AUnmannedVehicle::Health' has a wrong offset!");
static_assert(offsetof(AUnmannedVehicle, bDead) == 0x000294, "Member 'AUnmannedVehicle::bDead' has a wrong offset!");
static_assert(offsetof(AUnmannedVehicle, MaxHealth) == 0x000298, "Member 'AUnmannedVehicle::MaxHealth' has a wrong offset!");
static_assert(offsetof(AUnmannedVehicle, VehicleTabletName) == 0x0002A0, "Member 'AUnmannedVehicle::VehicleTabletName' has a wrong offset!");
static_assert(offsetof(AUnmannedVehicle, PreviousHUD) == 0x0002B8, "Member 'AUnmannedVehicle::PreviousHUD' has a wrong offset!");
static_assert(offsetof(AUnmannedVehicle, VehicleHUD) == 0x0002C0, "Member 'AUnmannedVehicle::VehicleHUD' has a wrong offset!");

// Class ReadyOrNot.Drone
// 0x02E8 (0x05B0 - 0x02C8)
class ADrone final  : public AUnmannedVehicle
{
public:
	TSubclassOf<class UUserWidget>                DroneWidgetClass;                                  // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            FPCameraRotationCurve;                             // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FPCameraRotationResetSpeed;                        // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24F9[0x4];                                     // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           FPDamageCurve;                                     // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FPDamageSpeed;                                     // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPitchTilt;                                      // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRollTilt;                                       // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRPM;                                            // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IdleRPM;                                           // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RPMThrottleMultiplier;                             // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrottleInterpSpeed;                               // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationInterpSpeed;                               // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnSpeed;                                         // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationInterpSpeedWhenSteady;                     // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnSpeedWhenSteady;                               // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSpeed;                                          // 0x0314(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeed;                                          // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedIncrementRate;                                // 0x031C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDroneDamageSpeed, float>                DroneSpeedToDamageValues;                          // 0x0320(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         InvincibilityTimeAfterDamageApplied;               // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotorRotation;                                     // 0x0374(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         RPM;                                               // 0x0380(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentAltitude;                                   // 0x0384(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentPilotDistance;                              // 0x0388(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24FA[0x4];                                     // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             DroneTransform;                                    // 0x0390(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               TargetRotation;                                    // 0x03C0(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               TargetSteadyCameraRotation;                        // 0x03CC(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bApplyingInput;                                    // 0x03D8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSteadyDrone;                                      // 0x03D9(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDroneThirdPerson;                                 // 0x03DA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24FB[0x5];                                     // 0x03DB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x03E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotPlayerController*            DroneController;                                   // 0x03E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotPlayerController*            OriginalController;                                // 0x03F0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24FC[0x20];                                    // 0x03F8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          FlightBox;                                         // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       DetectionSphere;                                   // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFloatingPawnMovement*                  FloatingMovementComponent;                         // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpringArmComponent*                    TPCameraArm;                                       // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       TPCamera;                                          // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        Audio;                                             // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       FPCamera;                                          // 0x0450(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            DroneWidgetHUD;                                    // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24FD[0x150];                                   // 0x0460(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_UpdateDrone(const struct FTransform& NewTransform, float InRPM);
	void ExitDrone();
	void Finished_CameraDamage();
	void IncrementSpeed(float Value);
	bool IsSpeedThresholdMet(float InSpeedAsPercentage);
	void OnDetectionSphereOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void OnDroneHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit);
	void QuickTurn();
	void Server_UpdateDrone(const struct FTransform& NewTransform, float InRPM);
	void SteadyDrone();
	void Tick_CameraDamage();
	void Tick_CameraReset();
	void ToggleThirdPerson();
	void UpdatePilotingInfo();

	float GetAltitude() const;
	struct FVector GetCurrentMovementDirection() const;
	float GetCurrentRPM() const;
	float GetCurrentSpeedAsPercentage() const;
	float GetDistanceToPilot() const;
	class AReadyOrNotPlayerController* GetDroneController() const;
	float GetIdleRPM() const;
	float GetMaxRPM() const;
	float GetMaxSpeed() const;
	float GetMinSpeed() const;
	bool HasPilot() const;
	bool IsApplyingInput() const;
	bool IsInThirdPersonMode() const;
	bool IsInvincible() const;
	bool IsMoving() const;
	bool IsMovingBackward() const;
	bool IsMovingForward() const;
	bool IsMovingLeft() const;
	bool IsMovingRight() const;
	bool IsStabilized() const;
	void RetrieveLastHitDamageInfo(EDroneDamageSpeed* InDroneDamageSpeed, float* InDamageAmount) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Drone">();
	}
	static class ADrone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADrone>();
	}
};
static_assert(alignof(ADrone) == 0x000010, "Wrong alignment on ADrone");
static_assert(sizeof(ADrone) == 0x0005B0, "Wrong size on ADrone");
static_assert(offsetof(ADrone, DroneWidgetClass) == 0x0002C8, "Member 'ADrone::DroneWidgetClass' has a wrong offset!");
static_assert(offsetof(ADrone, FPCameraRotationCurve) == 0x0002D0, "Member 'ADrone::FPCameraRotationCurve' has a wrong offset!");
static_assert(offsetof(ADrone, FPCameraRotationResetSpeed) == 0x0002D8, "Member 'ADrone::FPCameraRotationResetSpeed' has a wrong offset!");
static_assert(offsetof(ADrone, FPDamageCurve) == 0x0002E0, "Member 'ADrone::FPDamageCurve' has a wrong offset!");
static_assert(offsetof(ADrone, FPDamageSpeed) == 0x0002E8, "Member 'ADrone::FPDamageSpeed' has a wrong offset!");
static_assert(offsetof(ADrone, MaxPitchTilt) == 0x0002EC, "Member 'ADrone::MaxPitchTilt' has a wrong offset!");
static_assert(offsetof(ADrone, MaxRollTilt) == 0x0002F0, "Member 'ADrone::MaxRollTilt' has a wrong offset!");
static_assert(offsetof(ADrone, MaxRPM) == 0x0002F4, "Member 'ADrone::MaxRPM' has a wrong offset!");
static_assert(offsetof(ADrone, IdleRPM) == 0x0002F8, "Member 'ADrone::IdleRPM' has a wrong offset!");
static_assert(offsetof(ADrone, RPMThrottleMultiplier) == 0x0002FC, "Member 'ADrone::RPMThrottleMultiplier' has a wrong offset!");
static_assert(offsetof(ADrone, ThrottleInterpSpeed) == 0x000300, "Member 'ADrone::ThrottleInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADrone, RotationInterpSpeed) == 0x000304, "Member 'ADrone::RotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADrone, TurnSpeed) == 0x000308, "Member 'ADrone::TurnSpeed' has a wrong offset!");
static_assert(offsetof(ADrone, RotationInterpSpeedWhenSteady) == 0x00030C, "Member 'ADrone::RotationInterpSpeedWhenSteady' has a wrong offset!");
static_assert(offsetof(ADrone, TurnSpeedWhenSteady) == 0x000310, "Member 'ADrone::TurnSpeedWhenSteady' has a wrong offset!");
static_assert(offsetof(ADrone, MinSpeed) == 0x000314, "Member 'ADrone::MinSpeed' has a wrong offset!");
static_assert(offsetof(ADrone, MaxSpeed) == 0x000318, "Member 'ADrone::MaxSpeed' has a wrong offset!");
static_assert(offsetof(ADrone, SpeedIncrementRate) == 0x00031C, "Member 'ADrone::SpeedIncrementRate' has a wrong offset!");
static_assert(offsetof(ADrone, DroneSpeedToDamageValues) == 0x000320, "Member 'ADrone::DroneSpeedToDamageValues' has a wrong offset!");
static_assert(offsetof(ADrone, InvincibilityTimeAfterDamageApplied) == 0x000370, "Member 'ADrone::InvincibilityTimeAfterDamageApplied' has a wrong offset!");
static_assert(offsetof(ADrone, RotorRotation) == 0x000374, "Member 'ADrone::RotorRotation' has a wrong offset!");
static_assert(offsetof(ADrone, RPM) == 0x000380, "Member 'ADrone::RPM' has a wrong offset!");
static_assert(offsetof(ADrone, CurrentAltitude) == 0x000384, "Member 'ADrone::CurrentAltitude' has a wrong offset!");
static_assert(offsetof(ADrone, CurrentPilotDistance) == 0x000388, "Member 'ADrone::CurrentPilotDistance' has a wrong offset!");
static_assert(offsetof(ADrone, DroneTransform) == 0x000390, "Member 'ADrone::DroneTransform' has a wrong offset!");
static_assert(offsetof(ADrone, TargetRotation) == 0x0003C0, "Member 'ADrone::TargetRotation' has a wrong offset!");
static_assert(offsetof(ADrone, TargetSteadyCameraRotation) == 0x0003CC, "Member 'ADrone::TargetSteadyCameraRotation' has a wrong offset!");
static_assert(offsetof(ADrone, bApplyingInput) == 0x0003D8, "Member 'ADrone::bApplyingInput' has a wrong offset!");
static_assert(offsetof(ADrone, bSteadyDrone) == 0x0003D9, "Member 'ADrone::bSteadyDrone' has a wrong offset!");
static_assert(offsetof(ADrone, bDroneThirdPerson) == 0x0003DA, "Member 'ADrone::bDroneThirdPerson' has a wrong offset!");
static_assert(offsetof(ADrone, World) == 0x0003E0, "Member 'ADrone::World' has a wrong offset!");
static_assert(offsetof(ADrone, DroneController) == 0x0003E8, "Member 'ADrone::DroneController' has a wrong offset!");
static_assert(offsetof(ADrone, OriginalController) == 0x0003F0, "Member 'ADrone::OriginalController' has a wrong offset!");
static_assert(offsetof(ADrone, FlightBox) == 0x000418, "Member 'ADrone::FlightBox' has a wrong offset!");
static_assert(offsetof(ADrone, Mesh) == 0x000420, "Member 'ADrone::Mesh' has a wrong offset!");
static_assert(offsetof(ADrone, DetectionSphere) == 0x000428, "Member 'ADrone::DetectionSphere' has a wrong offset!");
static_assert(offsetof(ADrone, FloatingMovementComponent) == 0x000430, "Member 'ADrone::FloatingMovementComponent' has a wrong offset!");
static_assert(offsetof(ADrone, TPCameraArm) == 0x000438, "Member 'ADrone::TPCameraArm' has a wrong offset!");
static_assert(offsetof(ADrone, TPCamera) == 0x000440, "Member 'ADrone::TPCamera' has a wrong offset!");
static_assert(offsetof(ADrone, Audio) == 0x000448, "Member 'ADrone::Audio' has a wrong offset!");
static_assert(offsetof(ADrone, FPCamera) == 0x000450, "Member 'ADrone::FPCamera' has a wrong offset!");
static_assert(offsetof(ADrone, DroneWidgetHUD) == 0x000458, "Member 'ADrone::DroneWidgetHUD' has a wrong offset!");

// Class ReadyOrNot.PickUpCharacterActivity
// 0x0018 (0x01C0 - 0x01A8)
class UPickUpCharacterActivity final  : public UBaseActivity
{
public:
	class AReadyOrNotCharacter*                   PickUpCharacter;                                   // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2504[0x10];                                    // 0x01B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterCompleteStage();
	void EnterMoveToStage();
	void EnterPickUpStage();
	void EnterPlaceDownStage();
	void EnterTransitStage();
	void TickPickUpStage(float DeltaTime, float Uptime);

	bool CanPickUpNow() const;
	bool CanPlaceDownNow() const;
	bool CanTransitNow() const;
	bool IsPlaceDownComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickUpCharacterActivity">();
	}
	static class UPickUpCharacterActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPickUpCharacterActivity>();
	}
};
static_assert(alignof(UPickUpCharacterActivity) == 0x000008, "Wrong alignment on UPickUpCharacterActivity");
static_assert(sizeof(UPickUpCharacterActivity) == 0x0001C0, "Wrong size on UPickUpCharacterActivity");
static_assert(offsetof(UPickUpCharacterActivity, PickUpCharacter) == 0x0001A8, "Member 'UPickUpCharacterActivity::PickUpCharacter' has a wrong offset!");

// Class ReadyOrNot.CollectedEvidenceActor
// 0x0018 (0x0238 - 0x0220)
class ACollectedEvidenceActor : public AActor
{
public:
	uint8                                         Pad_2505[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   CollectionBagMesh;                                 // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             Bag_Spawn_Sound;                                   // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Multicast_PlaySpawnSound();
	void PlaySpawnSound();
	void Server_PlaySpawnSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectedEvidenceActor">();
	}
	static class ACollectedEvidenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectedEvidenceActor>();
	}
};
static_assert(alignof(ACollectedEvidenceActor) == 0x000008, "Wrong alignment on ACollectedEvidenceActor");
static_assert(sizeof(ACollectedEvidenceActor) == 0x000238, "Wrong size on ACollectedEvidenceActor");
static_assert(offsetof(ACollectedEvidenceActor, CollectionBagMesh) == 0x000228, "Member 'ACollectedEvidenceActor::CollectionBagMesh' has a wrong offset!");
static_assert(offsetof(ACollectedEvidenceActor, Bag_Spawn_Sound) == 0x000230, "Member 'ACollectedEvidenceActor::Bag_Spawn_Sound' has a wrong offset!");

// Class ReadyOrNot.MusicSequencerUnreal
// 0x0030 (0x0258 - 0x0228)
class AMusicSequencerUnreal final  : public AMusicSequencerBase
{
public:
	uint8                                         Pad_2506[0x20];                                    // 0x0228(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        AudioPlayer;                                       // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMusicState                                   CurrentState;                                      // 0x0250(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMusicState                                   NextState;                                         // 0x0251(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMusicState                                   NextScriptedState;                                 // 0x0252(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2507[0x5];                                     // 0x0253(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAudioFinished();
	void OnAudioPlaybackPercent(class USoundWave* PlayingSoundWave, float PlaybackPercent);
	void PlayScriptedMusic(class USoundCue* Music, EMusicState NewScriptedState, bool bImmediately);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicSequencerUnreal">();
	}
	static class AMusicSequencerUnreal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMusicSequencerUnreal>();
	}
};
static_assert(alignof(AMusicSequencerUnreal) == 0x000008, "Wrong alignment on AMusicSequencerUnreal");
static_assert(sizeof(AMusicSequencerUnreal) == 0x000258, "Wrong size on AMusicSequencerUnreal");
static_assert(offsetof(AMusicSequencerUnreal, AudioPlayer) == 0x000248, "Member 'AMusicSequencerUnreal::AudioPlayer' has a wrong offset!");
static_assert(offsetof(AMusicSequencerUnreal, CurrentState) == 0x000250, "Member 'AMusicSequencerUnreal::CurrentState' has a wrong offset!");
static_assert(offsetof(AMusicSequencerUnreal, NextState) == 0x000251, "Member 'AMusicSequencerUnreal::NextState' has a wrong offset!");
static_assert(offsetof(AMusicSequencerUnreal, NextScriptedState) == 0x000252, "Member 'AMusicSequencerUnreal::NextScriptedState' has a wrong offset!");

// Class ReadyOrNot.CollectEvidenceActivity
// 0x0018 (0x01C0 - 0x01A8)
class UCollectEvidenceActivity final  : public UBaseActivity
{
public:
	class AActor*                                 EvidenceItem;                                      // 0x01A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250A[0x10];                                    // 0x01B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterCollectStage();
	void EnterMoveToStage();
	void OnCollectEvidenceBegin();
	void OnCollectEvidenceEnd();
	void OnEvidenceCollected();
	void TickCollectStage(float DeltaTime, float Uptime);

	bool CanCollectEvidence() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectEvidenceActivity">();
	}
	static class UCollectEvidenceActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectEvidenceActivity>();
	}
};
static_assert(alignof(UCollectEvidenceActivity) == 0x000008, "Wrong alignment on UCollectEvidenceActivity");
static_assert(sizeof(UCollectEvidenceActivity) == 0x0001C0, "Wrong size on UCollectEvidenceActivity");
static_assert(offsetof(UCollectEvidenceActivity, EvidenceItem) == 0x0001A8, "Member 'UCollectEvidenceActivity::EvidenceItem' has a wrong offset!");

// Class ReadyOrNot.SoundData
// 0x0000 (0x0030 - 0x0030)
class USoundData final  : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundData">();
	}
	static class USoundData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundData>();
	}
};
static_assert(alignof(USoundData) == 0x000008, "Wrong alignment on USoundData");
static_assert(sizeof(USoundData) == 0x000030, "Wrong size on USoundData");

// Class ReadyOrNot.CoopGM
// 0x02E0 (0x0A50 - 0x0770)
#pragma pack(push, 0x1)
class alignas(0x10) ACoopGM : public AReadyOrNotGameMode
{
public:
	uint8                                         Pad_250B[0x8];                                     // 0x0770(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAllAISpawned;                                    // 0x0778(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AWorldDataGenerator*                    WorldDataGenerator;                                // 0x0788(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECOOPMode                                     Mode;                                              // 0x0790(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250C[0x27];                                    // 0x0791(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     KilledSuspectAvoidanceShape;                       // 0x07B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNegotiatorActive;                                 // 0x07C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAIEquipSameLoadoutAsPlayer;                       // 0x07C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250D[0x2];                                     // 0x07C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxHostagesKilledBeforeMissionFailed;              // 0x07C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTeamKillsBeforeAIRetaliates;                    // 0x07C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250E[0x4];                                     // 0x07CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACyberneticCharacter>       SwatAlphaClass;                                    // 0x07D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACyberneticCharacter>       SwatBetaClass;                                     // 0x07D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACyberneticCharacter>       SwatCharlieClass;                                  // 0x07E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACyberneticCharacter>       SwatDeltaClass;                                    // 0x07E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACyberneticCharacter>       SwatTrailerClass;                                  // 0x07F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AAIController>              FriendlyAIController;                              // 0x07F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSavedLoadout                          FriendlyAILoadout;                                 // 0x0800(0x0188)(Edit, NativeAccessSpecifierPublic)
	TSubclassOf<class AEvidenceActor>             EvidenceClass;                                     // 0x0988(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMissionEnded;                                    // 0x0990(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                GameStartedWidget;                                 // 0x09A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     KeycardClass;                                      // 0x09A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AI_SpawnTag;                                       // 0x09B0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AEvidenceActor*>                 EvidenceInWorld;                                   // 0x09B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NextHighgroundDesignation;                         // 0x09C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250F[0x4];                                     // 0x09CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHighgroundVolume*>              Highground;                                        // 0x09D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUniqueOfficerSoundsets;                           // 0x09E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2510[0x3];                                     // 0x09E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPickedOfficerSoundsets;                         // 0x09E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PickedOfficerSoundsets;                            // 0x09E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2511[0x4];                                     // 0x09EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASWATCharacter*>                 SpawnedSWATAI;                                     // 0x09F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ATrailerSWATCharacter*>          SpawnedTrailerSWATAI;                              // 0x0A00(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AAISpawn*>                       SpawnLaterSpawns;                                  // 0x0A10(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AISpawnDistance;                                   // 0x0A20(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2512[0x4];                                     // 0x0A24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              NegFeedback;                                       // 0x0A28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PosFeedBack;                                       // 0x0A30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          KickedDoorsTriggeredMoraleChange;                  // 0x0A38(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void AIArrested(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void AIIncapacitated(class AReadyOrNotCharacter* Incapacitated, class AReadyOrNotCharacter* InstigatorCharacter);
	void AIKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void AISurrendered(class AReadyOrNotCharacter* Character);
	void AllAISpawnedDelegate__DelegateSignature();
	class APlayerStart* FindPlayerStartForTeam(ETeamType Team);
	void FriendlyAIKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void IncapHumanKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AIncapacitatedHuman* KilledHuman);
	void MissionEnd(bool bSuccess);
	void OnMissionEnded__DelegateSignature(bool bMissionSucceded);
	void Personnel_SpawnHighground(int32 PersonnelNum, int32 MapPointNum, bool bSpotter, bool bMarksman, bool bSniper);
	void Personnel_SpawnNegotiator();
	void Personnel_SpawnOperator(int32 PersonnelNum, int32 MapPointNum, bool bNoisemaker);
	void Personnel_SpawnPowerCrew();
	void Personnel_SpawnTruckDriver(int32 PersonnelNum, int32 MapPointNum);
	void Personnel_SpawnVentilation(int32 PersonnelNum, int32 MapPointNum);
	void RemoveAllSpawnedAI();
	void ReturnToStation();
	void Server_SoftClearVoteCheck();
	void SpawnPolice();
	void SpawnSuspectsAndHostages();
	void StartMissionEndTimer(bool bWon);

	ECOOPMode GetCOOPMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoopGM">();
	}
	static class ACoopGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoopGM>();
	}
};
#pragma pack(pop)
static_assert(alignof(ACoopGM) == 0x000010, "Wrong alignment on ACoopGM");
static_assert(sizeof(ACoopGM) == 0x000A50, "Wrong size on ACoopGM");
static_assert(offsetof(ACoopGM, OnAllAISpawned) == 0x000778, "Member 'ACoopGM::OnAllAISpawned' has a wrong offset!");
static_assert(offsetof(ACoopGM, WorldDataGenerator) == 0x000788, "Member 'ACoopGM::WorldDataGenerator' has a wrong offset!");
static_assert(offsetof(ACoopGM, Mode) == 0x000790, "Member 'ACoopGM::Mode' has a wrong offset!");
static_assert(offsetof(ACoopGM, KilledSuspectAvoidanceShape) == 0x0007B8, "Member 'ACoopGM::KilledSuspectAvoidanceShape' has a wrong offset!");
static_assert(offsetof(ACoopGM, bNegotiatorActive) == 0x0007C0, "Member 'ACoopGM::bNegotiatorActive' has a wrong offset!");
static_assert(offsetof(ACoopGM, bAIEquipSameLoadoutAsPlayer) == 0x0007C1, "Member 'ACoopGM::bAIEquipSameLoadoutAsPlayer' has a wrong offset!");
static_assert(offsetof(ACoopGM, MaxHostagesKilledBeforeMissionFailed) == 0x0007C4, "Member 'ACoopGM::MaxHostagesKilledBeforeMissionFailed' has a wrong offset!");
static_assert(offsetof(ACoopGM, MaxTeamKillsBeforeAIRetaliates) == 0x0007C8, "Member 'ACoopGM::MaxTeamKillsBeforeAIRetaliates' has a wrong offset!");
static_assert(offsetof(ACoopGM, SwatAlphaClass) == 0x0007D0, "Member 'ACoopGM::SwatAlphaClass' has a wrong offset!");
static_assert(offsetof(ACoopGM, SwatBetaClass) == 0x0007D8, "Member 'ACoopGM::SwatBetaClass' has a wrong offset!");
static_assert(offsetof(ACoopGM, SwatCharlieClass) == 0x0007E0, "Member 'ACoopGM::SwatCharlieClass' has a wrong offset!");
static_assert(offsetof(ACoopGM, SwatDeltaClass) == 0x0007E8, "Member 'ACoopGM::SwatDeltaClass' has a wrong offset!");
static_assert(offsetof(ACoopGM, SwatTrailerClass) == 0x0007F0, "Member 'ACoopGM::SwatTrailerClass' has a wrong offset!");
static_assert(offsetof(ACoopGM, FriendlyAIController) == 0x0007F8, "Member 'ACoopGM::FriendlyAIController' has a wrong offset!");
static_assert(offsetof(ACoopGM, FriendlyAILoadout) == 0x000800, "Member 'ACoopGM::FriendlyAILoadout' has a wrong offset!");
static_assert(offsetof(ACoopGM, EvidenceClass) == 0x000988, "Member 'ACoopGM::EvidenceClass' has a wrong offset!");
static_assert(offsetof(ACoopGM, OnMissionEnded) == 0x000990, "Member 'ACoopGM::OnMissionEnded' has a wrong offset!");
static_assert(offsetof(ACoopGM, GameStartedWidget) == 0x0009A0, "Member 'ACoopGM::GameStartedWidget' has a wrong offset!");
static_assert(offsetof(ACoopGM, KeycardClass) == 0x0009A8, "Member 'ACoopGM::KeycardClass' has a wrong offset!");
static_assert(offsetof(ACoopGM, AI_SpawnTag) == 0x0009B0, "Member 'ACoopGM::AI_SpawnTag' has a wrong offset!");
static_assert(offsetof(ACoopGM, EvidenceInWorld) == 0x0009B8, "Member 'ACoopGM::EvidenceInWorld' has a wrong offset!");
static_assert(offsetof(ACoopGM, NextHighgroundDesignation) == 0x0009C8, "Member 'ACoopGM::NextHighgroundDesignation' has a wrong offset!");
static_assert(offsetof(ACoopGM, Highground) == 0x0009D0, "Member 'ACoopGM::Highground' has a wrong offset!");
static_assert(offsetof(ACoopGM, bUniqueOfficerSoundsets) == 0x0009E0, "Member 'ACoopGM::bUniqueOfficerSoundsets' has a wrong offset!");
static_assert(offsetof(ACoopGM, NumPickedOfficerSoundsets) == 0x0009E4, "Member 'ACoopGM::NumPickedOfficerSoundsets' has a wrong offset!");
static_assert(offsetof(ACoopGM, PickedOfficerSoundsets) == 0x0009E8, "Member 'ACoopGM::PickedOfficerSoundsets' has a wrong offset!");
static_assert(offsetof(ACoopGM, SpawnedSWATAI) == 0x0009F0, "Member 'ACoopGM::SpawnedSWATAI' has a wrong offset!");
static_assert(offsetof(ACoopGM, SpawnedTrailerSWATAI) == 0x000A00, "Member 'ACoopGM::SpawnedTrailerSWATAI' has a wrong offset!");
static_assert(offsetof(ACoopGM, SpawnLaterSpawns) == 0x000A10, "Member 'ACoopGM::SpawnLaterSpawns' has a wrong offset!");
static_assert(offsetof(ACoopGM, AISpawnDistance) == 0x000A20, "Member 'ACoopGM::AISpawnDistance' has a wrong offset!");
static_assert(offsetof(ACoopGM, NegFeedback) == 0x000A28, "Member 'ACoopGM::NegFeedback' has a wrong offset!");
static_assert(offsetof(ACoopGM, PosFeedBack) == 0x000A30, "Member 'ACoopGM::PosFeedBack' has a wrong offset!");
static_assert(offsetof(ACoopGM, KickedDoorsTriggeredMoraleChange) == 0x000A38, "Member 'ACoopGM::KickedDoorsTriggeredMoraleChange' has a wrong offset!");

// Class ReadyOrNot.EnvQueryTest_GasPath
// 0x0070 (0x02F0 - 0x0280)
class UEnvQueryTest_GasPath final  : public UEnvQueryTest_Pathfinding
{
public:
	struct FAIDataProviderBoolValue               CalculatePathLengthToAllContexts;                  // 0x0280(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              SafePointsBufferDistance;                          // 0x02B8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_GasPath">();
	}
	static class UEnvQueryTest_GasPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_GasPath>();
	}
};
static_assert(alignof(UEnvQueryTest_GasPath) == 0x000008, "Wrong alignment on UEnvQueryTest_GasPath");
static_assert(sizeof(UEnvQueryTest_GasPath) == 0x0002F0, "Wrong size on UEnvQueryTest_GasPath");
static_assert(offsetof(UEnvQueryTest_GasPath, CalculatePathLengthToAllContexts) == 0x000280, "Member 'UEnvQueryTest_GasPath::CalculatePathLengthToAllContexts' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_GasPath, SafePointsBufferDistance) == 0x0002B8, "Member 'UEnvQueryTest_GasPath::SafePointsBufferDistance' has a wrong offset!");

// Class ReadyOrNot.CommanderGM
// 0x0020 (0x0A70 - 0x0A50)
class ACommanderGM final  : public ACoopGM
{
public:
	class UCommanderProfile*                      CommanderProfile;                                  // 0x0A48(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URosterManager*                         RosterManager;                                     // 0x0A50(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AExfilPortal>               ExfilPortalClass;                                  // 0x0A58(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2516[0x10];                                    // 0x0A60(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommanderGM">();
	}
	static class ACommanderGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACommanderGM>();
	}
};
static_assert(alignof(ACommanderGM) == 0x000010, "Wrong alignment on ACommanderGM");
static_assert(sizeof(ACommanderGM) == 0x000A70, "Wrong size on ACommanderGM");
static_assert(offsetof(ACommanderGM, CommanderProfile) == 0x000A48, "Member 'ACommanderGM::CommanderProfile' has a wrong offset!");
static_assert(offsetof(ACommanderGM, RosterManager) == 0x000A50, "Member 'ACommanderGM::RosterManager' has a wrong offset!");
static_assert(offsetof(ACommanderGM, ExfilPortalClass) == 0x000A58, "Member 'ACommanderGM::ExfilPortalClass' has a wrong offset!");

// Class ReadyOrNot.CoopGS
// 0x0100 (0x08E0 - 0x07E0)
class ACoopGS : public AReadyOrNotGameState
{
public:
	uint8                                         Pad_2517[0x10];                                    // 0x07E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMissionSucceded;                                  // 0x07F0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMissionSoftCompleted;                             // 0x07F1(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECOOPMode                                     Mode;                                              // 0x07F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouchingTigerHiddenDragon;                       // 0x07F3(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentDeployables;                                // 0x07F4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DeployableDepot;                                   // 0x07F8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DepotLabel;                                        // 0x0800(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DepotNumber;                                       // 0x0808(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DepotCost;                                         // 0x080C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentPersonnel;                                  // 0x0810(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentUsedPersonnelPoints;                        // 0x0814(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            PersonnelMapping;                                  // 0x0818(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         TotalAIOfficers;                                   // 0x0868(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalOfficers;                                     // 0x086C(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCompleteExtraObjectives;                        // 0x0870(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTotalExtraObjectives;                           // 0x0874(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamKills;                                         // 0x0878(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllPlayerCharactesDead;                           // 0x087C(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2518[0x3];                                     // 0x087D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SquadPointsRemaining;                              // 0x0880(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESelectedSpawn                                SelectedRedSpawnPoint;                             // 0x0884(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2519[0x3];                                     // 0x0885(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RedSpawnSquadPoints;                               // 0x0888(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESelectedSpawn                                SelectedBlueSpawnPoint;                            // 0x088C(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251A[0x3];                                     // 0x088D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BlueSpawnSquadPoints;                              // 0x0890(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251B[0x4];                                     // 0x0894(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             MissionMusic;                                      // 0x0898(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFMODEventInstance                     MusicInstance;                                     // 0x08A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   PromotedLeaderFormat;                              // 0x08A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         YesVotes;                                          // 0x08C0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NoVotes;                                           // 0x08C4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251C[0x10];                                    // 0x08C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TOCDelay;                                          // 0x08D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251D[0x4];                                     // 0x08DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanChangeSpawn(bool bBlueTeam, ESelectedSpawn NewSpawn);
	TArray<int32> GetEnabledDeployables();
	TArray<class FText> GetEnabledDeployablesShortNames();
	TArray<int32> GetEnabledPersonnel();
	int32 GetPersonnelForMapNum(int32 MapPointNum);
	TArray<int32> GetUnenabledDeployables();
	TArray<int32> GetUnenabledPersonnel();
	TArray<int32> GetUsedPersonnelPoints();
	bool IsDeployableEnabled(int32 DeployableNumber);
	bool IsPersonnelEnabled(int32 PersonnelNum);
	void Multicast_BroadcastNewSquadLeader(class APlayerCharacter* NewLeader);
	void Multicast_GrantProgressionTags(float ScorePercentage);
	void Multicast_OnMissionEnd(bool bSuccess);
	void OnRep_COOPMode();
	void OnRep_MapElement();
	bool PlayerControllerVoted(class AReadyOrNotPlayerController* PlayerController, bool bVoteYes);
	void Server_SetDeployableDepot(class AReadyOrNotPlayerController* Controller, int32 NewDepotNum);
	void StartTOCBriefing(const class FString& TOCLine);
	void UpdateVotes(int32 Yes, int32 No);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoopGS">();
	}
	static class ACoopGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoopGS>();
	}
};
static_assert(alignof(ACoopGS) == 0x000008, "Wrong alignment on ACoopGS");
static_assert(sizeof(ACoopGS) == 0x0008E0, "Wrong size on ACoopGS");
static_assert(offsetof(ACoopGS, bMissionSucceded) == 0x0007F0, "Member 'ACoopGS::bMissionSucceded' has a wrong offset!");
static_assert(offsetof(ACoopGS, bMissionSoftCompleted) == 0x0007F1, "Member 'ACoopGS::bMissionSoftCompleted' has a wrong offset!");
static_assert(offsetof(ACoopGS, Mode) == 0x0007F2, "Member 'ACoopGS::Mode' has a wrong offset!");
static_assert(offsetof(ACoopGS, bCrouchingTigerHiddenDragon) == 0x0007F3, "Member 'ACoopGS::bCrouchingTigerHiddenDragon' has a wrong offset!");
static_assert(offsetof(ACoopGS, CurrentDeployables) == 0x0007F4, "Member 'ACoopGS::CurrentDeployables' has a wrong offset!");
static_assert(offsetof(ACoopGS, DeployableDepot) == 0x0007F8, "Member 'ACoopGS::DeployableDepot' has a wrong offset!");
static_assert(offsetof(ACoopGS, DepotLabel) == 0x000800, "Member 'ACoopGS::DepotLabel' has a wrong offset!");
static_assert(offsetof(ACoopGS, DepotNumber) == 0x000808, "Member 'ACoopGS::DepotNumber' has a wrong offset!");
static_assert(offsetof(ACoopGS, DepotCost) == 0x00080C, "Member 'ACoopGS::DepotCost' has a wrong offset!");
static_assert(offsetof(ACoopGS, CurrentPersonnel) == 0x000810, "Member 'ACoopGS::CurrentPersonnel' has a wrong offset!");
static_assert(offsetof(ACoopGS, CurrentUsedPersonnelPoints) == 0x000814, "Member 'ACoopGS::CurrentUsedPersonnelPoints' has a wrong offset!");
static_assert(offsetof(ACoopGS, PersonnelMapping) == 0x000818, "Member 'ACoopGS::PersonnelMapping' has a wrong offset!");
static_assert(offsetof(ACoopGS, TotalAIOfficers) == 0x000868, "Member 'ACoopGS::TotalAIOfficers' has a wrong offset!");
static_assert(offsetof(ACoopGS, TotalOfficers) == 0x00086C, "Member 'ACoopGS::TotalOfficers' has a wrong offset!");
static_assert(offsetof(ACoopGS, NumCompleteExtraObjectives) == 0x000870, "Member 'ACoopGS::NumCompleteExtraObjectives' has a wrong offset!");
static_assert(offsetof(ACoopGS, NumTotalExtraObjectives) == 0x000874, "Member 'ACoopGS::NumTotalExtraObjectives' has a wrong offset!");
static_assert(offsetof(ACoopGS, TeamKills) == 0x000878, "Member 'ACoopGS::TeamKills' has a wrong offset!");
static_assert(offsetof(ACoopGS, bAllPlayerCharactesDead) == 0x00087C, "Member 'ACoopGS::bAllPlayerCharactesDead' has a wrong offset!");
static_assert(offsetof(ACoopGS, SquadPointsRemaining) == 0x000880, "Member 'ACoopGS::SquadPointsRemaining' has a wrong offset!");
static_assert(offsetof(ACoopGS, SelectedRedSpawnPoint) == 0x000884, "Member 'ACoopGS::SelectedRedSpawnPoint' has a wrong offset!");
static_assert(offsetof(ACoopGS, RedSpawnSquadPoints) == 0x000888, "Member 'ACoopGS::RedSpawnSquadPoints' has a wrong offset!");
static_assert(offsetof(ACoopGS, SelectedBlueSpawnPoint) == 0x00088C, "Member 'ACoopGS::SelectedBlueSpawnPoint' has a wrong offset!");
static_assert(offsetof(ACoopGS, BlueSpawnSquadPoints) == 0x000890, "Member 'ACoopGS::BlueSpawnSquadPoints' has a wrong offset!");
static_assert(offsetof(ACoopGS, MissionMusic) == 0x000898, "Member 'ACoopGS::MissionMusic' has a wrong offset!");
static_assert(offsetof(ACoopGS, MusicInstance) == 0x0008A0, "Member 'ACoopGS::MusicInstance' has a wrong offset!");
static_assert(offsetof(ACoopGS, PromotedLeaderFormat) == 0x0008A8, "Member 'ACoopGS::PromotedLeaderFormat' has a wrong offset!");
static_assert(offsetof(ACoopGS, YesVotes) == 0x0008C0, "Member 'ACoopGS::YesVotes' has a wrong offset!");
static_assert(offsetof(ACoopGS, NoVotes) == 0x0008C4, "Member 'ACoopGS::NoVotes' has a wrong offset!");
static_assert(offsetof(ACoopGS, TOCDelay) == 0x0008D8, "Member 'ACoopGS::TOCDelay' has a wrong offset!");

// Class ReadyOrNot.CommanderGS
// 0x0000 (0x08E0 - 0x08E0)
class ACommanderGS final  : public ACoopGS
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommanderGS">();
	}
	static class ACommanderGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACommanderGS>();
	}
};
static_assert(alignof(ACommanderGS) == 0x000008, "Wrong alignment on ACommanderGS");
static_assert(sizeof(ACommanderGS) == 0x0008E0, "Wrong size on ACommanderGS");

// Class ReadyOrNot.TabletDisplay
// 0x0008 (0x0268 - 0x0260)
class UTabletDisplay final  : public UUserWidget
{
public:
	class ATablet*                                OwningTablet;                                      // 0x0260(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabletDisplay">();
	}
	static class UTabletDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabletDisplay>();
	}
};
static_assert(alignof(UTabletDisplay) == 0x000008, "Wrong alignment on UTabletDisplay");
static_assert(sizeof(UTabletDisplay) == 0x000268, "Wrong size on UTabletDisplay");
static_assert(offsetof(UTabletDisplay, OwningTablet) == 0x000260, "Member 'UTabletDisplay::OwningTablet' has a wrong offset!");

// Class ReadyOrNot.CommanderProfile
// 0x0180 (0x03F0 - 0x0270)
class UCommanderProfile final  : public UBaseProfile
{
public:
	int32                                         CommanderVersion;                                  // 0x0270(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2522[0x4];                                     // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCampaignData*                          Campaign;                                          // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         CompletedLevels;                                   // 0x0280(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         CompletedIronmanLevels;                            // 0x0290(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LostOfficers;                                      // 0x02A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2523[0x4];                                     // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         NewCompletedLevels;                                // 0x02A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<class FName>                             ProgressionTags;                                   // 0x02B8(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDateTime                              SaveDate;                                          // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              TotalPlaytime;                                     // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIronmanMode;                                      // 0x0318(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsModded;                                         // 0x0319(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2524[0x2];                                     // 0x031A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GameChecksum;                                      // 0x031C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReturningFromMission;                             // 0x0320(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2525[0x7];                                     // 0x0321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRosterSaveData                        RosterSaveData;                                    // 0x0328(0x0080)(NativeAccessSpecifierPublic)
	struct FLobbySaveData                         LobbySaveData;                                     // 0x03A8(0x0038)(NativeAccessSpecifierPublic)
	uint8                                         Pad_2526[0x10];                                    // 0x03E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCommanderProfile* GetDebugProfile();
	static class UCommanderProfile* LoadProfile(int32 Slot);

	void DeleteProfile();

	float GetCompletionPercentage() const;
	TSoftObjectPtr<class UTexture2D> GetMostRecentLevelImage() const;
	class FText GetMostRecentLevelName(class FText NothingCompletedText) const;
	class FString GetNextLevel() const;
	TSoftObjectPtr<class UTexture2D> GetNextLevelImage() const;
	class FText GetNextLevelName(class FText CompletedText) const;
	bool IsChecksumMismatched() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommanderProfile">();
	}
	static class UCommanderProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommanderProfile>();
	}
};
static_assert(alignof(UCommanderProfile) == 0x000008, "Wrong alignment on UCommanderProfile");
static_assert(sizeof(UCommanderProfile) == 0x0003F0, "Wrong size on UCommanderProfile");
static_assert(offsetof(UCommanderProfile, CommanderVersion) == 0x000270, "Member 'UCommanderProfile::CommanderVersion' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, Campaign) == 0x000278, "Member 'UCommanderProfile::Campaign' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, CompletedLevels) == 0x000280, "Member 'UCommanderProfile::CompletedLevels' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, CompletedIronmanLevels) == 0x000290, "Member 'UCommanderProfile::CompletedIronmanLevels' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, LostOfficers) == 0x0002A0, "Member 'UCommanderProfile::LostOfficers' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, NewCompletedLevels) == 0x0002A8, "Member 'UCommanderProfile::NewCompletedLevels' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, ProgressionTags) == 0x0002B8, "Member 'UCommanderProfile::ProgressionTags' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, SaveDate) == 0x000308, "Member 'UCommanderProfile::SaveDate' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, TotalPlaytime) == 0x000310, "Member 'UCommanderProfile::TotalPlaytime' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, bIronmanMode) == 0x000318, "Member 'UCommanderProfile::bIronmanMode' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, bIsModded) == 0x000319, "Member 'UCommanderProfile::bIsModded' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, GameChecksum) == 0x00031C, "Member 'UCommanderProfile::GameChecksum' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, bReturningFromMission) == 0x000320, "Member 'UCommanderProfile::bReturningFromMission' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, RosterSaveData) == 0x000328, "Member 'UCommanderProfile::RosterSaveData' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, LobbySaveData) == 0x0003A8, "Member 'UCommanderProfile::LobbySaveData' has a wrong offset!");

// Class ReadyOrNot.ElevatorButtonComponent
// 0x0040 (0x0520 - 0x04E0)
class UElevatorButtonComponent final  : public UStaticMeshComponent
{
public:
	uint8                                         Pad_2528[0x10];                                    // 0x04E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideButtonPromptText;                         // 0x04F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2529[0x7];                                     // 0x04F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ButtonPromptText;                                  // 0x04F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class AElevator*                              OwningElevator;                                    // 0x0510(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoorButton;                                       // 0x0518(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoorClose;                                        // 0x0519(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_252A[0x2];                                     // 0x051A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Floor;                                             // 0x051C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ElevatorButtonComponent">();
	}
	static class UElevatorButtonComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UElevatorButtonComponent>();
	}
};
static_assert(alignof(UElevatorButtonComponent) == 0x000010, "Wrong alignment on UElevatorButtonComponent");
static_assert(sizeof(UElevatorButtonComponent) == 0x000520, "Wrong size on UElevatorButtonComponent");
static_assert(offsetof(UElevatorButtonComponent, bOverrideButtonPromptText) == 0x0004F0, "Member 'UElevatorButtonComponent::bOverrideButtonPromptText' has a wrong offset!");
static_assert(offsetof(UElevatorButtonComponent, ButtonPromptText) == 0x0004F8, "Member 'UElevatorButtonComponent::ButtonPromptText' has a wrong offset!");
static_assert(offsetof(UElevatorButtonComponent, OwningElevator) == 0x000510, "Member 'UElevatorButtonComponent::OwningElevator' has a wrong offset!");
static_assert(offsetof(UElevatorButtonComponent, bDoorButton) == 0x000518, "Member 'UElevatorButtonComponent::bDoorButton' has a wrong offset!");
static_assert(offsetof(UElevatorButtonComponent, bDoorClose) == 0x000519, "Member 'UElevatorButtonComponent::bDoorClose' has a wrong offset!");
static_assert(offsetof(UElevatorButtonComponent, Floor) == 0x00051C, "Member 'UElevatorButtonComponent::Floor' has a wrong offset!");

// Class ReadyOrNot.CommandInterface
// 0x0040 (0x02A0 - 0x0260)
class UCommandInterface : public UUserWidget
{
public:
	class UImage*                                 SelectionLeft;                                     // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 SelectionRight;                                    // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 SelectionUp;                                       // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 SelectionDown;                                     // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 MoveIn;                                            // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 FallIn;                                            // 0x0288(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Cover;                                             // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Deploy;                                            // 0x0298(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DisableSelectionWidgets();
	void EnableSelectionWidgets(const struct FVector2D& Selection);
	void SetBlueColor();
	void SetGoldColor();
	void SetRedColor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandInterface">();
	}
	static class UCommandInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandInterface>();
	}
};
static_assert(alignof(UCommandInterface) == 0x000008, "Wrong alignment on UCommandInterface");
static_assert(sizeof(UCommandInterface) == 0x0002A0, "Wrong size on UCommandInterface");
static_assert(offsetof(UCommandInterface, SelectionLeft) == 0x000260, "Member 'UCommandInterface::SelectionLeft' has a wrong offset!");
static_assert(offsetof(UCommandInterface, SelectionRight) == 0x000268, "Member 'UCommandInterface::SelectionRight' has a wrong offset!");
static_assert(offsetof(UCommandInterface, SelectionUp) == 0x000270, "Member 'UCommandInterface::SelectionUp' has a wrong offset!");
static_assert(offsetof(UCommandInterface, SelectionDown) == 0x000278, "Member 'UCommandInterface::SelectionDown' has a wrong offset!");
static_assert(offsetof(UCommandInterface, MoveIn) == 0x000280, "Member 'UCommandInterface::MoveIn' has a wrong offset!");
static_assert(offsetof(UCommandInterface, FallIn) == 0x000288, "Member 'UCommandInterface::FallIn' has a wrong offset!");
static_assert(offsetof(UCommandInterface, Cover) == 0x000290, "Member 'UCommandInterface::Cover' has a wrong offset!");
static_assert(offsetof(UCommandInterface, Deploy) == 0x000298, "Member 'UCommandInterface::Deploy' has a wrong offset!");

// Class ReadyOrNot.CommandWheel
// 0x1128 (0x1388 - 0x0260)
class UCommandWheel : public UUserWidget
{
public:
	TSubclassOf<class ABaseGrenade>               Flashbang;                                         // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABaseGrenade>               Stinger;                                           // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABaseGrenade>               CSGas;                                             // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            OpenIcon;                                          // 0x0278(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            OpenDoorIcon;                                      // 0x0300(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            KickIcon;                                          // 0x0388(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            StackUpIcon;                                       // 0x0410(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            CoverIcon;                                         // 0x0498(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            MoveToIcon;                                        // 0x0520(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            DeployIcon;                                        // 0x05A8(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            RegroupIcon;                                       // 0x0630(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            StingerIcon;                                       // 0x06B8(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            TaserIcon;                                         // 0x0740(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            BreachIcon;                                        // 0x07C8(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            BreachShotgunIcon;                                 // 0x0850(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            C2ChargeIcon;                                      // 0x08D8(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            ClearIcon;                                         // 0x0960(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            CSGasIcon;                                         // 0x09E8(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            DeploySheildIcon;                                  // 0x0A70(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            DetonatorIcon;                                     // 0x0AF8(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            FlashbangIcon;                                     // 0x0B80(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            PepperSprayIcon;                                   // 0x0C08(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            CancelIcon;                                        // 0x0C90(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            ConfirmIcon;                                       // 0x0D18(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            ExecuteIcon;                                       // 0x0DA0(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            DisarmTrapWirecuttersIcon;                         // 0x0E28(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            DoorWedgeIcon;                                     // 0x0EB0(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            MirrorGunIcon;                                     // 0x0F38(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            RestrainIcon;                                      // 0x0FC0(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            CloseDoorIcon;                                     // 0x1048(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            ChemlightIcon;                                     // 0x10D0(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_252B[0xA0];                                    // 0x1158(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            InnerWheel;                                        // 0x11F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            OuterWheel;                                        // 0x1200(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ThumbstickImage;                                   // 0x1208(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CommandWheelCanvasPanel;                           // 0x1210(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             HeaderText;                                        // 0x1218(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               HeaderOverlay;                                     // 0x1220(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UReadyOrNotCommandFunctionLibrary*      CommandLibrary;                                    // 0x1228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_252C[0x158];                                   // 0x1230(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CycleSwatElement(bool Next);
	ETeamType GetActiveTeamType();
	void RedrawCommandWheel();
	void SetInnerSegments(int32 Num);
	void SetInnerWheelDirection(const struct FVector& Direction);
	void SetInnerwheelOpacity(float Opacity);
	void SetOuterSegments(int32 Num);
	void SetOuterWheelDirection(const struct FVector& Direction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandWheel">();
	}
	static class UCommandWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandWheel>();
	}
};
static_assert(alignof(UCommandWheel) == 0x000008, "Wrong alignment on UCommandWheel");
static_assert(sizeof(UCommandWheel) == 0x001388, "Wrong size on UCommandWheel");
static_assert(offsetof(UCommandWheel, Flashbang) == 0x000260, "Member 'UCommandWheel::Flashbang' has a wrong offset!");
static_assert(offsetof(UCommandWheel, Stinger) == 0x000268, "Member 'UCommandWheel::Stinger' has a wrong offset!");
static_assert(offsetof(UCommandWheel, CSGas) == 0x000270, "Member 'UCommandWheel::CSGas' has a wrong offset!");
static_assert(offsetof(UCommandWheel, OpenIcon) == 0x000278, "Member 'UCommandWheel::OpenIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, OpenDoorIcon) == 0x000300, "Member 'UCommandWheel::OpenDoorIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, KickIcon) == 0x000388, "Member 'UCommandWheel::KickIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, StackUpIcon) == 0x000410, "Member 'UCommandWheel::StackUpIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, CoverIcon) == 0x000498, "Member 'UCommandWheel::CoverIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, MoveToIcon) == 0x000520, "Member 'UCommandWheel::MoveToIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, DeployIcon) == 0x0005A8, "Member 'UCommandWheel::DeployIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, RegroupIcon) == 0x000630, "Member 'UCommandWheel::RegroupIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, StingerIcon) == 0x0006B8, "Member 'UCommandWheel::StingerIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, TaserIcon) == 0x000740, "Member 'UCommandWheel::TaserIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, BreachIcon) == 0x0007C8, "Member 'UCommandWheel::BreachIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, BreachShotgunIcon) == 0x000850, "Member 'UCommandWheel::BreachShotgunIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, C2ChargeIcon) == 0x0008D8, "Member 'UCommandWheel::C2ChargeIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, ClearIcon) == 0x000960, "Member 'UCommandWheel::ClearIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, CSGasIcon) == 0x0009E8, "Member 'UCommandWheel::CSGasIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, DeploySheildIcon) == 0x000A70, "Member 'UCommandWheel::DeploySheildIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, DetonatorIcon) == 0x000AF8, "Member 'UCommandWheel::DetonatorIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, FlashbangIcon) == 0x000B80, "Member 'UCommandWheel::FlashbangIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, PepperSprayIcon) == 0x000C08, "Member 'UCommandWheel::PepperSprayIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, CancelIcon) == 0x000C90, "Member 'UCommandWheel::CancelIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, ConfirmIcon) == 0x000D18, "Member 'UCommandWheel::ConfirmIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, ExecuteIcon) == 0x000DA0, "Member 'UCommandWheel::ExecuteIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, DisarmTrapWirecuttersIcon) == 0x000E28, "Member 'UCommandWheel::DisarmTrapWirecuttersIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, DoorWedgeIcon) == 0x000EB0, "Member 'UCommandWheel::DoorWedgeIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, MirrorGunIcon) == 0x000F38, "Member 'UCommandWheel::MirrorGunIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, RestrainIcon) == 0x000FC0, "Member 'UCommandWheel::RestrainIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, CloseDoorIcon) == 0x001048, "Member 'UCommandWheel::CloseDoorIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, ChemlightIcon) == 0x0010D0, "Member 'UCommandWheel::ChemlightIcon' has a wrong offset!");
static_assert(offsetof(UCommandWheel, InnerWheel) == 0x0011F8, "Member 'UCommandWheel::InnerWheel' has a wrong offset!");
static_assert(offsetof(UCommandWheel, OuterWheel) == 0x001200, "Member 'UCommandWheel::OuterWheel' has a wrong offset!");
static_assert(offsetof(UCommandWheel, ThumbstickImage) == 0x001208, "Member 'UCommandWheel::ThumbstickImage' has a wrong offset!");
static_assert(offsetof(UCommandWheel, CommandWheelCanvasPanel) == 0x001210, "Member 'UCommandWheel::CommandWheelCanvasPanel' has a wrong offset!");
static_assert(offsetof(UCommandWheel, HeaderText) == 0x001218, "Member 'UCommandWheel::HeaderText' has a wrong offset!");
static_assert(offsetof(UCommandWheel, HeaderOverlay) == 0x001220, "Member 'UCommandWheel::HeaderOverlay' has a wrong offset!");
static_assert(offsetof(UCommandWheel, CommandLibrary) == 0x001228, "Member 'UCommandWheel::CommandLibrary' has a wrong offset!");

// Class ReadyOrNot.CommitSuicideActivity
// 0x0030 (0x01D8 - 0x01A8)
class UCommitSuicideActivity final  : public UBaseActivity
{
public:
	uint8                                         Pad_252D[0x30];                                    // 0x01A8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDamaged(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnHeardYell(class AReadyOrNotCharacter* Shouter, bool bLOS);
	void OnMeleeHitTaken(class AReadyOrNotCharacter* InstigatorCharacter);
	void OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void SuicideActivityDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommitSuicideActivity">();
	}
	static class UCommitSuicideActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommitSuicideActivity>();
	}
};
static_assert(alignof(UCommitSuicideActivity) == 0x000008, "Wrong alignment on UCommitSuicideActivity");
static_assert(sizeof(UCommitSuicideActivity) == 0x0001D8, "Wrong size on UCommitSuicideActivity");

// Class ReadyOrNot.PairedInteractionDriver
// 0x0100 (0x0320 - 0x0220)
class APairedInteractionDriver final  : public AInfo
{
public:
	class UInteractionsData*                      InteractionData;                                   // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 Driver;                                            // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 Slave;                                             // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseItem*                              OptionalItem;                                      // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2530[0x88];                                    // 0x0240(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Event_OnPairedInteractionStarted;                  // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Event_OnDriverInteractionFinished;                 // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Event_OnSlaveInteractionFinished;                  // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Event_OnPairedInteractionFinished;                 // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2531[0x18];                                    // 0x0308(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorInteractionFinished__DelegateSignature(class AActor* InActor);
	void OnDriverInteractionFinished();
	void OnEquippedItemHolstered(class ABaseItem* Item);
	void OnInteractionFinished();
	void OnPairedInteractionFinished__DelegateSignature(class AActor* InDriver, class AActor* InSlave);
	void OnPairedInteractionStarted__DelegateSignature();
	void OnSlaveInteractionFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PairedInteractionDriver">();
	}
	static class APairedInteractionDriver* GetDefaultObj()
	{
		return GetDefaultObjImpl<APairedInteractionDriver>();
	}
};
static_assert(alignof(APairedInteractionDriver) == 0x000008, "Wrong alignment on APairedInteractionDriver");
static_assert(sizeof(APairedInteractionDriver) == 0x000320, "Wrong size on APairedInteractionDriver");
static_assert(offsetof(APairedInteractionDriver, InteractionData) == 0x000220, "Member 'APairedInteractionDriver::InteractionData' has a wrong offset!");
static_assert(offsetof(APairedInteractionDriver, Driver) == 0x000228, "Member 'APairedInteractionDriver::Driver' has a wrong offset!");
static_assert(offsetof(APairedInteractionDriver, Slave) == 0x000230, "Member 'APairedInteractionDriver::Slave' has a wrong offset!");
static_assert(offsetof(APairedInteractionDriver, OptionalItem) == 0x000238, "Member 'APairedInteractionDriver::OptionalItem' has a wrong offset!");
static_assert(offsetof(APairedInteractionDriver, Event_OnPairedInteractionStarted) == 0x0002C8, "Member 'APairedInteractionDriver::Event_OnPairedInteractionStarted' has a wrong offset!");
static_assert(offsetof(APairedInteractionDriver, Event_OnDriverInteractionFinished) == 0x0002D8, "Member 'APairedInteractionDriver::Event_OnDriverInteractionFinished' has a wrong offset!");
static_assert(offsetof(APairedInteractionDriver, Event_OnSlaveInteractionFinished) == 0x0002E8, "Member 'APairedInteractionDriver::Event_OnSlaveInteractionFinished' has a wrong offset!");
static_assert(offsetof(APairedInteractionDriver, Event_OnPairedInteractionFinished) == 0x0002F8, "Member 'APairedInteractionDriver::Event_OnPairedInteractionFinished' has a wrong offset!");

// Class ReadyOrNot.CommonButtonStyleFMOD
// 0x0010 (0x0590 - 0x0580)
class UCommonButtonStyleFMOD : public UCommonButtonStyle
{
public:
	class UFMODEvent*                             OnHoveredEvent;                                    // 0x0580(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             OnClickedEvent;                                    // 0x0588(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonButtonStyleFMOD">();
	}
	static class UCommonButtonStyleFMOD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonButtonStyleFMOD>();
	}
};
static_assert(alignof(UCommonButtonStyleFMOD) == 0x000008, "Wrong alignment on UCommonButtonStyleFMOD");
static_assert(sizeof(UCommonButtonStyleFMOD) == 0x000590, "Wrong size on UCommonButtonStyleFMOD");
static_assert(offsetof(UCommonButtonStyleFMOD, OnHoveredEvent) == 0x000580, "Member 'UCommonButtonStyleFMOD::OnHoveredEvent' has a wrong offset!");
static_assert(offsetof(UCommonButtonStyleFMOD, OnClickedEvent) == 0x000588, "Member 'UCommonButtonStyleFMOD::OnClickedEvent' has a wrong offset!");

// Class ReadyOrNot.ExplosionGibs
// 0x0008 (0x0228 - 0x0220)
class AExplosionGibs : public AActor
{
public:
	class UBloodData*                             BloodData;                                         // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetupGibsForSkeletalMesh(class USkeletalMeshComponent* Mesh);
	void SpawnBloodDecal(struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplosionGibs">();
	}
	static class AExplosionGibs* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExplosionGibs>();
	}
};
static_assert(alignof(AExplosionGibs) == 0x000008, "Wrong alignment on AExplosionGibs");
static_assert(sizeof(AExplosionGibs) == 0x000228, "Wrong size on AExplosionGibs");
static_assert(offsetof(AExplosionGibs, BloodData) == 0x000220, "Member 'AExplosionGibs::BloodData' has a wrong offset!");

// Class ReadyOrNot.CommonButtonFMOD
// 0x0010 (0x0BD0 - 0x0BC0)
class UCommonButtonFMOD : public UCommonButtonBase
{
public:
	class UFMODEvent*                             OnHoveredEvent;                                    // 0x0BC0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             OnClickedEvent;                                    // 0x0BC8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonButtonFMOD">();
	}
	static class UCommonButtonFMOD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonButtonFMOD>();
	}
};
static_assert(alignof(UCommonButtonFMOD) == 0x000008, "Wrong alignment on UCommonButtonFMOD");
static_assert(sizeof(UCommonButtonFMOD) == 0x000BD0, "Wrong size on UCommonButtonFMOD");
static_assert(offsetof(UCommonButtonFMOD, OnHoveredEvent) == 0x000BC0, "Member 'UCommonButtonFMOD::OnHoveredEvent' has a wrong offset!");
static_assert(offsetof(UCommonButtonFMOD, OnClickedEvent) == 0x000BC8, "Member 'UCommonButtonFMOD::OnClickedEvent' has a wrong offset!");

// Class ReadyOrNot.CommonButtonImplementation
// 0x0000 (0x0BD0 - 0x0BD0)
class UCommonButtonImplementation : public UCommonButtonFMOD
{
public:
	class UCommonTextBlock* BP_GetButtonLabel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonButtonImplementation">();
	}
	static class UCommonButtonImplementation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonButtonImplementation>();
	}
};
static_assert(alignof(UCommonButtonImplementation) == 0x000008, "Wrong alignment on UCommonButtonImplementation");
static_assert(sizeof(UCommonButtonImplementation) == 0x000BD0, "Wrong size on UCommonButtonImplementation");

// Class ReadyOrNot.PickupActor
// 0x0068 (0x0288 - 0x0220)
class APickupActor : public AActor
{
public:
	uint8                                         Pad_2532[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnActorPickedUp;                                   // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActorPickedUp_NoParam;                           // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActorDropped;                                    // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   PickupName;                                        // 0x0258(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectiveMarkerComponent*              ObjectiveMarkerComponent;                          // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InteractableComponent;                             // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 PickupInstigator;                                  // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ActorDropped(class AActor* InDroppedInstigator);
	void ActorPickedUp(class AActor* InPickupInstigator);
	bool CanPickUpNow(class APlayerCharacter* PickerUpper);
	void HideObjectiveMarker();
	void OnActorDropped__DelegateSignature(class AActor* DroppedActor);
	void OnActorPickedUp__DelegateSignature(class AActor* PickedActor);
	void OnActorPickedUp_NoParam__DelegateSignature();
	void ShowObjectiveMarker();
	void ToggleObjectiveMarker();

	class AActor* GetPickupInstigator() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupActor">();
	}
	static class APickupActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APickupActor>();
	}
};
static_assert(alignof(APickupActor) == 0x000008, "Wrong alignment on APickupActor");
static_assert(sizeof(APickupActor) == 0x000288, "Wrong size on APickupActor");
static_assert(offsetof(APickupActor, OnActorPickedUp) == 0x000228, "Member 'APickupActor::OnActorPickedUp' has a wrong offset!");
static_assert(offsetof(APickupActor, OnActorPickedUp_NoParam) == 0x000238, "Member 'APickupActor::OnActorPickedUp_NoParam' has a wrong offset!");
static_assert(offsetof(APickupActor, OnActorDropped) == 0x000248, "Member 'APickupActor::OnActorDropped' has a wrong offset!");
static_assert(offsetof(APickupActor, PickupName) == 0x000258, "Member 'APickupActor::PickupName' has a wrong offset!");
static_assert(offsetof(APickupActor, SkeletalMesh) == 0x000260, "Member 'APickupActor::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(APickupActor, StaticMesh) == 0x000268, "Member 'APickupActor::StaticMesh' has a wrong offset!");
static_assert(offsetof(APickupActor, ObjectiveMarkerComponent) == 0x000270, "Member 'APickupActor::ObjectiveMarkerComponent' has a wrong offset!");
static_assert(offsetof(APickupActor, InteractableComponent) == 0x000278, "Member 'APickupActor::InteractableComponent' has a wrong offset!");
static_assert(offsetof(APickupActor, PickupInstigator) == 0x000280, "Member 'APickupActor::PickupInstigator' has a wrong offset!");

// Class ReadyOrNot.EvidenceActor
// 0x0048 (0x02D0 - 0x0288)
class AEvidenceActor final  : public APickupActor
{
public:
	uint8                                         Pad_2534[0x18];                                    // 0x0288(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UScoringComponent*                      ScoringComponent;                                  // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   EvidenceName;                                      // 0x02A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         bEvidenceExtracted : 1;                            // 0x02C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EEvidenceActorState                           PreviousEvidenceState;                             // 0x02C1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEvidenceActorState                           EvidenceState;                                     // 0x02C2(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBeingCollected;                                 // 0x02C3(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentCollectionTime;                             // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCollectionTime;                                 // 0x02C8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInteractHeld : 1;                                 // 0x02CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2535[0x3];                                     // 0x02CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishExtractingEvidence();
	void OnRep_EvidenceStateChanged();
	void StartExtractingEvidence();
	void UpdateEvidenceCollection_COOP(float DeltaTime);

	class FText GetEvidenceName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvidenceActor">();
	}
	static class AEvidenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEvidenceActor>();
	}
};
static_assert(alignof(AEvidenceActor) == 0x000008, "Wrong alignment on AEvidenceActor");
static_assert(sizeof(AEvidenceActor) == 0x0002D0, "Wrong size on AEvidenceActor");
static_assert(offsetof(AEvidenceActor, ScoringComponent) == 0x0002A0, "Member 'AEvidenceActor::ScoringComponent' has a wrong offset!");
static_assert(offsetof(AEvidenceActor, EvidenceName) == 0x0002A8, "Member 'AEvidenceActor::EvidenceName' has a wrong offset!");
static_assert(offsetof(AEvidenceActor, PreviousEvidenceState) == 0x0002C1, "Member 'AEvidenceActor::PreviousEvidenceState' has a wrong offset!");
static_assert(offsetof(AEvidenceActor, EvidenceState) == 0x0002C2, "Member 'AEvidenceActor::EvidenceState' has a wrong offset!");
static_assert(offsetof(AEvidenceActor, bIsBeingCollected) == 0x0002C3, "Member 'AEvidenceActor::bIsBeingCollected' has a wrong offset!");
static_assert(offsetof(AEvidenceActor, CurrentCollectionTime) == 0x0002C4, "Member 'AEvidenceActor::CurrentCollectionTime' has a wrong offset!");
static_assert(offsetof(AEvidenceActor, MaxCollectionTime) == 0x0002C8, "Member 'AEvidenceActor::MaxCollectionTime' has a wrong offset!");

// Class ReadyOrNot.CommonFooterWidget
// 0x0048 (0x0368 - 0x0320)
class UCommonFooterWidget : public UCommonActivatableWidget
{
public:
	FMulticastInlineDelegateProperty_             OnDismissInputAction;                              // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    DismissInputActionSettings;                        // 0x0330(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bConsumeInput;                                     // 0x0340(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPersistent;                                     // 0x0341(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideInputActionText;                          // 0x0342(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2536[0x5];                                     // 0x0343(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   OverrideInputActionText;                           // 0x0348(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2537[0x4];                                     // 0x0360(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUsingGamepad;                                     // 0x0364(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2538[0x3];                                     // 0x0365(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_DismissInputActionProgress(float HeldTime);
	void BP_OnDismissInputAction();
	void OnDismissInputActionNative();
	void OnDismissInputActionProgressNative(float HeldPercent);
	void OnInputMethodChanged(ECommonInputType InputMethod);
	void RefreshWidget();

	class FText GetFooterText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonFooterWidget">();
	}
	static class UCommonFooterWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonFooterWidget>();
	}
};
static_assert(alignof(UCommonFooterWidget) == 0x000008, "Wrong alignment on UCommonFooterWidget");
static_assert(sizeof(UCommonFooterWidget) == 0x000368, "Wrong size on UCommonFooterWidget");
static_assert(offsetof(UCommonFooterWidget, OnDismissInputAction) == 0x000320, "Member 'UCommonFooterWidget::OnDismissInputAction' has a wrong offset!");
static_assert(offsetof(UCommonFooterWidget, DismissInputActionSettings) == 0x000330, "Member 'UCommonFooterWidget::DismissInputActionSettings' has a wrong offset!");
static_assert(offsetof(UCommonFooterWidget, bConsumeInput) == 0x000340, "Member 'UCommonFooterWidget::bConsumeInput' has a wrong offset!");
static_assert(offsetof(UCommonFooterWidget, bIsPersistent) == 0x000341, "Member 'UCommonFooterWidget::bIsPersistent' has a wrong offset!");
static_assert(offsetof(UCommonFooterWidget, bOverrideInputActionText) == 0x000342, "Member 'UCommonFooterWidget::bOverrideInputActionText' has a wrong offset!");
static_assert(offsetof(UCommonFooterWidget, OverrideInputActionText) == 0x000348, "Member 'UCommonFooterWidget::OverrideInputActionText' has a wrong offset!");
static_assert(offsetof(UCommonFooterWidget, bUsingGamepad) == 0x000364, "Member 'UCommonFooterWidget::bUsingGamepad' has a wrong offset!");

// Class ReadyOrNot.SwatCombatActivity
// 0x0010 (0x0430 - 0x0420)
class USwatCombatActivity final  : public UBaseCombatActivity
{
public:
	uint8                                         Pad_2539[0x10];                                    // 0x0420(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwatCombatActivity">();
	}
	static class USwatCombatActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwatCombatActivity>();
	}
};
static_assert(alignof(USwatCombatActivity) == 0x000008, "Wrong alignment on USwatCombatActivity");
static_assert(sizeof(USwatCombatActivity) == 0x000430, "Wrong size on USwatCombatActivity");

// Class ReadyOrNot.CommonIconButtonBase
// 0x0000 (0x0BD0 - 0x0BD0)
class UCommonIconButtonBase final  : public UCommonBoundActionButton
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonIconButtonBase">();
	}
	static class UCommonIconButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonIconButtonBase>();
	}
};
static_assert(alignof(UCommonIconButtonBase) == 0x000008, "Wrong alignment on UCommonIconButtonBase");
static_assert(sizeof(UCommonIconButtonBase) == 0x000BD0, "Wrong size on UCommonIconButtonBase");

// Class ReadyOrNot.CommonTabListAnimationSwitcher
// 0x0000 (0x0190 - 0x0190)
class UCommonTabListAnimationSwitcher final  : public UCommonAnimatedSwitcher
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonTabListAnimationSwitcher">();
	}
	static class UCommonTabListAnimationSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonTabListAnimationSwitcher>();
	}
};
static_assert(alignof(UCommonTabListAnimationSwitcher) == 0x000008, "Wrong alignment on UCommonTabListAnimationSwitcher");
static_assert(sizeof(UCommonTabListAnimationSwitcher) == 0x000190, "Wrong size on UCommonTabListAnimationSwitcher");

// Class ReadyOrNot.PlayDeadActivity
// 0x0020 (0x01C8 - 0x01A8)
class UPlayDeadActivity final  : public UBaseActivity
{
public:
	uint8                                         Pad_253A[0x20];                                    // 0x01A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDamaged(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnHeardYell(class AReadyOrNotCharacter* Shouter, bool bLOS);
	void OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayDeadActivity">();
	}
	static class UPlayDeadActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayDeadActivity>();
	}
};
static_assert(alignof(UPlayDeadActivity) == 0x000008, "Wrong alignment on UPlayDeadActivity");
static_assert(sizeof(UPlayDeadActivity) == 0x0001C8, "Wrong size on UPlayDeadActivity");

// Class ReadyOrNot.CompetitionHelperLib
// 0x0000 (0x0028 - 0x0028)
class UCompetitionHelperLib final  : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompetitionHelperLib">();
	}
	static class UCompetitionHelperLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompetitionHelperLib>();
	}
};
static_assert(alignof(UCompetitionHelperLib) == 0x000008, "Wrong alignment on UCompetitionHelperLib");
static_assert(sizeof(UCompetitionHelperLib) == 0x000028, "Wrong size on UCompetitionHelperLib");

// Class ReadyOrNot.ConsoleFireMode
// 0x0000 (0x0260 - 0x0260)
class UConsoleFireMode final  : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleFireMode">();
	}
	static class UConsoleFireMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleFireMode>();
	}
};
static_assert(alignof(UConsoleFireMode) == 0x000008, "Wrong alignment on UConsoleFireMode");
static_assert(sizeof(UConsoleFireMode) == 0x000260, "Wrong size on UConsoleFireMode");

// Class ReadyOrNot.ConsoleHotkey
// 0x0120 (0x0380 - 0x0260)
class UConsoleHotkey : public UUserWidget
{
public:
	struct FSlateBrush                            Button_Brush;                                      // 0x0260(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 Button_Image;                                      // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            Icon_Brush;                                        // 0x02F0(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 Icon_Image;                                        // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleHotkey">();
	}
	static class UConsoleHotkey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleHotkey>();
	}
};
static_assert(alignof(UConsoleHotkey) == 0x000008, "Wrong alignment on UConsoleHotkey");
static_assert(sizeof(UConsoleHotkey) == 0x000380, "Wrong size on UConsoleHotkey");
static_assert(offsetof(UConsoleHotkey, Button_Brush) == 0x000260, "Member 'UConsoleHotkey::Button_Brush' has a wrong offset!");
static_assert(offsetof(UConsoleHotkey, Button_Image) == 0x0002E8, "Member 'UConsoleHotkey::Button_Image' has a wrong offset!");
static_assert(offsetof(UConsoleHotkey, Icon_Brush) == 0x0002F0, "Member 'UConsoleHotkey::Icon_Brush' has a wrong offset!");
static_assert(offsetof(UConsoleHotkey, Icon_Image) == 0x000378, "Member 'UConsoleHotkey::Icon_Image' has a wrong offset!");

// Class ReadyOrNot.ReportableActor
// 0x00A0 (0x02C0 - 0x0220)
class AReportableActor final  : public AActor
{
public:
	uint8                                         Pad_253D[0x20];                                    // 0x0220(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bReportableEnabled;                                // 0x0240(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenReported;                                  // 0x0241(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableOnNoMatchingObjective;                     // 0x0242(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableWhileMatchingObjectiveHidden;              // 0x0243(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_253E[0x4];                                     // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReportableName;                                    // 0x0248(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 ReportVoiceLine;                                   // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTocResponseOnReport;                              // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_253F[0x7];                                     // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnReported;                                        // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UShapeComponent*                        ShapeComponent;                                    // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVolumeShape                                  Shape;                                             // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2540[0x3];                                     // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoxExtents;                                        // 0x0294(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZHeight;                                           // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SceneComponent;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 InteractableComponent;                             // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScoringComponent*                      ScoringComponent;                                  // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DisableReportableIfNoMatchingObjective();
	void OnRep_bReportableEnabled();
	void OnReported__DelegateSignature(class AReportableActor* ReportableActor);
	void SetReportableEnabled(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReportableActor">();
	}
	static class AReportableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReportableActor>();
	}
};
static_assert(alignof(AReportableActor) == 0x000008, "Wrong alignment on AReportableActor");
static_assert(sizeof(AReportableActor) == 0x0002C0, "Wrong size on AReportableActor");
static_assert(offsetof(AReportableActor, bReportableEnabled) == 0x000240, "Member 'AReportableActor::bReportableEnabled' has a wrong offset!");
static_assert(offsetof(AReportableActor, bHasBeenReported) == 0x000241, "Member 'AReportableActor::bHasBeenReported' has a wrong offset!");
static_assert(offsetof(AReportableActor, bDisableOnNoMatchingObjective) == 0x000242, "Member 'AReportableActor::bDisableOnNoMatchingObjective' has a wrong offset!");
static_assert(offsetof(AReportableActor, bDisableWhileMatchingObjectiveHidden) == 0x000243, "Member 'AReportableActor::bDisableWhileMatchingObjectiveHidden' has a wrong offset!");
static_assert(offsetof(AReportableActor, ReportableName) == 0x000248, "Member 'AReportableActor::ReportableName' has a wrong offset!");
static_assert(offsetof(AReportableActor, ReportVoiceLine) == 0x000260, "Member 'AReportableActor::ReportVoiceLine' has a wrong offset!");
static_assert(offsetof(AReportableActor, bTocResponseOnReport) == 0x000270, "Member 'AReportableActor::bTocResponseOnReport' has a wrong offset!");
static_assert(offsetof(AReportableActor, OnReported) == 0x000278, "Member 'AReportableActor::OnReported' has a wrong offset!");
static_assert(offsetof(AReportableActor, ShapeComponent) == 0x000288, "Member 'AReportableActor::ShapeComponent' has a wrong offset!");
static_assert(offsetof(AReportableActor, Shape) == 0x000290, "Member 'AReportableActor::Shape' has a wrong offset!");
static_assert(offsetof(AReportableActor, BoxExtents) == 0x000294, "Member 'AReportableActor::BoxExtents' has a wrong offset!");
static_assert(offsetof(AReportableActor, Radius) == 0x0002A0, "Member 'AReportableActor::Radius' has a wrong offset!");
static_assert(offsetof(AReportableActor, ZHeight) == 0x0002A4, "Member 'AReportableActor::ZHeight' has a wrong offset!");
static_assert(offsetof(AReportableActor, SceneComponent) == 0x0002A8, "Member 'AReportableActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(AReportableActor, InteractableComponent) == 0x0002B0, "Member 'AReportableActor::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AReportableActor, ScoringComponent) == 0x0002B8, "Member 'AReportableActor::ScoringComponent' has a wrong offset!");

// Class ReadyOrNot.ConsoleMagSelection
// 0x0010 (0x0270 - 0x0260)
class UConsoleMagSelection final  : public UUserWidget
{
public:
	class UHorizontalBox*                         Container;                                         // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMagCheck(class ABaseMagazineWeapon* MagazineWeapon);
	void OnWeaponFired(class ABaseWeapon* Weapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleMagSelection">();
	}
	static class UConsoleMagSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleMagSelection>();
	}
};
static_assert(alignof(UConsoleMagSelection) == 0x000008, "Wrong alignment on UConsoleMagSelection");
static_assert(sizeof(UConsoleMagSelection) == 0x000270, "Wrong size on UConsoleMagSelection");
static_assert(offsetof(UConsoleMagSelection, Container) == 0x000260, "Member 'UConsoleMagSelection::Container' has a wrong offset!");
static_assert(offsetof(UConsoleMagSelection, PlayerCharacter) == 0x000268, "Member 'UConsoleMagSelection::PlayerCharacter' has a wrong offset!");

// Class ReadyOrNot.ConsoleMultiplayerManager
// 0x0100 (0x0128 - 0x0028)
class UConsoleMultiplayerManager final  : public UObject
{
public:
	uint8                                         Pad_2541[0x100];                                   // 0x0028(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleMultiplayerManager">();
	}
	static class UConsoleMultiplayerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleMultiplayerManager>();
	}
};
static_assert(alignof(UConsoleMultiplayerManager) == 0x000008, "Wrong alignment on UConsoleMultiplayerManager");
static_assert(sizeof(UConsoleMultiplayerManager) == 0x000128, "Wrong size on UConsoleMultiplayerManager");

// Class ReadyOrNot.ConsoleSelectionItem
// 0x0028 (0x0288 - 0x0260)
class UConsoleSelectionItem : public UUserWidget
{
public:
	class FString                                 Name_ConsoleSelectionItem;                         // 0x0260(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0270(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2542[0x4];                                     // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 Icon_Image;                                        // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Selected_Image;                                    // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleSelectionItem">();
	}
	static class UConsoleSelectionItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleSelectionItem>();
	}
};
static_assert(alignof(UConsoleSelectionItem) == 0x000008, "Wrong alignment on UConsoleSelectionItem");
static_assert(sizeof(UConsoleSelectionItem) == 0x000288, "Wrong size on UConsoleSelectionItem");
static_assert(offsetof(UConsoleSelectionItem, Name_ConsoleSelectionItem) == 0x000260, "Member 'UConsoleSelectionItem::Name_ConsoleSelectionItem' has a wrong offset!");
static_assert(offsetof(UConsoleSelectionItem, Count) == 0x000270, "Member 'UConsoleSelectionItem::Count' has a wrong offset!");
static_assert(offsetof(UConsoleSelectionItem, Icon_Image) == 0x000278, "Member 'UConsoleSelectionItem::Icon_Image' has a wrong offset!");
static_assert(offsetof(UConsoleSelectionItem, Selected_Image) == 0x000280, "Member 'UConsoleSelectionItem::Selected_Image' has a wrong offset!");

// Class ReadyOrNot.ControlsBind
// 0x00F0 (0x0350 - 0x0260)
class UControlsBind : public UUserWidget
{
public:
	bool                                          IsAxis;                                            // 0x0260(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2543[0x3];                                     // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BindIndex;                                         // 0x0264(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ListeningForKeystrokes;                            // 0x0268(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2544[0x7];                                     // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   PendingNewKey;                                     // 0x0270(0x0018)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             DescriptionWidget;                                 // 0x0288(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             BindNotificationWidget;                            // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BindName;                                          // 0x0298(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   BindFriendlyName;                                  // 0x02A0(0x0018)(BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	float                                         AxisScale;                                         // 0x02B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputKeyCategoryV2                           KeyCategory;                                       // 0x02BC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2545[0x3];                                     // 0x02BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USettingsMenuGamepad*                   SettingsMenu;                                      // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAxisMappingStruct                     AxisMappingData;                                   // 0x02C8(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FActionMappingStruct                   ActionMappingData;                                 // 0x02F0(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   UnboundText;                                       // 0x0318(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FText>                           ConflictBindFriendlyNamesList;                     // 0x0330(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UTextBlock*                             BindingText;                                       // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Button_Selected;                                   // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddConflictingKeybindsToList(class FName MappingName, float Scale, TArray<struct FAxisMappingStruct>* AxesList, TArray<struct FActionMappingStruct>* ActionsList);
	void AddKeybindsToList(const TArray<struct FKeyBinding>& Keybinds, class FName MappingName, float Scale, TArray<struct FAxisMappingStruct>* AxesList, TArray<struct FActionMappingStruct>* ActionsList);
	void BindingFinished();
	class FText CheckConflictingKeybindsAreUnbindable(const TArray<struct FAxisMappingStruct>& AxesList, const TArray<struct FActionMappingStruct>& ActionsList);
	void GetConflictingKeybindsWhenValid(const TArray<struct FAxisMappingStruct>& AxesList, const TArray<struct FActionMappingStruct>& ActionsList, bool* HasConflict, TArray<struct FAxisMappingStruct>* ConflictingAxes, TArray<struct FActionMappingStruct>* ConflictingActions);
	class FText GetConflictingKeybindText(class FText RequiredKeybindName);
	void GetInputBindingData(int32 Param_Index, struct FAxisMappingStruct* AxisMapping, struct FActionMappingStruct* ActionMapping);
	bool RebindKey(const struct FKey& NewKey);
	void RemoveConflictKeybinds(const TArray<struct FAxisMappingStruct>& AxesList, const TArray<struct FActionMappingStruct>& ActionsList);
	void ResetBinding();
	void SetKeybindingText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlsBind">();
	}
	static class UControlsBind* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControlsBind>();
	}
};
static_assert(alignof(UControlsBind) == 0x000008, "Wrong alignment on UControlsBind");
static_assert(sizeof(UControlsBind) == 0x000350, "Wrong size on UControlsBind");
static_assert(offsetof(UControlsBind, IsAxis) == 0x000260, "Member 'UControlsBind::IsAxis' has a wrong offset!");
static_assert(offsetof(UControlsBind, BindIndex) == 0x000264, "Member 'UControlsBind::BindIndex' has a wrong offset!");
static_assert(offsetof(UControlsBind, ListeningForKeystrokes) == 0x000268, "Member 'UControlsBind::ListeningForKeystrokes' has a wrong offset!");
static_assert(offsetof(UControlsBind, PendingNewKey) == 0x000270, "Member 'UControlsBind::PendingNewKey' has a wrong offset!");
static_assert(offsetof(UControlsBind, DescriptionWidget) == 0x000288, "Member 'UControlsBind::DescriptionWidget' has a wrong offset!");
static_assert(offsetof(UControlsBind, BindNotificationWidget) == 0x000290, "Member 'UControlsBind::BindNotificationWidget' has a wrong offset!");
static_assert(offsetof(UControlsBind, BindName) == 0x000298, "Member 'UControlsBind::BindName' has a wrong offset!");
static_assert(offsetof(UControlsBind, BindFriendlyName) == 0x0002A0, "Member 'UControlsBind::BindFriendlyName' has a wrong offset!");
static_assert(offsetof(UControlsBind, AxisScale) == 0x0002B8, "Member 'UControlsBind::AxisScale' has a wrong offset!");
static_assert(offsetof(UControlsBind, KeyCategory) == 0x0002BC, "Member 'UControlsBind::KeyCategory' has a wrong offset!");
static_assert(offsetof(UControlsBind, SettingsMenu) == 0x0002C0, "Member 'UControlsBind::SettingsMenu' has a wrong offset!");
static_assert(offsetof(UControlsBind, AxisMappingData) == 0x0002C8, "Member 'UControlsBind::AxisMappingData' has a wrong offset!");
static_assert(offsetof(UControlsBind, ActionMappingData) == 0x0002F0, "Member 'UControlsBind::ActionMappingData' has a wrong offset!");
static_assert(offsetof(UControlsBind, UnboundText) == 0x000318, "Member 'UControlsBind::UnboundText' has a wrong offset!");
static_assert(offsetof(UControlsBind, ConflictBindFriendlyNamesList) == 0x000330, "Member 'UControlsBind::ConflictBindFriendlyNamesList' has a wrong offset!");
static_assert(offsetof(UControlsBind, BindingText) == 0x000340, "Member 'UControlsBind::BindingText' has a wrong offset!");
static_assert(offsetof(UControlsBind, Button_Selected) == 0x000348, "Member 'UControlsBind::Button_Selected' has a wrong offset!");

// Class ReadyOrNot.PlayerStart_VIP_Spawn
// 0x0040 (0x0290 - 0x0250)
class APlayerStart_VIP_Spawn final  : public APlayerStart
{
public:
	uint8                                         bHasVisited : 1;                                   // 0x0250(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_254B[0x7];                                     // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   VIPSpawnDescriptor;                                // 0x0258(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         SuffixNumber;                                      // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254C[0x4];                                     // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          SpawnBox;                                          // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextRenderComponent*                   TextRender;                                        // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        SpawnDirection;                                    // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FVector GetRandomSpawnPoint();
	struct FRotator GetSpawnDirection();

	class FText GetVIPSpawnDescriptor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStart_VIP_Spawn">();
	}
	static class APlayerStart_VIP_Spawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStart_VIP_Spawn>();
	}
};
static_assert(alignof(APlayerStart_VIP_Spawn) == 0x000008, "Wrong alignment on APlayerStart_VIP_Spawn");
static_assert(sizeof(APlayerStart_VIP_Spawn) == 0x000290, "Wrong size on APlayerStart_VIP_Spawn");
static_assert(offsetof(APlayerStart_VIP_Spawn, VIPSpawnDescriptor) == 0x000258, "Member 'APlayerStart_VIP_Spawn::VIPSpawnDescriptor' has a wrong offset!");
static_assert(offsetof(APlayerStart_VIP_Spawn, SuffixNumber) == 0x000270, "Member 'APlayerStart_VIP_Spawn::SuffixNumber' has a wrong offset!");
static_assert(offsetof(APlayerStart_VIP_Spawn, SpawnBox) == 0x000278, "Member 'APlayerStart_VIP_Spawn::SpawnBox' has a wrong offset!");
static_assert(offsetof(APlayerStart_VIP_Spawn, TextRender) == 0x000280, "Member 'APlayerStart_VIP_Spawn::TextRender' has a wrong offset!");
static_assert(offsetof(APlayerStart_VIP_Spawn, SpawnDirection) == 0x000288, "Member 'APlayerStart_VIP_Spawn::SpawnDirection' has a wrong offset!");

// Class ReadyOrNot.ConversationManager
// 0x0010 (0x0230 - 0x0220)
class AConversationManager final  : public AInfo
{
public:
	TArray<class UConversation*>                  RunningConversations;                              // 0x0220(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void PlayConversationInst(class UConversation* Conversation, class ACyberneticCharacter* ConversationStarter);
	class UConversation* PlayPrebuiltConversation(TSubclassOf<class UConversation> Conversation, class ACyberneticCharacter* ConversationStarter, class FName ConversationId);
	class UConversation* TryPlayConversation(class FName ConversationId, class ACyberneticCharacter* ConversationStarter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConversationManager">();
	}
	static class AConversationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AConversationManager>();
	}
};
static_assert(alignof(AConversationManager) == 0x000008, "Wrong alignment on AConversationManager");
static_assert(sizeof(AConversationManager) == 0x000230, "Wrong size on AConversationManager");
static_assert(offsetof(AConversationManager, RunningConversations) == 0x000220, "Member 'AConversationManager::RunningConversations' has a wrong offset!");

// Class ReadyOrNot.COOPScorePopUp
// 0x0008 (0x0268 - 0x0260)
class UCOOPScorePopUp : public UUserWidget
{
public:
	class UFMODEvent*                             Reward;                                            // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void PlayRewardSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"COOPScorePopUp">();
	}
	static class UCOOPScorePopUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCOOPScorePopUp>();
	}
};
static_assert(alignof(UCOOPScorePopUp) == 0x000008, "Wrong alignment on UCOOPScorePopUp");
static_assert(sizeof(UCOOPScorePopUp) == 0x000268, "Wrong size on UCOOPScorePopUp");
static_assert(offsetof(UCOOPScorePopUp, Reward) == 0x000260, "Member 'UCOOPScorePopUp::Reward' has a wrong offset!");

// Class ReadyOrNot.CoverFinderPreview
// 0x0460 (0x0680 - 0x0220)
class ACoverFinderPreview final  : public AActor
{
public:
	uint8                                         Pad_254D[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchExtent;                                      // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchDangerZone;                                  // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverSearchMode                              SearchMode;                                        // 0x0230(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverStance                                  CoverStance;                                       // 0x0231(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254E[0xE];                                     // 0x0232(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoverQueryTest                        SearchModeTest;                                    // 0x0240(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCoverQueryTest                        HeightDifferenceTest;                              // 0x0290(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCoverQueryTest                        LineOfSightTest;                                   // 0x02E0(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCoverQueryTest                        CoverBehindInstigatorTest;                         // 0x0330(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCoverQueryTest                        SufficientCoverTest;                               // 0x0380(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCoverQueryTest                        DistanceToInstigatorTest;                          // 0x03D0(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCoverQueryTest                        DirectionMatchTest;                                // 0x0420(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCoverQueryTest                        RoomTest;                                          // 0x0470(0x0050)(Edit, NativeAccessSpecifierPublic)
	int32                                         NumCoverPointsFound;                               // 0x04C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverSearchTimeMs;                                 // 0x04C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ACoverPoint>             BestCover;                                         // 0x04C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDrawLabels : 1;                                   // 0x04D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawScore : 1;                                    // 0x04D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawPass : 1;                                     // 0x04D0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawFail : 1;                                     // 0x04D0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawFailReason : 1;                               // 0x04D0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_254F[0x7];                                     // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x04D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2550[0x1A0];                                   // 0x04E0(0x01A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverFinderPreview">();
	}
	static class ACoverFinderPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoverFinderPreview>();
	}
};
static_assert(alignof(ACoverFinderPreview) == 0x000010, "Wrong alignment on ACoverFinderPreview");
static_assert(sizeof(ACoverFinderPreview) == 0x000680, "Wrong size on ACoverFinderPreview");
static_assert(offsetof(ACoverFinderPreview, SearchExtent) == 0x000228, "Member 'ACoverFinderPreview::SearchExtent' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, SearchDangerZone) == 0x00022C, "Member 'ACoverFinderPreview::SearchDangerZone' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, SearchMode) == 0x000230, "Member 'ACoverFinderPreview::SearchMode' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, CoverStance) == 0x000231, "Member 'ACoverFinderPreview::CoverStance' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, SearchModeTest) == 0x000240, "Member 'ACoverFinderPreview::SearchModeTest' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, HeightDifferenceTest) == 0x000290, "Member 'ACoverFinderPreview::HeightDifferenceTest' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, LineOfSightTest) == 0x0002E0, "Member 'ACoverFinderPreview::LineOfSightTest' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, CoverBehindInstigatorTest) == 0x000330, "Member 'ACoverFinderPreview::CoverBehindInstigatorTest' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, SufficientCoverTest) == 0x000380, "Member 'ACoverFinderPreview::SufficientCoverTest' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, DistanceToInstigatorTest) == 0x0003D0, "Member 'ACoverFinderPreview::DistanceToInstigatorTest' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, DirectionMatchTest) == 0x000420, "Member 'ACoverFinderPreview::DirectionMatchTest' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, RoomTest) == 0x000470, "Member 'ACoverFinderPreview::RoomTest' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, NumCoverPointsFound) == 0x0004C0, "Member 'ACoverFinderPreview::NumCoverPointsFound' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, CoverSearchTimeMs) == 0x0004C4, "Member 'ACoverFinderPreview::CoverSearchTimeMs' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, BestCover) == 0x0004C8, "Member 'ACoverFinderPreview::BestCover' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, SceneComponent) == 0x0004D8, "Member 'ACoverFinderPreview::SceneComponent' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotCharacterAnimData
// 0x0358 (0x0388 - 0x0030)
class UReadyOrNotCharacterAnimData final  : public UDataAsset
{
public:
	TArray<struct FCharacterTPAnim>               Surrender;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               FakeSurrender;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Spooked_Front;                                     // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Spooked_Right;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Spooked_Left;                                      // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Spooked_Back;                                      // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Arrested;                                          // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Decision;                                          // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               StandRelaxedFidget;                                // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               StandAlertFidget;                                  // 0x00C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_Head;                                  // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_UpperBody;                             // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_LowerBody;                             // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_LeftArm;                               // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_RightArm;                              // 0x0110(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_LeftLeg;                               // 0x0120(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_RightLeg;                              // 0x0130(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_LeftFoot;                              // 0x0140(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_RightFoot;                             // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_DropWeapon;                            // 0x0160(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCharacterTPAnim                       FireWeapon;                                        // 0x0170(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterTPAnim                       DrawWeapon;                                        // 0x0178(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterTPAnim                       HolsterWeapon;                                     // 0x0180(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterTPAnim                       ReloadWeapon;                                      // 0x0188(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Head_Front;                                  // 0x0190(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Head_Back;                                   // 0x01A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Arm_Left_Front;                              // 0x01B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Arm_Left_Back;                               // 0x01C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Arm_Right_Front;                             // 0x01D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Arm_Right_Back;                              // 0x01E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Leg_Left_Front;                              // 0x01F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Leg_Left_Back;                               // 0x0200(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Leg_Right_Front;                             // 0x0210(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Leg_Right_Back;                              // 0x0220(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Front;                                       // 0x0230(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Back;                                        // 0x0240(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Bleedout_Head;                               // 0x0250(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Bleedout_Chest;                              // 0x0260(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Bleedout_Stomach;                            // 0x0270(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Bleedout_Left_Arm;                           // 0x0280(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Bleedout_Right_Arm;                          // 0x0290(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Bleedout_Left_Leg;                           // 0x02A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Bleedout_Right_Leg;                          // 0x02B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Flashbanged;                                       // 0x02C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Stingballed;                                       // 0x02D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Gassed;                                            // 0x02E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Sprayed;                                           // 0x02F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Tasered;                                           // 0x0300(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Meleed;                                            // 0x0310(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCharacterTPAnim                       OpenDoor;                                          // 0x0320(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterTPAnim                       CloseDoor;                                         // 0x0328(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterTPAnim                       Flinches;                                          // 0x0330(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Calm_Turn90Left;                                   // 0x0338(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Calm_Turn90Right;                                  // 0x0340(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Calm_Turn180Left;                                  // 0x0348(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Calm_Turn180Right;                                 // 0x0350(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Alert_Turn90Left;                                  // 0x0358(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Alert_Turn90Right;                                 // 0x0360(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Alert_Turn180Left;                                 // 0x0368(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Alert_Turn180Right;                                // 0x0370(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               AllAnimsList;                                      // 0x0378(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotCharacterAnimData">();
	}
	static class UReadyOrNotCharacterAnimData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotCharacterAnimData>();
	}
};
static_assert(alignof(UReadyOrNotCharacterAnimData) == 0x000008, "Wrong alignment on UReadyOrNotCharacterAnimData");
static_assert(sizeof(UReadyOrNotCharacterAnimData) == 0x000388, "Wrong size on UReadyOrNotCharacterAnimData");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Surrender) == 0x000030, "Member 'UReadyOrNotCharacterAnimData::Surrender' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, FakeSurrender) == 0x000040, "Member 'UReadyOrNotCharacterAnimData::FakeSurrender' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Spooked_Front) == 0x000050, "Member 'UReadyOrNotCharacterAnimData::Spooked_Front' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Spooked_Right) == 0x000060, "Member 'UReadyOrNotCharacterAnimData::Spooked_Right' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Spooked_Left) == 0x000070, "Member 'UReadyOrNotCharacterAnimData::Spooked_Left' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Spooked_Back) == 0x000080, "Member 'UReadyOrNotCharacterAnimData::Spooked_Back' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Arrested) == 0x000090, "Member 'UReadyOrNotCharacterAnimData::Arrested' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Decision) == 0x0000A0, "Member 'UReadyOrNotCharacterAnimData::Decision' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, StandRelaxedFidget) == 0x0000B0, "Member 'UReadyOrNotCharacterAnimData::StandRelaxedFidget' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, StandAlertFidget) == 0x0000C0, "Member 'UReadyOrNotCharacterAnimData::StandAlertFidget' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_Head) == 0x0000D0, "Member 'UReadyOrNotCharacterAnimData::HitReaction_Head' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_UpperBody) == 0x0000E0, "Member 'UReadyOrNotCharacterAnimData::HitReaction_UpperBody' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_LowerBody) == 0x0000F0, "Member 'UReadyOrNotCharacterAnimData::HitReaction_LowerBody' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_LeftArm) == 0x000100, "Member 'UReadyOrNotCharacterAnimData::HitReaction_LeftArm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_RightArm) == 0x000110, "Member 'UReadyOrNotCharacterAnimData::HitReaction_RightArm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_LeftLeg) == 0x000120, "Member 'UReadyOrNotCharacterAnimData::HitReaction_LeftLeg' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_RightLeg) == 0x000130, "Member 'UReadyOrNotCharacterAnimData::HitReaction_RightLeg' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_LeftFoot) == 0x000140, "Member 'UReadyOrNotCharacterAnimData::HitReaction_LeftFoot' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_RightFoot) == 0x000150, "Member 'UReadyOrNotCharacterAnimData::HitReaction_RightFoot' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_DropWeapon) == 0x000160, "Member 'UReadyOrNotCharacterAnimData::HitReaction_DropWeapon' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, FireWeapon) == 0x000170, "Member 'UReadyOrNotCharacterAnimData::FireWeapon' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, DrawWeapon) == 0x000178, "Member 'UReadyOrNotCharacterAnimData::DrawWeapon' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HolsterWeapon) == 0x000180, "Member 'UReadyOrNotCharacterAnimData::HolsterWeapon' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, ReloadWeapon) == 0x000188, "Member 'UReadyOrNotCharacterAnimData::ReloadWeapon' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Head_Front) == 0x000190, "Member 'UReadyOrNotCharacterAnimData::Death_Head_Front' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Head_Back) == 0x0001A0, "Member 'UReadyOrNotCharacterAnimData::Death_Head_Back' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Arm_Left_Front) == 0x0001B0, "Member 'UReadyOrNotCharacterAnimData::Death_Arm_Left_Front' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Arm_Left_Back) == 0x0001C0, "Member 'UReadyOrNotCharacterAnimData::Death_Arm_Left_Back' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Arm_Right_Front) == 0x0001D0, "Member 'UReadyOrNotCharacterAnimData::Death_Arm_Right_Front' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Arm_Right_Back) == 0x0001E0, "Member 'UReadyOrNotCharacterAnimData::Death_Arm_Right_Back' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Leg_Left_Front) == 0x0001F0, "Member 'UReadyOrNotCharacterAnimData::Death_Leg_Left_Front' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Leg_Left_Back) == 0x000200, "Member 'UReadyOrNotCharacterAnimData::Death_Leg_Left_Back' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Leg_Right_Front) == 0x000210, "Member 'UReadyOrNotCharacterAnimData::Death_Leg_Right_Front' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Leg_Right_Back) == 0x000220, "Member 'UReadyOrNotCharacterAnimData::Death_Leg_Right_Back' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Front) == 0x000230, "Member 'UReadyOrNotCharacterAnimData::Death_Front' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Back) == 0x000240, "Member 'UReadyOrNotCharacterAnimData::Death_Back' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Bleedout_Head) == 0x000250, "Member 'UReadyOrNotCharacterAnimData::Death_Bleedout_Head' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Bleedout_Chest) == 0x000260, "Member 'UReadyOrNotCharacterAnimData::Death_Bleedout_Chest' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Bleedout_Stomach) == 0x000270, "Member 'UReadyOrNotCharacterAnimData::Death_Bleedout_Stomach' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Bleedout_Left_Arm) == 0x000280, "Member 'UReadyOrNotCharacterAnimData::Death_Bleedout_Left_Arm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Bleedout_Right_Arm) == 0x000290, "Member 'UReadyOrNotCharacterAnimData::Death_Bleedout_Right_Arm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Bleedout_Left_Leg) == 0x0002A0, "Member 'UReadyOrNotCharacterAnimData::Death_Bleedout_Left_Leg' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Bleedout_Right_Leg) == 0x0002B0, "Member 'UReadyOrNotCharacterAnimData::Death_Bleedout_Right_Leg' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Flashbanged) == 0x0002C0, "Member 'UReadyOrNotCharacterAnimData::Flashbanged' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Stingballed) == 0x0002D0, "Member 'UReadyOrNotCharacterAnimData::Stingballed' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Gassed) == 0x0002E0, "Member 'UReadyOrNotCharacterAnimData::Gassed' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Sprayed) == 0x0002F0, "Member 'UReadyOrNotCharacterAnimData::Sprayed' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Tasered) == 0x000300, "Member 'UReadyOrNotCharacterAnimData::Tasered' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Meleed) == 0x000310, "Member 'UReadyOrNotCharacterAnimData::Meleed' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, OpenDoor) == 0x000320, "Member 'UReadyOrNotCharacterAnimData::OpenDoor' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, CloseDoor) == 0x000328, "Member 'UReadyOrNotCharacterAnimData::CloseDoor' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Flinches) == 0x000330, "Member 'UReadyOrNotCharacterAnimData::Flinches' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Calm_Turn90Left) == 0x000338, "Member 'UReadyOrNotCharacterAnimData::Calm_Turn90Left' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Calm_Turn90Right) == 0x000340, "Member 'UReadyOrNotCharacterAnimData::Calm_Turn90Right' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Calm_Turn180Left) == 0x000348, "Member 'UReadyOrNotCharacterAnimData::Calm_Turn180Left' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Calm_Turn180Right) == 0x000350, "Member 'UReadyOrNotCharacterAnimData::Calm_Turn180Right' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Alert_Turn90Left) == 0x000358, "Member 'UReadyOrNotCharacterAnimData::Alert_Turn90Left' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Alert_Turn90Right) == 0x000360, "Member 'UReadyOrNotCharacterAnimData::Alert_Turn90Right' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Alert_Turn180Left) == 0x000368, "Member 'UReadyOrNotCharacterAnimData::Alert_Turn180Left' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Alert_Turn180Right) == 0x000370, "Member 'UReadyOrNotCharacterAnimData::Alert_Turn180Right' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, AllAnimsList) == 0x000378, "Member 'UReadyOrNotCharacterAnimData::AllAnimsList' has a wrong offset!");

// Class ReadyOrNot.CoverLandmark
// 0x02D0 (0x04F0 - 0x0220)
class ACoverLandmark final  : public AActor
{
public:
	uint8                                         Pad_2551[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnabled : 1;                                      // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2552[0x7];                                     // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LandmarkName;                                      // 0x0238(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverLandmarkType                            Type;                                              // 0x0248(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2553[0x7];                                     // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USearchLandmarkActivity>    CustomSearchActivityClass;                         // 0x0250(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SwatSearchAnimation;                               // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  CoverObject;                                       // 0x0268(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDisableCollision : 1;                             // 0x0290(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2554[0x7];                                     // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ETeamType>                             AllowedTeamsForCover;                              // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AStaticMeshActor>> IgnoredMeshActors;                                 // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         CooldownAfterUse;                                  // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCharacterHiddenInWaitingState;                    // 0x02BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2555[0x3];                                     // 0x02BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ExitTriggerBoxTransform;                           // 0x02C0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ExitTriggerBoxExtent;                              // 0x02F0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2556[0x4];                                     // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             IdleTriggerBoxTransform;                           // 0x0300(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                IdleTriggerBoxExtent;                              // 0x0330(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2557[0x4];                                     // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoverLandmarkAnimData                 Entry;                                             // 0x0340(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCoverLandmarkAnimData                 Loop;                                              // 0x0398(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCoverLandmarkAnimData                 Exit;                                              // 0x03F0(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         bAllowAbruptExit : 1;                              // 0x0448(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2558[0x7];                                     // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACoverLandmarkProxy*>            EntryPoints;                                       // 0x0450(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class ACoverLandmarkProxy*>            ExitPoints;                                        // 0x0460(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class ACoverLandmarkProxy*                    IdlePoint;                                         // 0x0470(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            OccupiedByController;                              // 0x0478(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            LastUsedByController;                              // 0x0480(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   CurrentSwatWithLineOfSight;                        // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearedBySwat;                                    // 0x0490(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2559[0x7];                                     // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AController*, float>               CooldownMap;                                       // 0x0498(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_255A[0x8];                                     // 0x04E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCooldownFor(class AController* InController, float InCooldownTime);
	void DisableLandmark();
	void EnableLandmark();
	void PreviewEntryAnim();
	void PreviewExitAnim();
	void PreviewIdleAnim();
	void ToggleLandmarkEnabled(bool bEnable);

	bool IsCooldownActiveFor(class AController* InController) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverLandmark">();
	}
	static class ACoverLandmark* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoverLandmark>();
	}
};
static_assert(alignof(ACoverLandmark) == 0x000010, "Wrong alignment on ACoverLandmark");
static_assert(sizeof(ACoverLandmark) == 0x0004F0, "Wrong size on ACoverLandmark");
static_assert(offsetof(ACoverLandmark, SceneComponent) == 0x000228, "Member 'ACoverLandmark::SceneComponent' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, LandmarkName) == 0x000238, "Member 'ACoverLandmark::LandmarkName' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, Type) == 0x000248, "Member 'ACoverLandmark::Type' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, CustomSearchActivityClass) == 0x000250, "Member 'ACoverLandmark::CustomSearchActivityClass' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, SwatSearchAnimation) == 0x000258, "Member 'ACoverLandmark::SwatSearchAnimation' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, CoverObject) == 0x000268, "Member 'ACoverLandmark::CoverObject' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, AllowedTeamsForCover) == 0x000298, "Member 'ACoverLandmark::AllowedTeamsForCover' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, IgnoredMeshActors) == 0x0002A8, "Member 'ACoverLandmark::IgnoredMeshActors' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, CooldownAfterUse) == 0x0002B8, "Member 'ACoverLandmark::CooldownAfterUse' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, bCharacterHiddenInWaitingState) == 0x0002BC, "Member 'ACoverLandmark::bCharacterHiddenInWaitingState' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, ExitTriggerBoxTransform) == 0x0002C0, "Member 'ACoverLandmark::ExitTriggerBoxTransform' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, ExitTriggerBoxExtent) == 0x0002F0, "Member 'ACoverLandmark::ExitTriggerBoxExtent' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, IdleTriggerBoxTransform) == 0x000300, "Member 'ACoverLandmark::IdleTriggerBoxTransform' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, IdleTriggerBoxExtent) == 0x000330, "Member 'ACoverLandmark::IdleTriggerBoxExtent' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, Entry) == 0x000340, "Member 'ACoverLandmark::Entry' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, Loop) == 0x000398, "Member 'ACoverLandmark::Loop' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, Exit) == 0x0003F0, "Member 'ACoverLandmark::Exit' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, EntryPoints) == 0x000450, "Member 'ACoverLandmark::EntryPoints' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, ExitPoints) == 0x000460, "Member 'ACoverLandmark::ExitPoints' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, IdlePoint) == 0x000470, "Member 'ACoverLandmark::IdlePoint' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, OccupiedByController) == 0x000478, "Member 'ACoverLandmark::OccupiedByController' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, LastUsedByController) == 0x000480, "Member 'ACoverLandmark::LastUsedByController' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, CurrentSwatWithLineOfSight) == 0x000488, "Member 'ACoverLandmark::CurrentSwatWithLineOfSight' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, bClearedBySwat) == 0x000490, "Member 'ACoverLandmark::bClearedBySwat' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, CooldownMap) == 0x000498, "Member 'ACoverLandmark::CooldownMap' has a wrong offset!");

// Class ReadyOrNot.CoverLandmarkProxy
// 0x0018 (0x0238 - 0x0220)
class ACoverLandmarkProxy final  : public AActor
{
public:
	class ACoverLandmark*                         LandmarkOwner;                                     // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverLandmarkAnimDirection                   EntryDirection;                                    // 0x0228(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverLandmarkAnimDirection                   ExitDirection;                                     // 0x0229(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_255D[0x6];                                     // 0x022A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DisableProxyInteraction();
	void EnableProxyInteraction();
	void OnProxyEnd(bool bSuccess);
	void OnProxyUse(bool bIsActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverLandmarkProxy">();
	}
	static class ACoverLandmarkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoverLandmarkProxy>();
	}
};
static_assert(alignof(ACoverLandmarkProxy) == 0x000008, "Wrong alignment on ACoverLandmarkProxy");
static_assert(sizeof(ACoverLandmarkProxy) == 0x000238, "Wrong size on ACoverLandmarkProxy");
static_assert(offsetof(ACoverLandmarkProxy, LandmarkOwner) == 0x000220, "Member 'ACoverLandmarkProxy::LandmarkOwner' has a wrong offset!");
static_assert(offsetof(ACoverLandmarkProxy, EntryDirection) == 0x000228, "Member 'ACoverLandmarkProxy::EntryDirection' has a wrong offset!");
static_assert(offsetof(ACoverLandmarkProxy, ExitDirection) == 0x000229, "Member 'ACoverLandmarkProxy::ExitDirection' has a wrong offset!");
static_assert(offsetof(ACoverLandmarkProxy, SceneComponent) == 0x000230, "Member 'ACoverLandmarkProxy::SceneComponent' has a wrong offset!");

// Class ReadyOrNot.CoverQueryResultInterface
// 0x0000 (0x0028 - 0x0028)
class ICoverQueryResultInterface final  : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverQueryResultInterface">();
	}
	static class ICoverQueryResultInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICoverQueryResultInterface>();
	}
};
static_assert(alignof(ICoverQueryResultInterface) == 0x000008, "Wrong alignment on ICoverQueryResultInterface");
static_assert(sizeof(ICoverQueryResultInterface) == 0x000028, "Wrong size on ICoverQueryResultInterface");

// Class ReadyOrNot.WeaponSound
// 0x0188 (0x01B8 - 0x0030)
class UWeaponSound final  : public UDataAsset
{
public:
	bool                                          bPlayFMODFiringAudio;                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_255E[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             FMODGunShot1P;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODGunShot3P;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MagCheck_FullSeq;                                  // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             QuickReload_FullSeq;                               // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             QuickReloadEmpty_FullSeq;                          // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             Reload_FullSeq;                                    // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ReloadEmpty_FullSeq;                               // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MagIn;                                             // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MagOut;                                            // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MagInQuick;                                        // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MagOutQuick;                                       // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MagDrop;                                           // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MagDropQuick;                                      // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             WeaponDrop;                                        // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BoltClose;                                         // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BoltCloseQuick;                                    // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BoltOpen;                                          // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BoltOpenQuick;                                     // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             OnADSSound;                                        // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             OnEndADSSound;                                     // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             NightvisionOn;                                     // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             NightvisionOff;                                    // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             Holster;                                           // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             Draw;                                              // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DrawFirst;                                         // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SelectSemi;                                        // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SelectBurst;                                       // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SelectAuto;                                        // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SelectSafe;                                        // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeaponSoundData                       Firing_Inside;                                     // 0x0120(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponSoundData                       Firing_Outside;                                    // 0x0140(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DryFire;                                           // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FireLast;                                          // 0x0168(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayBulletWhizz;                                  // 0x0170(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_255F[0x7];                                     // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             BulletWhizzFar;                                    // 0x0178(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             HitMarker;                                         // 0x0180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             HeadshotMarker;                                    // 0x0188(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             KillMarker;                                        // 0x0190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             PhysicsImpact;                                     // 0x0198(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             PlayerImpact;                                      // 0x01A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsImpactMinimumVelocity;                      // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2560[0x4];                                     // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             MovementLayer;                                     // 0x01B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponSound">();
	}
	static class UWeaponSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponSound>();
	}
};
static_assert(alignof(UWeaponSound) == 0x000008, "Wrong alignment on UWeaponSound");
static_assert(sizeof(UWeaponSound) == 0x0001B8, "Wrong size on UWeaponSound");
static_assert(offsetof(UWeaponSound, bPlayFMODFiringAudio) == 0x000030, "Member 'UWeaponSound::bPlayFMODFiringAudio' has a wrong offset!");
static_assert(offsetof(UWeaponSound, FMODGunShot1P) == 0x000038, "Member 'UWeaponSound::FMODGunShot1P' has a wrong offset!");
static_assert(offsetof(UWeaponSound, FMODGunShot3P) == 0x000040, "Member 'UWeaponSound::FMODGunShot3P' has a wrong offset!");
static_assert(offsetof(UWeaponSound, MagCheck_FullSeq) == 0x000048, "Member 'UWeaponSound::MagCheck_FullSeq' has a wrong offset!");
static_assert(offsetof(UWeaponSound, QuickReload_FullSeq) == 0x000050, "Member 'UWeaponSound::QuickReload_FullSeq' has a wrong offset!");
static_assert(offsetof(UWeaponSound, QuickReloadEmpty_FullSeq) == 0x000058, "Member 'UWeaponSound::QuickReloadEmpty_FullSeq' has a wrong offset!");
static_assert(offsetof(UWeaponSound, Reload_FullSeq) == 0x000060, "Member 'UWeaponSound::Reload_FullSeq' has a wrong offset!");
static_assert(offsetof(UWeaponSound, ReloadEmpty_FullSeq) == 0x000068, "Member 'UWeaponSound::ReloadEmpty_FullSeq' has a wrong offset!");
static_assert(offsetof(UWeaponSound, MagIn) == 0x000070, "Member 'UWeaponSound::MagIn' has a wrong offset!");
static_assert(offsetof(UWeaponSound, MagOut) == 0x000078, "Member 'UWeaponSound::MagOut' has a wrong offset!");
static_assert(offsetof(UWeaponSound, MagInQuick) == 0x000080, "Member 'UWeaponSound::MagInQuick' has a wrong offset!");
static_assert(offsetof(UWeaponSound, MagOutQuick) == 0x000088, "Member 'UWeaponSound::MagOutQuick' has a wrong offset!");
static_assert(offsetof(UWeaponSound, MagDrop) == 0x000090, "Member 'UWeaponSound::MagDrop' has a wrong offset!");
static_assert(offsetof(UWeaponSound, MagDropQuick) == 0x000098, "Member 'UWeaponSound::MagDropQuick' has a wrong offset!");
static_assert(offsetof(UWeaponSound, WeaponDrop) == 0x0000A0, "Member 'UWeaponSound::WeaponDrop' has a wrong offset!");
static_assert(offsetof(UWeaponSound, BoltClose) == 0x0000A8, "Member 'UWeaponSound::BoltClose' has a wrong offset!");
static_assert(offsetof(UWeaponSound, BoltCloseQuick) == 0x0000B0, "Member 'UWeaponSound::BoltCloseQuick' has a wrong offset!");
static_assert(offsetof(UWeaponSound, BoltOpen) == 0x0000B8, "Member 'UWeaponSound::BoltOpen' has a wrong offset!");
static_assert(offsetof(UWeaponSound, BoltOpenQuick) == 0x0000C0, "Member 'UWeaponSound::BoltOpenQuick' has a wrong offset!");
static_assert(offsetof(UWeaponSound, OnADSSound) == 0x0000C8, "Member 'UWeaponSound::OnADSSound' has a wrong offset!");
static_assert(offsetof(UWeaponSound, OnEndADSSound) == 0x0000D0, "Member 'UWeaponSound::OnEndADSSound' has a wrong offset!");
static_assert(offsetof(UWeaponSound, NightvisionOn) == 0x0000D8, "Member 'UWeaponSound::NightvisionOn' has a wrong offset!");
static_assert(offsetof(UWeaponSound, NightvisionOff) == 0x0000E0, "Member 'UWeaponSound::NightvisionOff' has a wrong offset!");
static_assert(offsetof(UWeaponSound, Holster) == 0x0000E8, "Member 'UWeaponSound::Holster' has a wrong offset!");
static_assert(offsetof(UWeaponSound, Draw) == 0x0000F0, "Member 'UWeaponSound::Draw' has a wrong offset!");
static_assert(offsetof(UWeaponSound, DrawFirst) == 0x0000F8, "Member 'UWeaponSound::DrawFirst' has a wrong offset!");
static_assert(offsetof(UWeaponSound, SelectSemi) == 0x000100, "Member 'UWeaponSound::SelectSemi' has a wrong offset!");
static_assert(offsetof(UWeaponSound, SelectBurst) == 0x000108, "Member 'UWeaponSound::SelectBurst' has a wrong offset!");
static_assert(offsetof(UWeaponSound, SelectAuto) == 0x000110, "Member 'UWeaponSound::SelectAuto' has a wrong offset!");
static_assert(offsetof(UWeaponSound, SelectSafe) == 0x000118, "Member 'UWeaponSound::SelectSafe' has a wrong offset!");
static_assert(offsetof(UWeaponSound, Firing_Inside) == 0x000120, "Member 'UWeaponSound::Firing_Inside' has a wrong offset!");
static_assert(offsetof(UWeaponSound, Firing_Outside) == 0x000140, "Member 'UWeaponSound::Firing_Outside' has a wrong offset!");
static_assert(offsetof(UWeaponSound, DryFire) == 0x000160, "Member 'UWeaponSound::DryFire' has a wrong offset!");
static_assert(offsetof(UWeaponSound, FireLast) == 0x000168, "Member 'UWeaponSound::FireLast' has a wrong offset!");
static_assert(offsetof(UWeaponSound, bPlayBulletWhizz) == 0x000170, "Member 'UWeaponSound::bPlayBulletWhizz' has a wrong offset!");
static_assert(offsetof(UWeaponSound, BulletWhizzFar) == 0x000178, "Member 'UWeaponSound::BulletWhizzFar' has a wrong offset!");
static_assert(offsetof(UWeaponSound, HitMarker) == 0x000180, "Member 'UWeaponSound::HitMarker' has a wrong offset!");
static_assert(offsetof(UWeaponSound, HeadshotMarker) == 0x000188, "Member 'UWeaponSound::HeadshotMarker' has a wrong offset!");
static_assert(offsetof(UWeaponSound, KillMarker) == 0x000190, "Member 'UWeaponSound::KillMarker' has a wrong offset!");
static_assert(offsetof(UWeaponSound, PhysicsImpact) == 0x000198, "Member 'UWeaponSound::PhysicsImpact' has a wrong offset!");
static_assert(offsetof(UWeaponSound, PlayerImpact) == 0x0001A0, "Member 'UWeaponSound::PlayerImpact' has a wrong offset!");
static_assert(offsetof(UWeaponSound, PhysicsImpactMinimumVelocity) == 0x0001A8, "Member 'UWeaponSound::PhysicsImpactMinimumVelocity' has a wrong offset!");
static_assert(offsetof(UWeaponSound, MovementLayer) == 0x0001B0, "Member 'UWeaponSound::MovementLayer' has a wrong offset!");

// Class ReadyOrNot.CSGasData
// 0x0028 (0x0058 - 0x0030)
class UCSGasData final  : public UDataAsset
{
public:
	class UEnvQuery*                              GasGenerationQuery;                                // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APepperGasCloud>            PepperGasCloud;                                    // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafePointsBufferDistance;                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NavModifierExtents;                                // 0x004C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGasData">();
	}
	static class UCSGasData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGasData>();
	}
};
static_assert(alignof(UCSGasData) == 0x000008, "Wrong alignment on UCSGasData");
static_assert(sizeof(UCSGasData) == 0x000058, "Wrong size on UCSGasData");
static_assert(offsetof(UCSGasData, GasGenerationQuery) == 0x000030, "Member 'UCSGasData::GasGenerationQuery' has a wrong offset!");
static_assert(offsetof(UCSGasData, DamageType) == 0x000038, "Member 'UCSGasData::DamageType' has a wrong offset!");
static_assert(offsetof(UCSGasData, PepperGasCloud) == 0x000040, "Member 'UCSGasData::PepperGasCloud' has a wrong offset!");
static_assert(offsetof(UCSGasData, SafePointsBufferDistance) == 0x000048, "Member 'UCSGasData::SafePointsBufferDistance' has a wrong offset!");
static_assert(offsetof(UCSGasData, NavModifierExtents) == 0x00004C, "Member 'UCSGasData::NavModifierExtents' has a wrong offset!");

// Class ReadyOrNot.CSGasManager
// 0x00F0 (0x0130 - 0x0040)
class UCSGasManager final  : public UTickableWorldSubsystem
{
public:
	class UEnvQuery*                              GasGenerationQuery;                                // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxGasPointsPerSource;                             // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2561[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCSGasData*                             GasData;                                           // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 NavVolumesContainer;                               // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         GasSources;                                        // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        SafePoints;                                        // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        GasPoints;                                         // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AReadyOrNotCharacter*>           CharactersInGasSourceRadius;                       // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         PepperbalLGasSources;                              // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2562[0x4];                                     // 0x00B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NavModifierBoxExtents;                             // 0x00B4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2563[0x70];                                    // 0x00C0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCSGasManager* Get(class UWorld* World);

	void AddGasSource(class AActor* Source);
	void AddPepperballLocation(class APepperProjectile* Projectile, const struct FVector& Location, const struct FVector& Normal);
	void GetGasSafePoints(TArray<struct FVector>* OutGasSafePoints);
	void GetGasSources(TArray<class AActor*>* OutGasSources);
	void OnPepperCloudSpawned(struct FVector* Location);
	void RemoveGasSource(class AActor* Source);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGasManager">();
	}
	static class UCSGasManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGasManager>();
	}
};
static_assert(alignof(UCSGasManager) == 0x000008, "Wrong alignment on UCSGasManager");
static_assert(sizeof(UCSGasManager) == 0x000130, "Wrong size on UCSGasManager");
static_assert(offsetof(UCSGasManager, GasGenerationQuery) == 0x000040, "Member 'UCSGasManager::GasGenerationQuery' has a wrong offset!");
static_assert(offsetof(UCSGasManager, MaxGasPointsPerSource) == 0x000048, "Member 'UCSGasManager::MaxGasPointsPerSource' has a wrong offset!");
static_assert(offsetof(UCSGasManager, GasData) == 0x000050, "Member 'UCSGasManager::GasData' has a wrong offset!");
static_assert(offsetof(UCSGasManager, NavVolumesContainer) == 0x000058, "Member 'UCSGasManager::NavVolumesContainer' has a wrong offset!");
static_assert(offsetof(UCSGasManager, GasSources) == 0x000060, "Member 'UCSGasManager::GasSources' has a wrong offset!");
static_assert(offsetof(UCSGasManager, SafePoints) == 0x000070, "Member 'UCSGasManager::SafePoints' has a wrong offset!");
static_assert(offsetof(UCSGasManager, GasPoints) == 0x000080, "Member 'UCSGasManager::GasPoints' has a wrong offset!");
static_assert(offsetof(UCSGasManager, CharactersInGasSourceRadius) == 0x000090, "Member 'UCSGasManager::CharactersInGasSourceRadius' has a wrong offset!");
static_assert(offsetof(UCSGasManager, PepperbalLGasSources) == 0x0000A0, "Member 'UCSGasManager::PepperbalLGasSources' has a wrong offset!");
static_assert(offsetof(UCSGasManager, NavModifierBoxExtents) == 0x0000B4, "Member 'UCSGasManager::NavModifierBoxExtents' has a wrong offset!");

// Class ReadyOrNot.ReplaySplineActor
// 0x0018 (0x0238 - 0x0220)
class AReplaySplineActor final  : public AActor
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRotator>                       SplinePointRotations;                              // 0x0228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplaySplineActor">();
	}
	static class AReplaySplineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReplaySplineActor>();
	}
};
static_assert(alignof(AReplaySplineActor) == 0x000008, "Wrong alignment on AReplaySplineActor");
static_assert(sizeof(AReplaySplineActor) == 0x000238, "Wrong size on AReplaySplineActor");
static_assert(offsetof(AReplaySplineActor, SplineComponent) == 0x000220, "Member 'AReplaySplineActor::SplineComponent' has a wrong offset!");
static_assert(offsetof(AReplaySplineActor, SplinePointRotations) == 0x000228, "Member 'AReplaySplineActor::SplinePointRotations' has a wrong offset!");

// Class ReadyOrNot.CTF_FlagSpawnPoint
// 0x0000 (0x0238 - 0x0238)
class ACTF_FlagSpawnPoint final  : public AActorSpawnPoint
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CTF_FlagSpawnPoint">();
	}
	static class ACTF_FlagSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACTF_FlagSpawnPoint>();
	}
};
static_assert(alignof(ACTF_FlagSpawnPoint) == 0x000008, "Wrong alignment on ACTF_FlagSpawnPoint");
static_assert(sizeof(ACTF_FlagSpawnPoint) == 0x000238, "Wrong size on ACTF_FlagSpawnPoint");

// Class ReadyOrNot.CurrentMatchRoundWidget
// 0x0010 (0x0288 - 0x0278)
class UCurrentMatchRoundWidget final  : public UBaseWidget
{
public:
	class UTextBlock*                             CurrentRound_Text;                                 // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentRound_Text_Style2;                          // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrentMatchRoundWidget">();
	}
	static class UCurrentMatchRoundWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurrentMatchRoundWidget>();
	}
};
static_assert(alignof(UCurrentMatchRoundWidget) == 0x000008, "Wrong alignment on UCurrentMatchRoundWidget");
static_assert(sizeof(UCurrentMatchRoundWidget) == 0x000288, "Wrong size on UCurrentMatchRoundWidget");
static_assert(offsetof(UCurrentMatchRoundWidget, CurrentRound_Text) == 0x000278, "Member 'UCurrentMatchRoundWidget::CurrentRound_Text' has a wrong offset!");
static_assert(offsetof(UCurrentMatchRoundWidget, CurrentRound_Text_Style2) == 0x000280, "Member 'UCurrentMatchRoundWidget::CurrentRound_Text_Style2' has a wrong offset!");

// Class ReadyOrNot.MissionPlanLinesWidget
// 0x0030 (0x0138 - 0x0108)
class UMissionPlanLinesWidget final  : public UWidget
{
public:
	float                                         LineWidth;                                         // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstNodeRadius;                                   // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NodeRadius;                                        // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2564[0x4];                                     // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     LineMaterial;                                      // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyDrawPreviewLine;                              // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2565[0x17];                                    // 0x0121(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurrentFloor(int32 Floor);
	void SetPreviewLine(struct FPlanningLine& Line);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionPlanLinesWidget">();
	}
	static class UMissionPlanLinesWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionPlanLinesWidget>();
	}
};
static_assert(alignof(UMissionPlanLinesWidget) == 0x000008, "Wrong alignment on UMissionPlanLinesWidget");
static_assert(sizeof(UMissionPlanLinesWidget) == 0x000138, "Wrong size on UMissionPlanLinesWidget");
static_assert(offsetof(UMissionPlanLinesWidget, LineWidth) == 0x000108, "Member 'UMissionPlanLinesWidget::LineWidth' has a wrong offset!");
static_assert(offsetof(UMissionPlanLinesWidget, FirstNodeRadius) == 0x00010C, "Member 'UMissionPlanLinesWidget::FirstNodeRadius' has a wrong offset!");
static_assert(offsetof(UMissionPlanLinesWidget, NodeRadius) == 0x000110, "Member 'UMissionPlanLinesWidget::NodeRadius' has a wrong offset!");
static_assert(offsetof(UMissionPlanLinesWidget, LineMaterial) == 0x000118, "Member 'UMissionPlanLinesWidget::LineMaterial' has a wrong offset!");
static_assert(offsetof(UMissionPlanLinesWidget, bOnlyDrawPreviewLine) == 0x000120, "Member 'UMissionPlanLinesWidget::bOnlyDrawPreviewLine' has a wrong offset!");

// Class ReadyOrNot.CustomizationEmpty
// 0x0000 (0x0170 - 0x0170)
class UCustomizationEmpty final  : public UCustomizationDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationEmpty">();
	}
	static class UCustomizationEmpty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationEmpty>();
	}
};
static_assert(alignof(UCustomizationEmpty) == 0x000008, "Wrong alignment on UCustomizationEmpty");
static_assert(sizeof(UCustomizationEmpty) == 0x000170, "Wrong size on UCustomizationEmpty");

// Class ReadyOrNot.CustomizationSkeletalMesh
// 0x0098 (0x0208 - 0x0170)
class UCustomizationSkeletalMesh final  : public UCustomizationDataBase
{
public:
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh;                                      // 0x0170(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0198(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMasterPose;                                    // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2566[0x7];                                     // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomizationMaterialSlot>     MaterialOverrides;                                 // 0x01A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, class FName>                SocketOverridesMap;                                // 0x01B8(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSkeletalMesh">();
	}
	static class UCustomizationSkeletalMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationSkeletalMesh>();
	}
};
static_assert(alignof(UCustomizationSkeletalMesh) == 0x000008, "Wrong alignment on UCustomizationSkeletalMesh");
static_assert(sizeof(UCustomizationSkeletalMesh) == 0x000208, "Wrong size on UCustomizationSkeletalMesh");
static_assert(offsetof(UCustomizationSkeletalMesh, SkeletalMesh) == 0x000170, "Member 'UCustomizationSkeletalMesh::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UCustomizationSkeletalMesh, Socket) == 0x000198, "Member 'UCustomizationSkeletalMesh::Socket' has a wrong offset!");
static_assert(offsetof(UCustomizationSkeletalMesh, bUseMasterPose) == 0x0001A0, "Member 'UCustomizationSkeletalMesh::bUseMasterPose' has a wrong offset!");
static_assert(offsetof(UCustomizationSkeletalMesh, MaterialOverrides) == 0x0001A8, "Member 'UCustomizationSkeletalMesh::MaterialOverrides' has a wrong offset!");
static_assert(offsetof(UCustomizationSkeletalMesh, SocketOverridesMap) == 0x0001B8, "Member 'UCustomizationSkeletalMesh::SocketOverridesMap' has a wrong offset!");

// Class ReadyOrNot.PlayersList
// 0x0040 (0x0360 - 0x0320)
class UPlayersList : public UCommonActivatableWidget
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FLobbyPlayer>                   PlayersList;                                       // 0x0340(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMuteStateDelegate;                               // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool GetMutedState(class FString& UniqueNetId);
	void GetPlayersList();
	class APlayerState* GetPlayerStateFromUniqueId(const class FString& UniqueId);
	void MuteStateDelegate__DelegateSignature();
	void OnPlayersListUpdated__DelegateSignature();
	void SetMutedState(class FString& UniqueNetId, bool Value);
	void UpdatedMutedState();
	bool VivoxAvailable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayersList">();
	}
	static class UPlayersList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayersList>();
	}
};
static_assert(alignof(UPlayersList) == 0x000008, "Wrong alignment on UPlayersList");
static_assert(sizeof(UPlayersList) == 0x000360, "Wrong size on UPlayersList");
static_assert(offsetof(UPlayersList, OnSuccess) == 0x000320, "Member 'UPlayersList::OnSuccess' has a wrong offset!");
static_assert(offsetof(UPlayersList, OnFailure) == 0x000330, "Member 'UPlayersList::OnFailure' has a wrong offset!");
static_assert(offsetof(UPlayersList, PlayersList) == 0x000340, "Member 'UPlayersList::PlayersList' has a wrong offset!");
static_assert(offsetof(UPlayersList, OnMuteStateDelegate) == 0x000350, "Member 'UPlayersList::OnMuteStateDelegate' has a wrong offset!");

// Class ReadyOrNot.CustomizationStaticMesh
// 0x0030 (0x01A0 - 0x0170)
class UCustomizationStaticMesh final  : public UCustomizationDataBase
{
public:
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0170(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0198(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationStaticMesh">();
	}
	static class UCustomizationStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationStaticMesh>();
	}
};
static_assert(alignof(UCustomizationStaticMesh) == 0x000008, "Wrong alignment on UCustomizationStaticMesh");
static_assert(sizeof(UCustomizationStaticMesh) == 0x0001A0, "Wrong size on UCustomizationStaticMesh");
static_assert(offsetof(UCustomizationStaticMesh, StaticMesh) == 0x000170, "Member 'UCustomizationStaticMesh::StaticMesh' has a wrong offset!");
static_assert(offsetof(UCustomizationStaticMesh, Socket) == 0x000198, "Member 'UCustomizationStaticMesh::Socket' has a wrong offset!");

// Class ReadyOrNot.CustomizationSkin
// 0x0058 (0x01C8 - 0x0170)
class UCustomizationSkin final  : public UCustomizationDataBase
{
public:
	TArray<class FName>                           CompatibleItemTags;                                // 0x0170(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           MeshOverride;                                      // 0x0180(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCustomizationMaterialSlot>     MaterialSlots;                                     // 0x01A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseSocketOverride;                                // 0x01B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2569[0x3];                                     // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketOverride;                                    // 0x01BC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_256A[0x4];                                     // 0x01C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSkin">();
	}
	static class UCustomizationSkin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationSkin>();
	}
};
static_assert(alignof(UCustomizationSkin) == 0x000008, "Wrong alignment on UCustomizationSkin");
static_assert(sizeof(UCustomizationSkin) == 0x0001C8, "Wrong size on UCustomizationSkin");
static_assert(offsetof(UCustomizationSkin, CompatibleItemTags) == 0x000170, "Member 'UCustomizationSkin::CompatibleItemTags' has a wrong offset!");
static_assert(offsetof(UCustomizationSkin, MeshOverride) == 0x000180, "Member 'UCustomizationSkin::MeshOverride' has a wrong offset!");
static_assert(offsetof(UCustomizationSkin, MaterialSlots) == 0x0001A8, "Member 'UCustomizationSkin::MaterialSlots' has a wrong offset!");
static_assert(offsetof(UCustomizationSkin, bUseSocketOverride) == 0x0001B8, "Member 'UCustomizationSkin::bUseSocketOverride' has a wrong offset!");
static_assert(offsetof(UCustomizationSkin, SocketOverride) == 0x0001BC, "Member 'UCustomizationSkin::SocketOverride' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotAnimInstance
// 0x01A0 (0x0460 - 0x02C0)
class UReadyOrNotAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_256B[0x4];                                     // 0x02B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Velocity;                                          // 0x02BC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedHorizontal;                                   // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedVertical;                                     // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction;                                         // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewPitch;                                         // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewYaw;                                           // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x02E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInAir;                                          // 0x02E5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_256C[0x2];                                     // 0x02E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               HeadLookRotation;                                  // 0x02E8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_256D[0xC];                                     // 0x02F4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ActorTransform;                                    // 0x0300(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                VelocityLocalNormalized;                           // 0x0330(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoveDirection                                CurrentDirection;                                  // 0x033C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_256E[0x3];                                     // 0x033D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 WalkSpeedDatabase;                                 // 0x0340(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 JogSpeedDatabase;                                  // 0x0350(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 CrouchWalkSpeedDatabase;                           // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DirDegreesPerSecond;                               // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardDirAngle;                                   // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardDirAngle;                                  // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftDirAngle;                                      // 0x037C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightDirAngle;                                     // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardDirDeg;                                     // 0x0384(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardDirDeg;                                    // 0x0388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftDirDeg;                                        // 0x038C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightDirDeg;                                       // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeForwardDir;                                  // 0x0394(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeBackwardDir;                                 // 0x0398(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeLeftDir;                                     // 0x039C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeRightDir;                                    // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementAlpha;                                     // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementJogAlpha;                                  // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementJogThreshold;                              // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftFootIKLocation;                                // 0x03B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightFootIKLocation;                               // 0x03BC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftFootIKRotation;                                // 0x03C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RightFootIKRotation;                               // 0x03D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                HipOffsetVector;                                   // 0x03E0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouching;                                        // 0x03EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStopping;                                       // 0x03ED(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_256F[0x2];                                     // 0x03EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               HeadRotation;                                      // 0x03F0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2570[0x4];                                     // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCarryArrestedAnimState                CarryArrestedAnimState;                            // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsCarried;                                        // 0x0408(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCarrying;                                       // 0x0409(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMotionBlockType                              CurMotionBlock;                                    // 0x040A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFalling;                                        // 0x040B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPrelanded;                                     // 0x040C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumpRecoveryActive;                               // 0x040D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2571[0x2];                                     // 0x040E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpRecoveryAnimTime;                              // 0x0410(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpRecoveryStrength;                              // 0x0414(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpRecoveryTime;                                  // 0x0418(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2572[0xC];                                     // 0x041C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DirAngle;                                          // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirAngleDegrees;                                   // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoveDirectionExt                             CurrentDirectionExt;                               // 0x0430(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTeamMLO;                                        // 0x0431(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2573[0x2];                                     // 0x0432(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftHandIKAlpha;                                   // 0x0434(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintAlpha;                                       // 0x0438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDeployableEquipped;                             // 0x043C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPistol;                                         // 0x043D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRifle;                                          // 0x043E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsItem;                                           // 0x043F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemOneHanded;                                    // 0x0440(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsC2Charge;                                       // 0x0441(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLevel1MovementTrigger;                            // 0x0442(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLevel2MovementTrigger;                            // 0x0443(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLevel3MovementTrigger;                            // 0x0444(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouchLevel1MovementTrigger;                      // 0x0445(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotationRateReached;                              // 0x0446(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2574[0x1];                                     // 0x0447(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaRotation;                                     // 0x0448(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2575[0xC];                                     // 0x044C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintFPAlpha;                                     // 0x0458(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisMovementBobAlpha;                            // 0x045C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	EMoveDirectionExt GetCurrentDirectionExtFromYawAngle(float YawAngle);
	struct FRotator GetLookAtRotation();
	EMoveDirectionExt GetOppositeDirectionExt(EMoveDirectionExt CurrentDir);
	float GetWeightFromSlot(class FName SlotName);
	float GetWeightFromSlotInversed(class FName SlotName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotAnimInstance">();
	}
	static class UReadyOrNotAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotAnimInstance>();
	}
};
static_assert(alignof(UReadyOrNotAnimInstance) == 0x000010, "Wrong alignment on UReadyOrNotAnimInstance");
static_assert(sizeof(UReadyOrNotAnimInstance) == 0x000460, "Wrong size on UReadyOrNotAnimInstance");
static_assert(offsetof(UReadyOrNotAnimInstance, Velocity) == 0x0002BC, "Member 'UReadyOrNotAnimInstance::Velocity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, Speed) == 0x0002C8, "Member 'UReadyOrNotAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, SpeedHorizontal) == 0x0002CC, "Member 'UReadyOrNotAnimInstance::SpeedHorizontal' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, SpeedVertical) == 0x0002D0, "Member 'UReadyOrNotAnimInstance::SpeedVertical' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, MaxSpeed) == 0x0002D4, "Member 'UReadyOrNotAnimInstance::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, Direction) == 0x0002D8, "Member 'UReadyOrNotAnimInstance::Direction' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, ViewPitch) == 0x0002DC, "Member 'UReadyOrNotAnimInstance::ViewPitch' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, ViewYaw) == 0x0002E0, "Member 'UReadyOrNotAnimInstance::ViewYaw' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsMoving) == 0x0002E4, "Member 'UReadyOrNotAnimInstance::bIsMoving' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsInAir) == 0x0002E5, "Member 'UReadyOrNotAnimInstance::bIsInAir' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, HeadLookRotation) == 0x0002E8, "Member 'UReadyOrNotAnimInstance::HeadLookRotation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, ActorTransform) == 0x000300, "Member 'UReadyOrNotAnimInstance::ActorTransform' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, VelocityLocalNormalized) == 0x000330, "Member 'UReadyOrNotAnimInstance::VelocityLocalNormalized' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, CurrentDirection) == 0x00033C, "Member 'UReadyOrNotAnimInstance::CurrentDirection' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, WalkSpeedDatabase) == 0x000340, "Member 'UReadyOrNotAnimInstance::WalkSpeedDatabase' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, JogSpeedDatabase) == 0x000350, "Member 'UReadyOrNotAnimInstance::JogSpeedDatabase' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, CrouchWalkSpeedDatabase) == 0x000360, "Member 'UReadyOrNotAnimInstance::CrouchWalkSpeedDatabase' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, DirDegreesPerSecond) == 0x000370, "Member 'UReadyOrNotAnimInstance::DirDegreesPerSecond' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, ForwardDirAngle) == 0x000374, "Member 'UReadyOrNotAnimInstance::ForwardDirAngle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, BackwardDirAngle) == 0x000378, "Member 'UReadyOrNotAnimInstance::BackwardDirAngle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, LeftDirAngle) == 0x00037C, "Member 'UReadyOrNotAnimInstance::LeftDirAngle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, RightDirAngle) == 0x000380, "Member 'UReadyOrNotAnimInstance::RightDirAngle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, ForwardDirDeg) == 0x000384, "Member 'UReadyOrNotAnimInstance::ForwardDirDeg' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, BackwardDirDeg) == 0x000388, "Member 'UReadyOrNotAnimInstance::BackwardDirDeg' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, LeftDirDeg) == 0x00038C, "Member 'UReadyOrNotAnimInstance::LeftDirDeg' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, RightDirDeg) == 0x000390, "Member 'UReadyOrNotAnimInstance::RightDirDeg' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, StrafeForwardDir) == 0x000394, "Member 'UReadyOrNotAnimInstance::StrafeForwardDir' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, StrafeBackwardDir) == 0x000398, "Member 'UReadyOrNotAnimInstance::StrafeBackwardDir' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, StrafeLeftDir) == 0x00039C, "Member 'UReadyOrNotAnimInstance::StrafeLeftDir' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, StrafeRightDir) == 0x0003A0, "Member 'UReadyOrNotAnimInstance::StrafeRightDir' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, MovementAlpha) == 0x0003A4, "Member 'UReadyOrNotAnimInstance::MovementAlpha' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, MovementJogAlpha) == 0x0003A8, "Member 'UReadyOrNotAnimInstance::MovementJogAlpha' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, MovementJogThreshold) == 0x0003AC, "Member 'UReadyOrNotAnimInstance::MovementJogThreshold' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, LeftFootIKLocation) == 0x0003B0, "Member 'UReadyOrNotAnimInstance::LeftFootIKLocation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, RightFootIKLocation) == 0x0003BC, "Member 'UReadyOrNotAnimInstance::RightFootIKLocation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, LeftFootIKRotation) == 0x0003C8, "Member 'UReadyOrNotAnimInstance::LeftFootIKRotation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, RightFootIKRotation) == 0x0003D4, "Member 'UReadyOrNotAnimInstance::RightFootIKRotation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, HipOffsetVector) == 0x0003E0, "Member 'UReadyOrNotAnimInstance::HipOffsetVector' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bCrouching) == 0x0003EC, "Member 'UReadyOrNotAnimInstance::bCrouching' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsStopping) == 0x0003ED, "Member 'UReadyOrNotAnimInstance::bIsStopping' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, HeadRotation) == 0x0003F0, "Member 'UReadyOrNotAnimInstance::HeadRotation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, CarryArrestedAnimState) == 0x000400, "Member 'UReadyOrNotAnimInstance::CarryArrestedAnimState' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsCarried) == 0x000408, "Member 'UReadyOrNotAnimInstance::bIsCarried' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsCarrying) == 0x000409, "Member 'UReadyOrNotAnimInstance::bIsCarrying' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, CurMotionBlock) == 0x00040A, "Member 'UReadyOrNotAnimInstance::CurMotionBlock' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsFalling) == 0x00040B, "Member 'UReadyOrNotAnimInstance::bIsFalling' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bHasPrelanded) == 0x00040C, "Member 'UReadyOrNotAnimInstance::bHasPrelanded' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bJumpRecoveryActive) == 0x00040D, "Member 'UReadyOrNotAnimInstance::bJumpRecoveryActive' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, JumpRecoveryAnimTime) == 0x000410, "Member 'UReadyOrNotAnimInstance::JumpRecoveryAnimTime' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, JumpRecoveryStrength) == 0x000414, "Member 'UReadyOrNotAnimInstance::JumpRecoveryStrength' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, JumpRecoveryTime) == 0x000418, "Member 'UReadyOrNotAnimInstance::JumpRecoveryTime' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, DirAngle) == 0x000428, "Member 'UReadyOrNotAnimInstance::DirAngle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, DirAngleDegrees) == 0x00042C, "Member 'UReadyOrNotAnimInstance::DirAngleDegrees' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, CurrentDirectionExt) == 0x000430, "Member 'UReadyOrNotAnimInstance::CurrentDirectionExt' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsTeamMLO) == 0x000431, "Member 'UReadyOrNotAnimInstance::bIsTeamMLO' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, LeftHandIKAlpha) == 0x000434, "Member 'UReadyOrNotAnimInstance::LeftHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, SprintAlpha) == 0x000438, "Member 'UReadyOrNotAnimInstance::SprintAlpha' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsDeployableEquipped) == 0x00043C, "Member 'UReadyOrNotAnimInstance::bIsDeployableEquipped' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsPistol) == 0x00043D, "Member 'UReadyOrNotAnimInstance::bIsPistol' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsRifle) == 0x00043E, "Member 'UReadyOrNotAnimInstance::bIsRifle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsItem) == 0x00043F, "Member 'UReadyOrNotAnimInstance::bIsItem' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bItemOneHanded) == 0x000440, "Member 'UReadyOrNotAnimInstance::bItemOneHanded' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsC2Charge) == 0x000441, "Member 'UReadyOrNotAnimInstance::bIsC2Charge' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bLevel1MovementTrigger) == 0x000442, "Member 'UReadyOrNotAnimInstance::bLevel1MovementTrigger' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bLevel2MovementTrigger) == 0x000443, "Member 'UReadyOrNotAnimInstance::bLevel2MovementTrigger' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bLevel3MovementTrigger) == 0x000444, "Member 'UReadyOrNotAnimInstance::bLevel3MovementTrigger' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bCrouchLevel1MovementTrigger) == 0x000445, "Member 'UReadyOrNotAnimInstance::bCrouchLevel1MovementTrigger' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bRotationRateReached) == 0x000446, "Member 'UReadyOrNotAnimInstance::bRotationRateReached' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, DeltaRotation) == 0x000448, "Member 'UReadyOrNotAnimInstance::DeltaRotation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, SprintFPAlpha) == 0x000458, "Member 'UReadyOrNotAnimInstance::SprintFPAlpha' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, PelvisMovementBobAlpha) == 0x00045C, "Member 'UReadyOrNotAnimInstance::PelvisMovementBobAlpha' has a wrong offset!");

// Class ReadyOrNot.CustomizationVoice
// 0x0008 (0x0178 - 0x0170)
class UCustomizationVoice final  : public UCustomizationDataBase
{
public:
	class FName                                   VoiceHandle;                                       // 0x0170(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationVoice">();
	}
	static class UCustomizationVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationVoice>();
	}
};
static_assert(alignof(UCustomizationVoice) == 0x000008, "Wrong alignment on UCustomizationVoice");
static_assert(sizeof(UCustomizationVoice) == 0x000178, "Wrong size on UCustomizationVoice");
static_assert(offsetof(UCustomizationVoice, VoiceHandle) == 0x000170, "Member 'UCustomizationVoice::VoiceHandle' has a wrong offset!");

// Class ReadyOrNot.LoadoutWeapon
// 0x0000 (0x0088 - 0x0088)
class ULoadoutWeapon final  : public ULoadoutEquipment
{
public:
	TArray<TSubclassOf<class UWeaponAttachment>> GetSupportedAttachmentsOfType(EWeaponAttachmentType Type) const;
	TArray<EWeaponAttachmentType> GetSupportedAttachmentTypes() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutWeapon">();
	}
	static class ULoadoutWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutWeapon>();
	}
};
static_assert(alignof(ULoadoutWeapon) == 0x000008, "Wrong alignment on ULoadoutWeapon");
static_assert(sizeof(ULoadoutWeapon) == 0x000088, "Wrong size on ULoadoutWeapon");

// Class ReadyOrNot.CustomizationWidget
// 0x03B8 (0x06D8 - 0x0320)
class UCustomizationWidget : public UCommonActivatableWidget
{
public:
	TMap<ECustomizationType, class UFMODEvent*>   CustomizationEquipEvents;                          // 0x0320(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class ULoadoutManager*                        LoadoutManager;                                    // 0x0370(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseProfile*                           Profile;                                           // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2578[0x8];                                     // 0x0380(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedLoadout                          CurrentLoadout;                                    // 0x0388(0x0188)(Transient, NativeAccessSpecifierPrivate)
	class AReadyOrNotCharacter*                   PreviewCharacter;                                  // 0x0510(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ULoadoutWeapon*>                 CachedPrimaryWeapons;                              // 0x0518(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ULoadoutWeapon*>                 CachedSecondaryWeapons;                            // 0x0528(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ULoadoutEquipment*>              CachedLongTacticalItems;                           // 0x0538(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ULoadoutEquipment*>              CachedTacticalItems;                               // 0x0548(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ULoadoutEquipment*>              CachedArmorItems;                                  // 0x0558(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ULoadoutEquipment*>              CachedHelmetItems;                                 // 0x0568(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FSavedCustomization                    CurrentCustomization;                              // 0x0578(0x00D0)(Transient, NativeAccessSpecifierPrivate)
	TArray<class ULoadoutCustomization*>          CachedCustomizationItems;                          // 0x0648(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ULoadoutCustomization*>          CachedCustomizationFamilies;                       // 0x0658(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FCompatibleSkinsArray> ItemToSkinsMap;                                    // 0x0668(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class ABaseItem*                              CustomizationTargetPrimaryWeapon;                  // 0x06B8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              CustomizationTargetSecondaryWeapon;                // 0x06C0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              CustomizationTargetArmor;                          // 0x06C8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              CustomizationTargetHelmet;                         // 0x06D0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ArmorSet(TSubclassOf<class ABaseItem> Param_Class);
	bool CanCustomizeType(ECustomizationType Type);
	void ClearCustomizationPreview();
	void ExitCustomization();
	const TArray<class ULoadoutEquipment*> GetArmorItems();
	TArray<class ULoadoutCustomization*> GetCustomizationItems(ECustomizationType Type, bool bFamiliesOnly);
	class ULoadoutCustomization* GetEquippedCustomizationItem(ECustomizationType Type);
	const TArray<class ULoadoutEquipment*> GetHelmetItems();
	const TArray<class ULoadoutEquipment*> GetLongTacticalItems();
	const TArray<class ULoadoutWeapon*> GetPrimaryWeapons();
	const TArray<class ULoadoutWeapon*> GetSecondaryWeapons();
	const TArray<class ULoadoutEquipment*> GetTacticalItems();
	void HelmetSet(TSubclassOf<class ABaseItem> Param_Class);
	void PreviewCustomizationItem(class ULoadoutCustomization* Item);
	void PrimarySet(TSubclassOf<class ABaseItem> Param_Class);
	void SecondarySet(TSubclassOf<class ABaseItem> Param_Class);
	void SetActiveSwatMember(EEquippingSwat InSwat);
	void SetArmor(class ULoadoutEquipment* Item);
	void SetCustomizationItem(class ULoadoutCustomization* Item);
	void SetHelmet(class ULoadoutEquipment* Item);
	void SetLongTactical(class ULoadoutEquipment* Item);
	void SetPrimaryAttachment(class UWeaponAttachment* Attachment);
	void SetPrimaryWeapon(class ULoadoutWeapon* Item);
	void SetSecondaryAttachment(class UWeaponAttachment* Attachment);
	void SetSecondaryWeapon(class ULoadoutWeapon* Item);

	EEquippingSwat GetActiveSwatMember() const;
	class ULoadoutEquipment* GetArmor() const;
	class ULoadoutEquipment* GetHelmet() const;
	class ULoadoutEquipment* GetLongTactical() const;
	class ULoadoutWeapon* GetPrimaryWeapon() const;
	class ULoadoutWeapon* GetSecondaryWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationWidget">();
	}
	static class UCustomizationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationWidget>();
	}
};
static_assert(alignof(UCustomizationWidget) == 0x000008, "Wrong alignment on UCustomizationWidget");
static_assert(sizeof(UCustomizationWidget) == 0x0006D8, "Wrong size on UCustomizationWidget");
static_assert(offsetof(UCustomizationWidget, CustomizationEquipEvents) == 0x000320, "Member 'UCustomizationWidget::CustomizationEquipEvents' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, LoadoutManager) == 0x000370, "Member 'UCustomizationWidget::LoadoutManager' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, Profile) == 0x000378, "Member 'UCustomizationWidget::Profile' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CurrentLoadout) == 0x000388, "Member 'UCustomizationWidget::CurrentLoadout' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, PreviewCharacter) == 0x000510, "Member 'UCustomizationWidget::PreviewCharacter' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CachedPrimaryWeapons) == 0x000518, "Member 'UCustomizationWidget::CachedPrimaryWeapons' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CachedSecondaryWeapons) == 0x000528, "Member 'UCustomizationWidget::CachedSecondaryWeapons' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CachedLongTacticalItems) == 0x000538, "Member 'UCustomizationWidget::CachedLongTacticalItems' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CachedTacticalItems) == 0x000548, "Member 'UCustomizationWidget::CachedTacticalItems' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CachedArmorItems) == 0x000558, "Member 'UCustomizationWidget::CachedArmorItems' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CachedHelmetItems) == 0x000568, "Member 'UCustomizationWidget::CachedHelmetItems' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CurrentCustomization) == 0x000578, "Member 'UCustomizationWidget::CurrentCustomization' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CachedCustomizationItems) == 0x000648, "Member 'UCustomizationWidget::CachedCustomizationItems' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CachedCustomizationFamilies) == 0x000658, "Member 'UCustomizationWidget::CachedCustomizationFamilies' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, ItemToSkinsMap) == 0x000668, "Member 'UCustomizationWidget::ItemToSkinsMap' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CustomizationTargetPrimaryWeapon) == 0x0006B8, "Member 'UCustomizationWidget::CustomizationTargetPrimaryWeapon' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CustomizationTargetSecondaryWeapon) == 0x0006C0, "Member 'UCustomizationWidget::CustomizationTargetSecondaryWeapon' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CustomizationTargetArmor) == 0x0006C8, "Member 'UCustomizationWidget::CustomizationTargetArmor' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CustomizationTargetHelmet) == 0x0006D0, "Member 'UCustomizationWidget::CustomizationTargetHelmet' has a wrong offset!");

// Class ReadyOrNot.DataSingleton
// 0x0298 (0x02C0 - 0x0028)
class UDataSingleton : public UObject
{
public:
	class ULookupData*                            LookupData;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawBulletDebug;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawNoNameplates;                                 // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_257B[0x6];                                     // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           LoadingScreen_Tips;                                // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   YouKilledFormat;                                   // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FText>                           KillfeedFormatRandom;                              // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           ArrestfeedFormatRandom;                            // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           FreefeedFormatRandom;                              // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           TeamkillfeedFormatRandom;                          // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   KillfeedWithA;                                     // 0x00A0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bShowGrenadeDamage;                                // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_257C[0x7];                                     // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemData*                              ItemData;                                          // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetsData*                           WidgetData;                                        // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPenetrationData*                       PenetrationData;                                   // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCampaignData*                          CampaignData;                                      // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ItemDataLookupTable;                               // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AmmoDataLookupTable;                               // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AIDataLookupTable;                                 // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             LevelDataLookupTable;                              // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AnimationDataLookupTable;                          // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AnimatedIconLookupTable;                           // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DoorDataLookupTable;                               // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TrapDataLookupTable;                               // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ConversationLookupTable;                           // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             GameSettingsLookupTable;                           // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CharacterLookOverrideTable;                        // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             RonInputKeyTable;                                  // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             InputKeyGamePadIconTable;                          // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class UDataTable*>        SpeechDataLookupTable;                             // 0x0148(0x0050)(Edit, NativeAccessSpecifierPublic)
	class UDataTable*                             WidgetDataLookupTable;                             // 0x0198(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             SuspectArmourDataTable;                            // 0x01A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PairedInteractionDataTable;                        // 0x01A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MoveStyleDataTable;                                // 0x01B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomizationCharacterLevel;                       // 0x01B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomizationMenuLevel;                            // 0x01C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWorldBuildingActivity>> RandomWorldBuildingActivities;                     // 0x01C8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_257D[0xE8];                                    // 0x01D8(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LoadLevels();
	void RefreshInputKeyTable();
	void UnloadLevels();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataSingleton">();
	}
	static class UDataSingleton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataSingleton>();
	}
};
static_assert(alignof(UDataSingleton) == 0x000008, "Wrong alignment on UDataSingleton");
static_assert(sizeof(UDataSingleton) == 0x0002C0, "Wrong size on UDataSingleton");
static_assert(offsetof(UDataSingleton, LookupData) == 0x000028, "Member 'UDataSingleton::LookupData' has a wrong offset!");
static_assert(offsetof(UDataSingleton, bDrawBulletDebug) == 0x000030, "Member 'UDataSingleton::bDrawBulletDebug' has a wrong offset!");
static_assert(offsetof(UDataSingleton, bDrawNoNameplates) == 0x000031, "Member 'UDataSingleton::bDrawNoNameplates' has a wrong offset!");
static_assert(offsetof(UDataSingleton, LoadingScreen_Tips) == 0x000038, "Member 'UDataSingleton::LoadingScreen_Tips' has a wrong offset!");
static_assert(offsetof(UDataSingleton, YouKilledFormat) == 0x000048, "Member 'UDataSingleton::YouKilledFormat' has a wrong offset!");
static_assert(offsetof(UDataSingleton, KillfeedFormatRandom) == 0x000060, "Member 'UDataSingleton::KillfeedFormatRandom' has a wrong offset!");
static_assert(offsetof(UDataSingleton, ArrestfeedFormatRandom) == 0x000070, "Member 'UDataSingleton::ArrestfeedFormatRandom' has a wrong offset!");
static_assert(offsetof(UDataSingleton, FreefeedFormatRandom) == 0x000080, "Member 'UDataSingleton::FreefeedFormatRandom' has a wrong offset!");
static_assert(offsetof(UDataSingleton, TeamkillfeedFormatRandom) == 0x000090, "Member 'UDataSingleton::TeamkillfeedFormatRandom' has a wrong offset!");
static_assert(offsetof(UDataSingleton, KillfeedWithA) == 0x0000A0, "Member 'UDataSingleton::KillfeedWithA' has a wrong offset!");
static_assert(offsetof(UDataSingleton, bShowGrenadeDamage) == 0x0000B8, "Member 'UDataSingleton::bShowGrenadeDamage' has a wrong offset!");
static_assert(offsetof(UDataSingleton, ItemData) == 0x0000C0, "Member 'UDataSingleton::ItemData' has a wrong offset!");
static_assert(offsetof(UDataSingleton, WidgetData) == 0x0000C8, "Member 'UDataSingleton::WidgetData' has a wrong offset!");
static_assert(offsetof(UDataSingleton, PenetrationData) == 0x0000D0, "Member 'UDataSingleton::PenetrationData' has a wrong offset!");
static_assert(offsetof(UDataSingleton, CampaignData) == 0x0000D8, "Member 'UDataSingleton::CampaignData' has a wrong offset!");
static_assert(offsetof(UDataSingleton, ItemDataLookupTable) == 0x0000E0, "Member 'UDataSingleton::ItemDataLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, AmmoDataLookupTable) == 0x0000E8, "Member 'UDataSingleton::AmmoDataLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, AIDataLookupTable) == 0x0000F0, "Member 'UDataSingleton::AIDataLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, LevelDataLookupTable) == 0x0000F8, "Member 'UDataSingleton::LevelDataLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, AnimationDataLookupTable) == 0x000100, "Member 'UDataSingleton::AnimationDataLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, AnimatedIconLookupTable) == 0x000108, "Member 'UDataSingleton::AnimatedIconLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, DoorDataLookupTable) == 0x000110, "Member 'UDataSingleton::DoorDataLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, TrapDataLookupTable) == 0x000118, "Member 'UDataSingleton::TrapDataLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, ConversationLookupTable) == 0x000120, "Member 'UDataSingleton::ConversationLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, GameSettingsLookupTable) == 0x000128, "Member 'UDataSingleton::GameSettingsLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, CharacterLookOverrideTable) == 0x000130, "Member 'UDataSingleton::CharacterLookOverrideTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, RonInputKeyTable) == 0x000138, "Member 'UDataSingleton::RonInputKeyTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, InputKeyGamePadIconTable) == 0x000140, "Member 'UDataSingleton::InputKeyGamePadIconTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, SpeechDataLookupTable) == 0x000148, "Member 'UDataSingleton::SpeechDataLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, WidgetDataLookupTable) == 0x000198, "Member 'UDataSingleton::WidgetDataLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, SuspectArmourDataTable) == 0x0001A0, "Member 'UDataSingleton::SuspectArmourDataTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, PairedInteractionDataTable) == 0x0001A8, "Member 'UDataSingleton::PairedInteractionDataTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, MoveStyleDataTable) == 0x0001B0, "Member 'UDataSingleton::MoveStyleDataTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, CustomizationCharacterLevel) == 0x0001B8, "Member 'UDataSingleton::CustomizationCharacterLevel' has a wrong offset!");
static_assert(offsetof(UDataSingleton, CustomizationMenuLevel) == 0x0001C0, "Member 'UDataSingleton::CustomizationMenuLevel' has a wrong offset!");
static_assert(offsetof(UDataSingleton, RandomWorldBuildingActivities) == 0x0001C8, "Member 'UDataSingleton::RandomWorldBuildingActivities' has a wrong offset!");

// Class ReadyOrNot.NavArea_Player
// 0x0000 (0x0048 - 0x0048)
class UNavArea_Player final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Player">();
	}
	static class UNavArea_Player* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Player>();
	}
};
static_assert(alignof(UNavArea_Player) == 0x000008, "Wrong alignment on UNavArea_Player");
static_assert(sizeof(UNavArea_Player) == 0x000048, "Wrong size on UNavArea_Player");

// Class ReadyOrNot.DefusalGM
// 0x00B0 (0x0880 - 0x07D0)
class ADefusalGM final  : public AReadyOrNotGameMode_PVP
{
public:
	class ABombActor*                             SelectedBombActor;                                 // 0x07D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AAISpawn*>                       SpawnPoints;                                       // 0x07D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class APlayerStart*                           SwatSpawn;                                         // 0x07E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStart*                           SuspectSpawn;                                      // 0x07F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class APlayerCharacter*, struct FCharacterLookOverride> CharacterLookMap;                                  // 0x07F8(0x0050)(NativeAccessSpecifierPrivate)
	class USkeletalMesh*                          BlankFaceMesh;                                     // 0x0848(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class APlayerController*>              PendingPlayerSpawn;                                // 0x0850(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSpawnData>                     SuspectSpawnData;                                  // 0x0860(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class USkeletalMesh*                          SuspectFPArmsOverride;                             // 0x0870(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_257E[0x8];                                     // 0x0878(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefusalGM">();
	}
	static class ADefusalGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADefusalGM>();
	}
};
static_assert(alignof(ADefusalGM) == 0x000010, "Wrong alignment on ADefusalGM");
static_assert(sizeof(ADefusalGM) == 0x000880, "Wrong size on ADefusalGM");
static_assert(offsetof(ADefusalGM, SelectedBombActor) == 0x0007D0, "Member 'ADefusalGM::SelectedBombActor' has a wrong offset!");
static_assert(offsetof(ADefusalGM, SpawnPoints) == 0x0007D8, "Member 'ADefusalGM::SpawnPoints' has a wrong offset!");
static_assert(offsetof(ADefusalGM, SwatSpawn) == 0x0007E8, "Member 'ADefusalGM::SwatSpawn' has a wrong offset!");
static_assert(offsetof(ADefusalGM, SuspectSpawn) == 0x0007F0, "Member 'ADefusalGM::SuspectSpawn' has a wrong offset!");
static_assert(offsetof(ADefusalGM, CharacterLookMap) == 0x0007F8, "Member 'ADefusalGM::CharacterLookMap' has a wrong offset!");
static_assert(offsetof(ADefusalGM, BlankFaceMesh) == 0x000848, "Member 'ADefusalGM::BlankFaceMesh' has a wrong offset!");
static_assert(offsetof(ADefusalGM, PendingPlayerSpawn) == 0x000850, "Member 'ADefusalGM::PendingPlayerSpawn' has a wrong offset!");
static_assert(offsetof(ADefusalGM, SuspectSpawnData) == 0x000860, "Member 'ADefusalGM::SuspectSpawnData' has a wrong offset!");
static_assert(offsetof(ADefusalGM, SuspectFPArmsOverride) == 0x000870, "Member 'ADefusalGM::SuspectFPArmsOverride' has a wrong offset!");

// Class ReadyOrNot.DefuseBombThreats
// 0x0008 (0x02B0 - 0x02A8)
class ADefuseBombThreats final  : public AObjective
{
public:
	uint8                                         Pad_257F[0x8];                                     // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBombDefused(class ABombActor* DefusedBomb);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefuseBombThreats">();
	}
	static class ADefuseBombThreats* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADefuseBombThreats>();
	}
};
static_assert(alignof(ADefuseBombThreats) == 0x000008, "Wrong alignment on ADefuseBombThreats");
static_assert(sizeof(ADefuseBombThreats) == 0x0002B0, "Wrong size on ADefuseBombThreats");

// Class ReadyOrNot.ReadyOrNotVoipSettings
// 0x0010 (0x0048 - 0x0038)
class UReadyOrNotVoipSettings final  : public UDeveloperSettings
{
public:
	int32                                         AudibleDistance;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConversationalDistance;                            // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeIntensityByDistance;                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAudioFadeModel                               FadeModel;                                         // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2580[0x3];                                     // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotVoipSettings">();
	}
	static class UReadyOrNotVoipSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotVoipSettings>();
	}
};
static_assert(alignof(UReadyOrNotVoipSettings) == 0x000008, "Wrong alignment on UReadyOrNotVoipSettings");
static_assert(sizeof(UReadyOrNotVoipSettings) == 0x000048, "Wrong size on UReadyOrNotVoipSettings");
static_assert(offsetof(UReadyOrNotVoipSettings, AudibleDistance) == 0x000038, "Member 'UReadyOrNotVoipSettings::AudibleDistance' has a wrong offset!");
static_assert(offsetof(UReadyOrNotVoipSettings, ConversationalDistance) == 0x00003C, "Member 'UReadyOrNotVoipSettings::ConversationalDistance' has a wrong offset!");
static_assert(offsetof(UReadyOrNotVoipSettings, FadeIntensityByDistance) == 0x000040, "Member 'UReadyOrNotVoipSettings::FadeIntensityByDistance' has a wrong offset!");
static_assert(offsetof(UReadyOrNotVoipSettings, FadeModel) == 0x000044, "Member 'UReadyOrNotVoipSettings::FadeModel' has a wrong offset!");

// Class ReadyOrNot.DeployableDepot
// 0x0018 (0x0238 - 0x0220)
class ADeployableDepot final  : public AActor
{
public:
	TArray<class UDeployableSpawnComponent*>      SpawnedDeployableComponents;                       // 0x0220(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   DepotLabel;                                        // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Multicast_OnSuccessfulSpawn();
	void OnGameStarted();
	void OnSuccessfulSpawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployableDepot">();
	}
	static class ADeployableDepot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeployableDepot>();
	}
};
static_assert(alignof(ADeployableDepot) == 0x000008, "Wrong alignment on ADeployableDepot");
static_assert(sizeof(ADeployableDepot) == 0x000238, "Wrong size on ADeployableDepot");
static_assert(offsetof(ADeployableDepot, SpawnedDeployableComponents) == 0x000220, "Member 'ADeployableDepot::SpawnedDeployableComponents' has a wrong offset!");
static_assert(offsetof(ADeployableDepot, DepotLabel) == 0x000230, "Member 'ADeployableDepot::DepotLabel' has a wrong offset!");

// Class ReadyOrNot.RosterPortal
// 0x0018 (0x0238 - 0x0220)
class ARosterPortal final  : public AActor
{
public:
	uint8                                         Pad_2581[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ERosterPortalType                             PortalType;                                        // 0x0228(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2582[0x7];                                     // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 InteractableComponent;                             // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterPortal">();
	}
	static class ARosterPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARosterPortal>();
	}
};
static_assert(alignof(ARosterPortal) == 0x000008, "Wrong alignment on ARosterPortal");
static_assert(sizeof(ARosterPortal) == 0x000238, "Wrong size on ARosterPortal");
static_assert(offsetof(ARosterPortal, PortalType) == 0x000228, "Member 'ARosterPortal::PortalType' has a wrong offset!");
static_assert(offsetof(ARosterPortal, InteractableComponent) == 0x000230, "Member 'ARosterPortal::InteractableComponent' has a wrong offset!");

// Class ReadyOrNot.DeployGrenadeAtLocationActivity
// 0x0000 (0x01C0 - 0x01C0)
class UDeployGrenadeAtLocationActivity final  : public UDeployItemAtLocationActivity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployGrenadeAtLocationActivity">();
	}
	static class UDeployGrenadeAtLocationActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployGrenadeAtLocationActivity>();
	}
};
static_assert(alignof(UDeployGrenadeAtLocationActivity) == 0x000008, "Wrong alignment on UDeployGrenadeAtLocationActivity");
static_assert(sizeof(UDeployGrenadeAtLocationActivity) == 0x0001C0, "Wrong size on UDeployGrenadeAtLocationActivity");

// Class ReadyOrNot.DeployWedgeActivity
// 0x0008 (0x0200 - 0x01F8)
class UDeployWedgeActivity final  : public UDoorInteractionActivity
{
public:
	uint8                                         Pad_2583[0x8];                                     // 0x01F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployWedgeActivity">();
	}
	static class UDeployWedgeActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployWedgeActivity>();
	}
};
static_assert(alignof(UDeployWedgeActivity) == 0x000008, "Wrong alignment on UDeployWedgeActivity");
static_assert(sizeof(UDeployWedgeActivity) == 0x000200, "Wrong size on UDeployWedgeActivity");

// Class ReadyOrNot.ReadyOrNotConsoleFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UReadyOrNotConsoleFunctionLibrary final  : public UBlueprintFunctionLibrary
{
public:
	static void ConsoleApplyLevelSpecificSettings(const class FString& MapName, bool QualityOverFrameRate);
	static ERuntimeDevice GetRuntimeDeviceProfile();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotConsoleFunctionLibrary">();
	}
	static class UReadyOrNotConsoleFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotConsoleFunctionLibrary>();
	}
};
static_assert(alignof(UReadyOrNotConsoleFunctionLibrary) == 0x000008, "Wrong alignment on UReadyOrNotConsoleFunctionLibrary");
static_assert(sizeof(UReadyOrNotConsoleFunctionLibrary) == 0x000028, "Wrong size on UReadyOrNotConsoleFunctionLibrary");

// Class ReadyOrNot.DestructibleDoorChunkComponent
// 0x0020 (0x0500 - 0x04E0)
class UDestructibleDoorChunkComponent final  : public UStaticMeshComponent
{
public:
	bool                                          bIsDoorHandle;                                     // 0x04E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsHinge;                                          // 0x04E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2585[0x2];                                     // 0x04E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x04E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCannotKickIfDestroyed;                            // 0x04E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2586[0x7];                                     // 0x04E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDestructibleDoorChunkComponent*> SupportChunks;                                     // 0x04F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleDoorChunkComponent">();
	}
	static class UDestructibleDoorChunkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestructibleDoorChunkComponent>();
	}
};
static_assert(alignof(UDestructibleDoorChunkComponent) == 0x000010, "Wrong alignment on UDestructibleDoorChunkComponent");
static_assert(sizeof(UDestructibleDoorChunkComponent) == 0x000500, "Wrong size on UDestructibleDoorChunkComponent");
static_assert(offsetof(UDestructibleDoorChunkComponent, bIsDoorHandle) == 0x0004E0, "Member 'UDestructibleDoorChunkComponent::bIsDoorHandle' has a wrong offset!");
static_assert(offsetof(UDestructibleDoorChunkComponent, bIsHinge) == 0x0004E1, "Member 'UDestructibleDoorChunkComponent::bIsHinge' has a wrong offset!");
static_assert(offsetof(UDestructibleDoorChunkComponent, Health) == 0x0004E4, "Member 'UDestructibleDoorChunkComponent::Health' has a wrong offset!");
static_assert(offsetof(UDestructibleDoorChunkComponent, bCannotKickIfDestroyed) == 0x0004E8, "Member 'UDestructibleDoorChunkComponent::bCannotKickIfDestroyed' has a wrong offset!");
static_assert(offsetof(UDestructibleDoorChunkComponent, SupportChunks) == 0x0004F0, "Member 'UDestructibleDoorChunkComponent::SupportChunks' has a wrong offset!");

// Class ReadyOrNot.RoomVolume
// 0x0028 (0x0280 - 0x0258)
class ARoomVolume final  : public AVolume
{
public:
	int32                                         RoomGroupID;                                       // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2587[0x14];                                    // 0x025C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         OverlappingActors;                                 // 0x0270(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomVolume">();
	}
	static class ARoomVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARoomVolume>();
	}
};
static_assert(alignof(ARoomVolume) == 0x000008, "Wrong alignment on ARoomVolume");
static_assert(sizeof(ARoomVolume) == 0x000280, "Wrong size on ARoomVolume");
static_assert(offsetof(ARoomVolume, RoomGroupID) == 0x000258, "Member 'ARoomVolume::RoomGroupID' has a wrong offset!");
static_assert(offsetof(ARoomVolume, OverlappingActors) == 0x000270, "Member 'ARoomVolume::OverlappingActors' has a wrong offset!");

// Class ReadyOrNot.DestructibleVehicleGlassComponent
// 0x0000 (0x04E0 - 0x04E0)
class UDestructibleVehicleGlassComponent final  : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleVehicleGlassComponent">();
	}
	static class UDestructibleVehicleGlassComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestructibleVehicleGlassComponent>();
	}
};
static_assert(alignof(UDestructibleVehicleGlassComponent) == 0x000010, "Wrong alignment on UDestructibleVehicleGlassComponent");
static_assert(sizeof(UDestructibleVehicleGlassComponent) == 0x0004E0, "Wrong size on UDestructibleVehicleGlassComponent");

// Class ReadyOrNot.Detonator
// 0x0020 (0x09F0 - 0x09D0)
class ADetonator : public ABaseItem
{
public:
	uint8                                         Pad_2588[0x8];                                     // 0x09D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlacedC2Explosive*>             PlacedCharges;                                     // 0x09D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PlacedChargesCount;                                // 0x09E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDetonationDistance;                             // 0x09EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Server_DetonateC2();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Detonator">();
	}
	static class ADetonator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADetonator>();
	}
};
static_assert(alignof(ADetonator) == 0x000010, "Wrong alignment on ADetonator");
static_assert(sizeof(ADetonator) == 0x0009F0, "Wrong size on ADetonator");
static_assert(offsetof(ADetonator, PlacedCharges) == 0x0009D8, "Member 'ADetonator::PlacedCharges' has a wrong offset!");
static_assert(offsetof(ADetonator, PlacedChargesCount) == 0x0009E8, "Member 'ADetonator::PlacedChargesCount' has a wrong offset!");
static_assert(offsetof(ADetonator, MaxDetonationDistance) == 0x0009EC, "Member 'ADetonator::MaxDetonationDistance' has a wrong offset!");

// Class ReadyOrNot.DisarmDoorTrapActivity
// 0x0000 (0x01F8 - 0x01F8)
class UDisarmDoorTrapActivity final  : public UDoorInteractionActivity
{
public:
	void OnTrapTriggered(class ATrapActor* Trap, class AReadyOrNotCharacter* TriggeredBy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisarmDoorTrapActivity">();
	}
	static class UDisarmDoorTrapActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisarmDoorTrapActivity>();
	}
};
static_assert(alignof(UDisarmDoorTrapActivity) == 0x000008, "Wrong alignment on UDisarmDoorTrapActivity");
static_assert(sizeof(UDisarmDoorTrapActivity) == 0x0001F8, "Wrong size on UDisarmDoorTrapActivity");

// Class ReadyOrNot.DontDie
// 0x0000 (0x02A8 - 0x02A8)
class ADontDie final  : public AObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DontDie">();
	}
	static class ADontDie* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADontDie>();
	}
};
static_assert(alignof(ADontDie) == 0x000008, "Wrong alignment on ADontDie");
static_assert(sizeof(ADontDie) == 0x0002A8, "Wrong size on ADontDie");

// Class ReadyOrNot.Door
// 0x0E98 (0x10C0 - 0x0228)
class ADoor final  : public ADoorwayWithoutDoor
{
public:
	uint8                                         Pad_2589[0x50];                                    // 0x0228(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDoorOpened;                                      // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSubDoorOpened;                                   // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoorClosed;                                      // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoorBroken;                                      // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoorMovementBlocked;                             // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoorExploded;                                    // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoorKicked;                                      // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    TypeOfDoor;                                        // 0x02E8(0x0010)(Edit, Net, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StartingOpenAngle;                                 // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOneWay : 1;                                       // 0x02FC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EDoorOneWayDirection                          OneWayDirection;                                   // 0x02FD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomlyOpenAtGameStart;                          // 0x02FE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuspectAlwaysUnlocks;                             // 0x02FF(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreForFlee;                                    // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoNavBlockerForGen;                               // 0x0301(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoAutomaticClearing;                              // 0x0302(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseC2;                                         // 0x0303(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseBSG;                                        // 0x0304(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseWedge;                                      // 0x0305(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseRam;                                        // 0x0306(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseOptiwand;                                   // 0x0307(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanPlayerInteract : 1;                            // 0x0308(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanIssueOrdersOnFrontSide;                        // 0x0309(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanIssueOrdersOnBackSide;                         // 0x030A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasFrame;                                         // 0x030B(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258A[0x4];                                     // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AThreatAwarenessActor*                  FrontThreat;                                       // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AThreatAwarenessActor*                  BackThreat;                                        // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AThreatAwarenessActor*>          FrontThreatAwarenessPoints;                        // 0x0320(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TArray<class AThreatAwarenessActor*>          BackThreatAwarenessPoints;                         // 0x0330(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TArray<class AStackUpActor*>                  FrontLeftStackUpPoints;                            // 0x0340(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class AStackUpActor*>                  FrontRightStackUpPoints;                           // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class AStackUpActor*>                  BackLeftStackUpPoints;                             // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class AStackUpActor*>                  BackRightStackUpPoints;                            // 0x0370(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<struct FClearPoint>                    FrontLeftClearPoints;                              // 0x0380(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<struct FClearPoint>                    FrontRightClearPoints;                             // 0x0390(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<struct FClearPoint>                    BackLeftClearPoints;                               // 0x03A0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<struct FClearPoint>                    BackRightClearPoints;                              // 0x03B0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         bDoorJammed : 1;                                   // 0x03C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Net, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Blocked : 1;                                       // 0x03C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Net, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_258B[0x7];                                     // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 DestroyedChunkIdxs;                                // 0x03C8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	bool                                          bHeldPushDoor;                                     // 0x03D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258C[0x3];                                     // 0x03D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PushDoorHoldTime;                                  // 0x03DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoorRoomPosition                             FrontRoomPosition;                                 // 0x03E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoorRoomPosition                             BackRoomPosition;                                  // 0x03E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManualRoomPositionSetup;                          // 0x03E2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258D[0x9];                                     // 0x03E3(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxFrontHorizontalClearingDistance;                // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBackHorizontalClearingDistance;                 // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MaxFrontRightClearThreshold;                       // 0x03F4(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MaxFrontLeftClearThreshold;                        // 0x03FC(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MaxBackRightClearThreshold;                        // 0x0404(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MaxBackLeftClearThreshold;                         // 0x040C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxFrontRightClearPoints;                          // 0x0414(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxFrontLeftClearPoints;                           // 0x0415(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxBackRightClearPoints;                           // 0x0416(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxBackLeftClearPoints;                            // 0x0417(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManualClearPointSetup;                            // 0x0418(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258E[0x17];                                    // 0x0419(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        KickedParticleSystem;                              // 0x0430(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        LockBrokenParticleSystem;                          // 0x0438(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RootScene;                                         // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DoorStatic;                                        // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DoorHandleFront;                                   // 0x0450(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DoorHandleBack;                                    // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMirrorPortalComponent*                 FrontMirrorPoint;                                  // 0x0460(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMirrorPortalComponent*                 BackMirrorPoint;                                   // 0x0468(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk0;                                        // 0x0470(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk1;                                        // 0x0478(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk2;                                        // 0x0480(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk3;                                        // 0x0488(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk4;                                        // 0x0490(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk5;                                        // 0x0498(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk6;                                        // 0x04A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk7;                                        // 0x04A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk8;                                        // 0x04B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   LightBlocker;                                      // 0x04B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 DoorOpenInteractableComp;                          // 0x04C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 DoorSublinkOpenInteractableComp;                   // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 DoorSublinkPushInteractableComp;                   // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 DoorPushInteractableComp;                          // 0x04D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 DoorKickInteractableComp;                          // 0x04E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 DoorSublinkKickInteractableComp;                   // 0x04E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 LockpickInteractableComponent;                     // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 C2InteractableComponent;                           // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 WedgeInteractableComponent;                        // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 OptiwandInteractableComponent;                     // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 BSGInteractableComponent;                          // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 BSGInteractableComponent_2;                        // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 DoorRamInteractableComponent;                      // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDecalComponent*                        C2ExplosionDecalComponent;                         // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioPropagationComponent*         FMODAudioPropagationComp;                          // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        LockpickArea;                                      // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        DoorArea;                                          // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        C2Area;                                            // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        BSGArea;                                           // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        MirrorgunArea;                                     // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        WedgeArea;                                         // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        BatteringRamArea;                                  // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          DoorBlockerComponent;                              // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BreachBlocker1Component;                           // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BreachBlocker2Component;                           // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BreachBlocker3Component;                           // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHasEverBeenOpenedBySwat : 1;                      // 0x0590(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_258F[0x7];                                     // 0x0591(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         OperatingStates;                                   // 0x0598(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	class ANavLinkProxy*                          NavLinkProxy;                                      // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2590[0x18];                                    // 0x05B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bNoSpawnTrap : 1;                                  // 0x05C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EDoorTrapSide                                 TrapSide;                                          // 0x05C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2591[0x6];                                     // 0x05CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    TypeOfTrap;                                        // 0x05D0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EDoorDamageType, float>                  DoorKillDistance;                                  // 0x05E0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EDoorDamageType, float>                  DoorStunDistance;                                  // 0x0630(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         MaxOpenClose;                                      // 0x0680(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenThreshold;                                     // 0x0684(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloseThreshold;                                    // 0x0688(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncrementAngle;                                    // 0x068C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalPushAmount;                                // 0x0690(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2592[0x4];                                     // 0x0694(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  DriveSubDoor;                                      // 0x0698(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bMainSubDoor : 1;                                  // 0x06A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bKickAlwaysFails : 1;                              // 0x06A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2593[0x3];                                     // 0x06A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorKickSuccessChance;                             // 0x06A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumSuccessfulKicksToBreakDown;                     // 0x06A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2594[0x7];                                     // 0x06A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     C2ExplosionDecal;                                  // 0x06B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAlwaysLocked : 1;                                 // 0x06B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideLockChance : 1;                           // 0x06B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2595[0x3];                                     // 0x06B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockedChance;                                      // 0x06BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsElectronicDoor;                                 // 0x06C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2596[0x3];                                     // 0x06C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ElectronicLockChance;                              // 0x06C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorPushCurve;                                     // 0x06C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorOpenCurve;                                     // 0x06D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorCloseCurve;                                    // 0x06D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorKickSuccessCurve;                              // 0x06E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorKickFailCurve;                                 // 0x06E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorLockedCurve;                                   // 0x06F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorRamCurve;                                      // 0x06F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorExplodeCurve;                                  // 0x0700(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorBreachCurve;                                   // 0x0708(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorHandleOpenCurve;                               // 0x0710(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorHandlePushCurve;                               // 0x0718(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorHandleLockedCurve;                             // 0x0720(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlacedC2Explosive*                     PlacedC2;                                          // 0x0728(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDestructibleDoorChunkComponent*> ChunkComponents;                                   // 0x0730(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bPendingSubDoorKick : 1;                           // 0x0740(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2597[0x7];                                     // 0x0741(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   LastDoorUser;                                      // 0x0748(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoorDamageType                               LastDoorDamage;                                    // 0x0750(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2598[0x7];                                     // 0x0751(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ATrapActorAttachedToDoor*               AttachedTrap;                                      // 0x0758(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADoorJam*                               AttachedWedge;                                     // 0x0760(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   AICheckingDoor;                                    // 0x0768(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTeamStackUpActivity*>           CurrentStackUpActivities;                          // 0x0770(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	TArray<class UBaseActivity*>                  CurrentActivities;                                 // 0x0780(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	float                                         OpenCloseAmount;                                   // 0x0790(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorHandlePitchAmount;                             // 0x0794(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bC2Placed : 1;                                     // 0x0798(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSWATKnowsLockState : 1;                           // 0x0798(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSuspectKnowsLockState : 1;                        // 0x0798(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSWATKnowsTrapState : 1;                           // 0x0798(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSuspectKnowsTrapState : 1;                        // 0x0798(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDoorBroken : 1;                                   // 0x0798(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTrapInFront : 1;                                  // 0x0798(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClientReset : 1;                                  // 0x0798(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDoorHandlesBroken : 1;                            // 0x0799(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSWATHasKeycard : 1;                               // 0x0799(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSuspectsHaveKeycard : 1;                          // 0x0799(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlarmTriggered : 1;                               // 0x0799(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2599[0x6BE];                                   // 0x079A(0x06BE)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotCharacter*>           CharactersOverlappingDoor;                         // 0x0E58(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259A[0x8];                                     // 0x0E68(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDoorData                              DoorData;                                          // 0x0E70(0x01F0)(Edit, Net, DisableEditOnTemplate, EditConst, RepNotify, NativeAccessSpecifierPublic)
	struct FTrapData                              TrapData;                                          // 0x1060(0x0050)(Edit, Net, DisableEditOnTemplate, EditConst, RepNotify, NativeAccessSpecifierPublic)
	float                                         OcclusionMultiplier;                               // 0x10B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259B[0xC];                                     // 0x10B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void FlipStackUpArea(EStackupGenArea* OutStackUpArea, bool bHorizontalFlip, bool bVerticalFlip);
	static void SetAllElectronicLocks(class UObject* WorldContextObject, bool Param_Blocked);
	static void SetSWATHasAllKeycards(class UObject* WorldContextObject);

	void ActivateDoorBlockerForWorldGen();
	void AIResponseToDoorDamage();
	void ApplyDoorDamage(EDoorDamageType InDoorDamage, class AReadyOrNotCharacter* Victim);
	void ApplyRandomDamageToChunks(float MinDamage, float MaxDamage);
	void AttachTrap(class ATrapActorAttachedToDoor* NewTrap, bool bAttachToDoor);
	void AttachWedge(class ADoorJam* NewWedge);
	void BlockAllDoorways();
	float BodyRamDoor(class AReadyOrNotCharacter* DoorRamCharacter);
	void BreachDoor(class AReadyOrNotCharacter* DoorBreacherCharacter, float InIncrementAngle);
	void BreachDoorFromPoint(class AReadyOrNotCharacter* DoorBreacherCharacter, const struct FVector& BreachPoint, float InIncrementAngle);
	void BreakAndDetachDoor(bool bDestroyAllChunks, class AReadyOrNotCharacter* DoorBreakerCharacter, float Impulse, float ForwardOffset);
	void BreakDoor(bool bDestroyAllChunks, class AReadyOrNotCharacter* DoorBreakerCharacter);
	void BreakDoorHandles();
	void CalculateRoomPositioning();
	void CloseDoor(class AReadyOrNotCharacter* DoorCloserCharacter, bool bInstant, bool bAnimateDoorHandle);
	void CloseDoor_Debug();
	void CloseSubDoor(class AReadyOrNotCharacter* DoorCloseCharacter, bool bInstant, bool bAnimateDoorHandle);
	void CollapseDoor(class AReadyOrNotCharacter* DoorBreacherCharacter, const struct FVector& BreachLocation);
	void DeactivateDoorBlocker();
	void DecreaseNumKicksToBreakDown(class AReadyOrNotCharacter* DoorKickCharacter, bool* bShouldOpenDoor, bool* bCanBreakLock, float KickChanceOffset);
	void DestroyAllChunks(struct FVector& Impulse, float ImpulseStrength, bool bKeepHinges);
	void DestroyChunk(class UDestructibleDoorChunkComponent* InChunk, struct FVector& Impulse, float ImpulseStrength);
	void DestroyChunk_Index(int32 ChunkIndex, struct FVector& Impulse, float ImpulseStrength);
	void DestroyNavLink();
	void DisableAllInteractables();
	void DisableNavLink();
	void EnableNavLink();
	void ExplodeDoor(class AReadyOrNotCharacter* DoorBreacherCharacter, class AActor* ExplosionCauser, bool bKeepHinges);
	void Finished_DoorExplode();
	void Finished_DoorKick_Success();
	void Finished_DoorRam();
	void ForceDoorReset();
	void GenerateClearPoints();
	void GenerateStackUpPoints();
	class FName GetTypeOfDoorRow();
	class FName GetTypeOfDoorTrap();
	bool IsIgnoredForFlee();
	bool IsSubDoorOpen();
	void KickDoor(class AReadyOrNotCharacter* DoorKickCharacter, bool bKickSubDoor, bool bForce);
	void KickSubDoor(class AReadyOrNotCharacter* DoorKickCharacter);
	void LockDoor(bool bLockSubDoor);
	void Multicast_CheckSupports();
	void Multicast_DisableDoorInteraction(bool bSetClosed);
	void Multicast_ExplodeDoor(class AReadyOrNotCharacter* DoorBreacherCharacter, class AActor* ExplosionCauser, bool bKeepHinges);
	void Multicast_PlayDoorDamageSound(EDoorDamageType DoorDamage, TArray<struct FMODParam>& Params_0);
	void Multicast_PlayDoorKickEffects(bool bBreakLock, bool bInFront);
	void Multicast_PlayDoorSound(EDoorInteraction DoorDamage, class AReadyOrNotCharacter* DoorInteractionInstigator, TArray<struct FMODParam>& Params_0);
	void Multicast_PlayElectronicDoorSound(class UFMODEvent* Event);
	void Multicast_SetLocked(bool bShouldLocked);
	void OnDoorBroken__DelegateSignature();
	void OnDoorClosed__DelegateSignature();
	void OnDoorExplode__DelegateSignature(class ADoor* Door, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnDoorKick__DelegateSignature(class ADoor* Door, class AReadyOrNotCharacter* InstigatorCharacter, bool bSuccess);
	void OnDoorMovementBlocked__DelegateSignature();
	void OnDoorOpened__DelegateSignature();
	void OnRep_ClientResetDoor();
	void OnRep_DestroyedChunkIdxChanged();
	void OnRep_DoorDataUpdated();
	void OnRep_DoorHandlesBroken();
	void OnRep_TrapDataUpdated();
	float OpenDoor(class AReadyOrNotCharacter* DoorOpenCharacter, bool bInstant, bool bAnimateDoorHandle, bool bNoCloseThreshold);
	void OpenDoor_Debug();
	void OpenDoor_SpecificAngle(class AReadyOrNotCharacter* DoorOpenCharacter, float CustomTargetAngle, bool bInstant, bool bAnimateDoorHandle);
	void OpenSubDoor(class AReadyOrNotCharacter* DoorOpenCharacter, bool bInstant, bool bAnimateDoorHandle);
	float PeekDoor(class AReadyOrNotCharacter* DoorPeekerCharacter, float InIncrementAngle, bool bAnimateDoorHandle);
	void PlayDoorDamageSound(EDoorDamageType DoorDamage, TArray<struct FMODParam>& Params_0);
	void PlayDoorKickSound(class AReadyOrNotCharacter* Kicker, float Result);
	void PlayDoorSound(EDoorInteraction DoorInteraction, class AReadyOrNotCharacter* DoorInteractionInstigator, TArray<struct FMODParam>& Params_0);
	float PushDoor(class AReadyOrNotCharacter* DoorPusherCharacter, float InIncrementAngle, bool bAnimateDoorHandle, bool bPlaySound);
	void PushDoor_SpecificAngle(class AReadyOrNotCharacter* DoorPusherCharacter, float CustomTargetAngle, bool bAnimateDoorHandle);
	float RamDoor(class AReadyOrNotCharacter* DoorRamCharacter, bool bPlayRamSound);
	void RemoveWedges();
	void ResetDoorLockKnowledge();
	void ResetDoorTrapKnowledge();
	void Restore();
	void Server_SetLockKnowledgeState(bool bSuspectTeam, bool bNewKnowledgeState);
	void Server_SetTrapKnowledgeState(bool bSuspectTeam, bool bNewKnowledgeState);
	void SetDoorLockKnowledge(bool bSuspectTeam, bool bKnowledge);
	void SetDoorTrapKnowledge(bool bSuspectTeam, bool bKnowledge);
	void SetLocked(bool bNewLocked);
	void Setup();
	void Tick_DoorBreach();
	void Tick_DoorExplode();
	void Tick_DoorHandle_Open();
	void Tick_DoorHandle_Push();
	void Tick_DoorHandleLocked();
	void Tick_DoorKick_Fail();
	void Tick_DoorKick_Success();
	void Tick_DoorLocked();
	void Tick_DoorOpenClose();
	void Tick_DoorPush();
	void Tick_DoorRam();
	void ToggleLightBlocker();
	void UnblockAllDoorways();
	void UnlockDoor(bool bUnlockSubDoor);

	bool AllBottomDoorChunksBroken() const;
	bool AllMajorDoorChunksDestroyed() const;
	bool AllMiddleDoorChunksBroken() const;
	bool AllTopDoorChunksBroken() const;
	bool AnyBottomDoorChunksBroken() const;
	bool AnyChunksDestroyed() const;
	bool AnyHingesLeft() const;
	bool AnyMiddleDoorChunksBroken() const;
	bool AnyTopDoorChunksBroken() const;
	struct FVector CalculateClosestPoint(const struct FVector& Location) const;
	bool CanCloseDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanDeployWedge(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanEquipBatteringRam(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanEquipBreachingShotgun(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanEquipC2Explosive(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanEquipMultitool(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanEquipOptiwand(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanEquipWedge(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanKickDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanLockpickDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanMirrorUnderDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanOpenDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanPeekDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanPlaceC2Explosive(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanPullDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanPushDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanPushDoorWhileBroken() const;
	bool CanRamDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanSpawnTrap() const;
	bool CanTakeDamage(float Damage, struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser) const;
	bool DoesSuspectKnowTrapState() const;
	bool DoesSWATKnowTrapState() const;
	EStackupGenArea FindStackUpAreaFromLocation(struct FVector& InInteractionLocation) const;
	class ATrapActorAttachedToDoor* GetAttachedTrap() const;
	class ADoorJam* GetAttachedWedge() const;
	class FName GetBackThreatOwningRoom() const;
	struct FVector GetBestDoorInteraction_FromLocation(struct FVector& InInteractionLocation, bool bDoorwayBased) const;
	struct FVector GetBestDoorInteraction_FromStackUpArea(EStackupGenArea& InStackUpArea, bool bDoorwayBased) const;
	TMap<EDoorDamageType, float> GetDoorKillDistance() const;
	struct FVector GetDoorMidLocation() const;
	TMap<EDoorDamageType, float> GetDoorStunDistance() const;
	class FName GetFrontThreatOwningRoom() const;
	float GetIncrementAngle() const;
	class AReadyOrNotCharacter* GetLastDoorUser() const;
	float GetMaxOpenAmount() const;
	float GetOpenAmount() const;
	float GetOpenAmountAsPercentage() const;
	float GetOpenThreshold() const;
	float GetOverrideLockChance() const;
	class APlacedC2Explosive* GetPlacedC2() const;
	float GetPseudoVelocity() const;
	TArray<class AStackUpActor*> GetStackupsForArea(EStackupGenArea StackupArea) const;
	float GetStartingOpenAngle() const;
	class ADoor* GetSubDoor() const;
	bool GetSuspectKnowsLockState() const;
	bool GetSWATKnowsLockState() const;
	float GetTargetAngle() const;
	struct FVector GetWedgeLocation() const;
	bool HasEverBeenOpened() const;
	bool HasTrapAndSuspectKnowsTrap() const;
	bool HasTrapAndSWATKnowsTrap() const;
	bool IsActorBehindDoor_Relative(class AActor* Actor) const;
	bool IsActorInFrontOfDoor(class AActor* Actor) const;
	bool IsActorInFrontOfDoorway(class AActor* Actor) const;
	bool IsActorRightOfDoorway(class AActor* Actor) const;
	bool IsActorSameSideAsTrap(class AActor* InActor) const;
	bool IsAlwaysLocked() const;
	bool IsAnyAIClosing() const;
	bool IsAnyAIOpening() const;
	bool IsAnyInteractionPlaying() const;
	bool IsAttachedToRoot() const;
	bool IsC2Placed() const;
	bool IsClosed() const;
	bool IsClosing() const;
	bool IsDestructible() const;
	bool IsDoorBroken() const;
	bool IsDoorChunkDestroyed(class UDestructibleDoorChunkComponent* InChunkComponent) const;
	bool IsDoorInteractionPlaying() const;
	bool IsDoorwayOnly() const;
	bool IsElectronicDoor() const;
	bool IsFullyOpen() const;
	bool IsFullyOpen_Backward() const;
	bool IsFullyOpen_Forward() const;
	bool IsHalfwayOpen() const;
	bool IsHandleBroken() const;
	bool IsJammed() const;
	bool IsLocationSameSideAsTrap(const struct FVector& InLocation) const;
	bool IsLockable() const;
	bool IsLockChanceOverridden() const;
	bool IsLocked() const;
	bool IsMainSubdoor() const;
	bool IsMiddleChunkBroken() const;
	bool IsMirrorBlocked() const;
	bool IsNonDoorInteractionPlaying() const;
	bool IsNonMainSubdoor() const;
	bool IsOpen() const;
	bool IsOpen_Backward() const;
	bool IsOpen_Forward() const;
	bool IsOpenAtOrBeyond(float Percentage) const;
	bool IsOpenAtOrBeyond_Angle(float Angle) const;
	bool IsOpenBeyond(float Percentage) const;
	bool IsOpenBeyond_Angle(float Angle) const;
	bool IsOpenBeyondCloseThreshold() const;
	bool IsOpenBeyondIncrementThreshold() const;
	bool IsOpenBy(float Percentage) const;
	bool IsOpenBy_Angle(float Angle) const;
	bool IsOpening() const;
	bool IsOutlineDisabled() const;
	bool IsOutlineEnabled(EActorOutlineType OutlineType) const;
	bool IsOverridingLockChance() const;
	bool IsPendingSubDoorKick() const;
	bool IsPointInFrontOfDoor(const struct FVector& Vector) const;
	bool IsPointRightOfDoorway(const struct FVector& Vector) const;
	bool IsStackUpDisabled(const struct FVector& CommandLocation) const;
	bool IsTooFarForKick() const;
	bool IsTrapLive() const;
	bool MainSubDoor_CanShowOpenDoorPrompt() const;
	bool NonMainSubDoor_CanShowOpenDoorPrompt() const;
	bool SubDoor_CanCloseDoors(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool SubDoor_CanOpenDoors(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool TeamKnowsDoorLockState(bool bSuspectTeam) const;
	bool TeamKnowsDoorTrapState(bool bSuspectTeam) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Door">();
	}
	static class ADoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoor>();
	}
};
static_assert(alignof(ADoor) == 0x000010, "Wrong alignment on ADoor");
static_assert(sizeof(ADoor) == 0x0010C0, "Wrong size on ADoor");
static_assert(offsetof(ADoor, OnDoorOpened) == 0x000278, "Member 'ADoor::OnDoorOpened' has a wrong offset!");
static_assert(offsetof(ADoor, OnSubDoorOpened) == 0x000288, "Member 'ADoor::OnSubDoorOpened' has a wrong offset!");
static_assert(offsetof(ADoor, OnDoorClosed) == 0x000298, "Member 'ADoor::OnDoorClosed' has a wrong offset!");
static_assert(offsetof(ADoor, OnDoorBroken) == 0x0002A8, "Member 'ADoor::OnDoorBroken' has a wrong offset!");
static_assert(offsetof(ADoor, OnDoorMovementBlocked) == 0x0002B8, "Member 'ADoor::OnDoorMovementBlocked' has a wrong offset!");
static_assert(offsetof(ADoor, OnDoorExploded) == 0x0002C8, "Member 'ADoor::OnDoorExploded' has a wrong offset!");
static_assert(offsetof(ADoor, OnDoorKicked) == 0x0002D8, "Member 'ADoor::OnDoorKicked' has a wrong offset!");
static_assert(offsetof(ADoor, TypeOfDoor) == 0x0002E8, "Member 'ADoor::TypeOfDoor' has a wrong offset!");
static_assert(offsetof(ADoor, StartingOpenAngle) == 0x0002F8, "Member 'ADoor::StartingOpenAngle' has a wrong offset!");
static_assert(offsetof(ADoor, OneWayDirection) == 0x0002FD, "Member 'ADoor::OneWayDirection' has a wrong offset!");
static_assert(offsetof(ADoor, bRandomlyOpenAtGameStart) == 0x0002FE, "Member 'ADoor::bRandomlyOpenAtGameStart' has a wrong offset!");
static_assert(offsetof(ADoor, bSuspectAlwaysUnlocks) == 0x0002FF, "Member 'ADoor::bSuspectAlwaysUnlocks' has a wrong offset!");
static_assert(offsetof(ADoor, bIgnoreForFlee) == 0x000300, "Member 'ADoor::bIgnoreForFlee' has a wrong offset!");
static_assert(offsetof(ADoor, bNoNavBlockerForGen) == 0x000301, "Member 'ADoor::bNoNavBlockerForGen' has a wrong offset!");
static_assert(offsetof(ADoor, bNoAutomaticClearing) == 0x000302, "Member 'ADoor::bNoAutomaticClearing' has a wrong offset!");
static_assert(offsetof(ADoor, bCanUseC2) == 0x000303, "Member 'ADoor::bCanUseC2' has a wrong offset!");
static_assert(offsetof(ADoor, bCanUseBSG) == 0x000304, "Member 'ADoor::bCanUseBSG' has a wrong offset!");
static_assert(offsetof(ADoor, bCanUseWedge) == 0x000305, "Member 'ADoor::bCanUseWedge' has a wrong offset!");
static_assert(offsetof(ADoor, bCanUseRam) == 0x000306, "Member 'ADoor::bCanUseRam' has a wrong offset!");
static_assert(offsetof(ADoor, bCanUseOptiwand) == 0x000307, "Member 'ADoor::bCanUseOptiwand' has a wrong offset!");
static_assert(offsetof(ADoor, bCanIssueOrdersOnFrontSide) == 0x000309, "Member 'ADoor::bCanIssueOrdersOnFrontSide' has a wrong offset!");
static_assert(offsetof(ADoor, bCanIssueOrdersOnBackSide) == 0x00030A, "Member 'ADoor::bCanIssueOrdersOnBackSide' has a wrong offset!");
static_assert(offsetof(ADoor, bHasFrame) == 0x00030B, "Member 'ADoor::bHasFrame' has a wrong offset!");
static_assert(offsetof(ADoor, FrontThreat) == 0x000310, "Member 'ADoor::FrontThreat' has a wrong offset!");
static_assert(offsetof(ADoor, BackThreat) == 0x000318, "Member 'ADoor::BackThreat' has a wrong offset!");
static_assert(offsetof(ADoor, FrontThreatAwarenessPoints) == 0x000320, "Member 'ADoor::FrontThreatAwarenessPoints' has a wrong offset!");
static_assert(offsetof(ADoor, BackThreatAwarenessPoints) == 0x000330, "Member 'ADoor::BackThreatAwarenessPoints' has a wrong offset!");
static_assert(offsetof(ADoor, FrontLeftStackUpPoints) == 0x000340, "Member 'ADoor::FrontLeftStackUpPoints' has a wrong offset!");
static_assert(offsetof(ADoor, FrontRightStackUpPoints) == 0x000350, "Member 'ADoor::FrontRightStackUpPoints' has a wrong offset!");
static_assert(offsetof(ADoor, BackLeftStackUpPoints) == 0x000360, "Member 'ADoor::BackLeftStackUpPoints' has a wrong offset!");
static_assert(offsetof(ADoor, BackRightStackUpPoints) == 0x000370, "Member 'ADoor::BackRightStackUpPoints' has a wrong offset!");
static_assert(offsetof(ADoor, FrontLeftClearPoints) == 0x000380, "Member 'ADoor::FrontLeftClearPoints' has a wrong offset!");
static_assert(offsetof(ADoor, FrontRightClearPoints) == 0x000390, "Member 'ADoor::FrontRightClearPoints' has a wrong offset!");
static_assert(offsetof(ADoor, BackLeftClearPoints) == 0x0003A0, "Member 'ADoor::BackLeftClearPoints' has a wrong offset!");
static_assert(offsetof(ADoor, BackRightClearPoints) == 0x0003B0, "Member 'ADoor::BackRightClearPoints' has a wrong offset!");
static_assert(offsetof(ADoor, DestroyedChunkIdxs) == 0x0003C8, "Member 'ADoor::DestroyedChunkIdxs' has a wrong offset!");
static_assert(offsetof(ADoor, bHeldPushDoor) == 0x0003D8, "Member 'ADoor::bHeldPushDoor' has a wrong offset!");
static_assert(offsetof(ADoor, PushDoorHoldTime) == 0x0003DC, "Member 'ADoor::PushDoorHoldTime' has a wrong offset!");
static_assert(offsetof(ADoor, FrontRoomPosition) == 0x0003E0, "Member 'ADoor::FrontRoomPosition' has a wrong offset!");
static_assert(offsetof(ADoor, BackRoomPosition) == 0x0003E1, "Member 'ADoor::BackRoomPosition' has a wrong offset!");
static_assert(offsetof(ADoor, bManualRoomPositionSetup) == 0x0003E2, "Member 'ADoor::bManualRoomPositionSetup' has a wrong offset!");
static_assert(offsetof(ADoor, MaxFrontHorizontalClearingDistance) == 0x0003EC, "Member 'ADoor::MaxFrontHorizontalClearingDistance' has a wrong offset!");
static_assert(offsetof(ADoor, MaxBackHorizontalClearingDistance) == 0x0003F0, "Member 'ADoor::MaxBackHorizontalClearingDistance' has a wrong offset!");
static_assert(offsetof(ADoor, MaxFrontRightClearThreshold) == 0x0003F4, "Member 'ADoor::MaxFrontRightClearThreshold' has a wrong offset!");
static_assert(offsetof(ADoor, MaxFrontLeftClearThreshold) == 0x0003FC, "Member 'ADoor::MaxFrontLeftClearThreshold' has a wrong offset!");
static_assert(offsetof(ADoor, MaxBackRightClearThreshold) == 0x000404, "Member 'ADoor::MaxBackRightClearThreshold' has a wrong offset!");
static_assert(offsetof(ADoor, MaxBackLeftClearThreshold) == 0x00040C, "Member 'ADoor::MaxBackLeftClearThreshold' has a wrong offset!");
static_assert(offsetof(ADoor, MaxFrontRightClearPoints) == 0x000414, "Member 'ADoor::MaxFrontRightClearPoints' has a wrong offset!");
static_assert(offsetof(ADoor, MaxFrontLeftClearPoints) == 0x000415, "Member 'ADoor::MaxFrontLeftClearPoints' has a wrong offset!");
static_assert(offsetof(ADoor, MaxBackRightClearPoints) == 0x000416, "Member 'ADoor::MaxBackRightClearPoints' has a wrong offset!");
static_assert(offsetof(ADoor, MaxBackLeftClearPoints) == 0x000417, "Member 'ADoor::MaxBackLeftClearPoints' has a wrong offset!");
static_assert(offsetof(ADoor, bManualClearPointSetup) == 0x000418, "Member 'ADoor::bManualClearPointSetup' has a wrong offset!");
static_assert(offsetof(ADoor, KickedParticleSystem) == 0x000430, "Member 'ADoor::KickedParticleSystem' has a wrong offset!");
static_assert(offsetof(ADoor, LockBrokenParticleSystem) == 0x000438, "Member 'ADoor::LockBrokenParticleSystem' has a wrong offset!");
static_assert(offsetof(ADoor, RootScene) == 0x000440, "Member 'ADoor::RootScene' has a wrong offset!");
static_assert(offsetof(ADoor, DoorStatic) == 0x000448, "Member 'ADoor::DoorStatic' has a wrong offset!");
static_assert(offsetof(ADoor, DoorHandleFront) == 0x000450, "Member 'ADoor::DoorHandleFront' has a wrong offset!");
static_assert(offsetof(ADoor, DoorHandleBack) == 0x000458, "Member 'ADoor::DoorHandleBack' has a wrong offset!");
static_assert(offsetof(ADoor, FrontMirrorPoint) == 0x000460, "Member 'ADoor::FrontMirrorPoint' has a wrong offset!");
static_assert(offsetof(ADoor, BackMirrorPoint) == 0x000468, "Member 'ADoor::BackMirrorPoint' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk0) == 0x000470, "Member 'ADoor::DoorChunk0' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk1) == 0x000478, "Member 'ADoor::DoorChunk1' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk2) == 0x000480, "Member 'ADoor::DoorChunk2' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk3) == 0x000488, "Member 'ADoor::DoorChunk3' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk4) == 0x000490, "Member 'ADoor::DoorChunk4' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk5) == 0x000498, "Member 'ADoor::DoorChunk5' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk6) == 0x0004A0, "Member 'ADoor::DoorChunk6' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk7) == 0x0004A8, "Member 'ADoor::DoorChunk7' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk8) == 0x0004B0, "Member 'ADoor::DoorChunk8' has a wrong offset!");
static_assert(offsetof(ADoor, LightBlocker) == 0x0004B8, "Member 'ADoor::LightBlocker' has a wrong offset!");
static_assert(offsetof(ADoor, DoorOpenInteractableComp) == 0x0004C0, "Member 'ADoor::DoorOpenInteractableComp' has a wrong offset!");
static_assert(offsetof(ADoor, DoorSublinkOpenInteractableComp) == 0x0004C8, "Member 'ADoor::DoorSublinkOpenInteractableComp' has a wrong offset!");
static_assert(offsetof(ADoor, DoorSublinkPushInteractableComp) == 0x0004D0, "Member 'ADoor::DoorSublinkPushInteractableComp' has a wrong offset!");
static_assert(offsetof(ADoor, DoorPushInteractableComp) == 0x0004D8, "Member 'ADoor::DoorPushInteractableComp' has a wrong offset!");
static_assert(offsetof(ADoor, DoorKickInteractableComp) == 0x0004E0, "Member 'ADoor::DoorKickInteractableComp' has a wrong offset!");
static_assert(offsetof(ADoor, DoorSublinkKickInteractableComp) == 0x0004E8, "Member 'ADoor::DoorSublinkKickInteractableComp' has a wrong offset!");
static_assert(offsetof(ADoor, LockpickInteractableComponent) == 0x0004F0, "Member 'ADoor::LockpickInteractableComponent' has a wrong offset!");
static_assert(offsetof(ADoor, C2InteractableComponent) == 0x0004F8, "Member 'ADoor::C2InteractableComponent' has a wrong offset!");
static_assert(offsetof(ADoor, WedgeInteractableComponent) == 0x000500, "Member 'ADoor::WedgeInteractableComponent' has a wrong offset!");
static_assert(offsetof(ADoor, OptiwandInteractableComponent) == 0x000508, "Member 'ADoor::OptiwandInteractableComponent' has a wrong offset!");
static_assert(offsetof(ADoor, BSGInteractableComponent) == 0x000510, "Member 'ADoor::BSGInteractableComponent' has a wrong offset!");
static_assert(offsetof(ADoor, BSGInteractableComponent_2) == 0x000518, "Member 'ADoor::BSGInteractableComponent_2' has a wrong offset!");
static_assert(offsetof(ADoor, DoorRamInteractableComponent) == 0x000520, "Member 'ADoor::DoorRamInteractableComponent' has a wrong offset!");
static_assert(offsetof(ADoor, C2ExplosionDecalComponent) == 0x000528, "Member 'ADoor::C2ExplosionDecalComponent' has a wrong offset!");
static_assert(offsetof(ADoor, FMODAudioPropagationComp) == 0x000530, "Member 'ADoor::FMODAudioPropagationComp' has a wrong offset!");
static_assert(offsetof(ADoor, LockpickArea) == 0x000538, "Member 'ADoor::LockpickArea' has a wrong offset!");
static_assert(offsetof(ADoor, DoorArea) == 0x000540, "Member 'ADoor::DoorArea' has a wrong offset!");
static_assert(offsetof(ADoor, C2Area) == 0x000548, "Member 'ADoor::C2Area' has a wrong offset!");
static_assert(offsetof(ADoor, BSGArea) == 0x000550, "Member 'ADoor::BSGArea' has a wrong offset!");
static_assert(offsetof(ADoor, MirrorgunArea) == 0x000558, "Member 'ADoor::MirrorgunArea' has a wrong offset!");
static_assert(offsetof(ADoor, WedgeArea) == 0x000560, "Member 'ADoor::WedgeArea' has a wrong offset!");
static_assert(offsetof(ADoor, BatteringRamArea) == 0x000568, "Member 'ADoor::BatteringRamArea' has a wrong offset!");
static_assert(offsetof(ADoor, DoorBlockerComponent) == 0x000570, "Member 'ADoor::DoorBlockerComponent' has a wrong offset!");
static_assert(offsetof(ADoor, BreachBlocker1Component) == 0x000578, "Member 'ADoor::BreachBlocker1Component' has a wrong offset!");
static_assert(offsetof(ADoor, BreachBlocker2Component) == 0x000580, "Member 'ADoor::BreachBlocker2Component' has a wrong offset!");
static_assert(offsetof(ADoor, BreachBlocker3Component) == 0x000588, "Member 'ADoor::BreachBlocker3Component' has a wrong offset!");
static_assert(offsetof(ADoor, OperatingStates) == 0x000598, "Member 'ADoor::OperatingStates' has a wrong offset!");
static_assert(offsetof(ADoor, NavLinkProxy) == 0x0005A8, "Member 'ADoor::NavLinkProxy' has a wrong offset!");
static_assert(offsetof(ADoor, TrapSide) == 0x0005C9, "Member 'ADoor::TrapSide' has a wrong offset!");
static_assert(offsetof(ADoor, TypeOfTrap) == 0x0005D0, "Member 'ADoor::TypeOfTrap' has a wrong offset!");
static_assert(offsetof(ADoor, DoorKillDistance) == 0x0005E0, "Member 'ADoor::DoorKillDistance' has a wrong offset!");
static_assert(offsetof(ADoor, DoorStunDistance) == 0x000630, "Member 'ADoor::DoorStunDistance' has a wrong offset!");
static_assert(offsetof(ADoor, MaxOpenClose) == 0x000680, "Member 'ADoor::MaxOpenClose' has a wrong offset!");
static_assert(offsetof(ADoor, OpenThreshold) == 0x000684, "Member 'ADoor::OpenThreshold' has a wrong offset!");
static_assert(offsetof(ADoor, CloseThreshold) == 0x000688, "Member 'ADoor::CloseThreshold' has a wrong offset!");
static_assert(offsetof(ADoor, IncrementAngle) == 0x00068C, "Member 'ADoor::IncrementAngle' has a wrong offset!");
static_assert(offsetof(ADoor, PhysicalPushAmount) == 0x000690, "Member 'ADoor::PhysicalPushAmount' has a wrong offset!");
static_assert(offsetof(ADoor, DriveSubDoor) == 0x000698, "Member 'ADoor::DriveSubDoor' has a wrong offset!");
static_assert(offsetof(ADoor, DoorKickSuccessChance) == 0x0006A4, "Member 'ADoor::DoorKickSuccessChance' has a wrong offset!");
static_assert(offsetof(ADoor, NumSuccessfulKicksToBreakDown) == 0x0006A8, "Member 'ADoor::NumSuccessfulKicksToBreakDown' has a wrong offset!");
static_assert(offsetof(ADoor, C2ExplosionDecal) == 0x0006B0, "Member 'ADoor::C2ExplosionDecal' has a wrong offset!");
static_assert(offsetof(ADoor, LockedChance) == 0x0006BC, "Member 'ADoor::LockedChance' has a wrong offset!");
static_assert(offsetof(ADoor, bIsElectronicDoor) == 0x0006C0, "Member 'ADoor::bIsElectronicDoor' has a wrong offset!");
static_assert(offsetof(ADoor, ElectronicLockChance) == 0x0006C4, "Member 'ADoor::ElectronicLockChance' has a wrong offset!");
static_assert(offsetof(ADoor, DoorPushCurve) == 0x0006C8, "Member 'ADoor::DoorPushCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorOpenCurve) == 0x0006D0, "Member 'ADoor::DoorOpenCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorCloseCurve) == 0x0006D8, "Member 'ADoor::DoorCloseCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorKickSuccessCurve) == 0x0006E0, "Member 'ADoor::DoorKickSuccessCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorKickFailCurve) == 0x0006E8, "Member 'ADoor::DoorKickFailCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorLockedCurve) == 0x0006F0, "Member 'ADoor::DoorLockedCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorRamCurve) == 0x0006F8, "Member 'ADoor::DoorRamCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorExplodeCurve) == 0x000700, "Member 'ADoor::DoorExplodeCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorBreachCurve) == 0x000708, "Member 'ADoor::DoorBreachCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorHandleOpenCurve) == 0x000710, "Member 'ADoor::DoorHandleOpenCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorHandlePushCurve) == 0x000718, "Member 'ADoor::DoorHandlePushCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorHandleLockedCurve) == 0x000720, "Member 'ADoor::DoorHandleLockedCurve' has a wrong offset!");
static_assert(offsetof(ADoor, PlacedC2) == 0x000728, "Member 'ADoor::PlacedC2' has a wrong offset!");
static_assert(offsetof(ADoor, ChunkComponents) == 0x000730, "Member 'ADoor::ChunkComponents' has a wrong offset!");
static_assert(offsetof(ADoor, LastDoorUser) == 0x000748, "Member 'ADoor::LastDoorUser' has a wrong offset!");
static_assert(offsetof(ADoor, LastDoorDamage) == 0x000750, "Member 'ADoor::LastDoorDamage' has a wrong offset!");
static_assert(offsetof(ADoor, AttachedTrap) == 0x000758, "Member 'ADoor::AttachedTrap' has a wrong offset!");
static_assert(offsetof(ADoor, AttachedWedge) == 0x000760, "Member 'ADoor::AttachedWedge' has a wrong offset!");
static_assert(offsetof(ADoor, AICheckingDoor) == 0x000768, "Member 'ADoor::AICheckingDoor' has a wrong offset!");
static_assert(offsetof(ADoor, CurrentStackUpActivities) == 0x000770, "Member 'ADoor::CurrentStackUpActivities' has a wrong offset!");
static_assert(offsetof(ADoor, CurrentActivities) == 0x000780, "Member 'ADoor::CurrentActivities' has a wrong offset!");
static_assert(offsetof(ADoor, OpenCloseAmount) == 0x000790, "Member 'ADoor::OpenCloseAmount' has a wrong offset!");
static_assert(offsetof(ADoor, DoorHandlePitchAmount) == 0x000794, "Member 'ADoor::DoorHandlePitchAmount' has a wrong offset!");
static_assert(offsetof(ADoor, CharactersOverlappingDoor) == 0x000E58, "Member 'ADoor::CharactersOverlappingDoor' has a wrong offset!");
static_assert(offsetof(ADoor, DoorData) == 0x000E70, "Member 'ADoor::DoorData' has a wrong offset!");
static_assert(offsetof(ADoor, TrapData) == 0x001060, "Member 'ADoor::TrapData' has a wrong offset!");
static_assert(offsetof(ADoor, OcclusionMultiplier) == 0x0010B0, "Member 'ADoor::OcclusionMultiplier' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotLoadoutManager
// 0x02A8 (0x02D0 - 0x0028)
class UReadyOrNotLoadoutManager final  : public UObject
{
public:
	uint8                                         Pad_25E3[0x50];                                    // 0x0028(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class ABaseWeapon>, struct FStoredWeaponAttachments> StoredAttachmentsByWeapon;                         // 0x0078(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPresetApplied;                                   // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAvailablePresetsChanged;                         // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E4[0x50];                                    // 0x00E8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedLoadout                          ActiveLoadout;                                     // 0x0138(0x0188)(NativeAccessSpecifierPrivate)
	EEquippingSwat                                ActiveSwatMember;                                  // 0x02C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25E5[0x7];                                     // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoadoutManager*                        LoadoutManager;                                    // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ApplyPreset(const class FString& Param_Name);
	bool AttachmentIsEquipped(TSubclassOf<class UWeaponAttachment> WeaponAttachment, EWeaponAttachmentType AttachmentType);
	void DecrementGrenadeSlotCount(TSubclassOf<class ABaseItem> SlotItem);
	void DecrementPrimarySlotCount(class FName AmmoType);
	void DecrementSecondarySlotCount(class FName AmmoType);
	void DecrementTacticalSlotCount(TSubclassOf<class ABaseItem> SlotItem);
	void DeletePreset(const class FString& Param_Name);
	void DoSaveActiveLoadout();
	void DoSaveLoadout(EEquippingSwat SwatMember, const struct FSavedLoadout& Loadout);
	EEquippingSwat FStringToEquippingSwat(const class FString& Param_Name);
	class UArmourMaterial* GetActiveArmorMaterial();
	TSubclassOf<class ABaseItem> GetActiveBodyArmor();
	TSubclassOf<class ABaseItem> GetActiveHeadwear();
	struct FSavedLoadout GetActiveLoadout();
	TSubclassOf<class ABaseItem> GetActiveLongTactical();
	TSubclassOf<class ABaseWeapon> GetActivePrimary();
	TSubclassOf<class UWeaponAttachment> GetActivePrimaryAttachmentByType(EWeaponAttachmentType AttachmentType);
	TSubclassOf<class ABaseWeapon> GetActiveSecondary();
	TSubclassOf<class UWeaponAttachment> GetActiveSecondaryAttachmentByType(EWeaponAttachmentType AttachmentType);
	EEquippingSwat GetActiveSwatMember();
	class FString GetActiveSwatMemberLabel();
	class FText GetAmmunitionCaliber(class FName AmmunitionName);
	class FText GetAmmunitionDescription(class FName AmmunitionName);
	class FText GetAmmunitionDisplayName(class FName AmmunitionName);
	EArmourCoverage GetArmorCoverage();
	class FText GetArmorCoverageText(EArmourCoverage Coverage);
	TArray<class UArmourMaterial*> GetArmorMaterials();
	TArray<TSubclassOf<class UWeaponAttachment>> GetAttachmentByWeaponAndType(class ABaseWeapon* Weapon, EWeaponAttachmentType Type);
	TArray<EWeaponAttachmentType> GetAvailableAttachmentTypesByWeapon(TSubclassOf<class ABaseWeapon> BaseWeapon);
	TSoftObjectPtr<class UTexture2D> GetBodyArmorItemImage(class ABaseItem* Item);
	TArray<class ABaseItem*> GetBodyArmors();
	class FText GetCurrentPresetDisplayName();
	int32 GetCurrentSlotCount();
	int32 GetGrenadeSlotCount(TSubclassOf<class ABaseItem> SlotItem);
	TSoftObjectPtr<class UTexture2D> GetHeadwearItemImage(class ABaseItem* Item);
	TArray<class ABaseItem*> GetHeadwears();
	TArray<class ABaseItem*> GetItemsByLoadoutCategory(ELoadoutCategory LoadoutCategory);
	TSoftObjectPtr<class UTexture2D> GetLongTacticalItemImage(class ABaseItem* Item);
	int32 GetMaximumSlotCount();
	struct FSavedLoadout GetPreset(const class FString& Param_Name);
	int32 GetPreviewGrenadeSlotCount(const struct FSavedLoadout& PreviewLoadout, TSubclassOf<class ABaseItem> SlotItem);
	int32 GetPreviewPrimarySlotCount(const struct FSavedLoadout& PreviewLoadout, class FName AmmoType);
	int32 GetPreviewSecondarySlotCount(const struct FSavedLoadout& PreviewLoadout, class FName AmmoType);
	int32 GetPreviewSlotCount(const struct FSavedLoadout& PreviewLoadout, TSubclassOf<class ABaseItem> SlotItem);
	int32 GetPreviewTacticalSlotCount(const struct FSavedLoadout& PreviewLoadout, TSubclassOf<class ABaseItem> SlotItem);
	TArray<class FName> GetPrimaryAmmoTypes();
	int32 GetPrimarySlotCount(class FName AmmoType);
	TSoftObjectPtr<class UTexture2D> GetPrimaryWeaponImage(class ABaseItem* Item);
	TArray<class FName> GetSecondaryAmmoTypes();
	int32 GetSecondarySlotCount(class FName AmmoType);
	TSoftObjectPtr<class UTexture2D> GetSecondaryWeaponImage(class ABaseItem* Item);
	int32 GetSlotCount(TSubclassOf<class ABaseItem> SlotItem);
	class UWeaponAttachment* GetStoredAttachmentByWeaponAndType(TSubclassOf<class ABaseWeapon> Weapon, EWeaponAttachmentType Type);
	int32 GetTacticalSlotCount(TSubclassOf<class ABaseItem> SlotItem);
	void IncrementGrenadeSlotCount(TSubclassOf<class ABaseItem> SlotItem);
	void IncrementPrimarySlotCount(class FName AmmoType);
	void IncrementSecondarySlotCount(class FName AmmoType);
	void IncrementTacticalSlotCount(TSubclassOf<class ABaseItem> SlotItem);
	bool ItemIsInActiveLoadout(TSubclassOf<class ABaseItem> Item);
	EEquippingSwat NextActiveSwatMember();
	void OnAvailablePresetsChanged__DelegateSignature();
	void OnPresetApplied__DelegateSignature(const class FString& Param_Name, struct FSavedLoadout& Loadout);
	EEquippingSwat PreviousActiveSwatMember();
	void ResetLoadoutToDefault();
	void SanitizeActiveLoadout();
	void SavePreset(const class FString& Param_Name);
	void SetActiveBodyArmor(TSubclassOf<class ABaseItem> Armor);
	void SetActiveHeadwear(TSubclassOf<class ABaseItem> Headwear);
	void SetActiveLoadout(const struct FSavedLoadout& Loadout);
	void SetActiveLoadoutByName(const class FString& LoadoutName);
	void SetActiveLongTactical(TSubclassOf<class ABaseItem> LongTactical);
	void SetActivePrimary(TSubclassOf<class ABaseWeapon> Primary);
	void SetActivePrimarySkin(TSubclassOf<class USkinComponent> Skin);
	void SetActiveSecondary(TSubclassOf<class ABaseWeapon> Secondary);
	void SetActiveSecondarySkin(TSubclassOf<class USkinComponent> Skin);
	void SetActiveSwatMember(EEquippingSwat SwatMember);
	void SetArmorCoverage(EArmourCoverage ArmorCoverage);
	void SetArmorMaterial(class UArmourMaterial* ArmorMaterial);
	void SetPrimaryAttachment(TSubclassOf<class UWeaponAttachment> WeaponAttachment, EWeaponAttachmentType AttachmentType);
	void SetSecondaryAttachment(TSubclassOf<class UWeaponAttachment> WeaponAttachment, EWeaponAttachmentType AttachmentType);

	TArray<class FString> GetAllPresetNames() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotLoadoutManager">();
	}
	static class UReadyOrNotLoadoutManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotLoadoutManager>();
	}
};
static_assert(alignof(UReadyOrNotLoadoutManager) == 0x000008, "Wrong alignment on UReadyOrNotLoadoutManager");
static_assert(sizeof(UReadyOrNotLoadoutManager) == 0x0002D0, "Wrong size on UReadyOrNotLoadoutManager");
static_assert(offsetof(UReadyOrNotLoadoutManager, StoredAttachmentsByWeapon) == 0x000078, "Member 'UReadyOrNotLoadoutManager::StoredAttachmentsByWeapon' has a wrong offset!");
static_assert(offsetof(UReadyOrNotLoadoutManager, OnPresetApplied) == 0x0000C8, "Member 'UReadyOrNotLoadoutManager::OnPresetApplied' has a wrong offset!");
static_assert(offsetof(UReadyOrNotLoadoutManager, OnAvailablePresetsChanged) == 0x0000D8, "Member 'UReadyOrNotLoadoutManager::OnAvailablePresetsChanged' has a wrong offset!");
static_assert(offsetof(UReadyOrNotLoadoutManager, ActiveLoadout) == 0x000138, "Member 'UReadyOrNotLoadoutManager::ActiveLoadout' has a wrong offset!");
static_assert(offsetof(UReadyOrNotLoadoutManager, ActiveSwatMember) == 0x0002C0, "Member 'UReadyOrNotLoadoutManager::ActiveSwatMember' has a wrong offset!");
static_assert(offsetof(UReadyOrNotLoadoutManager, LoadoutManager) == 0x0002C8, "Member 'UReadyOrNotLoadoutManager::LoadoutManager' has a wrong offset!");

// Class ReadyOrNot.C2DoorActivity
// 0x0010 (0x0228 - 0x0218)
class UC2DoorActivity final  : public UDoorBreachActivity
{
public:
	uint8                                         Pad_25FA[0x10];                                    // 0x0218(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterDetonateC2Stage();
	void OnC2Detonate();
	void OnC2Placed();
	void PerformDetonateC2Stage(float DeltaTime, float Uptime);

	bool CanDetonateC2() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"C2DoorActivity">();
	}
	static class UC2DoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UC2DoorActivity>();
	}
};
static_assert(alignof(UC2DoorActivity) == 0x000008, "Wrong alignment on UC2DoorActivity");
static_assert(sizeof(UC2DoorActivity) == 0x000228, "Wrong size on UC2DoorActivity");

// Class ReadyOrNot.RamDoorActivity
// 0x0008 (0x0220 - 0x0218)
class URamDoorActivity final  : public UDoorBreachActivity
{
public:
	uint8                                         Pad_25FB[0x8];                                     // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDoorRammed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RamDoorActivity">();
	}
	static class URamDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<URamDoorActivity>();
	}
};
static_assert(alignof(URamDoorActivity) == 0x000008, "Wrong alignment on URamDoorActivity");
static_assert(sizeof(URamDoorActivity) == 0x000220, "Wrong size on URamDoorActivity");

// Class ReadyOrNot.NavQuery_GasFleeingSuspect
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_GasFleeingSuspect final  : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_GasFleeingSuspect">();
	}
	static class UNavQuery_GasFleeingSuspect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_GasFleeingSuspect>();
	}
};
static_assert(alignof(UNavQuery_GasFleeingSuspect) == 0x000008, "Wrong alignment on UNavQuery_GasFleeingSuspect");
static_assert(sizeof(UNavQuery_GasFleeingSuspect) == 0x000048, "Wrong size on UNavQuery_GasFleeingSuspect");

// Class ReadyOrNot.ThrowItemThroughDoorActivity
// 0x0040 (0x0258 - 0x0218)
class UThrowItemThroughDoorActivity : public UDoorBreachActivity
{
public:
	TSubclassOf<class ABaseItem>                  ThrowItemClass;                                    // 0x0218(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnThrowReady;                                      // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnThrowingItem;                                    // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_25FC[0x8];                                     // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseItem*                              ThrownItem;                                        // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25FD[0x8];                                     // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrowItemThroughDoorActivity">();
	}
	static class UThrowItemThroughDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThrowItemThroughDoorActivity>();
	}
};
static_assert(alignof(UThrowItemThroughDoorActivity) == 0x000008, "Wrong alignment on UThrowItemThroughDoorActivity");
static_assert(sizeof(UThrowItemThroughDoorActivity) == 0x000258, "Wrong size on UThrowItemThroughDoorActivity");
static_assert(offsetof(UThrowItemThroughDoorActivity, ThrowItemClass) == 0x000218, "Member 'UThrowItemThroughDoorActivity::ThrowItemClass' has a wrong offset!");
static_assert(offsetof(UThrowItemThroughDoorActivity, OnThrowReady) == 0x000220, "Member 'UThrowItemThroughDoorActivity::OnThrowReady' has a wrong offset!");
static_assert(offsetof(UThrowItemThroughDoorActivity, OnThrowingItem) == 0x000230, "Member 'UThrowItemThroughDoorActivity::OnThrowingItem' has a wrong offset!");
static_assert(offsetof(UThrowItemThroughDoorActivity, ThrownItem) == 0x000248, "Member 'UThrowItemThroughDoorActivity::ThrownItem' has a wrong offset!");

// Class ReadyOrNot.ThrowGrenadeThroughDoorActivity
// 0x0000 (0x0258 - 0x0258)
class UThrowGrenadeThroughDoorActivity final  : public UThrowItemThroughDoorActivity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrowGrenadeThroughDoorActivity">();
	}
	static class UThrowGrenadeThroughDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThrowGrenadeThroughDoorActivity>();
	}
};
static_assert(alignof(UThrowGrenadeThroughDoorActivity) == 0x000008, "Wrong alignment on UThrowGrenadeThroughDoorActivity");
static_assert(sizeof(UThrowGrenadeThroughDoorActivity) == 0x000258, "Wrong size on UThrowGrenadeThroughDoorActivity");

// Class ReadyOrNot.CustomDoorBreachActivity
// 0x0000 (0x0218 - 0x0218)
class UCustomDoorBreachActivity final  : public UDoorBreachActivity
{
public:
	void TickBreachDoor(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomDoorBreachActivity">();
	}
	static class UCustomDoorBreachActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomDoorBreachActivity>();
	}
};
static_assert(alignof(UCustomDoorBreachActivity) == 0x000008, "Wrong alignment on UCustomDoorBreachActivity");
static_assert(sizeof(UCustomDoorBreachActivity) == 0x000218, "Wrong size on UCustomDoorBreachActivity");

// Class ReadyOrNot.DoorJam
// 0x0050 (0x0A20 - 0x09D0)
class ADoorJam : public ABaseItem
{
public:
	uint8                                         Pad_25FE[0x8];                                     // 0x09D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bSet : 1;                                          // 0x09D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25FF[0x7];                                     // 0x09D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   PlacedBy;                                          // 0x09E0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADoor*                                  PendingPlacement;                                  // 0x09E8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADoor*                                  JammedDoor;                                        // 0x09F0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DoorJamSocket;                                     // 0x09F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          PlacedMesh;                                        // 0x0A00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlacementTimer;                                    // 0x0A08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WedgeRemovalTime;                                  // 0x0A0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2600[0x10];                                    // 0x0A10(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JamDoor(class ADoor* Door);
	void Multicast_StartPlacement();
	void OnRep_DoorjamSet();
	void Server_FinishDoorjamPlacement(class ADoor* PendingDoor);
	void Server_StartDoorjamPlacement(class ADoor* PendingDoor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorJam">();
	}
	static class ADoorJam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoorJam>();
	}
};
static_assert(alignof(ADoorJam) == 0x000010, "Wrong alignment on ADoorJam");
static_assert(sizeof(ADoorJam) == 0x000A20, "Wrong size on ADoorJam");
static_assert(offsetof(ADoorJam, PlacedBy) == 0x0009E0, "Member 'ADoorJam::PlacedBy' has a wrong offset!");
static_assert(offsetof(ADoorJam, PendingPlacement) == 0x0009E8, "Member 'ADoorJam::PendingPlacement' has a wrong offset!");
static_assert(offsetof(ADoorJam, JammedDoor) == 0x0009F0, "Member 'ADoorJam::JammedDoor' has a wrong offset!");
static_assert(offsetof(ADoorJam, DoorJamSocket) == 0x0009F8, "Member 'ADoorJam::DoorJamSocket' has a wrong offset!");
static_assert(offsetof(ADoorJam, PlacedMesh) == 0x000A00, "Member 'ADoorJam::PlacedMesh' has a wrong offset!");
static_assert(offsetof(ADoorJam, PlacementTimer) == 0x000A08, "Member 'ADoorJam::PlacementTimer' has a wrong offset!");
static_assert(offsetof(ADoorJam, WedgeRemovalTime) == 0x000A0C, "Member 'ADoorJam::WedgeRemovalTime' has a wrong offset!");

// Class ReadyOrNot.MissionSelect
// 0x0110 (0x0330 - 0x0220)
class AMissionSelect final  : public AActor
{
public:
	TSoftObjectPtr<class UWorld>                  LosSuenosLevel;                                    // 0x0220(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PersistentLightingLevelName;                       // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LevelOffset;                                       // 0x0250(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraTag;                                         // 0x025C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectsTag;                                        // 0x0264(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PreloadTag;                                        // 0x026C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraInterpSpeed;                                 // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeHoldTime;                                      // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FadeColor;                                         // 0x0284(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBlockingLoad;                                  // 0x0294(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2601[0x3];                                     // 0x0295(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADirectionalLight*>              HiddenDirectionalLights;                           // 0x0298(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class ASkyLight*>                      HiddenSkyLights;                                   // 0x02A8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class APostProcessVolume*>             HiddenPostProcessVolumes;                          // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class AExponentialHeightFog*>          HiddenExponentialHeightFogs;                       // 0x02C8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	class AActor*                                 ViewTargetActor;                                   // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginalCameraPosition;                            // 0x02E0(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2602[0x1C];                                    // 0x02EC(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelStreamingDynamic*                 CurrentLevel;                                      // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelStreamingDynamic*                 InFlightLevel;                                     // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelStreaming*                        PersistentLightingLevel;                           // 0x0318(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AReadyOrNotPlayerController*            PlayerController;                                  // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerCameraManager*                   PlayerCameraManager;                               // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CloseMissionSelect();
	void LoadLevel(TSoftObjectPtr<class UWorld> Level);
	void OnLevelLoaded();
	void OnLevelShown();
	void OpenMissionSelect();
	void PreviewMission(class ULevelData* LevelData);
	void SelectMission(class ULevelData* LevelData);

	bool IsOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionSelect">();
	}
	static class AMissionSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMissionSelect>();
	}
};
static_assert(alignof(AMissionSelect) == 0x000008, "Wrong alignment on AMissionSelect");
static_assert(sizeof(AMissionSelect) == 0x000330, "Wrong size on AMissionSelect");
static_assert(offsetof(AMissionSelect, LosSuenosLevel) == 0x000220, "Member 'AMissionSelect::LosSuenosLevel' has a wrong offset!");
static_assert(offsetof(AMissionSelect, PersistentLightingLevelName) == 0x000248, "Member 'AMissionSelect::PersistentLightingLevelName' has a wrong offset!");
static_assert(offsetof(AMissionSelect, LevelOffset) == 0x000250, "Member 'AMissionSelect::LevelOffset' has a wrong offset!");
static_assert(offsetof(AMissionSelect, CameraTag) == 0x00025C, "Member 'AMissionSelect::CameraTag' has a wrong offset!");
static_assert(offsetof(AMissionSelect, EffectsTag) == 0x000264, "Member 'AMissionSelect::EffectsTag' has a wrong offset!");
static_assert(offsetof(AMissionSelect, PreloadTag) == 0x00026C, "Member 'AMissionSelect::PreloadTag' has a wrong offset!");
static_assert(offsetof(AMissionSelect, CameraInterpSpeed) == 0x000274, "Member 'AMissionSelect::CameraInterpSpeed' has a wrong offset!");
static_assert(offsetof(AMissionSelect, FadeOutTime) == 0x000278, "Member 'AMissionSelect::FadeOutTime' has a wrong offset!");
static_assert(offsetof(AMissionSelect, FadeInTime) == 0x00027C, "Member 'AMissionSelect::FadeInTime' has a wrong offset!");
static_assert(offsetof(AMissionSelect, FadeHoldTime) == 0x000280, "Member 'AMissionSelect::FadeHoldTime' has a wrong offset!");
static_assert(offsetof(AMissionSelect, FadeColor) == 0x000284, "Member 'AMissionSelect::FadeColor' has a wrong offset!");
static_assert(offsetof(AMissionSelect, bUseBlockingLoad) == 0x000294, "Member 'AMissionSelect::bUseBlockingLoad' has a wrong offset!");
static_assert(offsetof(AMissionSelect, HiddenDirectionalLights) == 0x000298, "Member 'AMissionSelect::HiddenDirectionalLights' has a wrong offset!");
static_assert(offsetof(AMissionSelect, HiddenSkyLights) == 0x0002A8, "Member 'AMissionSelect::HiddenSkyLights' has a wrong offset!");
static_assert(offsetof(AMissionSelect, HiddenPostProcessVolumes) == 0x0002B8, "Member 'AMissionSelect::HiddenPostProcessVolumes' has a wrong offset!");
static_assert(offsetof(AMissionSelect, HiddenExponentialHeightFogs) == 0x0002C8, "Member 'AMissionSelect::HiddenExponentialHeightFogs' has a wrong offset!");
static_assert(offsetof(AMissionSelect, ViewTargetActor) == 0x0002D8, "Member 'AMissionSelect::ViewTargetActor' has a wrong offset!");
static_assert(offsetof(AMissionSelect, OriginalCameraPosition) == 0x0002E0, "Member 'AMissionSelect::OriginalCameraPosition' has a wrong offset!");
static_assert(offsetof(AMissionSelect, CurrentLevel) == 0x000308, "Member 'AMissionSelect::CurrentLevel' has a wrong offset!");
static_assert(offsetof(AMissionSelect, InFlightLevel) == 0x000310, "Member 'AMissionSelect::InFlightLevel' has a wrong offset!");
static_assert(offsetof(AMissionSelect, PersistentLightingLevel) == 0x000318, "Member 'AMissionSelect::PersistentLightingLevel' has a wrong offset!");
static_assert(offsetof(AMissionSelect, PlayerController) == 0x000320, "Member 'AMissionSelect::PlayerController' has a wrong offset!");
static_assert(offsetof(AMissionSelect, PlayerCameraManager) == 0x000328, "Member 'AMissionSelect::PlayerCameraManager' has a wrong offset!");

// Class ReadyOrNot.DoorRam
// 0x00C0 (0x0A90 - 0x09D0)
class ADoorRam : public ABaseDeployableGear
{
public:
	TArray<TSubclassOf<class AActor>>             AcceptableHitWhitelist;                            // 0x09D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         MaxHitDistance;                                    // 0x09E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2603[0x4];                                     // 0x09E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                RamDamageTypeDefault;                              // 0x09E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                RamDamageTypeCrumble;                              // 0x09F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                RamDamageTypePlayer;                               // 0x09F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrikePlayerDamage;                                // 0x0A00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             LastGoodHit;                                       // 0x0A04(0x0088)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2604[0x4];                                     // 0x0A8C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBatteringRamHit();
	void Server_StrikeDoor(class ADoor* TargetDoor);
	void Server_StrikePlayer(class APlayerCharacter* TargetPlayer);

	bool CanHitActor(struct FHitResult& TestHit) const;
	struct FHitResult TryGetHitPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorRam">();
	}
	static class ADoorRam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoorRam>();
	}
};
static_assert(alignof(ADoorRam) == 0x000010, "Wrong alignment on ADoorRam");
static_assert(sizeof(ADoorRam) == 0x000A90, "Wrong size on ADoorRam");
static_assert(offsetof(ADoorRam, AcceptableHitWhitelist) == 0x0009D0, "Member 'ADoorRam::AcceptableHitWhitelist' has a wrong offset!");
static_assert(offsetof(ADoorRam, MaxHitDistance) == 0x0009E0, "Member 'ADoorRam::MaxHitDistance' has a wrong offset!");
static_assert(offsetof(ADoorRam, RamDamageTypeDefault) == 0x0009E8, "Member 'ADoorRam::RamDamageTypeDefault' has a wrong offset!");
static_assert(offsetof(ADoorRam, RamDamageTypeCrumble) == 0x0009F0, "Member 'ADoorRam::RamDamageTypeCrumble' has a wrong offset!");
static_assert(offsetof(ADoorRam, RamDamageTypePlayer) == 0x0009F8, "Member 'ADoorRam::RamDamageTypePlayer' has a wrong offset!");
static_assert(offsetof(ADoorRam, StrikePlayerDamage) == 0x000A00, "Member 'ADoorRam::StrikePlayerDamage' has a wrong offset!");
static_assert(offsetof(ADoorRam, LastGoodHit) == 0x000A04, "Member 'ADoorRam::LastGoodHit' has a wrong offset!");

// Class ReadyOrNot.DoorwayComponent
// 0x0000 (0x0480 - 0x0480)
class UDoorwayComponent final  : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorwayComponent">();
	}
	static class UDoorwayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoorwayComponent>();
	}
};
static_assert(alignof(UDoorwayComponent) == 0x000010, "Wrong alignment on UDoorwayComponent");
static_assert(sizeof(UDoorwayComponent) == 0x000480, "Wrong size on UDoorwayComponent");

// Class ReadyOrNot.DroneVehicle
// 0x0148 (0x0410 - 0x02C8)
class ADroneVehicle final  : public AUnmannedVehicle
{
public:
	class UBoxComponent*                          FlightBox;                                         // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        Audio;                                             // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       FirstPersonCamera;                                 // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    ThirdPersonSpringArm;                              // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       ThirdPersonCamera;                                 // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatingPawnMovement*                  FloatingMovementComponent;                         // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTilt;                                           // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRPM;                                            // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleRPM;                                           // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RPMForceScale;                                     // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RPMThrottleMultiplier;                             // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrottleInterpSpeed;                               // 0x0314(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationInterpSpeed;                               // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSpeed;                                         // 0x031C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationInterpSpeedWhenSteady;                     // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSpeedWhenSteady;                               // 0x0324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeed;                                          // 0x0328(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x032C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedIncrementRate;                                // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvincibilityTimeAfterDamageApplied;               // 0x0334(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RPM;                                               // 0x0338(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotorRotation;                                     // 0x033C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CurrentAltitude;                                   // 0x0348(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentPilotDistance;                              // 0x034C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             DroneTransform;                                    // 0x0350(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRotation;                                    // 0x0380(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2606[0x34];                                    // 0x038C(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bApplyingInput;                                    // 0x03C0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSteadyDrone;                                      // 0x03C1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2607[0x26];                                    // 0x03C2(0x0026)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       DroneOwner;                                        // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2608[0x18];                                    // 0x03F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Drone_Exit();
	void Drone_MoveForward(float Val);
	void Drone_QuickTurn();
	void Drone_Right(float Val);
	void Drone_Steady();
	void Drone_Throttle(float Val);
	void Drone_ToggleThirdPerson();
	void Drone_Yaw(float Val);
	void OnDroneHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit);
	void OnRep_DroneMovement();
	void Server_UpdateDroneTransform(const struct FTransform& NewTransform);
	void UpdatePilotingInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroneVehicle">();
	}
	static class ADroneVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADroneVehicle>();
	}
};
static_assert(alignof(ADroneVehicle) == 0x000010, "Wrong alignment on ADroneVehicle");
static_assert(sizeof(ADroneVehicle) == 0x000410, "Wrong size on ADroneVehicle");
static_assert(offsetof(ADroneVehicle, FlightBox) == 0x0002C8, "Member 'ADroneVehicle::FlightBox' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, Mesh) == 0x0002D0, "Member 'ADroneVehicle::Mesh' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, Audio) == 0x0002D8, "Member 'ADroneVehicle::Audio' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, FirstPersonCamera) == 0x0002E0, "Member 'ADroneVehicle::FirstPersonCamera' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, ThirdPersonSpringArm) == 0x0002E8, "Member 'ADroneVehicle::ThirdPersonSpringArm' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, ThirdPersonCamera) == 0x0002F0, "Member 'ADroneVehicle::ThirdPersonCamera' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, FloatingMovementComponent) == 0x0002F8, "Member 'ADroneVehicle::FloatingMovementComponent' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, MaxTilt) == 0x000300, "Member 'ADroneVehicle::MaxTilt' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, MaxRPM) == 0x000304, "Member 'ADroneVehicle::MaxRPM' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, IdleRPM) == 0x000308, "Member 'ADroneVehicle::IdleRPM' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, RPMForceScale) == 0x00030C, "Member 'ADroneVehicle::RPMForceScale' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, RPMThrottleMultiplier) == 0x000310, "Member 'ADroneVehicle::RPMThrottleMultiplier' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, ThrottleInterpSpeed) == 0x000314, "Member 'ADroneVehicle::ThrottleInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, RotationInterpSpeed) == 0x000318, "Member 'ADroneVehicle::RotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, TurnSpeed) == 0x00031C, "Member 'ADroneVehicle::TurnSpeed' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, RotationInterpSpeedWhenSteady) == 0x000320, "Member 'ADroneVehicle::RotationInterpSpeedWhenSteady' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, TurnSpeedWhenSteady) == 0x000324, "Member 'ADroneVehicle::TurnSpeedWhenSteady' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, MinSpeed) == 0x000328, "Member 'ADroneVehicle::MinSpeed' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, MaxSpeed) == 0x00032C, "Member 'ADroneVehicle::MaxSpeed' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, SpeedIncrementRate) == 0x000330, "Member 'ADroneVehicle::SpeedIncrementRate' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, InvincibilityTimeAfterDamageApplied) == 0x000334, "Member 'ADroneVehicle::InvincibilityTimeAfterDamageApplied' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, RPM) == 0x000338, "Member 'ADroneVehicle::RPM' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, RotorRotation) == 0x00033C, "Member 'ADroneVehicle::RotorRotation' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, CurrentAltitude) == 0x000348, "Member 'ADroneVehicle::CurrentAltitude' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, CurrentPilotDistance) == 0x00034C, "Member 'ADroneVehicle::CurrentPilotDistance' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, DroneTransform) == 0x000350, "Member 'ADroneVehicle::DroneTransform' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, TargetRotation) == 0x000380, "Member 'ADroneVehicle::TargetRotation' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, bApplyingInput) == 0x0003C0, "Member 'ADroneVehicle::bApplyingInput' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, bSteadyDrone) == 0x0003C1, "Member 'ADroneVehicle::bSteadyDrone' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, DroneOwner) == 0x0003E8, "Member 'ADroneVehicle::DroneOwner' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, World) == 0x0003F0, "Member 'ADroneVehicle::World' has a wrong offset!");

// Class ReadyOrNot.NavArea_SwatDelta
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SwatDelta final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SwatDelta">();
	}
	static class UNavArea_SwatDelta* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SwatDelta>();
	}
};
static_assert(alignof(UNavArea_SwatDelta) == 0x000008, "Wrong alignment on UNavArea_SwatDelta");
static_assert(sizeof(UNavArea_SwatDelta) == 0x000048, "Wrong size on UNavArea_SwatDelta");

// Class ReadyOrNot.DuelingCombatMove
// 0x0030 (0x0208 - 0x01D8)
class UDuelingCombatMove final  : public UBaseCombatMoveActivity
{
public:
	uint8                                         Pad_260A[0x30];                                    // 0x01D8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DuelingCombatMove">();
	}
	static class UDuelingCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDuelingCombatMove>();
	}
};
static_assert(alignof(UDuelingCombatMove) == 0x000008, "Wrong alignment on UDuelingCombatMove");
static_assert(sizeof(UDuelingCombatMove) == 0x000208, "Wrong size on UDuelingCombatMove");

// Class ReadyOrNot.DynamicWorldActor
// 0x0010 (0x0230 - 0x0220)
class ADynamicWorldActor final  : public AActor
{
public:
	class FName                                   DynamicLabel;                                      // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicateSpawn;                                   // 0x0228(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260B[0x7];                                     // 0x0229(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckDynamicSpawn();
	void OnDynamicallySpawned();
	void OnRep_ReplicateSpawn();
	void SetDynamicSpawn(bool bShouldSpawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicWorldActor">();
	}
	static class ADynamicWorldActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicWorldActor>();
	}
};
static_assert(alignof(ADynamicWorldActor) == 0x000008, "Wrong alignment on ADynamicWorldActor");
static_assert(sizeof(ADynamicWorldActor) == 0x000230, "Wrong size on ADynamicWorldActor");
static_assert(offsetof(ADynamicWorldActor, DynamicLabel) == 0x000220, "Member 'ADynamicWorldActor::DynamicLabel' has a wrong offset!");
static_assert(offsetof(ADynamicWorldActor, bReplicateSpawn) == 0x000228, "Member 'ADynamicWorldActor::bReplicateSpawn' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotGameUserSettings
// 0x01A0 (0x02C0 - 0x0120)
class UReadyOrNotGameUserSettings final  : public UGameUserSettings
{
public:
	uint8                                         Pad_260C[0x18];                                    // 0x0120(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MasterSoundVolume;                                 // 0x0138(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MusicSoundVolume;                                  // 0x013C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UISoundVolume;                                     // 0x0140(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SFXSoundVolume;                                    // 0x0144(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VOIPVolume;                                        // 0x0148(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoiceType                                    DefaultVOIPChannel;                                // 0x014C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitmarkerSfxEnabled;                              // 0x014D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260D[0x2];                                     // 0x014E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MouseSensitivity;                                  // 0x0150(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreelookSensitivity;                               // 0x0154(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadLookSensitivity;                            // 0x0158(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadAimSensitivity;                             // 0x015C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetLocale;                                      // 0x0160(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldOfView;                                       // 0x0170(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LadderRollSensitivity;                             // 0x0174(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleADS;                                        // 0x0178(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldCrouch;                                       // 0x0179(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTogglePS5Gyro;                                    // 0x017A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsingAlternateControls;                           // 0x017B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxShellsInWorld;                                  // 0x017C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxShellLifeTime;                                  // 0x0180(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMeshPainting;                                  // 0x0184(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260E[0x3];                                     // 0x0185(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LastConnectedServerIP;                             // 0x0188(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IconScale;                                         // 0x0198(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickThrowScale;                                   // 0x019C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWorldDecalsEnabled;                               // 0x01A0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260F[0x3];                                     // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WorldDecalScreenFadeSize;                          // 0x01A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldDecalDensity;                                 // 0x01A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireModeDisplayOption;                             // 0x01AC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamViewFPS;                                       // 0x01B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeamViewFPSEnabled;                               // 0x01B4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowFPS;                                          // 0x01B5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHUD;                                          // 0x01B6(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCompass;                                      // 0x01B7(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowWeaponHUD;                                    // 0x01B8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMagazineHUD;                                  // 0x01B9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowChat;                                         // 0x01BA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHUDSwaying;                                 // 0x01BB(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHotkeyHints;                                  // 0x01BC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHealthIcons;                                  // 0x01BD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCommandContextHint;                           // 0x01BE(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZoomADS;                                          // 0x01BF(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSendMapStatistics;                                // 0x01C0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScoreReadoutMode                             ScoreReadoutMode;                                  // 0x01C1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwatCommand                                  DefaultCommand;                                    // 0x01C2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwatCommand                                  DefaultDoorUnknownCommand;                         // 0x01C3(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwatCommand                                  DefaultDoorOpenCommand;                            // 0x01C4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwatCommand                                  DefaultDoorLockedCommand;                          // 0x01C5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwatCommand                                  DefaultDoorUnlockedCommand;                        // 0x01C6(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2610[0x1];                                     // 0x01C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultCommandOption;                              // 0x01C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ViewDistanceQuality;                               // 0x01CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AntiAliasingQuality;                               // 0x01D0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShadowQuality;                                     // 0x01D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PostProcessQuality;                                // 0x01D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextureQuality;                                    // 0x01DC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectsQuality;                                    // 0x01E0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePerObjectShadows;                           // 0x01E4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2611[0x3];                                     // 0x01E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultDoorUnknownCommandOption;                   // 0x01E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultDoorOpenCommandOption;                      // 0x01EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultDoorLockedCommandOption;                    // 0x01F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultDoorUnlockedCommandOption;                  // 0x01F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurvedHUD;                                        // 0x01F8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          b2DReloadIcons;                                    // 0x01F9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPlayerNamePlates;                             // 0x01FA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPlayerIcon;                                   // 0x01FB(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowTeamStatus;                                   // 0x01FC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMirrorReflectionEnabled;                          // 0x01FD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMirrorInLobbyOnly;                                // 0x01FE(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2612[0x1];                                     // 0x01FF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MirrorFPS;                                         // 0x0200(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PiPFPS;                                            // 0x0204(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPiPFPSEnabled;                                    // 0x0208(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDepthOfField;                                     // 0x0209(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMotionBlur;                                       // 0x020A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2613[0x1];                                     // 0x020B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MotionBlurStrength;                                // 0x020C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PiPResolutionScale;                                // 0x0210(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafeZoneX;                                         // 0x0214(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafeZoneY;                                         // 0x0218(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GraphicsPresetIndex;                               // 0x021C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowButtonPrompts;                                // 0x0220(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertMousePitch;                                 // 0x0221(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertMouseYaw;                                   // 0x0222(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertGamepadHorizontal;                          // 0x0223(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertGamepadVertical;                            // 0x0224(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExperimentalFeatures;                             // 0x0225(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowControlsOnScreen;                             // 0x0226(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHesitationBar;                                // 0x0227(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRayTracingEnabled;                                // 0x0228(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRayTracingReflectionsEnabled;                     // 0x0229(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRayTracingShadowsEnabled;                         // 0x022A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRayTracingAmbientOcclusionEnabled;                // 0x022B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2614[0x4];                                     // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DlssQualitySetting;                                // 0x0230(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExperimentalFrameGenerationSetting;                // 0x0234(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FSRQualitySetting;                                 // 0x0238(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MicInputGain;                                      // 0x023C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InputAudioDevice;                                  // 0x0240(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFrameLimitEnabled;                                // 0x0250(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemSelectionInterfaceType                   ItemSelectionInterface;                            // 0x0251(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGrenadeThrowSettingType                      GrenadeThrowType;                                  // 0x0252(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShotgunReloadType                            ShotgunLoadType;                                   // 0x0253(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEmptyMagReloadType                           EmptyMagReloadType;                                // 0x0254(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOptiwandViewMode                             OptiwandViewMode;                                  // 0x0255(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2615[0x2];                                     // 0x0256(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DMOAddress;                                        // 0x0258(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DMOGameMode;                                       // 0x0268(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     DMOTeamType;                                       // 0x0278(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2616[0x3];                                     // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMirrorReflectionSettings              MirrorReflectionSettings;                          // 0x027C(0x0008)(Config, NoDestructor, NativeAccessSpecifierPublic)
	ENVGStyle                                     NVGStyle;                                          // 0x0284(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHighReadyStyle;                                // 0x0285(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBounceLightEnabled;                               // 0x0286(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlashlightShadowsEnabled;                         // 0x0287(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerSideChecksum;                               // 0x0288(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReflexMode;                                        // 0x0289(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReflexGameToRenderLatencyInMSEnabled;             // 0x028A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReflexGameLatencyInMSEnabled;                     // 0x028B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReflexRenderLatencyInMSEnabled;                   // 0x028C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReflexFlashIndicatorEnabled;                      // 0x028D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EColorVisionDeficiency                        ColorVisionDeficiency;                             // 0x028E(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2617[0x1];                                     // 0x028F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ColorVisionDeficiencyStrength;                     // 0x0290(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighlightWeapons;                                 // 0x0294(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWorldSpaceActionPrompts;                          // 0x0295(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2618[0x2];                                     // 0x0296(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterfaceAspectRatio;                              // 0x0298(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSubtitles;                                  // 0x029C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESubtitlesSize                                SubtitlesSize;                                     // 0x029D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2619[0x2];                                     // 0x029E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SubtitlesLocale;                                   // 0x02A0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubtitlesBackgroundOpacity;                        // 0x02B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubtitlesSpeed;                                    // 0x02B4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261A[0x8];                                     // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ResetKeybinds();

	void ResetGamepadControlsSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotGameUserSettings">();
	}
	static class UReadyOrNotGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotGameUserSettings>();
	}
};
static_assert(alignof(UReadyOrNotGameUserSettings) == 0x000008, "Wrong alignment on UReadyOrNotGameUserSettings");
static_assert(sizeof(UReadyOrNotGameUserSettings) == 0x0002C0, "Wrong size on UReadyOrNotGameUserSettings");
static_assert(offsetof(UReadyOrNotGameUserSettings, MasterSoundVolume) == 0x000138, "Member 'UReadyOrNotGameUserSettings::MasterSoundVolume' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, MusicSoundVolume) == 0x00013C, "Member 'UReadyOrNotGameUserSettings::MusicSoundVolume' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, UISoundVolume) == 0x000140, "Member 'UReadyOrNotGameUserSettings::UISoundVolume' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, SFXSoundVolume) == 0x000144, "Member 'UReadyOrNotGameUserSettings::SFXSoundVolume' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, VOIPVolume) == 0x000148, "Member 'UReadyOrNotGameUserSettings::VOIPVolume' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultVOIPChannel) == 0x00014C, "Member 'UReadyOrNotGameUserSettings::DefaultVOIPChannel' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bHitmarkerSfxEnabled) == 0x00014D, "Member 'UReadyOrNotGameUserSettings::bHitmarkerSfxEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, MouseSensitivity) == 0x000150, "Member 'UReadyOrNotGameUserSettings::MouseSensitivity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, FreelookSensitivity) == 0x000154, "Member 'UReadyOrNotGameUserSettings::FreelookSensitivity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GamepadLookSensitivity) == 0x000158, "Member 'UReadyOrNotGameUserSettings::GamepadLookSensitivity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GamepadAimSensitivity) == 0x00015C, "Member 'UReadyOrNotGameUserSettings::GamepadAimSensitivity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, TargetLocale) == 0x000160, "Member 'UReadyOrNotGameUserSettings::TargetLocale' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, FieldOfView) == 0x000170, "Member 'UReadyOrNotGameUserSettings::FieldOfView' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, LadderRollSensitivity) == 0x000174, "Member 'UReadyOrNotGameUserSettings::LadderRollSensitivity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bToggleADS) == 0x000178, "Member 'UReadyOrNotGameUserSettings::bToggleADS' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bHoldCrouch) == 0x000179, "Member 'UReadyOrNotGameUserSettings::bHoldCrouch' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bTogglePS5Gyro) == 0x00017A, "Member 'UReadyOrNotGameUserSettings::bTogglePS5Gyro' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bUsingAlternateControls) == 0x00017B, "Member 'UReadyOrNotGameUserSettings::bUsingAlternateControls' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, MaxShellsInWorld) == 0x00017C, "Member 'UReadyOrNotGameUserSettings::MaxShellsInWorld' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, MaxShellLifeTime) == 0x000180, "Member 'UReadyOrNotGameUserSettings::MaxShellLifeTime' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bUseMeshPainting) == 0x000184, "Member 'UReadyOrNotGameUserSettings::bUseMeshPainting' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, LastConnectedServerIP) == 0x000188, "Member 'UReadyOrNotGameUserSettings::LastConnectedServerIP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, IconScale) == 0x000198, "Member 'UReadyOrNotGameUserSettings::IconScale' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, QuickThrowScale) == 0x00019C, "Member 'UReadyOrNotGameUserSettings::QuickThrowScale' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bWorldDecalsEnabled) == 0x0001A0, "Member 'UReadyOrNotGameUserSettings::bWorldDecalsEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, WorldDecalScreenFadeSize) == 0x0001A4, "Member 'UReadyOrNotGameUserSettings::WorldDecalScreenFadeSize' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, WorldDecalDensity) == 0x0001A8, "Member 'UReadyOrNotGameUserSettings::WorldDecalDensity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, FireModeDisplayOption) == 0x0001AC, "Member 'UReadyOrNotGameUserSettings::FireModeDisplayOption' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, TeamViewFPS) == 0x0001B0, "Member 'UReadyOrNotGameUserSettings::TeamViewFPS' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bTeamViewFPSEnabled) == 0x0001B4, "Member 'UReadyOrNotGameUserSettings::bTeamViewFPSEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowFPS) == 0x0001B5, "Member 'UReadyOrNotGameUserSettings::bShowFPS' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowHUD) == 0x0001B6, "Member 'UReadyOrNotGameUserSettings::bShowHUD' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowCompass) == 0x0001B7, "Member 'UReadyOrNotGameUserSettings::bShowCompass' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowWeaponHUD) == 0x0001B8, "Member 'UReadyOrNotGameUserSettings::bShowWeaponHUD' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowMagazineHUD) == 0x0001B9, "Member 'UReadyOrNotGameUserSettings::bShowMagazineHUD' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowChat) == 0x0001BA, "Member 'UReadyOrNotGameUserSettings::bShowChat' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bEnableHUDSwaying) == 0x0001BB, "Member 'UReadyOrNotGameUserSettings::bEnableHUDSwaying' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowHotkeyHints) == 0x0001BC, "Member 'UReadyOrNotGameUserSettings::bShowHotkeyHints' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowHealthIcons) == 0x0001BD, "Member 'UReadyOrNotGameUserSettings::bShowHealthIcons' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowCommandContextHint) == 0x0001BE, "Member 'UReadyOrNotGameUserSettings::bShowCommandContextHint' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bZoomADS) == 0x0001BF, "Member 'UReadyOrNotGameUserSettings::bZoomADS' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bSendMapStatistics) == 0x0001C0, "Member 'UReadyOrNotGameUserSettings::bSendMapStatistics' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ScoreReadoutMode) == 0x0001C1, "Member 'UReadyOrNotGameUserSettings::ScoreReadoutMode' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultCommand) == 0x0001C2, "Member 'UReadyOrNotGameUserSettings::DefaultCommand' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultDoorUnknownCommand) == 0x0001C3, "Member 'UReadyOrNotGameUserSettings::DefaultDoorUnknownCommand' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultDoorOpenCommand) == 0x0001C4, "Member 'UReadyOrNotGameUserSettings::DefaultDoorOpenCommand' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultDoorLockedCommand) == 0x0001C5, "Member 'UReadyOrNotGameUserSettings::DefaultDoorLockedCommand' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultDoorUnlockedCommand) == 0x0001C6, "Member 'UReadyOrNotGameUserSettings::DefaultDoorUnlockedCommand' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultCommandOption) == 0x0001C8, "Member 'UReadyOrNotGameUserSettings::DefaultCommandOption' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ViewDistanceQuality) == 0x0001CC, "Member 'UReadyOrNotGameUserSettings::ViewDistanceQuality' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, AntiAliasingQuality) == 0x0001D0, "Member 'UReadyOrNotGameUserSettings::AntiAliasingQuality' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ShadowQuality) == 0x0001D4, "Member 'UReadyOrNotGameUserSettings::ShadowQuality' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, PostProcessQuality) == 0x0001D8, "Member 'UReadyOrNotGameUserSettings::PostProcessQuality' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, TextureQuality) == 0x0001DC, "Member 'UReadyOrNotGameUserSettings::TextureQuality' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, EffectsQuality) == 0x0001E0, "Member 'UReadyOrNotGameUserSettings::EffectsQuality' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bEnablePerObjectShadows) == 0x0001E4, "Member 'UReadyOrNotGameUserSettings::bEnablePerObjectShadows' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultDoorUnknownCommandOption) == 0x0001E8, "Member 'UReadyOrNotGameUserSettings::DefaultDoorUnknownCommandOption' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultDoorOpenCommandOption) == 0x0001EC, "Member 'UReadyOrNotGameUserSettings::DefaultDoorOpenCommandOption' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultDoorLockedCommandOption) == 0x0001F0, "Member 'UReadyOrNotGameUserSettings::DefaultDoorLockedCommandOption' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultDoorUnlockedCommandOption) == 0x0001F4, "Member 'UReadyOrNotGameUserSettings::DefaultDoorUnlockedCommandOption' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bCurvedHUD) == 0x0001F8, "Member 'UReadyOrNotGameUserSettings::bCurvedHUD' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, b2DReloadIcons) == 0x0001F9, "Member 'UReadyOrNotGameUserSettings::b2DReloadIcons' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowPlayerNamePlates) == 0x0001FA, "Member 'UReadyOrNotGameUserSettings::bShowPlayerNamePlates' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowPlayerIcon) == 0x0001FB, "Member 'UReadyOrNotGameUserSettings::bShowPlayerIcon' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowTeamStatus) == 0x0001FC, "Member 'UReadyOrNotGameUserSettings::bShowTeamStatus' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bMirrorReflectionEnabled) == 0x0001FD, "Member 'UReadyOrNotGameUserSettings::bMirrorReflectionEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bMirrorInLobbyOnly) == 0x0001FE, "Member 'UReadyOrNotGameUserSettings::bMirrorInLobbyOnly' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, MirrorFPS) == 0x000200, "Member 'UReadyOrNotGameUserSettings::MirrorFPS' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, PiPFPS) == 0x000204, "Member 'UReadyOrNotGameUserSettings::PiPFPS' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bPiPFPSEnabled) == 0x000208, "Member 'UReadyOrNotGameUserSettings::bPiPFPSEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bDepthOfField) == 0x000209, "Member 'UReadyOrNotGameUserSettings::bDepthOfField' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bMotionBlur) == 0x00020A, "Member 'UReadyOrNotGameUserSettings::bMotionBlur' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, MotionBlurStrength) == 0x00020C, "Member 'UReadyOrNotGameUserSettings::MotionBlurStrength' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, PiPResolutionScale) == 0x000210, "Member 'UReadyOrNotGameUserSettings::PiPResolutionScale' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, SafeZoneX) == 0x000214, "Member 'UReadyOrNotGameUserSettings::SafeZoneX' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, SafeZoneY) == 0x000218, "Member 'UReadyOrNotGameUserSettings::SafeZoneY' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GraphicsPresetIndex) == 0x00021C, "Member 'UReadyOrNotGameUserSettings::GraphicsPresetIndex' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowButtonPrompts) == 0x000220, "Member 'UReadyOrNotGameUserSettings::bShowButtonPrompts' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bInvertMousePitch) == 0x000221, "Member 'UReadyOrNotGameUserSettings::bInvertMousePitch' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bInvertMouseYaw) == 0x000222, "Member 'UReadyOrNotGameUserSettings::bInvertMouseYaw' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bInvertGamepadHorizontal) == 0x000223, "Member 'UReadyOrNotGameUserSettings::bInvertGamepadHorizontal' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bInvertGamepadVertical) == 0x000224, "Member 'UReadyOrNotGameUserSettings::bInvertGamepadVertical' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bExperimentalFeatures) == 0x000225, "Member 'UReadyOrNotGameUserSettings::bExperimentalFeatures' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowControlsOnScreen) == 0x000226, "Member 'UReadyOrNotGameUserSettings::bShowControlsOnScreen' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowHesitationBar) == 0x000227, "Member 'UReadyOrNotGameUserSettings::bShowHesitationBar' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bRayTracingEnabled) == 0x000228, "Member 'UReadyOrNotGameUserSettings::bRayTracingEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bRayTracingReflectionsEnabled) == 0x000229, "Member 'UReadyOrNotGameUserSettings::bRayTracingReflectionsEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bRayTracingShadowsEnabled) == 0x00022A, "Member 'UReadyOrNotGameUserSettings::bRayTracingShadowsEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bRayTracingAmbientOcclusionEnabled) == 0x00022B, "Member 'UReadyOrNotGameUserSettings::bRayTracingAmbientOcclusionEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DlssQualitySetting) == 0x000230, "Member 'UReadyOrNotGameUserSettings::DlssQualitySetting' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ExperimentalFrameGenerationSetting) == 0x000234, "Member 'UReadyOrNotGameUserSettings::ExperimentalFrameGenerationSetting' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, FSRQualitySetting) == 0x000238, "Member 'UReadyOrNotGameUserSettings::FSRQualitySetting' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, MicInputGain) == 0x00023C, "Member 'UReadyOrNotGameUserSettings::MicInputGain' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, InputAudioDevice) == 0x000240, "Member 'UReadyOrNotGameUserSettings::InputAudioDevice' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bFrameLimitEnabled) == 0x000250, "Member 'UReadyOrNotGameUserSettings::bFrameLimitEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ItemSelectionInterface) == 0x000251, "Member 'UReadyOrNotGameUserSettings::ItemSelectionInterface' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GrenadeThrowType) == 0x000252, "Member 'UReadyOrNotGameUserSettings::GrenadeThrowType' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ShotgunLoadType) == 0x000253, "Member 'UReadyOrNotGameUserSettings::ShotgunLoadType' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, EmptyMagReloadType) == 0x000254, "Member 'UReadyOrNotGameUserSettings::EmptyMagReloadType' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, OptiwandViewMode) == 0x000255, "Member 'UReadyOrNotGameUserSettings::OptiwandViewMode' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DMOAddress) == 0x000258, "Member 'UReadyOrNotGameUserSettings::DMOAddress' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DMOGameMode) == 0x000268, "Member 'UReadyOrNotGameUserSettings::DMOGameMode' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DMOTeamType) == 0x000278, "Member 'UReadyOrNotGameUserSettings::DMOTeamType' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, MirrorReflectionSettings) == 0x00027C, "Member 'UReadyOrNotGameUserSettings::MirrorReflectionSettings' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, NVGStyle) == 0x000284, "Member 'UReadyOrNotGameUserSettings::NVGStyle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bUseHighReadyStyle) == 0x000285, "Member 'UReadyOrNotGameUserSettings::bUseHighReadyStyle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bBounceLightEnabled) == 0x000286, "Member 'UReadyOrNotGameUserSettings::bBounceLightEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bFlashlightShadowsEnabled) == 0x000287, "Member 'UReadyOrNotGameUserSettings::bFlashlightShadowsEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bServerSideChecksum) == 0x000288, "Member 'UReadyOrNotGameUserSettings::bServerSideChecksum' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ReflexMode) == 0x000289, "Member 'UReadyOrNotGameUserSettings::ReflexMode' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bReflexGameToRenderLatencyInMSEnabled) == 0x00028A, "Member 'UReadyOrNotGameUserSettings::bReflexGameToRenderLatencyInMSEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bReflexGameLatencyInMSEnabled) == 0x00028B, "Member 'UReadyOrNotGameUserSettings::bReflexGameLatencyInMSEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bReflexRenderLatencyInMSEnabled) == 0x00028C, "Member 'UReadyOrNotGameUserSettings::bReflexRenderLatencyInMSEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bReflexFlashIndicatorEnabled) == 0x00028D, "Member 'UReadyOrNotGameUserSettings::bReflexFlashIndicatorEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ColorVisionDeficiency) == 0x00028E, "Member 'UReadyOrNotGameUserSettings::ColorVisionDeficiency' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ColorVisionDeficiencyStrength) == 0x000290, "Member 'UReadyOrNotGameUserSettings::ColorVisionDeficiencyStrength' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bHighlightWeapons) == 0x000294, "Member 'UReadyOrNotGameUserSettings::bHighlightWeapons' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bWorldSpaceActionPrompts) == 0x000295, "Member 'UReadyOrNotGameUserSettings::bWorldSpaceActionPrompts' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, InterfaceAspectRatio) == 0x000298, "Member 'UReadyOrNotGameUserSettings::InterfaceAspectRatio' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bEnableSubtitles) == 0x00029C, "Member 'UReadyOrNotGameUserSettings::bEnableSubtitles' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, SubtitlesSize) == 0x00029D, "Member 'UReadyOrNotGameUserSettings::SubtitlesSize' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, SubtitlesLocale) == 0x0002A0, "Member 'UReadyOrNotGameUserSettings::SubtitlesLocale' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, SubtitlesBackgroundOpacity) == 0x0002B0, "Member 'UReadyOrNotGameUserSettings::SubtitlesBackgroundOpacity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, SubtitlesSpeed) == 0x0002B4, "Member 'UReadyOrNotGameUserSettings::SubtitlesSpeed' has a wrong offset!");

// Class ReadyOrNot.Elevator
// 0x0068 (0x0288 - 0x0220)
class AElevator final  : public AActor
{
public:
	class USplineComponent*                       ElevatorPath;                                      // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveElevator;                                     // 0x0228(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCloseDoors;                                       // 0x0229(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261B[0x6];                                     // 0x022A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 ElevatorMesh;                                      // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    DestinationReachedSound;                           // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    FloorReachedSound;                                 // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    DoorOpenSoundFMOD;                                 // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    DoorCloseSoundFMOD;                                // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultElevatorLoc;                                // 0x0258(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Floors;                                            // 0x0264(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElevatorSpeed;                                     // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentFloor;                                      // 0x026C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveElevatorDelay;                                 // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261C[0x4];                                     // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           MoveElevatorDelay_Handle;                          // 0x0278(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedFloor;                                     // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261D[0x4];                                     // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_PlayDestinationReachedSound();
	void Multicast_PlayDoorCloseSound();
	void Multicast_PlayDoorOpenSound();
	void Multicast_PlayFloorReachedSound();
	void Server_OpenCloseDoors(bool bShouldCloseDoors);
	void Server_SetSelectedFloor(int32 Floor);
	void SetSelectedFloor(int32 Floor);
	void StartMovingElevator();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Elevator">();
	}
	static class AElevator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AElevator>();
	}
};
static_assert(alignof(AElevator) == 0x000008, "Wrong alignment on AElevator");
static_assert(sizeof(AElevator) == 0x000288, "Wrong size on AElevator");
static_assert(offsetof(AElevator, ElevatorPath) == 0x000220, "Member 'AElevator::ElevatorPath' has a wrong offset!");
static_assert(offsetof(AElevator, bMoveElevator) == 0x000228, "Member 'AElevator::bMoveElevator' has a wrong offset!");
static_assert(offsetof(AElevator, bCloseDoors) == 0x000229, "Member 'AElevator::bCloseDoors' has a wrong offset!");
static_assert(offsetof(AElevator, ElevatorMesh) == 0x000230, "Member 'AElevator::ElevatorMesh' has a wrong offset!");
static_assert(offsetof(AElevator, DestinationReachedSound) == 0x000238, "Member 'AElevator::DestinationReachedSound' has a wrong offset!");
static_assert(offsetof(AElevator, FloorReachedSound) == 0x000240, "Member 'AElevator::FloorReachedSound' has a wrong offset!");
static_assert(offsetof(AElevator, DoorOpenSoundFMOD) == 0x000248, "Member 'AElevator::DoorOpenSoundFMOD' has a wrong offset!");
static_assert(offsetof(AElevator, DoorCloseSoundFMOD) == 0x000250, "Member 'AElevator::DoorCloseSoundFMOD' has a wrong offset!");
static_assert(offsetof(AElevator, DefaultElevatorLoc) == 0x000258, "Member 'AElevator::DefaultElevatorLoc' has a wrong offset!");
static_assert(offsetof(AElevator, Floors) == 0x000264, "Member 'AElevator::Floors' has a wrong offset!");
static_assert(offsetof(AElevator, ElevatorSpeed) == 0x000268, "Member 'AElevator::ElevatorSpeed' has a wrong offset!");
static_assert(offsetof(AElevator, CurrentFloor) == 0x00026C, "Member 'AElevator::CurrentFloor' has a wrong offset!");
static_assert(offsetof(AElevator, MoveElevatorDelay) == 0x000270, "Member 'AElevator::MoveElevatorDelay' has a wrong offset!");
static_assert(offsetof(AElevator, MoveElevatorDelay_Handle) == 0x000278, "Member 'AElevator::MoveElevatorDelay_Handle' has a wrong offset!");
static_assert(offsetof(AElevator, SelectedFloor) == 0x000280, "Member 'AElevator::SelectedFloor' has a wrong offset!");

// Class ReadyOrNot.EngageTargetLessLethalActivity
// 0x0018 (0x01C0 - 0x01A8)
class UEngageTargetLessLethalActivity final  : public UBaseActivity
{
public:
	class AReadyOrNotCharacter*                   TargetCharacter;                                   // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261E[0x10];                                    // 0x01B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EngageTargetLessLethalActivity">();
	}
	static class UEngageTargetLessLethalActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEngageTargetLessLethalActivity>();
	}
};
static_assert(alignof(UEngageTargetLessLethalActivity) == 0x000008, "Wrong alignment on UEngageTargetLessLethalActivity");
static_assert(sizeof(UEngageTargetLessLethalActivity) == 0x0001C0, "Wrong size on UEngageTargetLessLethalActivity");
static_assert(offsetof(UEngageTargetLessLethalActivity, TargetCharacter) == 0x0001A8, "Member 'UEngageTargetLessLethalActivity::TargetCharacter' has a wrong offset!");

// Class ReadyOrNot.NavQuery_Swat
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_Swat : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_Swat">();
	}
	static class UNavQuery_Swat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_Swat>();
	}
};
static_assert(alignof(UNavQuery_Swat) == 0x000008, "Wrong alignment on UNavQuery_Swat");
static_assert(sizeof(UNavQuery_Swat) == 0x000048, "Wrong size on UNavQuery_Swat");

// Class ReadyOrNot.NavQuery_SwatDelta
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_SwatDelta final  : public UNavQuery_Swat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_SwatDelta">();
	}
	static class UNavQuery_SwatDelta* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_SwatDelta>();
	}
};
static_assert(alignof(UNavQuery_SwatDelta) == 0x000008, "Wrong alignment on UNavQuery_SwatDelta");
static_assert(sizeof(UNavQuery_SwatDelta) == 0x000048, "Wrong size on UNavQuery_SwatDelta");

// Class ReadyOrNot.EnvQueryContext_GasSafePoints
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_GasSafePoints final  : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_GasSafePoints">();
	}
	static class UEnvQueryContext_GasSafePoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_GasSafePoints>();
	}
};
static_assert(alignof(UEnvQueryContext_GasSafePoints) == 0x000008, "Wrong alignment on UEnvQueryContext_GasSafePoints");
static_assert(sizeof(UEnvQueryContext_GasSafePoints) == 0x000028, "Wrong size on UEnvQueryContext_GasSafePoints");

// Class ReadyOrNot.EnvQueryContext_NavProjectedQuerier
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_NavProjectedQuerier final  : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_NavProjectedQuerier">();
	}
	static class UEnvQueryContext_NavProjectedQuerier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_NavProjectedQuerier>();
	}
};
static_assert(alignof(UEnvQueryContext_NavProjectedQuerier) == 0x000008, "Wrong alignment on UEnvQueryContext_NavProjectedQuerier");
static_assert(sizeof(UEnvQueryContext_NavProjectedQuerier) == 0x000028, "Wrong size on UEnvQueryContext_NavProjectedQuerier");

// Class ReadyOrNot.EnvQueryGenerator_GasPoints
// 0x00B8 (0x0138 - 0x0080)
class UEnvQueryGenerator_GasPoints final  : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderFloatValue              GridRadius;                                        // 0x0080(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              SpaceBetween;                                      // 0x00B8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UNavigationQueryFilter>     NavigationFilter;                                  // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              SafePointsBufferDistance;                          // 0x0100(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_GasPoints">();
	}
	static class UEnvQueryGenerator_GasPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_GasPoints>();
	}
};
static_assert(alignof(UEnvQueryGenerator_GasPoints) == 0x000008, "Wrong alignment on UEnvQueryGenerator_GasPoints");
static_assert(sizeof(UEnvQueryGenerator_GasPoints) == 0x000138, "Wrong size on UEnvQueryGenerator_GasPoints");
static_assert(offsetof(UEnvQueryGenerator_GasPoints, GridRadius) == 0x000080, "Member 'UEnvQueryGenerator_GasPoints::GridRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_GasPoints, SpaceBetween) == 0x0000B8, "Member 'UEnvQueryGenerator_GasPoints::SpaceBetween' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_GasPoints, GenerateAround) == 0x0000F0, "Member 'UEnvQueryGenerator_GasPoints::GenerateAround' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_GasPoints, NavigationFilter) == 0x0000F8, "Member 'UEnvQueryGenerator_GasPoints::NavigationFilter' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_GasPoints, SafePointsBufferDistance) == 0x000100, "Member 'UEnvQueryGenerator_GasPoints::SafePointsBufferDistance' has a wrong offset!");

// Class ReadyOrNot.RescueAllOfTheCivilians
// 0x0010 (0x02B8 - 0x02A8)
class ARescueAllOfTheCivilians final  : public AObjective
{
public:
	uint8                                         Pad_261F[0x10];                                    // 0x02A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAISpawned();
	void OnCivilianKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RescueAllOfTheCivilians">();
	}
	static class ARescueAllOfTheCivilians* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARescueAllOfTheCivilians>();
	}
};
static_assert(alignof(ARescueAllOfTheCivilians) == 0x000008, "Wrong alignment on ARescueAllOfTheCivilians");
static_assert(sizeof(ARescueAllOfTheCivilians) == 0x0002B8, "Wrong size on ARescueAllOfTheCivilians");

// Class ReadyOrNot.EvidenceSpawnPoint
// 0x0018 (0x0250 - 0x0238)
class AEvidenceSpawnPoint final  : public AActorSpawnPoint
{
public:
	TSubclassOf<class AEvidenceActor>             EvidenceActorClass;                                // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASplineTrigger_Incrimination*           EvidenceSearchArea;                                // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingTrigger_Incrimination*         EvidenceBuilding;                                  // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvidenceSpawnPoint">();
	}
	static class AEvidenceSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEvidenceSpawnPoint>();
	}
};
static_assert(alignof(AEvidenceSpawnPoint) == 0x000008, "Wrong alignment on AEvidenceSpawnPoint");
static_assert(sizeof(AEvidenceSpawnPoint) == 0x000250, "Wrong size on AEvidenceSpawnPoint");
static_assert(offsetof(AEvidenceSpawnPoint, EvidenceActorClass) == 0x000238, "Member 'AEvidenceSpawnPoint::EvidenceActorClass' has a wrong offset!");
static_assert(offsetof(AEvidenceSpawnPoint, EvidenceSearchArea) == 0x000240, "Member 'AEvidenceSpawnPoint::EvidenceSearchArea' has a wrong offset!");
static_assert(offsetof(AEvidenceSpawnPoint, EvidenceBuilding) == 0x000248, "Member 'AEvidenceSpawnPoint::EvidenceBuilding' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotSpinTestController
// 0x0040 (0x0070 - 0x0030)
class UReadyOrNotSpinTestController final  : public UGauntletTestController
{
public:
	uint8                                         Pad_2620[0x40];                                    // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void On60FPSTick();
	void StartTesting();
	void StopProfiling();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotSpinTestController">();
	}
	static class UReadyOrNotSpinTestController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotSpinTestController>();
	}
};
static_assert(alignof(UReadyOrNotSpinTestController) == 0x000008, "Wrong alignment on UReadyOrNotSpinTestController");
static_assert(sizeof(UReadyOrNotSpinTestController) == 0x000070, "Wrong size on UReadyOrNotSpinTestController");

// Class ReadyOrNot.ExfilPortal
// 0x0050 (0x0270 - 0x0220)
class AExfilPortal : public AActor
{
public:
	uint8                                         Pad_2621[0x10];                                    // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 InteractableComponent;                             // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScoringComponent*                      ScoringComponent;                                  // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          CollisionComponent;                                // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ASWATCharacter*>                 OverlappingSwatMembers;                            // 0x0248(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           CompsToOutline;                                    // 0x0258(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2622[0x1];                                     // 0x0268(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowWarningDialogue;                              // 0x0269(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2623[0x6];                                     // 0x026A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActorBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void ActorEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void ExfiltrateMission();
	void MulticastEnableExfil(bool bEnable);
	void OnExfilEnabledChange(bool bEnabled);
	void OnExfilSwatMemberKilled(class AReadyOrNotCharacter* Killer, class AReadyOrNotCharacter* KilledMember);
	void OnMissionSoftComplete();
	void OnPlayerInteracted();
	void ServerTriggerExfil();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExfilPortal">();
	}
	static class AExfilPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExfilPortal>();
	}
};
static_assert(alignof(AExfilPortal) == 0x000008, "Wrong alignment on AExfilPortal");
static_assert(sizeof(AExfilPortal) == 0x000270, "Wrong size on AExfilPortal");
static_assert(offsetof(AExfilPortal, InteractableComponent) == 0x000230, "Member 'AExfilPortal::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AExfilPortal, ScoringComponent) == 0x000238, "Member 'AExfilPortal::ScoringComponent' has a wrong offset!");
static_assert(offsetof(AExfilPortal, CollisionComponent) == 0x000240, "Member 'AExfilPortal::CollisionComponent' has a wrong offset!");
static_assert(offsetof(AExfilPortal, OverlappingSwatMembers) == 0x000248, "Member 'AExfilPortal::OverlappingSwatMembers' has a wrong offset!");
static_assert(offsetof(AExfilPortal, CompsToOutline) == 0x000258, "Member 'AExfilPortal::CompsToOutline' has a wrong offset!");
static_assert(offsetof(AExfilPortal, bShowWarningDialogue) == 0x000269, "Member 'AExfilPortal::bShowWarningDialogue' has a wrong offset!");

// Class ReadyOrNot.ExplosiveContainer
// 0x0058 (0x0278 - 0x0220)
class AExplosiveContainer final  : public AActor
{
public:
	class UStaticMeshComponent*                   BaseMesh;                                          // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               FireEffectParticle;                                // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ExplosionEffectParticle;                           // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    FMODFireAudioComponent;                            // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2624[0x2];                                     // 0x0240(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHideMeshAfterDetonation;                          // 0x0242(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2625[0x5];                                     // 0x0243(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     ScorchDecal;                                       // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODExplosionAudio;                                // 0x0250(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UStunDamage>                StunDamageType;                                    // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        ExplosionScreenShake;                              // 0x0260(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            ExplosionInstigator;                               // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimerUntilExplosionOnceTriggered;                  // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDamageToTrigger;                                // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Multicast_PlayExplosionEffects();
	void Multicast_TriggerExplosive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplosiveContainer">();
	}
	static class AExplosiveContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExplosiveContainer>();
	}
};
static_assert(alignof(AExplosiveContainer) == 0x000008, "Wrong alignment on AExplosiveContainer");
static_assert(sizeof(AExplosiveContainer) == 0x000278, "Wrong size on AExplosiveContainer");
static_assert(offsetof(AExplosiveContainer, BaseMesh) == 0x000220, "Member 'AExplosiveContainer::BaseMesh' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, FireEffectParticle) == 0x000228, "Member 'AExplosiveContainer::FireEffectParticle' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, ExplosionEffectParticle) == 0x000230, "Member 'AExplosiveContainer::ExplosionEffectParticle' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, FMODFireAudioComponent) == 0x000238, "Member 'AExplosiveContainer::FMODFireAudioComponent' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, bHideMeshAfterDetonation) == 0x000242, "Member 'AExplosiveContainer::bHideMeshAfterDetonation' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, ScorchDecal) == 0x000248, "Member 'AExplosiveContainer::ScorchDecal' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, FMODExplosionAudio) == 0x000250, "Member 'AExplosiveContainer::FMODExplosionAudio' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, StunDamageType) == 0x000258, "Member 'AExplosiveContainer::StunDamageType' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, ExplosionScreenShake) == 0x000260, "Member 'AExplosiveContainer::ExplosionScreenShake' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, ExplosionInstigator) == 0x000268, "Member 'AExplosiveContainer::ExplosionInstigator' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, TimerUntilExplosionOnceTriggered) == 0x000270, "Member 'AExplosiveContainer::TimerUntilExplosionOnceTriggered' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, MinDamageToTrigger) == 0x000274, "Member 'AExplosiveContainer::MinDamageToTrigger' has a wrong offset!");

// Class ReadyOrNot.ExplosiveVest
// 0x0080 (0x0B50 - 0x0AD0)
class AExplosiveVest : public ASuspectArmour
{
public:
	uint8                                         Pad_2626[0x10];                                    // 0x0AD0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldExplodeOnHit;                               // 0x0AE0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldExplodeOnDeath;                             // 0x0AE1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2627[0x6];                                     // 0x0AE2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                ExplosionDamageType;                               // 0x0AE8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDamageOnDetonation;                             // 0x0AF0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDamageOnDetonation;                             // 0x0AF4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageInnerRadius;                                 // 0x0AF8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageOuterRadius;                                 // 0x0AFC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionEffectDelay;                              // 0x0B00(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionEffectRandomDelay;                        // 0x0B04(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionDamageDelay;                              // 0x0B08(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2628[0x4];                                     // 0x0B0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DetonationMontage;                                 // 0x0B10(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExplosiveVestSocket;                               // 0x0B20(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ExplosionParticle;                                 // 0x0B28(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ExplosionEvent;                                    // 0x0B30(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DetonationEvent;                                   // 0x0B38(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        ExplosionScreenShake;                              // 0x0B40(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionScreenShakeRadius;                        // 0x0B48(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2629[0x4];                                     // 0x0B4C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExplodeVest();
	void Multicast_PlayExplosionEffects();
	void Multicast_PlayPreExplosionEffects();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplosiveVest">();
	}
	static class AExplosiveVest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExplosiveVest>();
	}
};
static_assert(alignof(AExplosiveVest) == 0x000010, "Wrong alignment on AExplosiveVest");
static_assert(sizeof(AExplosiveVest) == 0x000B50, "Wrong size on AExplosiveVest");
static_assert(offsetof(AExplosiveVest, bShouldExplodeOnHit) == 0x000AE0, "Member 'AExplosiveVest::bShouldExplodeOnHit' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, bShouldExplodeOnDeath) == 0x000AE1, "Member 'AExplosiveVest::bShouldExplodeOnDeath' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosionDamageType) == 0x000AE8, "Member 'AExplosiveVest::ExplosionDamageType' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, MaxDamageOnDetonation) == 0x000AF0, "Member 'AExplosiveVest::MaxDamageOnDetonation' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, MinDamageOnDetonation) == 0x000AF4, "Member 'AExplosiveVest::MinDamageOnDetonation' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, DamageInnerRadius) == 0x000AF8, "Member 'AExplosiveVest::DamageInnerRadius' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, DamageOuterRadius) == 0x000AFC, "Member 'AExplosiveVest::DamageOuterRadius' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosionEffectDelay) == 0x000B00, "Member 'AExplosiveVest::ExplosionEffectDelay' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosionEffectRandomDelay) == 0x000B04, "Member 'AExplosiveVest::ExplosionEffectRandomDelay' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosionDamageDelay) == 0x000B08, "Member 'AExplosiveVest::ExplosionDamageDelay' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, DetonationMontage) == 0x000B10, "Member 'AExplosiveVest::DetonationMontage' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosiveVestSocket) == 0x000B20, "Member 'AExplosiveVest::ExplosiveVestSocket' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosionParticle) == 0x000B28, "Member 'AExplosiveVest::ExplosionParticle' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosionEvent) == 0x000B30, "Member 'AExplosiveVest::ExplosionEvent' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, DetonationEvent) == 0x000B38, "Member 'AExplosiveVest::DetonationEvent' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosionScreenShake) == 0x000B40, "Member 'AExplosiveVest::ExplosionScreenShake' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosionScreenShakeRadius) == 0x000B48, "Member 'AExplosiveVest::ExplosionScreenShakeRadius' has a wrong offset!");

// Class ReadyOrNot.FirefightGM
// 0x0060 (0x0830 - 0x07D0)
class AFirefightGM final  : public AReadyOrNotGameMode_PVP
{
public:
	bool                                          bSuddenDeath;                                      // 0x07D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_262A[0x7];                                     // 0x07D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             TeamKilledSound_SERT_RED;                          // 0x07D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             TeamKilledSound_SERT_BLUE;                         // 0x07E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchLoopMusic;                                    // 0x07E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchStartMusic;                                   // 0x07F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchEndMusic;                                     // 0x07F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSavedLoadout>                  RandomLoadouts;                                    // 0x0800(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedLoadout>                  GeneratedLoadouts;                                 // 0x0810(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumRedSpawned;                                     // 0x0820(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBlueSpawned;                                    // 0x0824(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_262B[0x8];                                     // 0x0828(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetNumberOfActivePlayersOnTeam(ETeamType Team);
	void RegenerateRandomLoadouts();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirefightGM">();
	}
	static class AFirefightGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFirefightGM>();
	}
};
static_assert(alignof(AFirefightGM) == 0x000010, "Wrong alignment on AFirefightGM");
static_assert(sizeof(AFirefightGM) == 0x000830, "Wrong size on AFirefightGM");
static_assert(offsetof(AFirefightGM, bSuddenDeath) == 0x0007D0, "Member 'AFirefightGM::bSuddenDeath' has a wrong offset!");
static_assert(offsetof(AFirefightGM, TeamKilledSound_SERT_RED) == 0x0007D8, "Member 'AFirefightGM::TeamKilledSound_SERT_RED' has a wrong offset!");
static_assert(offsetof(AFirefightGM, TeamKilledSound_SERT_BLUE) == 0x0007E0, "Member 'AFirefightGM::TeamKilledSound_SERT_BLUE' has a wrong offset!");
static_assert(offsetof(AFirefightGM, MatchLoopMusic) == 0x0007E8, "Member 'AFirefightGM::MatchLoopMusic' has a wrong offset!");
static_assert(offsetof(AFirefightGM, MatchStartMusic) == 0x0007F0, "Member 'AFirefightGM::MatchStartMusic' has a wrong offset!");
static_assert(offsetof(AFirefightGM, MatchEndMusic) == 0x0007F8, "Member 'AFirefightGM::MatchEndMusic' has a wrong offset!");
static_assert(offsetof(AFirefightGM, RandomLoadouts) == 0x000800, "Member 'AFirefightGM::RandomLoadouts' has a wrong offset!");
static_assert(offsetof(AFirefightGM, GeneratedLoadouts) == 0x000810, "Member 'AFirefightGM::GeneratedLoadouts' has a wrong offset!");
static_assert(offsetof(AFirefightGM, NumRedSpawned) == 0x000820, "Member 'AFirefightGM::NumRedSpawned' has a wrong offset!");
static_assert(offsetof(AFirefightGM, NumBlueSpawned) == 0x000824, "Member 'AFirefightGM::NumBlueSpawned' has a wrong offset!");

// Class ReadyOrNot.FireOnDroppedAnimNotify
// 0x0008 (0x0040 - 0x0038)
class UFireOnDroppedAnimNotify final  : public UAnimNotify
{
public:
	float                                         ChanceToFire;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262D[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireOnDroppedAnimNotify">();
	}
	static class UFireOnDroppedAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFireOnDroppedAnimNotify>();
	}
};
static_assert(alignof(UFireOnDroppedAnimNotify) == 0x000008, "Wrong alignment on UFireOnDroppedAnimNotify");
static_assert(sizeof(UFireOnDroppedAnimNotify) == 0x000040, "Wrong size on UFireOnDroppedAnimNotify");
static_assert(offsetof(UFireOnDroppedAnimNotify, ChanceToFire) == 0x000038, "Member 'UFireOnDroppedAnimNotify::ChanceToFire' has a wrong offset!");

// Class ReadyOrNot.ObjectiveMarkerWidget
// 0x0050 (0x02C8 - 0x0278)
class UObjectiveMarkerWidget : public UBaseWidget
{
public:
	class UObjectiveMarkerComponent*              ParentComponent;                                   // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           RootCanvasPanel;                                   // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               Icon_SizeBox;                                      // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Icon_Image;                                        // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DirectionalArrow_Image;                            // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DistanceInMeters_Text;                             // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MarkerName_Text;                                   // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Location;                                          // 0x02B0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceToLocalPlayer;                             // 0x02BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DirectionAngle;                                    // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHideDistance : 1;                                 // 0x02C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_262E[0x3];                                     // 0x02C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideAll();
	void HideIcon();
	void HideMarkerText();
	void OnMarkerVisibilityDisabled();
	void OnMarkerVisibilityEnabled();
	void SetDirectionAngle(float Angle);
	void SetIconColorAndOpacity(struct FLinearColor& InColor);
	void SetIconImage(struct FSlateBrush& InBrush);
	void SetIconSize(const struct FVector2D& NewIconSize);
	void SetMarkerNameText(class FText NewMarkerNameText);
	void SetMarkerNameTextColorAndOpacity(struct FLinearColor& InColor);
	void SetMarkerNameTextFontSize(int32 NewFontSize);
	void SetTargetLocation(const struct FVector& NewLocation);
	void ShowAll();
	void ShowIcon();
	void ShowMarkerText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveMarkerWidget">();
	}
	static class UObjectiveMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveMarkerWidget>();
	}
};
static_assert(alignof(UObjectiveMarkerWidget) == 0x000008, "Wrong alignment on UObjectiveMarkerWidget");
static_assert(sizeof(UObjectiveMarkerWidget) == 0x0002C8, "Wrong size on UObjectiveMarkerWidget");
static_assert(offsetof(UObjectiveMarkerWidget, ParentComponent) == 0x000278, "Member 'UObjectiveMarkerWidget::ParentComponent' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, RootCanvasPanel) == 0x000280, "Member 'UObjectiveMarkerWidget::RootCanvasPanel' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, Icon_SizeBox) == 0x000288, "Member 'UObjectiveMarkerWidget::Icon_SizeBox' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, Icon_Image) == 0x000290, "Member 'UObjectiveMarkerWidget::Icon_Image' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, DirectionalArrow_Image) == 0x000298, "Member 'UObjectiveMarkerWidget::DirectionalArrow_Image' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, DistanceInMeters_Text) == 0x0002A0, "Member 'UObjectiveMarkerWidget::DistanceInMeters_Text' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, MarkerName_Text) == 0x0002A8, "Member 'UObjectiveMarkerWidget::MarkerName_Text' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, Location) == 0x0002B0, "Member 'UObjectiveMarkerWidget::Location' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, DistanceToLocalPlayer) == 0x0002BC, "Member 'UObjectiveMarkerWidget::DistanceToLocalPlayer' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, DirectionAngle) == 0x0002C0, "Member 'UObjectiveMarkerWidget::DirectionAngle' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotPathFollowingComp
// 0x0038 (0x0288 - 0x0250)
class UReadyOrNotPathFollowingComp final  : public UPathFollowingComponent
{
public:
	float                                         HoleTraversalCooldown;                             // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262F[0x14];                                    // 0x0254(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  LastUsedDoorLink;                                  // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AWallHoleTraversal*                     LastUsedWallHole;                                  // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNavLinkCustomComponent*                LastUsedDoorLinkComp;                              // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2630[0x8];                                     // 0x0280(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHoleTraversalFinished(class UBaseActivity* Activity, class ACyberneticController* Controller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotPathFollowingComp">();
	}
	static class UReadyOrNotPathFollowingComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotPathFollowingComp>();
	}
};
static_assert(alignof(UReadyOrNotPathFollowingComp) == 0x000008, "Wrong alignment on UReadyOrNotPathFollowingComp");
static_assert(sizeof(UReadyOrNotPathFollowingComp) == 0x000288, "Wrong size on UReadyOrNotPathFollowingComp");
static_assert(offsetof(UReadyOrNotPathFollowingComp, HoleTraversalCooldown) == 0x000250, "Member 'UReadyOrNotPathFollowingComp::HoleTraversalCooldown' has a wrong offset!");
static_assert(offsetof(UReadyOrNotPathFollowingComp, LastUsedDoorLink) == 0x000268, "Member 'UReadyOrNotPathFollowingComp::LastUsedDoorLink' has a wrong offset!");
static_assert(offsetof(UReadyOrNotPathFollowingComp, LastUsedWallHole) == 0x000270, "Member 'UReadyOrNotPathFollowingComp::LastUsedWallHole' has a wrong offset!");
static_assert(offsetof(UReadyOrNotPathFollowingComp, LastUsedDoorLinkComp) == 0x000278, "Member 'UReadyOrNotPathFollowingComp::LastUsedDoorLinkComp' has a wrong offset!");

// Class ReadyOrNot.FlankingAvoidanceVolume
// 0x0010 (0x0230 - 0x0220)
class AFlankingAvoidanceVolume final  : public AActor
{
public:
	class UBoxComponent*                          Bounds;                                            // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNavModifierComponent*                  NavModifierComponent;                              // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlankingAvoidanceVolume">();
	}
	static class AFlankingAvoidanceVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlankingAvoidanceVolume>();
	}
};
static_assert(alignof(AFlankingAvoidanceVolume) == 0x000008, "Wrong alignment on AFlankingAvoidanceVolume");
static_assert(sizeof(AFlankingAvoidanceVolume) == 0x000230, "Wrong size on AFlankingAvoidanceVolume");
static_assert(offsetof(AFlankingAvoidanceVolume, Bounds) == 0x000220, "Member 'AFlankingAvoidanceVolume::Bounds' has a wrong offset!");
static_assert(offsetof(AFlankingAvoidanceVolume, NavModifierComponent) == 0x000228, "Member 'AFlankingAvoidanceVolume::NavModifierComponent' has a wrong offset!");

// Class ReadyOrNot.FlankingCombatMove
// 0x0048 (0x0220 - 0x01D8)
class UFlankingCombatMove final  : public UBaseCombatMoveActivity
{
public:
	class AReadyOrNotCharacter*                   FlankingAgainstCharacter;                          // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFlankingAvoidanceVolume*               FlankingAvoidanceVolume;                           // 0x01E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2631[0x38];                                    // 0x01E8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlankingCombatMove">();
	}
	static class UFlankingCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlankingCombatMove>();
	}
};
static_assert(alignof(UFlankingCombatMove) == 0x000008, "Wrong alignment on UFlankingCombatMove");
static_assert(sizeof(UFlankingCombatMove) == 0x000220, "Wrong size on UFlankingCombatMove");
static_assert(offsetof(UFlankingCombatMove, FlankingAgainstCharacter) == 0x0001D8, "Member 'UFlankingCombatMove::FlankingAgainstCharacter' has a wrong offset!");
static_assert(offsetof(UFlankingCombatMove, FlankingAvoidanceVolume) == 0x0001E0, "Member 'UFlankingCombatMove::FlankingAvoidanceVolume' has a wrong offset!");

// Class ReadyOrNot.FlashLightTrackingPoint
// 0x0038 (0x0258 - 0x0220)
class AFlashLightTrackingPoint final  : public AActor
{
public:
	uint8                                         Pad_2632[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsPrimary : 1;                                    // 0x0228(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2633[0x7];                                     // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   MeshComp;                                          // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIPerceptionStimuliSourceComponent*    PerceptionStimuliComp;                             // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ACyberneticController*>          SensedByControllers;                               // 0x0240(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2634[0x8];                                     // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashLightTrackingPoint">();
	}
	static class AFlashLightTrackingPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlashLightTrackingPoint>();
	}
};
static_assert(alignof(AFlashLightTrackingPoint) == 0x000008, "Wrong alignment on AFlashLightTrackingPoint");
static_assert(sizeof(AFlashLightTrackingPoint) == 0x000258, "Wrong size on AFlashLightTrackingPoint");
static_assert(offsetof(AFlashLightTrackingPoint, MeshComp) == 0x000230, "Member 'AFlashLightTrackingPoint::MeshComp' has a wrong offset!");
static_assert(offsetof(AFlashLightTrackingPoint, PerceptionStimuliComp) == 0x000238, "Member 'AFlashLightTrackingPoint::PerceptionStimuliComp' has a wrong offset!");
static_assert(offsetof(AFlashLightTrackingPoint, SensedByControllers) == 0x000240, "Member 'AFlashLightTrackingPoint::SensedByControllers' has a wrong offset!");

// Class ReadyOrNot.MoraleComponent
// 0x00B0 (0x01B8 - 0x0108)
class UMoraleComponent final  : public UResourceComponent
{
public:
	class ACyberneticCharacter*                   OwnerCharacter;                                    // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingMorale;                                    // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2635[0xA4];                                    // 0x0114(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ApplyRadialMoraleDamage(class UObject* WorldContextObject, const struct FVector& Location, float Damage, float Radius, const struct FMoraleDamageTraceParameters& LOSParameters, const TArray<ETeamType>& Teams, class FName Reason);
	static void ApplyRadialMoraleDamageWithFalloff(class UObject* WorldContextObject, const struct FVector& Location, float Damage, float InnerRadius, float OuterRadius, const struct FMoraleDamageTraceParameters& LOSParameters, const TArray<ETeamType>& Teams, EEasingFunc FalloffCurve, class FName Reason);
	static void IncreaseMoraleOnCharacter(class ACyberneticCharacter* Character, float MoraleValue, class FName Reason);
	static void LowerMoraleOnCharacter(class ACyberneticCharacter* Character, float MoraleValue, class FName Reason);
	static void ResetMoraleOnCharacter(class ACyberneticCharacter* Character);

	TMap<class FName, struct FMoraleChangeInfo> GetMoraleDamageHistory();
	TMap<class FName, struct FMoraleChangeInfo> GetMoraleGainHistory();

	float GetMorale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoraleComponent">();
	}
	static class UMoraleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoraleComponent>();
	}
};
static_assert(alignof(UMoraleComponent) == 0x000008, "Wrong alignment on UMoraleComponent");
static_assert(sizeof(UMoraleComponent) == 0x0001B8, "Wrong size on UMoraleComponent");
static_assert(offsetof(UMoraleComponent, OwnerCharacter) == 0x000108, "Member 'UMoraleComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UMoraleComponent, StartingMorale) == 0x000110, "Member 'UMoraleComponent::StartingMorale' has a wrong offset!");

// Class ReadyOrNot.MirrorUnderDoorActivity
// 0x0028 (0x0220 - 0x01F8)
class UMirrorUnderDoorActivity final  : public UDoorInteractionActivity
{
public:
	EMirrorContactType                            MirrorContactType;                                 // 0x01F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_263B[0x7];                                     // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACyberneticCharacter*>           SpottedCharacters;                                 // 0x0200(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_263C[0x10];                                    // 0x0210(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MirrorForCustom();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MirrorUnderDoorActivity">();
	}
	static class UMirrorUnderDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMirrorUnderDoorActivity>();
	}
};
static_assert(alignof(UMirrorUnderDoorActivity) == 0x000008, "Wrong alignment on UMirrorUnderDoorActivity");
static_assert(sizeof(UMirrorUnderDoorActivity) == 0x000220, "Wrong size on UMirrorUnderDoorActivity");
static_assert(offsetof(UMirrorUnderDoorActivity, MirrorContactType) == 0x0001F8, "Member 'UMirrorUnderDoorActivity::MirrorContactType' has a wrong offset!");
static_assert(offsetof(UMirrorUnderDoorActivity, SpottedCharacters) == 0x000200, "Member 'UMirrorUnderDoorActivity::SpottedCharacters' has a wrong offset!");

// Class ReadyOrNot.FMODAudioPropagationComponent
// 0x0040 (0x03D0 - 0x0390)
class UFMODAudioPropagationComponent final  : public UFMODAudioComponent
{
public:
	uint8                                         Pad_263D[0x18];                                    // 0x0390(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AudioPlayLocation;                                 // 0x03A8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VolumeToSet;                                       // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SilentDistance;                                    // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OcclusionAmount;                                   // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDistance;                                       // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayPropagation;                                  // 0x03C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_263E[0xB];                                     // 0x03C5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckOcclusion();
	struct FFMODEventInstance PlayEvent(class UFMODEvent* EventToPlay, const struct FVector& Origin, const TArray<struct FMODParam>& Params_0);
	void PlayEventAttached(class UFMODEvent* EventToPlay, class USceneComponent* CompToAttach, class FName AttachPoint, const TArray<struct FMODParam>& Params_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMODAudioPropagationComponent">();
	}
	static class UFMODAudioPropagationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMODAudioPropagationComponent>();
	}
};
static_assert(alignof(UFMODAudioPropagationComponent) == 0x000010, "Wrong alignment on UFMODAudioPropagationComponent");
static_assert(sizeof(UFMODAudioPropagationComponent) == 0x0003D0, "Wrong size on UFMODAudioPropagationComponent");
static_assert(offsetof(UFMODAudioPropagationComponent, AudioPlayLocation) == 0x0003A8, "Member 'UFMODAudioPropagationComponent::AudioPlayLocation' has a wrong offset!");
static_assert(offsetof(UFMODAudioPropagationComponent, VolumeToSet) == 0x0003B4, "Member 'UFMODAudioPropagationComponent::VolumeToSet' has a wrong offset!");
static_assert(offsetof(UFMODAudioPropagationComponent, SilentDistance) == 0x0003B8, "Member 'UFMODAudioPropagationComponent::SilentDistance' has a wrong offset!");
static_assert(offsetof(UFMODAudioPropagationComponent, OcclusionAmount) == 0x0003BC, "Member 'UFMODAudioPropagationComponent::OcclusionAmount' has a wrong offset!");
static_assert(offsetof(UFMODAudioPropagationComponent, MinDistance) == 0x0003C0, "Member 'UFMODAudioPropagationComponent::MinDistance' has a wrong offset!");
static_assert(offsetof(UFMODAudioPropagationComponent, bPlayPropagation) == 0x0003C4, "Member 'UFMODAudioPropagationComponent::bPlayPropagation' has a wrong offset!");

// Class ReadyOrNot.FootstepFoleyComponent
// 0x0010 (0x0490 - 0x0480)
class UFootstepFoleyComponent final  : public UBoxComponent
{
public:
	class UFMODEvent*                             SetEventTo;                                        // 0x0478(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SetEventToRemote;                                  // 0x0480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayOnPlayer;                                     // 0x0488(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayEveryStep;                                    // 0x0489(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2640[0x6];                                     // 0x048A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartedOverlapping(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void StoppedOverlapping(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepFoleyComponent">();
	}
	static class UFootstepFoleyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepFoleyComponent>();
	}
};
static_assert(alignof(UFootstepFoleyComponent) == 0x000010, "Wrong alignment on UFootstepFoleyComponent");
static_assert(sizeof(UFootstepFoleyComponent) == 0x000490, "Wrong size on UFootstepFoleyComponent");
static_assert(offsetof(UFootstepFoleyComponent, SetEventTo) == 0x000478, "Member 'UFootstepFoleyComponent::SetEventTo' has a wrong offset!");
static_assert(offsetof(UFootstepFoleyComponent, SetEventToRemote) == 0x000480, "Member 'UFootstepFoleyComponent::SetEventToRemote' has a wrong offset!");
static_assert(offsetof(UFootstepFoleyComponent, bPlayOnPlayer) == 0x000488, "Member 'UFootstepFoleyComponent::bPlayOnPlayer' has a wrong offset!");
static_assert(offsetof(UFootstepFoleyComponent, bPlayEveryStep) == 0x000489, "Member 'UFootstepFoleyComponent::bPlayEveryStep' has a wrong offset!");

// Class ReadyOrNot.PingActor
// 0x00B8 (0x02D8 - 0x0220)
class APingActor final  : public AActor
{
public:
	class AActor*                                 PingedActor;                                       // 0x0220(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            IconBrush;                                         // 0x0228(0x0088)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	class FText                                   PingText;                                          // 0x02B0(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	class UObjectiveMarkerComponent*              ObjectiveMarkerComponent;                          // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapActorComponent*                     MapActorComponent;                                 // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_SetIconBrush();
	void OnRep_SetPingText();
	void Setup(class AActor* InActor);

	void HideObjectiveMarker() const;
	void ShowObjectiveMarker() const;
	void ToggleObjectiveMarkerVisibility() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingActor">();
	}
	static class APingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APingActor>();
	}
};
static_assert(alignof(APingActor) == 0x000008, "Wrong alignment on APingActor");
static_assert(sizeof(APingActor) == 0x0002D8, "Wrong size on APingActor");
static_assert(offsetof(APingActor, PingedActor) == 0x000220, "Member 'APingActor::PingedActor' has a wrong offset!");
static_assert(offsetof(APingActor, IconBrush) == 0x000228, "Member 'APingActor::IconBrush' has a wrong offset!");
static_assert(offsetof(APingActor, PingText) == 0x0002B0, "Member 'APingActor::PingText' has a wrong offset!");
static_assert(offsetof(APingActor, ObjectiveMarkerComponent) == 0x0002C8, "Member 'APingActor::ObjectiveMarkerComponent' has a wrong offset!");
static_assert(offsetof(APingActor, MapActorComponent) == 0x0002D0, "Member 'APingActor::MapActorComponent' has a wrong offset!");

// Class ReadyOrNot.FootstepFoleyVolume
// 0x0018 (0x0270 - 0x0258)
class AFootstepFoleyVolume final  : public AVolume
{
public:
	class UFMODEvent*                             FootstepFoleyEvent;                                // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FootstepFoleyEventFirstPerson;                     // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNPCsTriggerFootstepFoley;                         // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2643[0x7];                                     // 0x0269(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepFoleyVolume">();
	}
	static class AFootstepFoleyVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFootstepFoleyVolume>();
	}
};
static_assert(alignof(AFootstepFoleyVolume) == 0x000008, "Wrong alignment on AFootstepFoleyVolume");
static_assert(sizeof(AFootstepFoleyVolume) == 0x000270, "Wrong size on AFootstepFoleyVolume");
static_assert(offsetof(AFootstepFoleyVolume, FootstepFoleyEvent) == 0x000258, "Member 'AFootstepFoleyVolume::FootstepFoleyEvent' has a wrong offset!");
static_assert(offsetof(AFootstepFoleyVolume, FootstepFoleyEventFirstPerson) == 0x000260, "Member 'AFootstepFoleyVolume::FootstepFoleyEventFirstPerson' has a wrong offset!");
static_assert(offsetof(AFootstepFoleyVolume, bNPCsTriggerFootstepFoley) == 0x000268, "Member 'AFootstepFoleyVolume::bNPCsTriggerFootstepFoley' has a wrong offset!");

// Class ReadyOrNot.FootstepImpactEffectsPool
// 0x0000 (0x00D0 - 0x00D0)
class UFootstepImpactEffectsPool : public UObjectPoolBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepImpactEffectsPool">();
	}
	static class UFootstepImpactEffectsPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepImpactEffectsPool>();
	}
};
static_assert(alignof(UFootstepImpactEffectsPool) == 0x000008, "Wrong alignment on UFootstepImpactEffectsPool");
static_assert(sizeof(UFootstepImpactEffectsPool) == 0x0000D0, "Wrong size on UFootstepImpactEffectsPool");

// Class ReadyOrNot.FootstepNativeAnimNotify
// 0x0000 (0x0038 - 0x0038)
class UFootstepNativeAnimNotify final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepNativeAnimNotify">();
	}
	static class UFootstepNativeAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepNativeAnimNotify>();
	}
};
static_assert(alignof(UFootstepNativeAnimNotify) == 0x000008, "Wrong alignment on UFootstepNativeAnimNotify");
static_assert(sizeof(UFootstepNativeAnimNotify) == 0x000038, "Wrong size on UFootstepNativeAnimNotify");

// Class ReadyOrNot.ForceLowReadyVolume
// 0x0008 (0x0260 - 0x0258)
class AForceLowReadyVolume final  : public AVolume
{
public:
	bool                                          bForceLowReadyWhileAimingAt;                       // 0x0258(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceLowReadyWhileInside;                         // 0x0259(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2644[0x6];                                     // 0x025A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceLowReadyVolume">();
	}
	static class AForceLowReadyVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AForceLowReadyVolume>();
	}
};
static_assert(alignof(AForceLowReadyVolume) == 0x000008, "Wrong alignment on AForceLowReadyVolume");
static_assert(sizeof(AForceLowReadyVolume) == 0x000260, "Wrong size on AForceLowReadyVolume");
static_assert(offsetof(AForceLowReadyVolume, bForceLowReadyWhileAimingAt) == 0x000258, "Member 'AForceLowReadyVolume::bForceLowReadyWhileAimingAt' has a wrong offset!");
static_assert(offsetof(AForceLowReadyVolume, bForceLowReadyWhileInside) == 0x000259, "Member 'AForceLowReadyVolume::bForceLowReadyWhileInside' has a wrong offset!");

// Class ReadyOrNot.FreeMode
// 0x0010 (0x0780 - 0x0770)
class AFreeMode final  : public AReadyOrNotGameMode
{
public:
	float                                         RespawnTime;                                       // 0x0770(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2645[0xC];                                     // 0x0774(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FreeMode">();
	}
	static class AFreeMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFreeMode>();
	}
};
static_assert(alignof(AFreeMode) == 0x000010, "Wrong alignment on AFreeMode");
static_assert(sizeof(AFreeMode) == 0x000780, "Wrong size on AFreeMode");
static_assert(offsetof(AFreeMode, RespawnTime) == 0x000770, "Member 'AFreeMode::RespawnTime' has a wrong offset!");

// Class ReadyOrNot.FriendsList
// 0x0040 (0x02A0 - 0x0260)
class UFriendsList : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FFriend>                        FriendsList;                                       // 0x0280(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2646[0x10];                                    // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FBPUniqueNetId CreateUniqueNetIdFromString(class FString& PlatformId);

	void GetFriendsList();
	void OnFriendsListUpdated__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendsList">();
	}
	static class UFriendsList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendsList>();
	}
};
static_assert(alignof(UFriendsList) == 0x000008, "Wrong alignment on UFriendsList");
static_assert(sizeof(UFriendsList) == 0x0002A0, "Wrong size on UFriendsList");
static_assert(offsetof(UFriendsList, OnSuccess) == 0x000260, "Member 'UFriendsList::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFriendsList, OnFailure) == 0x000270, "Member 'UFriendsList::OnFailure' has a wrong offset!");
static_assert(offsetof(UFriendsList, FriendsList) == 0x000280, "Member 'UFriendsList::FriendsList' has a wrong offset!");

// Class ReadyOrNot.GameFeatureLibrary
// 0x0000 (0x0028 - 0x0028)
class UGameFeatureLibrary final  : public UBlueprintFunctionLibrary
{
public:
	static bool IsFeatureEnabled(EGameFeature InFeature);
	static bool IsFullGame();
	static bool IsGameDemo();
	static bool IsGameVersionEnabled(EGameVersionRestriction InFeature);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeatureLibrary">();
	}
	static class UGameFeatureLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeatureLibrary>();
	}
};
static_assert(alignof(UGameFeatureLibrary) == 0x000008, "Wrong alignment on UGameFeatureLibrary");
static_assert(sizeof(UGameFeatureLibrary) == 0x000028, "Wrong size on UGameFeatureLibrary");

// Class ReadyOrNot.GamepadHelperLib
// 0x0000 (0x0028 - 0x0028)
class UGamepadHelperLib final  : public UBlueprintFunctionLibrary
{
public:
	static bool EnableCommonInputPreprocessing(class UWorld* World, bool Enable);
	static int32 GetActiveButton(int32 CurrentIndex, int32 NavigationDirection, const TArray<bool>& buttonAvailability);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamepadHelperLib">();
	}
	static class UGamepadHelperLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamepadHelperLib>();
	}
};
static_assert(alignof(UGamepadHelperLib) == 0x000008, "Wrong alignment on UGamepadHelperLib");
static_assert(sizeof(UGamepadHelperLib) == 0x000028, "Wrong size on UGamepadHelperLib");

// Class ReadyOrNot.GameplayConfig
// 0x0000 (0x0028 - 0x0028)
class UGameplayConfig : public UObject
{
public:
	bool GetBool(const class FString& ConfigKey, bool FallbackValue);
	float GetFloat(const class FString& ConfigKey, float FallbackValue);
	int32 GetInt(const class FString& ConfigKey, int32 FallbackValue);
	class FString GetString(const class FString& ConfigKey, const class FString& FallbackValue);
	TArray<class FString> GetStringArray(const class FString& ConfigKey, TArray<class FString>& FallbackValue);
	TArray<class FString> GetStringArray_SingleLine(const class FString& ConfigKey, TArray<class FString>& FallbackValue);
	struct FVector GetVector(const class FString& ConfigKey, struct FVector& FallbackValue);
	struct FVector2D GetVector2D(const class FString& ConfigKey, struct FVector2D& FallbackValue);
	void ReloadConfig();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayConfig">();
	}
	static class UGameplayConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayConfig>();
	}
};
static_assert(alignof(UGameplayConfig) == 0x000008, "Wrong alignment on UGameplayConfig");
static_assert(sizeof(UGameplayConfig) == 0x000028, "Wrong size on UGameplayConfig");

// Class ReadyOrNot.Pepperspray
// 0x0090 (0x0A60 - 0x09D0)
class APepperspray : public ABaseItem
{
public:
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x09D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264A[0x8];                                     // 0x09D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               SprayParticleComponent;                            // 0x09E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAmmoComponent*                         AmmoComponent;                                     // 0x09E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ParticleStart;                                     // 0x09F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ParticleEnd;                                       // 0x09F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ParticleImpact;                                    // 0x0A00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ParticleRunningOut;                                // 0x0A08(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ParticleSprayLoop;                                 // 0x0A10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ParticleSprayLoopComponent;                        // 0x0A18(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FMODSprayEvent;                                    // 0x0A20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FMODSprayEmptyEvent;                               // 0x0A28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FMODImpactEvent;                                   // 0x0A30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FMODSprayLowAmmoEvent;                             // 0x0A38(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprayDistance;                                     // 0x0A40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bSpraying : 1;                                     // 0x0A44(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_264B[0x3];                                     // 0x0A45(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationFrontTorso;                                // 0x0A48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DurationBackFace;                                  // 0x0A4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DurationFrontFace;                                 // 0x0A50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PepperSprayAbuseDebounce;                          // 0x0A54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_264C[0x8];                                     // 0x0A58(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDepletedPeppersprayAmmo();
	void OnLowPeppersprayAmmo(float CurrentResource);
	void OnRep_Spraying();
	void PlaySprayParticleEffect(bool bRunningOutEffect);
	void PlaySpraySoundEffect(bool bRunningOutEffect);
	void Server_StartSpraying();
	void Server_StopSpraying();
	void StartSpraying();
	void StopSpraying();
	void StopSprayParticleEffect();
	void StopSpraySoundEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Pepperspray">();
	}
	static class APepperspray* GetDefaultObj()
	{
		return GetDefaultObjImpl<APepperspray>();
	}
};
static_assert(alignof(APepperspray) == 0x000010, "Wrong alignment on APepperspray");
static_assert(sizeof(APepperspray) == 0x000A60, "Wrong size on APepperspray");
static_assert(offsetof(APepperspray, DamageType) == 0x0009D0, "Member 'APepperspray::DamageType' has a wrong offset!");
static_assert(offsetof(APepperspray, SprayParticleComponent) == 0x0009E0, "Member 'APepperspray::SprayParticleComponent' has a wrong offset!");
static_assert(offsetof(APepperspray, AmmoComponent) == 0x0009E8, "Member 'APepperspray::AmmoComponent' has a wrong offset!");
static_assert(offsetof(APepperspray, ParticleStart) == 0x0009F0, "Member 'APepperspray::ParticleStart' has a wrong offset!");
static_assert(offsetof(APepperspray, ParticleEnd) == 0x0009F8, "Member 'APepperspray::ParticleEnd' has a wrong offset!");
static_assert(offsetof(APepperspray, ParticleImpact) == 0x000A00, "Member 'APepperspray::ParticleImpact' has a wrong offset!");
static_assert(offsetof(APepperspray, ParticleRunningOut) == 0x000A08, "Member 'APepperspray::ParticleRunningOut' has a wrong offset!");
static_assert(offsetof(APepperspray, ParticleSprayLoop) == 0x000A10, "Member 'APepperspray::ParticleSprayLoop' has a wrong offset!");
static_assert(offsetof(APepperspray, ParticleSprayLoopComponent) == 0x000A18, "Member 'APepperspray::ParticleSprayLoopComponent' has a wrong offset!");
static_assert(offsetof(APepperspray, FMODSprayEvent) == 0x000A20, "Member 'APepperspray::FMODSprayEvent' has a wrong offset!");
static_assert(offsetof(APepperspray, FMODSprayEmptyEvent) == 0x000A28, "Member 'APepperspray::FMODSprayEmptyEvent' has a wrong offset!");
static_assert(offsetof(APepperspray, FMODImpactEvent) == 0x000A30, "Member 'APepperspray::FMODImpactEvent' has a wrong offset!");
static_assert(offsetof(APepperspray, FMODSprayLowAmmoEvent) == 0x000A38, "Member 'APepperspray::FMODSprayLowAmmoEvent' has a wrong offset!");
static_assert(offsetof(APepperspray, SprayDistance) == 0x000A40, "Member 'APepperspray::SprayDistance' has a wrong offset!");
static_assert(offsetof(APepperspray, DurationFrontTorso) == 0x000A48, "Member 'APepperspray::DurationFrontTorso' has a wrong offset!");
static_assert(offsetof(APepperspray, DurationBackFace) == 0x000A4C, "Member 'APepperspray::DurationBackFace' has a wrong offset!");
static_assert(offsetof(APepperspray, DurationFrontFace) == 0x000A50, "Member 'APepperspray::DurationFrontFace' has a wrong offset!");
static_assert(offsetof(APepperspray, PepperSprayAbuseDebounce) == 0x000A54, "Member 'APepperspray::PepperSprayAbuseDebounce' has a wrong offset!");

// Class ReadyOrNot.GasNavLinkGenerator
// 0x0008 (0x0228 - 0x0220)
class AGasNavLinkGenerator final  : public AActor
{
public:
	class UBillboardComponent*                    BillboardComponent;                                // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void GenerateNavLinks();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GasNavLinkGenerator">();
	}
	static class AGasNavLinkGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGasNavLinkGenerator>();
	}
};
static_assert(alignof(AGasNavLinkGenerator) == 0x000008, "Wrong alignment on AGasNavLinkGenerator");
static_assert(sizeof(AGasNavLinkGenerator) == 0x000228, "Wrong size on AGasNavLinkGenerator");
static_assert(offsetof(AGasNavLinkGenerator, BillboardComponent) == 0x000220, "Member 'AGasNavLinkGenerator::BillboardComponent' has a wrong offset!");

// Class ReadyOrNot.MusicManager
// 0x0018 (0x0048 - 0x0030)
class UMusicManager final  : public UWorldSubsystem
{
public:
	class UFMODEvent*                             MusicEvent;                                        // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFMODEventInstance                     MusicEventInst;                                    // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TH_UpdateMusicParameters;                          // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PauseMusicParametersUpdate();
	void ResumeMusicParametersUpdate();
	void SetMusicParameterValue(const class FString& ParamName, float ParamValue);
	void StartMusicParametersUpdate();
	void StopMusicParametersUpdate();
	void StopTheMusic(bool bGoHome);
	void UpdateMusicParameters();

	TArray<class FString> GetMusicParameters() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicManager">();
	}
	static class UMusicManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMusicManager>();
	}
};
static_assert(alignof(UMusicManager) == 0x000008, "Wrong alignment on UMusicManager");
static_assert(sizeof(UMusicManager) == 0x000048, "Wrong size on UMusicManager");
static_assert(offsetof(UMusicManager, MusicEvent) == 0x000030, "Member 'UMusicManager::MusicEvent' has a wrong offset!");
static_assert(offsetof(UMusicManager, MusicEventInst) == 0x000038, "Member 'UMusicManager::MusicEventInst' has a wrong offset!");
static_assert(offsetof(UMusicManager, TH_UpdateMusicParameters) == 0x000040, "Member 'UMusicManager::TH_UpdateMusicParameters' has a wrong offset!");

// Class ReadyOrNot.GasSource
// 0x0000 (0x0028 - 0x0028)
class IGasSource final  : public IInterface
{
public:
	float GetGasRadius() const;
	bool GetGasReleaseLocation(struct FVector* OutLocation) const;
	int32 GetMaximumGasPoints() const;
	bool IsReleasingGas() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GasSource">();
	}
	static class IGasSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGasSource>();
	}
};
static_assert(alignof(IGasSource) == 0x000008, "Wrong alignment on IGasSource");
static_assert(sizeof(IGasSource) == 0x000028, "Wrong size on IGasSource");

// Class ReadyOrNot.GatherDebugInterface
// 0x0000 (0x0028 - 0x0028)
class IGatherDebugInterface final  : public IInterface
{
public:
	void DrawVisualDebug();
	void GatherDebugData(TArray<struct FDebugData>* OutDebugData);
	void GatherDebugText(class FString* OutText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GatherDebugInterface">();
	}
	static class IGatherDebugInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGatherDebugInterface>();
	}
};
static_assert(alignof(IGatherDebugInterface) == 0x000008, "Wrong alignment on IGatherDebugInterface");
static_assert(sizeof(IGatherDebugInterface) == 0x000028, "Wrong size on IGatherDebugInterface");

// Class ReadyOrNot.PremissionStreetView
// 0x0060 (0x0280 - 0x0220)
class APremissionStreetView final  : public AActor
{
public:
	class UStaticMeshComponent*                   LeftBuildingMesh;                                  // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   RightBuildingMesh;                                 // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChildActorComponent*                   LeftTrafficLight;                                  // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChildActorComponent*                   RightTrafficLight;                                 // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArrowComponent*                        Direction;                                         // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStaticMesh*>                    Buildings;                                         // 0x0248(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             TrafficLights;                                     // 0x0258(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_264F[0xC];                                     // 0x0268(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpConstantSpeed;                               // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeUntilReset;                                    // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2650[0x4];                                     // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PremissionStreetView">();
	}
	static class APremissionStreetView* GetDefaultObj()
	{
		return GetDefaultObjImpl<APremissionStreetView>();
	}
};
static_assert(alignof(APremissionStreetView) == 0x000008, "Wrong alignment on APremissionStreetView");
static_assert(sizeof(APremissionStreetView) == 0x000280, "Wrong size on APremissionStreetView");
static_assert(offsetof(APremissionStreetView, LeftBuildingMesh) == 0x000220, "Member 'APremissionStreetView::LeftBuildingMesh' has a wrong offset!");
static_assert(offsetof(APremissionStreetView, RightBuildingMesh) == 0x000228, "Member 'APremissionStreetView::RightBuildingMesh' has a wrong offset!");
static_assert(offsetof(APremissionStreetView, LeftTrafficLight) == 0x000230, "Member 'APremissionStreetView::LeftTrafficLight' has a wrong offset!");
static_assert(offsetof(APremissionStreetView, RightTrafficLight) == 0x000238, "Member 'APremissionStreetView::RightTrafficLight' has a wrong offset!");
static_assert(offsetof(APremissionStreetView, Direction) == 0x000240, "Member 'APremissionStreetView::Direction' has a wrong offset!");
static_assert(offsetof(APremissionStreetView, Buildings) == 0x000248, "Member 'APremissionStreetView::Buildings' has a wrong offset!");
static_assert(offsetof(APremissionStreetView, TrafficLights) == 0x000258, "Member 'APremissionStreetView::TrafficLights' has a wrong offset!");
static_assert(offsetof(APremissionStreetView, InterpConstantSpeed) == 0x000274, "Member 'APremissionStreetView::InterpConstantSpeed' has a wrong offset!");
static_assert(offsetof(APremissionStreetView, TimeUntilReset) == 0x000278, "Member 'APremissionStreetView::TimeUntilReset' has a wrong offset!");

// Class ReadyOrNot.GetFriendlyName
// 0x0000 (0x0028 - 0x0028)
class IGetFriendlyName final  : public IInterface
{
public:
	class UTexture2D* GetFriendlyIcon();
	class FString GetFriendlyName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetFriendlyName">();
	}
	static class IGetFriendlyName* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGetFriendlyName>();
	}
};
static_assert(alignof(IGetFriendlyName) == 0x000008, "Wrong alignment on IGetFriendlyName");
static_assert(sizeof(IGetFriendlyName) == 0x000028, "Wrong size on IGetFriendlyName");

// Class ReadyOrNot.GibComponent
// 0x0070 (0x0120 - 0x00B0)
class UGibComponent final  : public UActorComponent
{
public:
	uint8                                         Pad_2651[0x18];                                    // 0x00B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGibAreas>                             GibbedAreas;                                       // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	class UBloodData*                             BloodData;                                         // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 BodyMesh;                                          // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 FaceMesh;                                          // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            GibHead;                                           // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            GibArms;                                           // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            GibLegs;                                           // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            BoneHead;                                          // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            BoneArms;                                          // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            BoneLegs;                                          // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GibComponent">();
	}
	static class UGibComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGibComponent>();
	}
};
static_assert(alignof(UGibComponent) == 0x000008, "Wrong alignment on UGibComponent");
static_assert(sizeof(UGibComponent) == 0x000120, "Wrong size on UGibComponent");
static_assert(offsetof(UGibComponent, GibbedAreas) == 0x0000C8, "Member 'UGibComponent::GibbedAreas' has a wrong offset!");
static_assert(offsetof(UGibComponent, BloodData) == 0x0000D8, "Member 'UGibComponent::BloodData' has a wrong offset!");
static_assert(offsetof(UGibComponent, BodyMesh) == 0x0000E0, "Member 'UGibComponent::BodyMesh' has a wrong offset!");
static_assert(offsetof(UGibComponent, FaceMesh) == 0x0000E8, "Member 'UGibComponent::FaceMesh' has a wrong offset!");
static_assert(offsetof(UGibComponent, GibHead) == 0x0000F0, "Member 'UGibComponent::GibHead' has a wrong offset!");
static_assert(offsetof(UGibComponent, GibArms) == 0x0000F8, "Member 'UGibComponent::GibArms' has a wrong offset!");
static_assert(offsetof(UGibComponent, GibLegs) == 0x000100, "Member 'UGibComponent::GibLegs' has a wrong offset!");
static_assert(offsetof(UGibComponent, BoneHead) == 0x000108, "Member 'UGibComponent::BoneHead' has a wrong offset!");
static_assert(offsetof(UGibComponent, BoneArms) == 0x000110, "Member 'UGibComponent::BoneArms' has a wrong offset!");
static_assert(offsetof(UGibComponent, BoneLegs) == 0x000118, "Member 'UGibComponent::BoneLegs' has a wrong offset!");

// Class ReadyOrNot.Multitool
// 0x0080 (0x0A70 - 0x09F0)
class AMultitool : public ATool
{
public:
	TMap<EMultitoolFunctions, class UReadyOrNotWeaponAnimData*> MultitoolAnimData;                                 // 0x09E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UInteractionsData*                      PvPFreeInteraction;                                // 0x0A38(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMultitoolFunctions                           CurrentToolKit;                                    // 0x0A40(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAudioBasedProgress : 1;                           // 0x0A41(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2652[0x6];                                     // 0x0A42(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             FMODLockpickingSound;                              // 0x0A48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODKnifeSound;                                    // 0x0A50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODWirecutterSound;                               // 0x0A58(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODFreeingSound;                                  // 0x0A60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       PendingFreeCharacter;                              // 0x0A68(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ChangeToolkit(EMultitoolFunctions MultitoolFunction, bool bPlayAnimation);
	void Client_ChangeToolkit(EMultitoolFunctions MultitoolFunction, bool bPlayAnimation);
	void Client_PlayMultitoolAudio();
	void Client_StopMultitoolAudio();

	float GetMultitoolOperatingTimeFromActiveToolkit() const;
	float GetMultitoolOperatingTimeFromAudioLength(class UFMODEvent* Event) const;
	float GetMultitoolOperatingTimeFromToolkit(EMultitoolFunctions MultitoolFunction) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Multitool">();
	}
	static class AMultitool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMultitool>();
	}
};
static_assert(alignof(AMultitool) == 0x000010, "Wrong alignment on AMultitool");
static_assert(sizeof(AMultitool) == 0x000A70, "Wrong size on AMultitool");
static_assert(offsetof(AMultitool, MultitoolAnimData) == 0x0009E8, "Member 'AMultitool::MultitoolAnimData' has a wrong offset!");
static_assert(offsetof(AMultitool, PvPFreeInteraction) == 0x000A38, "Member 'AMultitool::PvPFreeInteraction' has a wrong offset!");
static_assert(offsetof(AMultitool, CurrentToolKit) == 0x000A40, "Member 'AMultitool::CurrentToolKit' has a wrong offset!");
static_assert(offsetof(AMultitool, FMODLockpickingSound) == 0x000A48, "Member 'AMultitool::FMODLockpickingSound' has a wrong offset!");
static_assert(offsetof(AMultitool, FMODKnifeSound) == 0x000A50, "Member 'AMultitool::FMODKnifeSound' has a wrong offset!");
static_assert(offsetof(AMultitool, FMODWirecutterSound) == 0x000A58, "Member 'AMultitool::FMODWirecutterSound' has a wrong offset!");
static_assert(offsetof(AMultitool, FMODFreeingSound) == 0x000A60, "Member 'AMultitool::FMODFreeingSound' has a wrong offset!");
static_assert(offsetof(AMultitool, PendingFreeCharacter) == 0x000A68, "Member 'AMultitool::PendingFreeCharacter' has a wrong offset!");

// Class ReadyOrNot.GlassActor
// 0x0038 (0x0258 - 0x0220)
class AGlassActor final  : public AActor
{
public:
	class UDestructibleComponent*                 DestructibleWindow;                                // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              RandomGlassMaterial;                               // 0x0228(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              RandomShatteredGlassMaterial;                      // 0x0238(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnApplyDamageToWindow;                             // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class UMaterialInterface* GetRandomGlassMaterial();
	class UMaterialInterface* GetRandomShatteredGlassMaterial();
	void Multicast_ApplyDamageToWindow(float DamageAmount, const struct FVector& HitLocation, const struct FVector& ImpulseDir, float ImpulseStrength);
	void Multicast_TakeDamage(float DamageAmount, struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void OnApplyDamageToWindow__DelegateSignature(float DamageAmount, const struct FVector& HitLocation, const struct FVector& ImpulseDir, float ImpulseStrength);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlassActor">();
	}
	static class AGlassActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGlassActor>();
	}
};
static_assert(alignof(AGlassActor) == 0x000008, "Wrong alignment on AGlassActor");
static_assert(sizeof(AGlassActor) == 0x000258, "Wrong size on AGlassActor");
static_assert(offsetof(AGlassActor, DestructibleWindow) == 0x000220, "Member 'AGlassActor::DestructibleWindow' has a wrong offset!");
static_assert(offsetof(AGlassActor, RandomGlassMaterial) == 0x000228, "Member 'AGlassActor::RandomGlassMaterial' has a wrong offset!");
static_assert(offsetof(AGlassActor, RandomShatteredGlassMaterial) == 0x000238, "Member 'AGlassActor::RandomShatteredGlassMaterial' has a wrong offset!");
static_assert(offsetof(AGlassActor, OnApplyDamageToWindow) == 0x000248, "Member 'AGlassActor::OnApplyDamageToWindow' has a wrong offset!");

// Class ReadyOrNot.GrenadeLauncher
// 0x0240 (0x1670 - 0x1430)
class AGrenadeLauncher : public ABaseMagazineWeapon
{
public:
	TArray<class AGrenadeProjectile*>             AppliedGrenadeProjectilePaths;                     // 0x1430(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class AGrenadeProjectile*                     LastSimulatedGrenade;                              // 0x1440(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LaunchDistance;                                    // 0x1448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GrenadeBounciness;                                 // 0x144C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2656[0x8];                                     // 0x1450(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        BounceParticleEffect;                              // 0x1458(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             BounceFMODEvent;                                   // 0x1460(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        FirstBouncePath;                                   // 0x1468(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FHitResult                             FirstBounceHit;                                    // 0x1478(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2657[0x8];                                     // 0x1500(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        SecondBouncePath;                                  // 0x1508(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FHitResult                             SecondBounceHit;                                   // 0x1518(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2658[0x8];                                     // 0x15A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ThirdBouncePath;                                   // 0x15A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FHitResult                             ThirdBounceHit;                                    // 0x15B8(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2659[0x18];                                    // 0x1640(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BouncePt1;                                         // 0x1658(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BouncePt2;                                         // 0x165C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BouncePt3;                                         // 0x1660(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_265A[0xC];                                     // 0x1664(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateServerPath(TArray<struct FVector_NetQuantize>& Path, int32 Bounce1, int32 Bounce2, int32 Bounce3);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrenadeLauncher">();
	}
	static class AGrenadeLauncher* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGrenadeLauncher>();
	}
};
static_assert(alignof(AGrenadeLauncher) == 0x000010, "Wrong alignment on AGrenadeLauncher");
static_assert(sizeof(AGrenadeLauncher) == 0x001670, "Wrong size on AGrenadeLauncher");
static_assert(offsetof(AGrenadeLauncher, AppliedGrenadeProjectilePaths) == 0x001430, "Member 'AGrenadeLauncher::AppliedGrenadeProjectilePaths' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, LastSimulatedGrenade) == 0x001440, "Member 'AGrenadeLauncher::LastSimulatedGrenade' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, LaunchDistance) == 0x001448, "Member 'AGrenadeLauncher::LaunchDistance' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, GrenadeBounciness) == 0x00144C, "Member 'AGrenadeLauncher::GrenadeBounciness' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, BounceParticleEffect) == 0x001458, "Member 'AGrenadeLauncher::BounceParticleEffect' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, BounceFMODEvent) == 0x001460, "Member 'AGrenadeLauncher::BounceFMODEvent' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, FirstBouncePath) == 0x001468, "Member 'AGrenadeLauncher::FirstBouncePath' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, FirstBounceHit) == 0x001478, "Member 'AGrenadeLauncher::FirstBounceHit' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, SecondBouncePath) == 0x001508, "Member 'AGrenadeLauncher::SecondBouncePath' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, SecondBounceHit) == 0x001518, "Member 'AGrenadeLauncher::SecondBounceHit' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, ThirdBouncePath) == 0x0015A8, "Member 'AGrenadeLauncher::ThirdBouncePath' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, ThirdBounceHit) == 0x0015B8, "Member 'AGrenadeLauncher::ThirdBounceHit' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, BouncePt1) == 0x001658, "Member 'AGrenadeLauncher::BouncePt1' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, BouncePt2) == 0x00165C, "Member 'AGrenadeLauncher::BouncePt2' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, BouncePt3) == 0x001660, "Member 'AGrenadeLauncher::BouncePt3' has a wrong offset!");

// Class ReadyOrNot.GrenadeProjectile
// 0x00A0 (0x0408 - 0x0368)
class AGrenadeProjectile : public ABulletProjectile
{
public:
	class URadialForceComponent*                  DetonationRadialForce;                             // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGrenadeDetonated;                                // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_265C[0x4];                                     // 0x0380(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    ProjectileLocation;                                // 0x0384(0x000C)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetonationTime;                                    // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetonationBetweenTime;                             // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x0398(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DetonationCount;                                   // 0x039C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DetonationMax;                                     // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_265D[0x4];                                     // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGrenadeDamage>                 GrenadeDamage;                                     // 0x03A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIncreaseRadiusOverTime;                           // 0x03B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_265E[0x7];                                     // 0x03B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             DetonationSound;                                   // 0x03C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayDetonationSoundOnce : 1;                      // 0x03C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_265F[0x7];                                     // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        BounceLocations;                                   // 0x03D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDetonateOnValidation;                             // 0x03E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2660[0x3];                                     // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationRecordingRate;                             // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecordDistanceThreshold;                           // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2661[0x4];                                     // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        PastLocations;                                     // 0x03F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2662[0x8];                                     // 0x0400(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDetonate();
	void OnDetonate_Blueprint();
	void OnDetonationComplete_Blueprint();
	void OnProjectileDetonated__DelegateSignature(class AGrenadeProjectile* Projectile);
	void RecordLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrenadeProjectile">();
	}
	static class AGrenadeProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGrenadeProjectile>();
	}
};
static_assert(alignof(AGrenadeProjectile) == 0x000008, "Wrong alignment on AGrenadeProjectile");
static_assert(sizeof(AGrenadeProjectile) == 0x000408, "Wrong size on AGrenadeProjectile");
static_assert(offsetof(AGrenadeProjectile, DetonationRadialForce) == 0x000368, "Member 'AGrenadeProjectile::DetonationRadialForce' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, OnGrenadeDetonated) == 0x000370, "Member 'AGrenadeProjectile::OnGrenadeDetonated' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, ProjectileLocation) == 0x000384, "Member 'AGrenadeProjectile::ProjectileLocation' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, DetonationTime) == 0x000390, "Member 'AGrenadeProjectile::DetonationTime' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, DetonationBetweenTime) == 0x000394, "Member 'AGrenadeProjectile::DetonationBetweenTime' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, ElapsedTime) == 0x000398, "Member 'AGrenadeProjectile::ElapsedTime' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, DetonationCount) == 0x00039C, "Member 'AGrenadeProjectile::DetonationCount' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, DetonationMax) == 0x0003A0, "Member 'AGrenadeProjectile::DetonationMax' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, GrenadeDamage) == 0x0003A8, "Member 'AGrenadeProjectile::GrenadeDamage' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, bIncreaseRadiusOverTime) == 0x0003B8, "Member 'AGrenadeProjectile::bIncreaseRadiusOverTime' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, DetonationSound) == 0x0003C0, "Member 'AGrenadeProjectile::DetonationSound' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, BounceLocations) == 0x0003D0, "Member 'AGrenadeProjectile::BounceLocations' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, bDetonateOnValidation) == 0x0003E0, "Member 'AGrenadeProjectile::bDetonateOnValidation' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, LocationRecordingRate) == 0x0003E4, "Member 'AGrenadeProjectile::LocationRecordingRate' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, RecordDistanceThreshold) == 0x0003E8, "Member 'AGrenadeProjectile::RecordDistanceThreshold' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, PastLocations) == 0x0003F0, "Member 'AGrenadeProjectile::PastLocations' has a wrong offset!");

// Class ReadyOrNot.GunGameGM
// 0x01B0 (0x0980 - 0x07D0)
class AGunGameGM final  : public AReadyOrNotGameMode_PVP
{
public:
	float                                         RespawnTime;                                       // 0x07D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuddenDeath;                                      // 0x07D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2663[0x3];                                     // 0x07D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           ItemList;                                          // 0x07D8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FSavedLoadout                          DefaultItems;                                      // 0x07E8(0x0188)(Edit, NativeAccessSpecifierPublic)
	int32                                         KillsToProgress;                                   // 0x0970(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2664[0xC];                                     // 0x0974(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ABaseItem* EquipNextGun(class APlayerCharacter* Player, bool bAdvanceGunIdx);
	TArray<class AReadyOrNotPlayerState*> FindTopKillers();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunGameGM">();
	}
	static class AGunGameGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGunGameGM>();
	}
};
static_assert(alignof(AGunGameGM) == 0x000010, "Wrong alignment on AGunGameGM");
static_assert(sizeof(AGunGameGM) == 0x000980, "Wrong size on AGunGameGM");
static_assert(offsetof(AGunGameGM, RespawnTime) == 0x0007D0, "Member 'AGunGameGM::RespawnTime' has a wrong offset!");
static_assert(offsetof(AGunGameGM, bSuddenDeath) == 0x0007D4, "Member 'AGunGameGM::bSuddenDeath' has a wrong offset!");
static_assert(offsetof(AGunGameGM, ItemList) == 0x0007D8, "Member 'AGunGameGM::ItemList' has a wrong offset!");
static_assert(offsetof(AGunGameGM, DefaultItems) == 0x0007E8, "Member 'AGunGameGM::DefaultItems' has a wrong offset!");
static_assert(offsetof(AGunGameGM, KillsToProgress) == 0x000970, "Member 'AGunGameGM::KillsToProgress' has a wrong offset!");

// Class ReadyOrNot.GunGameGS
// 0x0000 (0x07E0 - 0x07E0)
class AGunGameGS final  : public AReadyOrNotGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunGameGS">();
	}
	static class AGunGameGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGunGameGS>();
	}
};
static_assert(alignof(AGunGameGS) == 0x000008, "Wrong alignment on AGunGameGS");
static_assert(sizeof(AGunGameGS) == 0x0007E0, "Wrong size on AGunGameGS");

// Class ReadyOrNot.HardcoreMoneyGM
// 0x0000 (0x0A50 - 0x0A50)
class AHardcoreMoneyGM final  : public ACoopGM
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HardcoreMoneyGM">();
	}
	static class AHardcoreMoneyGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHardcoreMoneyGM>();
	}
};
static_assert(alignof(AHardcoreMoneyGM) == 0x000010, "Wrong alignment on AHardcoreMoneyGM");
static_assert(sizeof(AHardcoreMoneyGM) == 0x000A50, "Wrong size on AHardcoreMoneyGM");

// Class ReadyOrNot.HardcoreMoneyGS
// 0x0000 (0x08E0 - 0x08E0)
class AHardcoreMoneyGS final  : public ACoopGS
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HardcoreMoneyGS">();
	}
	static class AHardcoreMoneyGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHardcoreMoneyGS>();
	}
};
static_assert(alignof(AHardcoreMoneyGS) == 0x000008, "Wrong alignment on AHardcoreMoneyGS");
static_assert(sizeof(AHardcoreMoneyGS) == 0x0008E0, "Wrong size on AHardcoreMoneyGS");

// Class ReadyOrNot.SpawnSkeletalMeshAnimNotifyState
// 0x0080 (0x00B0 - 0x0030)
class USpawnSkeletalMeshAnimNotifyState final  : public UAnimNotifyState
{
public:
	class USkeletalMesh*                          SkeletalMeshToSpawn;                               // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        PlayAnimation;                                     // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             MeshTransform;                                     // 0x0040(0x0030)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableWeaponFOVShader;                            // 0x0070(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyOwnerSee;                                     // 0x0071(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOwnerNoSee;                                       // 0x0072(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2666[0x1];                                     // 0x0073(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneToSpawnOn;                                     // 0x0074(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2667[0x10];                                    // 0x007C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDestroyAtEnd;                                     // 0x008C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulatePhysicsAtEnd;                             // 0x008D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2668[0x2];                                     // 0x008E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ForceVector;                                       // 0x0090(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2669[0x4];                                     // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASkeletalMeshActor*                     SkeletalMeshActor;                                 // 0x00A0(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_266A[0x8];                                     // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnSkeletalMeshAnimNotifyState">();
	}
	static class USpawnSkeletalMeshAnimNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnSkeletalMeshAnimNotifyState>();
	}
};
static_assert(alignof(USpawnSkeletalMeshAnimNotifyState) == 0x000010, "Wrong alignment on USpawnSkeletalMeshAnimNotifyState");
static_assert(sizeof(USpawnSkeletalMeshAnimNotifyState) == 0x0000B0, "Wrong size on USpawnSkeletalMeshAnimNotifyState");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, SkeletalMeshToSpawn) == 0x000030, "Member 'USpawnSkeletalMeshAnimNotifyState::SkeletalMeshToSpawn' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, PlayAnimation) == 0x000038, "Member 'USpawnSkeletalMeshAnimNotifyState::PlayAnimation' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, MeshTransform) == 0x000040, "Member 'USpawnSkeletalMeshAnimNotifyState::MeshTransform' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, bEnableWeaponFOVShader) == 0x000070, "Member 'USpawnSkeletalMeshAnimNotifyState::bEnableWeaponFOVShader' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, bOnlyOwnerSee) == 0x000071, "Member 'USpawnSkeletalMeshAnimNotifyState::bOnlyOwnerSee' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, bOwnerNoSee) == 0x000072, "Member 'USpawnSkeletalMeshAnimNotifyState::bOwnerNoSee' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, BoneToSpawnOn) == 0x000074, "Member 'USpawnSkeletalMeshAnimNotifyState::BoneToSpawnOn' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, bDestroyAtEnd) == 0x00008C, "Member 'USpawnSkeletalMeshAnimNotifyState::bDestroyAtEnd' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, bSimulatePhysicsAtEnd) == 0x00008D, "Member 'USpawnSkeletalMeshAnimNotifyState::bSimulatePhysicsAtEnd' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, ForceVector) == 0x000090, "Member 'USpawnSkeletalMeshAnimNotifyState::ForceVector' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, SkeletalMeshActor) == 0x0000A0, "Member 'USpawnSkeletalMeshAnimNotifyState::SkeletalMeshActor' has a wrong offset!");

// Class ReadyOrNot.HardCoverCombatMove
// 0x02D8 (0x04B0 - 0x01D8)
class UHardCoverCombatMove final  : public UBaseCombatMoveActivity
{
public:
	uint8                                         Pad_266B[0x78];                                    // 0x01D8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UTakeCoverActivity*                     TakeCoverActivity;                                 // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTakeCoverAtLandmarkActivity*           TakeCoverAtLandmarkActivity;                       // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_266C[0x1A8];                                   // 0x0260(0x01A8)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   LastTrackedEnemy;                                  // 0x0408(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCoverInstigatorStimulus               LastCoverInstigatorStimulus;                       // 0x0410(0x0050)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCoverInstigatorStimulus               PendingCoverInstigatorStimulus;                    // 0x0460(0x0050)(NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void CoverEventDelegate__DelegateSignature();
	void CoverFoundDelegate__DelegateSignature();
	void OnTakeCoverActivityFinished(class UBaseActivity* Activity, class ACyberneticController* Controller);
	void OnTakeCoverAtLandmarkActivityFinished(class UBaseActivity* Activity, class ACyberneticController* Controller);
	void TrackNewEnemy(class AReadyOrNotCharacter* NewTrackedEnemy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HardCoverCombatMove">();
	}
	static class UHardCoverCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHardCoverCombatMove>();
	}
};
static_assert(alignof(UHardCoverCombatMove) == 0x000010, "Wrong alignment on UHardCoverCombatMove");
static_assert(sizeof(UHardCoverCombatMove) == 0x0004B0, "Wrong size on UHardCoverCombatMove");
static_assert(offsetof(UHardCoverCombatMove, TakeCoverActivity) == 0x000250, "Member 'UHardCoverCombatMove::TakeCoverActivity' has a wrong offset!");
static_assert(offsetof(UHardCoverCombatMove, TakeCoverAtLandmarkActivity) == 0x000258, "Member 'UHardCoverCombatMove::TakeCoverAtLandmarkActivity' has a wrong offset!");
static_assert(offsetof(UHardCoverCombatMove, LastTrackedEnemy) == 0x000408, "Member 'UHardCoverCombatMove::LastTrackedEnemy' has a wrong offset!");
static_assert(offsetof(UHardCoverCombatMove, LastCoverInstigatorStimulus) == 0x000410, "Member 'UHardCoverCombatMove::LastCoverInstigatorStimulus' has a wrong offset!");
static_assert(offsetof(UHardCoverCombatMove, PendingCoverInstigatorStimulus) == 0x000460, "Member 'UHardCoverCombatMove::PendingCoverInstigatorStimulus' has a wrong offset!");

// Class ReadyOrNot.HealthStatusWidget
// 0x0140 (0x03A0 - 0x0260)
class UHealthStatusWidget final  : public UUserWidget
{
public:
	class UImage*                                 Icon_Image;                                        // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Percentage_Text;                                   // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            HealthIconBrush;                                   // 0x0270(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	struct FSlateBrush                            EmptyHealthIconBrush;                              // 0x02F8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	struct FLinearColor                           ZeroPercentColor;                                  // 0x0380(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           OneHundredPercentColor;                            // 0x0390(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AutoDetermineIconImage();
	void UpdateHealthPercentage(float CurrentValue, float MaxValue);
	void UpdateIconColor(float CurrentValue, float MinValue, float MaxValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthStatusWidget">();
	}
	static class UHealthStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthStatusWidget>();
	}
};
static_assert(alignof(UHealthStatusWidget) == 0x000008, "Wrong alignment on UHealthStatusWidget");
static_assert(sizeof(UHealthStatusWidget) == 0x0003A0, "Wrong size on UHealthStatusWidget");
static_assert(offsetof(UHealthStatusWidget, Icon_Image) == 0x000260, "Member 'UHealthStatusWidget::Icon_Image' has a wrong offset!");
static_assert(offsetof(UHealthStatusWidget, Percentage_Text) == 0x000268, "Member 'UHealthStatusWidget::Percentage_Text' has a wrong offset!");
static_assert(offsetof(UHealthStatusWidget, HealthIconBrush) == 0x000270, "Member 'UHealthStatusWidget::HealthIconBrush' has a wrong offset!");
static_assert(offsetof(UHealthStatusWidget, EmptyHealthIconBrush) == 0x0002F8, "Member 'UHealthStatusWidget::EmptyHealthIconBrush' has a wrong offset!");
static_assert(offsetof(UHealthStatusWidget, ZeroPercentColor) == 0x000380, "Member 'UHealthStatusWidget::ZeroPercentColor' has a wrong offset!");
static_assert(offsetof(UHealthStatusWidget, OneHundredPercentColor) == 0x000390, "Member 'UHealthStatusWidget::OneHundredPercentColor' has a wrong offset!");

// Class ReadyOrNot.HideCursorWidget
// 0x0000 (0x0260 - 0x0260)
class UHideCursorWidget final  : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HideCursorWidget">();
	}
	static class UHideCursorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHideCursorWidget>();
	}
};
static_assert(alignof(UHideCursorWidget) == 0x000008, "Wrong alignment on UHideCursorWidget");
static_assert(sizeof(UHideCursorWidget) == 0x000260, "Wrong size on UHideCursorWidget");

// Class ReadyOrNot.RoNAnimInstance_PlayerFP
// 0x0090 (0x04F0 - 0x0460)
class URoNAnimInstance_PlayerFP : public UReadyOrNotAnimInstance
{
public:
	class UReadyOrNotWeaponAnimData*              LastWeaponAnimData;                                // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotWeaponAnimData*              EditorWeaponAnimData;                              // 0x0468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAngleY;                                        // 0x0470(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAngleZ;                                        // 0x0474(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MeshControlRotation;                               // 0x0478(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                MeshPostureLeanOffset;                             // 0x0484(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MeshWeaponOffset;                                  // 0x0490(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MeshWeaponRotation;                                // 0x049C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               MeshWeaponFreeAimRotation;                         // 0x04A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                MeshWeaponLeanOffset;                              // 0x04B4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MeshWeaponLeanRotation;                            // 0x04C0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_266D[0x4];                                     // 0x04CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 TPMeshReference;                                   // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LazySpringStrength;                                // 0x04D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADS_Movement_Weight;                               // 0x04DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionSlotAlpha;                              // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultSlotAlpha;                                  // 0x04E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollMoveInput;                                     // 0x04E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_266E[0x4];                                     // 0x04EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnC2Detonation();
	void OnHolsterComplete();
	void OnReloadComplete();

	class UAnimSequenceBase* GetPlayerAnimation_FP(EBaseAnimType_FP AnimName) const;
	class UBlendSpaceBase* GetPlayerBlendspace_FP(EBaseBlendspaces_FP BlendspaceName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoNAnimInstance_PlayerFP">();
	}
	static class URoNAnimInstance_PlayerFP* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoNAnimInstance_PlayerFP>();
	}
};
static_assert(alignof(URoNAnimInstance_PlayerFP) == 0x000010, "Wrong alignment on URoNAnimInstance_PlayerFP");
static_assert(sizeof(URoNAnimInstance_PlayerFP) == 0x0004F0, "Wrong size on URoNAnimInstance_PlayerFP");
static_assert(offsetof(URoNAnimInstance_PlayerFP, LastWeaponAnimData) == 0x000460, "Member 'URoNAnimInstance_PlayerFP::LastWeaponAnimData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, EditorWeaponAnimData) == 0x000468, "Member 'URoNAnimInstance_PlayerFP::EditorWeaponAnimData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, LeanAngleY) == 0x000470, "Member 'URoNAnimInstance_PlayerFP::LeanAngleY' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, LeanAngleZ) == 0x000474, "Member 'URoNAnimInstance_PlayerFP::LeanAngleZ' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, MeshControlRotation) == 0x000478, "Member 'URoNAnimInstance_PlayerFP::MeshControlRotation' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, MeshPostureLeanOffset) == 0x000484, "Member 'URoNAnimInstance_PlayerFP::MeshPostureLeanOffset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, MeshWeaponOffset) == 0x000490, "Member 'URoNAnimInstance_PlayerFP::MeshWeaponOffset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, MeshWeaponRotation) == 0x00049C, "Member 'URoNAnimInstance_PlayerFP::MeshWeaponRotation' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, MeshWeaponFreeAimRotation) == 0x0004A8, "Member 'URoNAnimInstance_PlayerFP::MeshWeaponFreeAimRotation' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, MeshWeaponLeanOffset) == 0x0004B4, "Member 'URoNAnimInstance_PlayerFP::MeshWeaponLeanOffset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, MeshWeaponLeanRotation) == 0x0004C0, "Member 'URoNAnimInstance_PlayerFP::MeshWeaponLeanRotation' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, TPMeshReference) == 0x0004D0, "Member 'URoNAnimInstance_PlayerFP::TPMeshReference' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, LazySpringStrength) == 0x0004D8, "Member 'URoNAnimInstance_PlayerFP::LazySpringStrength' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, ADS_Movement_Weight) == 0x0004DC, "Member 'URoNAnimInstance_PlayerFP::ADS_Movement_Weight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, InteractionSlotAlpha) == 0x0004E0, "Member 'URoNAnimInstance_PlayerFP::InteractionSlotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, DefaultSlotAlpha) == 0x0004E4, "Member 'URoNAnimInstance_PlayerFP::DefaultSlotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, RollMoveInput) == 0x0004E8, "Member 'URoNAnimInstance_PlayerFP::RollMoveInput' has a wrong offset!");

// Class ReadyOrNot.HighgroundVolume
// 0x0070 (0x0290 - 0x0220)
class AHighgroundVolume final  : public AActor
{
public:
	uint8                                         Pad_2671[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AudioDebounce;                                     // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2672[0x4];                                     // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          Bounds;                                            // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        AudioComp;                                         // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWatching;                                         // 0x0240(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2673[0x3];                                     // 0x0241(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SierraDesignation;                                 // 0x0244(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VolumeLabel;                                       // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     ContactEnteredVolumeAudio;                         // 0x0250(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     ContactExitedVolumeAudio;                          // 0x0260(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     SwatEnteredVolumeAudio;                            // 0x0270(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     SwatExitedVolumeAudio;                             // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void OnAudioFinished();
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HighgroundVolume">();
	}
	static class AHighgroundVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHighgroundVolume>();
	}
};
static_assert(alignof(AHighgroundVolume) == 0x000008, "Wrong alignment on AHighgroundVolume");
static_assert(sizeof(AHighgroundVolume) == 0x000290, "Wrong size on AHighgroundVolume");
static_assert(offsetof(AHighgroundVolume, AudioDebounce) == 0x000228, "Member 'AHighgroundVolume::AudioDebounce' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, Bounds) == 0x000230, "Member 'AHighgroundVolume::Bounds' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, AudioComp) == 0x000238, "Member 'AHighgroundVolume::AudioComp' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, bWatching) == 0x000240, "Member 'AHighgroundVolume::bWatching' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, SierraDesignation) == 0x000244, "Member 'AHighgroundVolume::SierraDesignation' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, VolumeLabel) == 0x000248, "Member 'AHighgroundVolume::VolumeLabel' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, ContactEnteredVolumeAudio) == 0x000250, "Member 'AHighgroundVolume::ContactEnteredVolumeAudio' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, ContactExitedVolumeAudio) == 0x000260, "Member 'AHighgroundVolume::ContactExitedVolumeAudio' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, SwatEnteredVolumeAudio) == 0x000270, "Member 'AHighgroundVolume::SwatEnteredVolumeAudio' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, SwatExitedVolumeAudio) == 0x000280, "Member 'AHighgroundVolume::SwatExitedVolumeAudio' has a wrong offset!");

// Class ReadyOrNot.HitRegistrationSettings
// 0x0020 (0x0058 - 0x0038)
class UHitRegistrationSettings final  : public UDeveloperSettings
{
public:
	bool                                          bEnableValidation;                                 // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2676[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitscanForgiveness;                                // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShooterForgiveness;                                // 0x0040(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDistanceForgiveness;                          // 0x0044(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapshotVelocityFactor;                            // 0x0048(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MinimumSnapshotExtent;                             // 0x004C(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitRegistrationSettings">();
	}
	static class UHitRegistrationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitRegistrationSettings>();
	}
};
static_assert(alignof(UHitRegistrationSettings) == 0x000008, "Wrong alignment on UHitRegistrationSettings");
static_assert(sizeof(UHitRegistrationSettings) == 0x000058, "Wrong size on UHitRegistrationSettings");
static_assert(offsetof(UHitRegistrationSettings, bEnableValidation) == 0x000038, "Member 'UHitRegistrationSettings::bEnableValidation' has a wrong offset!");
static_assert(offsetof(UHitRegistrationSettings, HitscanForgiveness) == 0x00003C, "Member 'UHitRegistrationSettings::HitscanForgiveness' has a wrong offset!");
static_assert(offsetof(UHitRegistrationSettings, ShooterForgiveness) == 0x000040, "Member 'UHitRegistrationSettings::ShooterForgiveness' has a wrong offset!");
static_assert(offsetof(UHitRegistrationSettings, TraceDistanceForgiveness) == 0x000044, "Member 'UHitRegistrationSettings::TraceDistanceForgiveness' has a wrong offset!");
static_assert(offsetof(UHitRegistrationSettings, SnapshotVelocityFactor) == 0x000048, "Member 'UHitRegistrationSettings::SnapshotVelocityFactor' has a wrong offset!");
static_assert(offsetof(UHitRegistrationSettings, MinimumSnapshotExtent) == 0x00004C, "Member 'UHitRegistrationSettings::MinimumSnapshotExtent' has a wrong offset!");

// Class ReadyOrNot.HoldActivity
// 0x0010 (0x01C8 - 0x01B8)
class UHoldActivity final  : public UTeamBaseActivity
{
public:
	uint8                                         Pad_2677[0x10];                                    // 0x01B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoldActivity">();
	}
	static class UHoldActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoldActivity>();
	}
};
static_assert(alignof(UHoldActivity) == 0x000008, "Wrong alignment on UHoldActivity");
static_assert(sizeof(UHoldActivity) == 0x0001C8, "Wrong size on UHoldActivity");

// Class ReadyOrNot.PepperballDamageType
// 0x0010 (0x0630 - 0x0620)
class UPepperballDamageType : public UStunDamage
{
public:
	float                                         StunDurationHeadshot;                              // 0x0620(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StunDurationLeg;                                   // 0x0624(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2678[0x8];                                     // 0x0628(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PepperballDamageType">();
	}
	static class UPepperballDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPepperballDamageType>();
	}
};
static_assert(alignof(UPepperballDamageType) == 0x000010, "Wrong alignment on UPepperballDamageType");
static_assert(sizeof(UPepperballDamageType) == 0x000630, "Wrong size on UPepperballDamageType");
static_assert(offsetof(UPepperballDamageType, StunDurationHeadshot) == 0x000620, "Member 'UPepperballDamageType::StunDurationHeadshot' has a wrong offset!");
static_assert(offsetof(UPepperballDamageType, StunDurationLeg) == 0x000624, "Member 'UPepperballDamageType::StunDurationLeg' has a wrong offset!");

// Class ReadyOrNot.RealtimeWidget
// 0x0000 (0x0260 - 0x0260)
class URealtimeWidget : public UUserWidget
{
public:
	void OnSynchronizeProperties();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RealtimeWidget">();
	}
	static class URealtimeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URealtimeWidget>();
	}
};
static_assert(alignof(URealtimeWidget) == 0x000008, "Wrong alignment on URealtimeWidget");
static_assert(sizeof(URealtimeWidget) == 0x000260, "Wrong size on URealtimeWidget");

// Class ReadyOrNot.HostMigrationManager
// 0x0100 (0x0128 - 0x0028)
class UHostMigrationManager final  : public UObject
{
public:
	uint8                                         Pad_2679[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHm_PlayerInformation>          PlayerInformations;                                // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FHm_CyberneticsInformation>     CyberneticsInformations;                           // 0x0048(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FHm_DoorInformation>            DoorInformations;                                  // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FHm_BombInformation>            BombInformations;                                  // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FHm_BaggedEvidence>             BaggedEvidenceInformations;                        // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FHm_DroppedEvidence>            DroppedEvidenceInformations;                       // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FHm_Objectives>                 ObjectiveInformations;                             // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         ActiveEvidence;                                    // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_267A[0x10];                                    // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerState*                           NextHost;                                          // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MigrationGUID;                                     // 0x00D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_267B[0x8];                                     // 0x00E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MapName;                                           // 0x00E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ModeName;                                          // 0x00F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_267C[0x8];                                     // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NextHostName;                                      // 0x0110(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpectedPlayerCount;                               // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_267D[0x4];                                     // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateMigrationSession();
	void FindMigrationSession();
	void OnLobbySuccess();
	void OnMigrationSessionFoundFailed(TArray<struct FBlueprintSessionResult>& Results);
	void OnMigrationSessionFoundSuccess(TArray<struct FBlueprintSessionResult>& Results);
	void ReturnToMainMenu();
	void SaveState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HostMigrationManager">();
	}
	static class UHostMigrationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHostMigrationManager>();
	}
};
static_assert(alignof(UHostMigrationManager) == 0x000008, "Wrong alignment on UHostMigrationManager");
static_assert(sizeof(UHostMigrationManager) == 0x000128, "Wrong size on UHostMigrationManager");
static_assert(offsetof(UHostMigrationManager, PlayerInformations) == 0x000038, "Member 'UHostMigrationManager::PlayerInformations' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, CyberneticsInformations) == 0x000048, "Member 'UHostMigrationManager::CyberneticsInformations' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, DoorInformations) == 0x000058, "Member 'UHostMigrationManager::DoorInformations' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, BombInformations) == 0x000068, "Member 'UHostMigrationManager::BombInformations' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, BaggedEvidenceInformations) == 0x000078, "Member 'UHostMigrationManager::BaggedEvidenceInformations' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, DroppedEvidenceInformations) == 0x000088, "Member 'UHostMigrationManager::DroppedEvidenceInformations' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, ObjectiveInformations) == 0x000098, "Member 'UHostMigrationManager::ObjectiveInformations' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, ActiveEvidence) == 0x0000A8, "Member 'UHostMigrationManager::ActiveEvidence' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, NextHost) == 0x0000C8, "Member 'UHostMigrationManager::NextHost' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, MigrationGUID) == 0x0000D0, "Member 'UHostMigrationManager::MigrationGUID' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, MapName) == 0x0000E8, "Member 'UHostMigrationManager::MapName' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, ModeName) == 0x0000F8, "Member 'UHostMigrationManager::ModeName' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, NextHostName) == 0x000110, "Member 'UHostMigrationManager::NextHostName' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, ExpectedPlayerCount) == 0x000120, "Member 'UHostMigrationManager::ExpectedPlayerCount' has a wrong offset!");

// Class ReadyOrNot.OcclusionTestActor
// 0x0048 (0x0268 - 0x0220)
class AOcclusionTestActor final  : public AActor
{
public:
	float                                         OcclusionMultiplier;                               // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullOcclusionDepth;                                // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickInterval;                                      // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GunshotOrFootstep;                                 // 0x022C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_267E[0x3];                                     // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             GunshotSound;                                      // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOutside;                                        // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_267F[0x7];                                     // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             FootstepSound;                                     // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FoleySound;                                        // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeavyArmor;                                       // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCrouching;                                      // 0x0251(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2680[0x6];                                     // 0x0252(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODAudioPropagationComponent*         FMODAudioPropagationComp;                          // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    AudioComponent;                                    // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OcclusionTestActor">();
	}
	static class AOcclusionTestActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOcclusionTestActor>();
	}
};
static_assert(alignof(AOcclusionTestActor) == 0x000008, "Wrong alignment on AOcclusionTestActor");
static_assert(sizeof(AOcclusionTestActor) == 0x000268, "Wrong size on AOcclusionTestActor");
static_assert(offsetof(AOcclusionTestActor, OcclusionMultiplier) == 0x000220, "Member 'AOcclusionTestActor::OcclusionMultiplier' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, FullOcclusionDepth) == 0x000224, "Member 'AOcclusionTestActor::FullOcclusionDepth' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, TickInterval) == 0x000228, "Member 'AOcclusionTestActor::TickInterval' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, GunshotOrFootstep) == 0x00022C, "Member 'AOcclusionTestActor::GunshotOrFootstep' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, GunshotSound) == 0x000230, "Member 'AOcclusionTestActor::GunshotSound' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, bIsOutside) == 0x000238, "Member 'AOcclusionTestActor::bIsOutside' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, FootstepSound) == 0x000240, "Member 'AOcclusionTestActor::FootstepSound' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, FoleySound) == 0x000248, "Member 'AOcclusionTestActor::FoleySound' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, bHeavyArmor) == 0x000250, "Member 'AOcclusionTestActor::bHeavyArmor' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, bIsCrouching) == 0x000251, "Member 'AOcclusionTestActor::bIsCrouching' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, FMODAudioPropagationComp) == 0x000258, "Member 'AOcclusionTestActor::FMODAudioPropagationComp' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, AudioComponent) == 0x000260, "Member 'AOcclusionTestActor::AudioComponent' has a wrong offset!");

// Class ReadyOrNot.HotkeysWidget
// 0x0050 (0x02C8 - 0x0278)
class UHotkeysWidget : public UBaseWidget
{
public:
	class UOverlay*                               Hotkeys_Overlay;                                   // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         Hotkeys_Container;                                 // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHotkeyWidget*                          Hotkey_Grenade;                                    // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHotkeyWidget*                          Hotkey_Chemlight;                                  // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHotkeyWidget*                          Hotkey_NVG;                                        // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHotkeyWidget*                          Hotkey_Scope;                                      // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        IlluminatorAttachment_Switcher;                    // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHotkeyWidget*                          Hotkey_Laser;                                      // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHotkeyWidget*                          Hotkey_Flashlight;                                 // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x02C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void RefreshHotkeyInput();
	void SetHotkeyVisibility(class UWidget* Widget, bool bCondition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HotkeysWidget">();
	}
	static class UHotkeysWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHotkeysWidget>();
	}
};
static_assert(alignof(UHotkeysWidget) == 0x000008, "Wrong alignment on UHotkeysWidget");
static_assert(sizeof(UHotkeysWidget) == 0x0002C8, "Wrong size on UHotkeysWidget");
static_assert(offsetof(UHotkeysWidget, Hotkeys_Overlay) == 0x000278, "Member 'UHotkeysWidget::Hotkeys_Overlay' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, Hotkeys_Container) == 0x000280, "Member 'UHotkeysWidget::Hotkeys_Container' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, Hotkey_Grenade) == 0x000288, "Member 'UHotkeysWidget::Hotkey_Grenade' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, Hotkey_Chemlight) == 0x000290, "Member 'UHotkeysWidget::Hotkey_Chemlight' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, Hotkey_NVG) == 0x000298, "Member 'UHotkeysWidget::Hotkey_NVG' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, Hotkey_Scope) == 0x0002A0, "Member 'UHotkeysWidget::Hotkey_Scope' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, IlluminatorAttachment_Switcher) == 0x0002A8, "Member 'UHotkeysWidget::IlluminatorAttachment_Switcher' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, Hotkey_Laser) == 0x0002B0, "Member 'UHotkeysWidget::Hotkey_Laser' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, Hotkey_Flashlight) == 0x0002B8, "Member 'UHotkeysWidget::Hotkey_Flashlight' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, PlayerCharacter) == 0x0002C0, "Member 'UHotkeysWidget::PlayerCharacter' has a wrong offset!");

// Class ReadyOrNot.HotkeyWidget
// 0x00C8 (0x0328 - 0x0260)
class UHotkeyWidget : public UUserWidget
{
public:
	class UTextBlock*                             Hotkey_Text;                                       // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Hotkey_Image;                                      // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HotkeyDivider_Image;                               // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RemainingUses_Text;                                // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_Pressed;                                      // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_Released;                                     // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   InputName;                                         // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            Icon;                                              // 0x0298(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         bCustomAnimation : 1;                              // 0x0320(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowRemainingUses : 1;                            // 0x0320(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2682[0x7];                                     // 0x0321(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayPressedAnimation();
	void PlayReleasedAnimation();
	void RefreshHotkey();
	void SetHotkeyImage(struct FSlateBrush& Brush);
	void SetHotkeyRemainingUses(int32 InRemainingUses);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HotkeyWidget">();
	}
	static class UHotkeyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHotkeyWidget>();
	}
};
static_assert(alignof(UHotkeyWidget) == 0x000008, "Wrong alignment on UHotkeyWidget");
static_assert(sizeof(UHotkeyWidget) == 0x000328, "Wrong size on UHotkeyWidget");
static_assert(offsetof(UHotkeyWidget, Hotkey_Text) == 0x000260, "Member 'UHotkeyWidget::Hotkey_Text' has a wrong offset!");
static_assert(offsetof(UHotkeyWidget, Hotkey_Image) == 0x000268, "Member 'UHotkeyWidget::Hotkey_Image' has a wrong offset!");
static_assert(offsetof(UHotkeyWidget, HotkeyDivider_Image) == 0x000270, "Member 'UHotkeyWidget::HotkeyDivider_Image' has a wrong offset!");
static_assert(offsetof(UHotkeyWidget, RemainingUses_Text) == 0x000278, "Member 'UHotkeyWidget::RemainingUses_Text' has a wrong offset!");
static_assert(offsetof(UHotkeyWidget, Anim_Pressed) == 0x000280, "Member 'UHotkeyWidget::Anim_Pressed' has a wrong offset!");
static_assert(offsetof(UHotkeyWidget, Anim_Released) == 0x000288, "Member 'UHotkeyWidget::Anim_Released' has a wrong offset!");
static_assert(offsetof(UHotkeyWidget, InputName) == 0x000290, "Member 'UHotkeyWidget::InputName' has a wrong offset!");
static_assert(offsetof(UHotkeyWidget, Icon) == 0x000298, "Member 'UHotkeyWidget::Icon' has a wrong offset!");

// Class ReadyOrNot.Pouch
// 0x0038 (0x02E0 - 0x02A8)
class APouch final  : public ASkeletalMeshActor
{
public:
	class USkeletalMeshComponent*                 MagazineComponent;                                 // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        AttachToComp;                                      // 0x02B0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AttachToSocket;                                    // 0x02B8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowMagazine;                                     // 0x02C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2683[0x3];                                     // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MagazineSocket;                                    // 0x02C4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2684[0x4];                                     // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          OpenPouch;                                         // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ClosePouch;                                        // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnRep_Attach();
	void OnRep_UpdateVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Pouch">();
	}
	static class APouch* GetDefaultObj()
	{
		return GetDefaultObjImpl<APouch>();
	}
};
static_assert(alignof(APouch) == 0x000008, "Wrong alignment on APouch");
static_assert(sizeof(APouch) == 0x0002E0, "Wrong size on APouch");
static_assert(offsetof(APouch, MagazineComponent) == 0x0002A8, "Member 'APouch::MagazineComponent' has a wrong offset!");
static_assert(offsetof(APouch, AttachToComp) == 0x0002B0, "Member 'APouch::AttachToComp' has a wrong offset!");
static_assert(offsetof(APouch, AttachToSocket) == 0x0002B8, "Member 'APouch::AttachToSocket' has a wrong offset!");
static_assert(offsetof(APouch, bShowMagazine) == 0x0002C0, "Member 'APouch::bShowMagazine' has a wrong offset!");
static_assert(offsetof(APouch, MagazineSocket) == 0x0002C4, "Member 'APouch::MagazineSocket' has a wrong offset!");
static_assert(offsetof(APouch, OpenPouch) == 0x0002D0, "Member 'APouch::OpenPouch' has a wrong offset!");
static_assert(offsetof(APouch, ClosePouch) == 0x0002D8, "Member 'APouch::ClosePouch' has a wrong offset!");

// Class ReadyOrNot.HumanCharacterHUD_V2
// 0x0120 (0x0458 - 0x0338)
class UHumanCharacterHUD_V2 : public UActivatableBaseWidget
{
public:
	FMulticastInlineDelegateProperty_             OnSlot1Updated;                                    // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSlot2Updated;                                    // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSlot3Updated;                                    // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSlot4Updated;                                    // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSlotReserved1Updated;                            // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSlotReserved2Updated;                            // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       Anim_FadeInHUD;                                    // 0x0398(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           CanvasPanel_Main;                                  // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_Gamepad;                               // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URetainerBox*                           RetainerBox_SwayableElements;                      // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionText_Slot_1;                           // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionText_Slot_2;                           // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionText_Slot_3;                           // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionText_Slot_4;                           // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionText_Slot_Reserved_1;                  // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionText_Slot_Reserved_2;                  // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemWheel*                             ItemWheel;                                         // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommandWheel*                          CommandWheel;                                      // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHUDStyle                                     HUDStyle;                                          // 0x03F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2685[0x7];                                     // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ObjectiveMarker_WidgetFadeZones;                   // 0x0400(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bEnableHUDSway : 1;                                // 0x0410(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2686[0x3];                                     // 0x0411(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MaxHUDSwayMovement;                                // 0x0414(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              SwayStrength;                                      // 0x041C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              SwaySpeed;                                         // 0x0424(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnableCurvedHUD : 1;                              // 0x042C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2687[0x3];                                     // 0x042D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurvedHUDStrength;                                 // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2688[0x4];                                     // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0438(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotPlayerController*            PlayerController;                                  // 0x0440(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              AccumulatedMouseDelta;                             // 0x0448(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2689[0x8];                                     // 0x0450(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMapActorWidget* AddMapActor(class UMapActorComponent* MapActorComponent, TSubclassOf<class UMapActorWidget> MapActorIconWidgetClass, struct FSlateBrush& IconBrush, struct FLinearColor& IconColor, struct FLinearColor& IconTextColor, float RotationOffset);
	void AddObjectivePopup(class FText& PopupText);
	void AddScorePopup(class FText& ScoreText, int32 ScoreValue, bool bGive);
	void AssignPlayerActionPrompt(int32 InSlot, const struct FKey& InputKey, EInputEvent InputEvent, class FText InActionText, const class FString& InColorLabel, bool bAnimate, bool bLoopAnimation);
	void AssignPlayerActionPrompt_Custom(int32 InSlot, class FText InCustomPromptText, bool bAnimate, bool bLoopAnimation);
	void AssignPlayerActionPrompt_Reserved(int32 InSlot, const struct FKey& InputKey, EInputEvent InputEvent, class FText InActionText, const class FString& InColorLabel, bool bAnimate, bool bLoopAnimation);
	void AssignPlayerActionPromptToFreeSlot(const struct FKey& InputKey, EInputEvent InputEvent, class FText InActionText, const class FString& InColorLabel, bool bAnimate, bool bLoopAnimation);
	int32 AssignPlayerActionPromptToFreeSlot_Reserved(const struct FKey& InputKey, EInputEvent InputEvent, class FText InActionText, const class FString& InColorLabel, bool bAnimate, bool bLoopAnimation);
	void ChatPressed();
	void ClearAllPlayerActionPrompts();
	class UCommandWheel* GetCommandWheel();
	class UItemWheel* GetItemWheel();
	class UScreenspaceMarkerWidget* GetRoundupWidget();
	class UScreenspaceMarkerWidget* GetScreenspaceMarkerWidget();
	class UTutorialWidget* GetTutorialWidget();
	void HideHUD();
	void HideTutorialOverview(const class FString& MessageID);
	void HideTutorialPrompt(const class FString& MessageID);
	void LocalReadyStateChanged(bool bReady);
	void OnInventoryItemsChanged();
	void OnSlot1Updated__DelegateSignature(class FText InText, bool ClearText, bool bAnimate, bool bLoopAnimation);
	void OnSlot2Updated__DelegateSignature(class FText InText, bool ClearText, bool bAnimate, bool bLoopAnimation);
	void OnSlot3Updated__DelegateSignature(class FText InText, bool ClearText, bool bAnimate, bool bLoopAnimation);
	void OnSlot4Updated__DelegateSignature(class FText InText, bool ClearText, bool bAnimate, bool bLoopAnimation);
	void OnSlotReserved1Updated__DelegateSignature(class FText InText, bool ClearText, bool bAnimate, bool bLoopAnimation);
	void OnSlotReserved2Updated__DelegateSignature(class FText InText, bool ClearText, bool bAnimate, bool bLoopAnimation);
	void OnTabletClose();
	void OnTabletNotificationEvent();
	void OnTabletOpen();
	void ReadiedPlayersChanged();
	void ReflectHUDSettings();
	void RemoveMapActor(class UMapActorComponent* MapActorComponent);
	void RemovePlayerActionPrompt(int32 InSlot);
	void RemovePlayerActionPrompt_Reserved(int32 InSlot);
	void ShowHUD();
	void ShowTutorialOverview(const class FString& MessageID, class FText& MessageTitle, TArray<class FText>& MessageContent);
	void ShowTutorialPrompt(const class FString& MessageID, bool bFirstShowing, class FText& MessageTitle, TArray<class FText>& MessageContent);
	void TeamChatPressed();
	void UpdateMapFloors(TArray<struct FBuildingFloor>& Floors);

	bool IsActionSlotInUse(int32 InSlot) const;
	bool IsActionSlotInUse_Reserved(int32 InSlot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanCharacterHUD_V2">();
	}
	static class UHumanCharacterHUD_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanCharacterHUD_V2>();
	}
};
static_assert(alignof(UHumanCharacterHUD_V2) == 0x000008, "Wrong alignment on UHumanCharacterHUD_V2");
static_assert(sizeof(UHumanCharacterHUD_V2) == 0x000458, "Wrong size on UHumanCharacterHUD_V2");
static_assert(offsetof(UHumanCharacterHUD_V2, OnSlot1Updated) == 0x000338, "Member 'UHumanCharacterHUD_V2::OnSlot1Updated' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, OnSlot2Updated) == 0x000348, "Member 'UHumanCharacterHUD_V2::OnSlot2Updated' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, OnSlot3Updated) == 0x000358, "Member 'UHumanCharacterHUD_V2::OnSlot3Updated' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, OnSlot4Updated) == 0x000368, "Member 'UHumanCharacterHUD_V2::OnSlot4Updated' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, OnSlotReserved1Updated) == 0x000378, "Member 'UHumanCharacterHUD_V2::OnSlotReserved1Updated' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, OnSlotReserved2Updated) == 0x000388, "Member 'UHumanCharacterHUD_V2::OnSlotReserved2Updated' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, Anim_FadeInHUD) == 0x000398, "Member 'UHumanCharacterHUD_V2::Anim_FadeInHUD' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, CanvasPanel_Main) == 0x0003A0, "Member 'UHumanCharacterHUD_V2::CanvasPanel_Main' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, CanvasPanel_Gamepad) == 0x0003A8, "Member 'UHumanCharacterHUD_V2::CanvasPanel_Gamepad' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, RetainerBox_SwayableElements) == 0x0003B0, "Member 'UHumanCharacterHUD_V2::RetainerBox_SwayableElements' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, PlayerActionText_Slot_1) == 0x0003B8, "Member 'UHumanCharacterHUD_V2::PlayerActionText_Slot_1' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, PlayerActionText_Slot_2) == 0x0003C0, "Member 'UHumanCharacterHUD_V2::PlayerActionText_Slot_2' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, PlayerActionText_Slot_3) == 0x0003C8, "Member 'UHumanCharacterHUD_V2::PlayerActionText_Slot_3' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, PlayerActionText_Slot_4) == 0x0003D0, "Member 'UHumanCharacterHUD_V2::PlayerActionText_Slot_4' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, PlayerActionText_Slot_Reserved_1) == 0x0003D8, "Member 'UHumanCharacterHUD_V2::PlayerActionText_Slot_Reserved_1' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, PlayerActionText_Slot_Reserved_2) == 0x0003E0, "Member 'UHumanCharacterHUD_V2::PlayerActionText_Slot_Reserved_2' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, ItemWheel) == 0x0003E8, "Member 'UHumanCharacterHUD_V2::ItemWheel' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, CommandWheel) == 0x0003F0, "Member 'UHumanCharacterHUD_V2::CommandWheel' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, HUDStyle) == 0x0003F8, "Member 'UHumanCharacterHUD_V2::HUDStyle' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, ObjectiveMarker_WidgetFadeZones) == 0x000400, "Member 'UHumanCharacterHUD_V2::ObjectiveMarker_WidgetFadeZones' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, MaxHUDSwayMovement) == 0x000414, "Member 'UHumanCharacterHUD_V2::MaxHUDSwayMovement' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, SwayStrength) == 0x00041C, "Member 'UHumanCharacterHUD_V2::SwayStrength' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, SwaySpeed) == 0x000424, "Member 'UHumanCharacterHUD_V2::SwaySpeed' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, CurvedHUDStrength) == 0x000430, "Member 'UHumanCharacterHUD_V2::CurvedHUDStrength' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, PlayerCharacter) == 0x000438, "Member 'UHumanCharacterHUD_V2::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, PlayerController) == 0x000440, "Member 'UHumanCharacterHUD_V2::PlayerController' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, AccumulatedMouseDelta) == 0x000448, "Member 'UHumanCharacterHUD_V2::AccumulatedMouseDelta' has a wrong offset!");

// Class ReadyOrNot.MessagePromptActor
// 0x0050 (0x0270 - 0x0220)
class AMessagePromptActor final  : public AActor
{
public:
	class FString                                 MessageMapID;                                      // 0x0220(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBigPopUp;                                       // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasDisplayedMessage;                              // 0x0231(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A1[0x6];                                     // 0x0232(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MessageTitle;                                      // 0x0238(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FText>                           MessageContent;                                    // 0x0250(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMessagePromptContent>          MessageActions;                                    // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void GenerateMessageContent();
	void HideMessagePopUp();
	void ShowMessageThroughPopUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessagePromptActor">();
	}
	static class AMessagePromptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMessagePromptActor>();
	}
};
static_assert(alignof(AMessagePromptActor) == 0x000008, "Wrong alignment on AMessagePromptActor");
static_assert(sizeof(AMessagePromptActor) == 0x000270, "Wrong size on AMessagePromptActor");
static_assert(offsetof(AMessagePromptActor, MessageMapID) == 0x000220, "Member 'AMessagePromptActor::MessageMapID' has a wrong offset!");
static_assert(offsetof(AMessagePromptActor, bIsBigPopUp) == 0x000230, "Member 'AMessagePromptActor::bIsBigPopUp' has a wrong offset!");
static_assert(offsetof(AMessagePromptActor, bHasDisplayedMessage) == 0x000231, "Member 'AMessagePromptActor::bHasDisplayedMessage' has a wrong offset!");
static_assert(offsetof(AMessagePromptActor, MessageTitle) == 0x000238, "Member 'AMessagePromptActor::MessageTitle' has a wrong offset!");
static_assert(offsetof(AMessagePromptActor, MessageContent) == 0x000250, "Member 'AMessagePromptActor::MessageContent' has a wrong offset!");
static_assert(offsetof(AMessagePromptActor, MessageActions) == 0x000260, "Member 'AMessagePromptActor::MessageActions' has a wrong offset!");

// Class ReadyOrNot.StandardModal
// 0x00A0 (0x0300 - 0x0260)
class UStandardModal : public UUserWidget
{
public:
	class FText                                   TitleBar;                                          // 0x0260(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   ModalDescription;                                  // 0x0278(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          ShowApplyButton;                                   // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowCancelButton;                                  // 0x0291(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowOkButton;                                      // 0x0292(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A2[0x5];                                     // 0x0293(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ApplyButtonText;                                   // 0x0298(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   CancelButtonText;                                  // 0x02B0(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   OkButtonText;                                      // 0x02C8(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          RequireScrollToBottom;                             // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A3[0x3];                                     // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Size;                                              // 0x02E4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A4[0x4];                                     // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCancelClicked;                                   // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StandardModal">();
	}
	static class UStandardModal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStandardModal>();
	}
};
static_assert(alignof(UStandardModal) == 0x000008, "Wrong alignment on UStandardModal");
static_assert(sizeof(UStandardModal) == 0x000300, "Wrong size on UStandardModal");
static_assert(offsetof(UStandardModal, TitleBar) == 0x000260, "Member 'UStandardModal::TitleBar' has a wrong offset!");
static_assert(offsetof(UStandardModal, ModalDescription) == 0x000278, "Member 'UStandardModal::ModalDescription' has a wrong offset!");
static_assert(offsetof(UStandardModal, ShowApplyButton) == 0x000290, "Member 'UStandardModal::ShowApplyButton' has a wrong offset!");
static_assert(offsetof(UStandardModal, ShowCancelButton) == 0x000291, "Member 'UStandardModal::ShowCancelButton' has a wrong offset!");
static_assert(offsetof(UStandardModal, ShowOkButton) == 0x000292, "Member 'UStandardModal::ShowOkButton' has a wrong offset!");
static_assert(offsetof(UStandardModal, ApplyButtonText) == 0x000298, "Member 'UStandardModal::ApplyButtonText' has a wrong offset!");
static_assert(offsetof(UStandardModal, CancelButtonText) == 0x0002B0, "Member 'UStandardModal::CancelButtonText' has a wrong offset!");
static_assert(offsetof(UStandardModal, OkButtonText) == 0x0002C8, "Member 'UStandardModal::OkButtonText' has a wrong offset!");
static_assert(offsetof(UStandardModal, RequireScrollToBottom) == 0x0002E0, "Member 'UStandardModal::RequireScrollToBottom' has a wrong offset!");
static_assert(offsetof(UStandardModal, Size) == 0x0002E4, "Member 'UStandardModal::Size' has a wrong offset!");
static_assert(offsetof(UStandardModal, OnCancelClicked) == 0x0002F0, "Member 'UStandardModal::OnCancelClicked' has a wrong offset!");

// Class ReadyOrNot.IllegalUnbindModal
// 0x0000 (0x0300 - 0x0300)
class UIllegalUnbindModal : public UStandardModal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IllegalUnbindModal">();
	}
	static class UIllegalUnbindModal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIllegalUnbindModal>();
	}
};
static_assert(alignof(UIllegalUnbindModal) == 0x000008, "Wrong alignment on UIllegalUnbindModal");
static_assert(sizeof(UIllegalUnbindModal) == 0x000300, "Wrong size on UIllegalUnbindModal");

// Class ReadyOrNot.ImpactEffect
// 0x0B30 (0x0D98 - 0x0268)
class AImpactEffect : public APooledActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    FMODAudioComponent;                                // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        DecalComponent;                                    // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        DecalRicochetComponent;                            // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        DecalBloodComponent;                               // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       SpawnedParticles;                                  // 0x0298(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A5[0x110];                                   // 0x02A8(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	EImpactEffectType                             Type;                                              // 0x03B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayDefaultIfNull;                                // 0x03B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A6[0x2];                                     // 0x03BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecalScale;                                        // 0x03BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A7[0x8];                                     // 0x03C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecalMinSize;                                      // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalMaxSize;                                      // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleScale;                                     // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReflectImpactEffectAcrossNormal;                  // 0x03D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A8[0x3];                                     // 0x03D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             FMODSoundFx;                                       // 0x03D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODHitmarker;                                     // 0x03E0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDecalMeshes;                                    // 0x03E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalMeshScaleMultiplier;                          // 0x03EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBulletGoneThroughPlayer;                          // 0x03F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArmorImpact;                                      // 0x03F1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnParticle;                                    // 0x03F2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x03F3(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A9[0x4];                                     // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             BloodExitDecals;                                   // 0x03F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              DefaultImpactFx;                                   // 0x0408(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Aluminium;                                     // 0x0438(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Asphalt;                                       // 0x0468(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Brick;                                         // 0x0498(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_CarbonFibre;                                   // 0x04C8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Cardboard;                                     // 0x04F8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Ceramic;                                       // 0x0528(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_ConcreteSoft;                                  // 0x0558(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_ConcreteStrong;                                // 0x0588(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Dirt;                                          // 0x05B8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Drywall;                                       // 0x05E8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Electrical;                                    // 0x0618(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_EnergyShield;                                  // 0x0648(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Fabric_Carpet;                                 // 0x0678(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Fabric_Stuffing;                               // 0x06A8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Fabric_Thin;                                   // 0x06D8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Flesh;                                         // 0x0708(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Galvanized;                                    // 0x0738(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Glass_Plate;                                   // 0x0768(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Glass_Windshield;                              // 0x0798(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Grass;                                         // 0x07C8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Gravel;                                        // 0x07F8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Ice;                                           // 0x0828(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Lava;                                          // 0x0858(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Lead;                                          // 0x0888(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Leaves;                                        // 0x08B8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Limestone;                                     // 0x08E8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Mahogany;                                      // 0x0918(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Marble_Coated;                                 // 0x0948(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Marble_Thick;                                  // 0x0978(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Mud;                                           // 0x09A8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Oil;                                           // 0x09D8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Paper;                                         // 0x0A08(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Pine;                                          // 0x0A38(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Plaster;                                       // 0x0A68(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Plastic;                                       // 0x0A98(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Plywood;                                       // 0x0AC8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Polystyrene;                                   // 0x0AF8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Powder;                                        // 0x0B28(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Rock;                                          // 0x0B58(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Rubber;                                        // 0x0B88(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Sand;                                          // 0x0BB8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Snow;                                          // 0x0BE8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Soil;                                          // 0x0C18(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Steel;                                         // 0x0C48(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Tin;                                           // 0x0C78(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Treewood;                                      // 0x0CA8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Wallpaper;                                     // 0x0CD8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Water;                                         // 0x0D08(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Vehicle;                                       // 0x0D38(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Bulletproof_Glass;                             // 0x0D68(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImpactEffect">();
	}
	static class AImpactEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AImpactEffect>();
	}
};
static_assert(alignof(AImpactEffect) == 0x000008, "Wrong alignment on AImpactEffect");
static_assert(sizeof(AImpactEffect) == 0x000D98, "Wrong size on AImpactEffect");
static_assert(offsetof(AImpactEffect, SceneComponent) == 0x000268, "Member 'AImpactEffect::SceneComponent' has a wrong offset!");
static_assert(offsetof(AImpactEffect, ParticleSystemComponent) == 0x000270, "Member 'AImpactEffect::ParticleSystemComponent' has a wrong offset!");
static_assert(offsetof(AImpactEffect, FMODAudioComponent) == 0x000278, "Member 'AImpactEffect::FMODAudioComponent' has a wrong offset!");
static_assert(offsetof(AImpactEffect, DecalComponent) == 0x000280, "Member 'AImpactEffect::DecalComponent' has a wrong offset!");
static_assert(offsetof(AImpactEffect, DecalRicochetComponent) == 0x000288, "Member 'AImpactEffect::DecalRicochetComponent' has a wrong offset!");
static_assert(offsetof(AImpactEffect, DecalBloodComponent) == 0x000290, "Member 'AImpactEffect::DecalBloodComponent' has a wrong offset!");
static_assert(offsetof(AImpactEffect, SpawnedParticles) == 0x000298, "Member 'AImpactEffect::SpawnedParticles' has a wrong offset!");
static_assert(offsetof(AImpactEffect, Type) == 0x0003B8, "Member 'AImpactEffect::Type' has a wrong offset!");
static_assert(offsetof(AImpactEffect, bPlayDefaultIfNull) == 0x0003B9, "Member 'AImpactEffect::bPlayDefaultIfNull' has a wrong offset!");
static_assert(offsetof(AImpactEffect, DecalScale) == 0x0003BC, "Member 'AImpactEffect::DecalScale' has a wrong offset!");
static_assert(offsetof(AImpactEffect, DecalMinSize) == 0x0003C8, "Member 'AImpactEffect::DecalMinSize' has a wrong offset!");
static_assert(offsetof(AImpactEffect, DecalMaxSize) == 0x0003CC, "Member 'AImpactEffect::DecalMaxSize' has a wrong offset!");
static_assert(offsetof(AImpactEffect, ParticleScale) == 0x0003D0, "Member 'AImpactEffect::ParticleScale' has a wrong offset!");
static_assert(offsetof(AImpactEffect, bReflectImpactEffectAcrossNormal) == 0x0003D4, "Member 'AImpactEffect::bReflectImpactEffectAcrossNormal' has a wrong offset!");
static_assert(offsetof(AImpactEffect, FMODSoundFx) == 0x0003D8, "Member 'AImpactEffect::FMODSoundFx' has a wrong offset!");
static_assert(offsetof(AImpactEffect, FMODHitmarker) == 0x0003E0, "Member 'AImpactEffect::FMODHitmarker' has a wrong offset!");
static_assert(offsetof(AImpactEffect, MaxDecalMeshes) == 0x0003E8, "Member 'AImpactEffect::MaxDecalMeshes' has a wrong offset!");
static_assert(offsetof(AImpactEffect, DecalMeshScaleMultiplier) == 0x0003EC, "Member 'AImpactEffect::DecalMeshScaleMultiplier' has a wrong offset!");
static_assert(offsetof(AImpactEffect, bBulletGoneThroughPlayer) == 0x0003F0, "Member 'AImpactEffect::bBulletGoneThroughPlayer' has a wrong offset!");
static_assert(offsetof(AImpactEffect, bArmorImpact) == 0x0003F1, "Member 'AImpactEffect::bArmorImpact' has a wrong offset!");
static_assert(offsetof(AImpactEffect, bSpawnParticle) == 0x0003F2, "Member 'AImpactEffect::bSpawnParticle' has a wrong offset!");
static_assert(offsetof(AImpactEffect, bTraceComplex) == 0x0003F3, "Member 'AImpactEffect::bTraceComplex' has a wrong offset!");
static_assert(offsetof(AImpactEffect, BloodExitDecals) == 0x0003F8, "Member 'AImpactEffect::BloodExitDecals' has a wrong offset!");
static_assert(offsetof(AImpactEffect, DefaultImpactFx) == 0x000408, "Member 'AImpactEffect::DefaultImpactFx' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Aluminium) == 0x000438, "Member 'AImpactEffect::RON_Aluminium' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Asphalt) == 0x000468, "Member 'AImpactEffect::RON_Asphalt' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Brick) == 0x000498, "Member 'AImpactEffect::RON_Brick' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_CarbonFibre) == 0x0004C8, "Member 'AImpactEffect::RON_CarbonFibre' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Cardboard) == 0x0004F8, "Member 'AImpactEffect::RON_Cardboard' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Ceramic) == 0x000528, "Member 'AImpactEffect::RON_Ceramic' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_ConcreteSoft) == 0x000558, "Member 'AImpactEffect::RON_ConcreteSoft' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_ConcreteStrong) == 0x000588, "Member 'AImpactEffect::RON_ConcreteStrong' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Dirt) == 0x0005B8, "Member 'AImpactEffect::RON_Dirt' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Drywall) == 0x0005E8, "Member 'AImpactEffect::RON_Drywall' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Electrical) == 0x000618, "Member 'AImpactEffect::RON_Electrical' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_EnergyShield) == 0x000648, "Member 'AImpactEffect::RON_EnergyShield' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Fabric_Carpet) == 0x000678, "Member 'AImpactEffect::RON_Fabric_Carpet' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Fabric_Stuffing) == 0x0006A8, "Member 'AImpactEffect::RON_Fabric_Stuffing' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Fabric_Thin) == 0x0006D8, "Member 'AImpactEffect::RON_Fabric_Thin' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Flesh) == 0x000708, "Member 'AImpactEffect::RON_Flesh' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Galvanized) == 0x000738, "Member 'AImpactEffect::RON_Galvanized' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Glass_Plate) == 0x000768, "Member 'AImpactEffect::RON_Glass_Plate' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Glass_Windshield) == 0x000798, "Member 'AImpactEffect::RON_Glass_Windshield' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Grass) == 0x0007C8, "Member 'AImpactEffect::RON_Grass' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Gravel) == 0x0007F8, "Member 'AImpactEffect::RON_Gravel' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Ice) == 0x000828, "Member 'AImpactEffect::RON_Ice' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Lava) == 0x000858, "Member 'AImpactEffect::RON_Lava' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Lead) == 0x000888, "Member 'AImpactEffect::RON_Lead' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Leaves) == 0x0008B8, "Member 'AImpactEffect::RON_Leaves' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Limestone) == 0x0008E8, "Member 'AImpactEffect::RON_Limestone' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Mahogany) == 0x000918, "Member 'AImpactEffect::RON_Mahogany' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Marble_Coated) == 0x000948, "Member 'AImpactEffect::RON_Marble_Coated' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Marble_Thick) == 0x000978, "Member 'AImpactEffect::RON_Marble_Thick' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Mud) == 0x0009A8, "Member 'AImpactEffect::RON_Mud' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Oil) == 0x0009D8, "Member 'AImpactEffect::RON_Oil' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Paper) == 0x000A08, "Member 'AImpactEffect::RON_Paper' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Pine) == 0x000A38, "Member 'AImpactEffect::RON_Pine' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Plaster) == 0x000A68, "Member 'AImpactEffect::RON_Plaster' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Plastic) == 0x000A98, "Member 'AImpactEffect::RON_Plastic' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Plywood) == 0x000AC8, "Member 'AImpactEffect::RON_Plywood' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Polystyrene) == 0x000AF8, "Member 'AImpactEffect::RON_Polystyrene' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Powder) == 0x000B28, "Member 'AImpactEffect::RON_Powder' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Rock) == 0x000B58, "Member 'AImpactEffect::RON_Rock' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Rubber) == 0x000B88, "Member 'AImpactEffect::RON_Rubber' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Sand) == 0x000BB8, "Member 'AImpactEffect::RON_Sand' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Snow) == 0x000BE8, "Member 'AImpactEffect::RON_Snow' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Soil) == 0x000C18, "Member 'AImpactEffect::RON_Soil' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Steel) == 0x000C48, "Member 'AImpactEffect::RON_Steel' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Tin) == 0x000C78, "Member 'AImpactEffect::RON_Tin' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Treewood) == 0x000CA8, "Member 'AImpactEffect::RON_Treewood' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Wallpaper) == 0x000CD8, "Member 'AImpactEffect::RON_Wallpaper' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Water) == 0x000D08, "Member 'AImpactEffect::RON_Water' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Vehicle) == 0x000D38, "Member 'AImpactEffect::RON_Vehicle' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Bulletproof_Glass) == 0x000D68, "Member 'AImpactEffect::RON_Bulletproof_Glass' has a wrong offset!");

// Class ReadyOrNot.IncapacitatedHuman
// 0x00C0 (0x02E0 - 0x0220)
class AIncapacitatedHuman final  : public AActor
{
public:
	uint8                                         Pad_26AA[0x28];                                    // 0x0220(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultScene;                                      // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 HumanMesh;                                         // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 HumanMeshFace;                                     // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 ReportInteractableComponent;                       // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScoringComponent*                      ScoringComponent;                                  // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    IncapacitatedAudioComponent;                       // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIPerceptionStimuliSourceComponent*    PerceptionStimuliComp;                             // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsAsset*                          RagdollPhysicsAsset;                               // 0x0288(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DyingMontage;                                      // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FMODEventLoop;                                     // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ShotParticleEffect;                                // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsChild;                                          // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartDead;                                        // 0x02A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanEverDieByTime;                                 // 0x02AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26AB[0x1];                                     // 0x02AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeRemainingUntilDead;                            // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInGroup;                                        // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMasterOfGroup;                                  // 0x02B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26AC[0x6];                                     // 0x02B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AIncapacitatedHuman*>            IncapacitatedHumansInGroup;                        // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AIncapacitatedHuman*                    MasterHumanInGroup;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachReportInteractableToMesh;                   // 0x02D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26AD[0x3];                                     // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketToAttach;                                    // 0x02D4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeamType                                     Team;                                              // 0x02DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDead;                                           // 0x02DD(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasBeenReported;                                  // 0x02DE(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26AE[0x1];                                     // 0x02DF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MakeMasterInGroup();
	void SelectAllInGroup();

	bool HasBeenReported() const;
	bool IsChild() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncapacitatedHuman">();
	}
	static class AIncapacitatedHuman* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIncapacitatedHuman>();
	}
};
static_assert(alignof(AIncapacitatedHuman) == 0x000008, "Wrong alignment on AIncapacitatedHuman");
static_assert(sizeof(AIncapacitatedHuman) == 0x0002E0, "Wrong size on AIncapacitatedHuman");
static_assert(offsetof(AIncapacitatedHuman, DefaultScene) == 0x000248, "Member 'AIncapacitatedHuman::DefaultScene' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, HumanMesh) == 0x000250, "Member 'AIncapacitatedHuman::HumanMesh' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, HumanMeshFace) == 0x000258, "Member 'AIncapacitatedHuman::HumanMeshFace' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, CapsuleComponent) == 0x000260, "Member 'AIncapacitatedHuman::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, ReportInteractableComponent) == 0x000268, "Member 'AIncapacitatedHuman::ReportInteractableComponent' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, ScoringComponent) == 0x000270, "Member 'AIncapacitatedHuman::ScoringComponent' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, IncapacitatedAudioComponent) == 0x000278, "Member 'AIncapacitatedHuman::IncapacitatedAudioComponent' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, PerceptionStimuliComp) == 0x000280, "Member 'AIncapacitatedHuman::PerceptionStimuliComp' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, RagdollPhysicsAsset) == 0x000288, "Member 'AIncapacitatedHuman::RagdollPhysicsAsset' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, DyingMontage) == 0x000290, "Member 'AIncapacitatedHuman::DyingMontage' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, FMODEventLoop) == 0x000298, "Member 'AIncapacitatedHuman::FMODEventLoop' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, ShotParticleEffect) == 0x0002A0, "Member 'AIncapacitatedHuman::ShotParticleEffect' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, bIsChild) == 0x0002A8, "Member 'AIncapacitatedHuman::bIsChild' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, bStartDead) == 0x0002A9, "Member 'AIncapacitatedHuman::bStartDead' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, bCanEverDieByTime) == 0x0002AA, "Member 'AIncapacitatedHuman::bCanEverDieByTime' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, TimeRemainingUntilDead) == 0x0002AC, "Member 'AIncapacitatedHuman::TimeRemainingUntilDead' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, bIsInGroup) == 0x0002B0, "Member 'AIncapacitatedHuman::bIsInGroup' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, bIsMasterOfGroup) == 0x0002B1, "Member 'AIncapacitatedHuman::bIsMasterOfGroup' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, IncapacitatedHumansInGroup) == 0x0002B8, "Member 'AIncapacitatedHuman::IncapacitatedHumansInGroup' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, MasterHumanInGroup) == 0x0002C8, "Member 'AIncapacitatedHuman::MasterHumanInGroup' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, bAttachReportInteractableToMesh) == 0x0002D0, "Member 'AIncapacitatedHuman::bAttachReportInteractableToMesh' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, SocketToAttach) == 0x0002D4, "Member 'AIncapacitatedHuman::SocketToAttach' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, Team) == 0x0002DC, "Member 'AIncapacitatedHuman::Team' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, bIsDead) == 0x0002DD, "Member 'AIncapacitatedHuman::bIsDead' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, bHasBeenReported) == 0x0002DE, "Member 'AIncapacitatedHuman::bHasBeenReported' has a wrong offset!");

// Class ReadyOrNot.IncriminationClue
// 0x0070 (0x02F8 - 0x0288)
class AIncriminationClue final  : public APickupActor
{
public:
	FMulticastInlineDelegateProperty_             Delegate_OnClueFound;                              // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMapActorComponent*                     MapActorComponent;                                 // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClueNumber;                                        // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26AF[0x3];                                     // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShowObjectiveMarkerIn;                             // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AIncriminationClue*                     NextClue;                                          // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ClueName;                                          // 0x02B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, Protected, NativeAccessSpecifierProtected)
	class FText                                   ClueFoundMessage;                                  // 0x02C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, Protected, NativeAccessSpecifierProtected)
	class AIncriminationClueSpawnPoint*           SpawnPointOwner;                                   // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bClueFound : 1;                                    // 0x02E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bClueTimerExpired : 1;                             // 0x02E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EClueState                                    ClueState;                                         // 0x02E9(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26B0[0xE];                                     // 0x02EA(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AIncriminationClueSpawnPoint* OwningSpawn, uint8 InClueNumber, class FText& InClueName, class FText& InClueFoundMessage, float InShowObjectiveMarkerIn);
	void OnClueFound();
	void OnClueFound__DelegateSignature(class AIncriminationClue* ClueActor, class AActor* ClueFounder);
	void OnRep_OnClueFound();
	void OnRep_OnClueStateChanged();
	void RevealNextClue();

	bool IsClueFound() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncriminationClue">();
	}
	static class AIncriminationClue* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIncriminationClue>();
	}
};
static_assert(alignof(AIncriminationClue) == 0x000008, "Wrong alignment on AIncriminationClue");
static_assert(sizeof(AIncriminationClue) == 0x0002F8, "Wrong size on AIncriminationClue");
static_assert(offsetof(AIncriminationClue, Delegate_OnClueFound) == 0x000288, "Member 'AIncriminationClue::Delegate_OnClueFound' has a wrong offset!");
static_assert(offsetof(AIncriminationClue, MapActorComponent) == 0x000298, "Member 'AIncriminationClue::MapActorComponent' has a wrong offset!");
static_assert(offsetof(AIncriminationClue, ClueNumber) == 0x0002A0, "Member 'AIncriminationClue::ClueNumber' has a wrong offset!");
static_assert(offsetof(AIncriminationClue, ShowObjectiveMarkerIn) == 0x0002A4, "Member 'AIncriminationClue::ShowObjectiveMarkerIn' has a wrong offset!");
static_assert(offsetof(AIncriminationClue, NextClue) == 0x0002A8, "Member 'AIncriminationClue::NextClue' has a wrong offset!");
static_assert(offsetof(AIncriminationClue, ClueName) == 0x0002B0, "Member 'AIncriminationClue::ClueName' has a wrong offset!");
static_assert(offsetof(AIncriminationClue, ClueFoundMessage) == 0x0002C8, "Member 'AIncriminationClue::ClueFoundMessage' has a wrong offset!");
static_assert(offsetof(AIncriminationClue, SpawnPointOwner) == 0x0002E0, "Member 'AIncriminationClue::SpawnPointOwner' has a wrong offset!");
static_assert(offsetof(AIncriminationClue, ClueState) == 0x0002E9, "Member 'AIncriminationClue::ClueState' has a wrong offset!");

// Class ReadyOrNot.IncriminationGM
// 0x0020 (0x07F0 - 0x07D0)
class AIncriminationGM final  : public AReadyOrNotGameMode_PVP
{
public:
	uint8                                         MaxCluesToFind;                                    // 0x07D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26B3[0x7];                                     // 0x07D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ASpawnGenerator*                        ChosenSpawnGroup_BlueTeam;                         // 0x07D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASpawnGenerator*                        ChosenSpawnGroup_RedTeam;                          // 0x07E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26B4[0x8];                                     // 0x07E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClueFound(class AIncriminationClue* ClueActor, class AActor* ClueFounder);
	void OnEvidenceDropped(class AActor* DropActor);
	void OnEvidencePickedUp(class AActor* PickupActor);

	bool HasVisitedAllEvidenceSpawns() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncriminationGM">();
	}
	static class AIncriminationGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIncriminationGM>();
	}
};
static_assert(alignof(AIncriminationGM) == 0x000010, "Wrong alignment on AIncriminationGM");
static_assert(sizeof(AIncriminationGM) == 0x0007F0, "Wrong size on AIncriminationGM");
static_assert(offsetof(AIncriminationGM, MaxCluesToFind) == 0x0007D0, "Member 'AIncriminationGM::MaxCluesToFind' has a wrong offset!");
static_assert(offsetof(AIncriminationGM, ChosenSpawnGroup_BlueTeam) == 0x0007D8, "Member 'AIncriminationGM::ChosenSpawnGroup_BlueTeam' has a wrong offset!");
static_assert(offsetof(AIncriminationGM, ChosenSpawnGroup_RedTeam) == 0x0007E0, "Member 'AIncriminationGM::ChosenSpawnGroup_RedTeam' has a wrong offset!");

// Class ReadyOrNot.InGameLogSubsystem
// 0x0040 (0x0070 - 0x0030)
class UInGameLogSubsystem final  : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnLogMessageEnqueued;                              // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLogMessageDequeued;                              // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_26B5[0x20];                                    // 0x0050(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnqueueLogMessage(const struct FInGameLogMessage& InLogMessage);
	void EnqueueLogMessages(TArray<struct FInGameLogMessage>& InLogMessages);
	void EnqueuePVPMessage(const struct FInGameLogMessage_PVP& InLogMessage);
	void EnqueuePVPMessages(TArray<struct FInGameLogMessage_PVP>& InLogMessages);
	bool GetNextLogMessage(struct FInGameLogMessage* OutLogMessage);
	bool GetNextLogMessage_PVP(struct FInGameLogMessage_PVP* OutLogMessage);
	void OnLogMessageDequeued__DelegateSignature();
	void OnLogMessageEnqueued__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameLogSubsystem">();
	}
	static class UInGameLogSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameLogSubsystem>();
	}
};
static_assert(alignof(UInGameLogSubsystem) == 0x000008, "Wrong alignment on UInGameLogSubsystem");
static_assert(sizeof(UInGameLogSubsystem) == 0x000070, "Wrong size on UInGameLogSubsystem");
static_assert(offsetof(UInGameLogSubsystem, OnLogMessageEnqueued) == 0x000030, "Member 'UInGameLogSubsystem::OnLogMessageEnqueued' has a wrong offset!");
static_assert(offsetof(UInGameLogSubsystem, OnLogMessageDequeued) == 0x000040, "Member 'UInGameLogSubsystem::OnLogMessageDequeued' has a wrong offset!");

// Class ReadyOrNot.MemorialWidget
// 0x0010 (0x0330 - 0x0320)
class UMemorialWidget : public UCommonActivatableWidget
{
public:
	TArray<class URosterCharacter*>               MemorialCharacters;                                // 0x0320(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void CloseMemorialWidget();
	TArray<class URosterCharacter*> GetMemorialCharacters();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MemorialWidget">();
	}
	static class UMemorialWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMemorialWidget>();
	}
};
static_assert(alignof(UMemorialWidget) == 0x000008, "Wrong alignment on UMemorialWidget");
static_assert(sizeof(UMemorialWidget) == 0x000330, "Wrong size on UMemorialWidget");
static_assert(offsetof(UMemorialWidget, MemorialCharacters) == 0x000320, "Member 'UMemorialWidget::MemorialCharacters' has a wrong offset!");

// Class ReadyOrNot.PersonalizationWidget
// 0x0008 (0x0268 - 0x0260)
class UPersonalizationWidget : public UUserWidget
{
public:
	class ACharacterCustomizationPortal*          SpawnedFromPortal;                                 // 0x0260(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonalizationWidget">();
	}
	static class UPersonalizationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonalizationWidget>();
	}
};
static_assert(alignof(UPersonalizationWidget) == 0x000008, "Wrong alignment on UPersonalizationWidget");
static_assert(sizeof(UPersonalizationWidget) == 0x000268, "Wrong size on UPersonalizationWidget");
static_assert(offsetof(UPersonalizationWidget, SpawnedFromPortal) == 0x000260, "Member 'UPersonalizationWidget::SpawnedFromPortal' has a wrong offset!");

// Class ReadyOrNot.InteractableComponent
// 0x0430 (0x09D0 - 0x05A0)
class UInteractableComponent final  : public UWidgetComponent
{
public:
	uint8                                         bEnabled : 1;                                      // 0x05A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_26B8[0x3];                                     // 0x05A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimatedIconName;                                  // 0x05A4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowActionPromptInWorld;                          // 0x05AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableActionPromptBackground;                     // 0x05AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideActionPromptUserSettings;                 // 0x05AE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShowIconWhenActionsLocked : 1;                    // 0x05AF(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	struct FPlayerActionPromptSlot                ActionSlot1;                                       // 0x05B0(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPlayerActionPromptSlot                ActionSlot2;                                       // 0x0640(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPlayerActionPromptSlot                ActionSlot3;                                       // 0x06D0(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPlayerActionPromptSlot                ActionSlot4;                                       // 0x0760(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bDistanceChecksEnabled;                            // 0x07F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26B9[0x3];                                     // 0x07F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinShowPromptAtDistance;                           // 0x07F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShowPromptAtDistance;                              // 0x07F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMustBeLookingAt : 1;                              // 0x07FC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_26BA[0x3];                                     // 0x07FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RequiredLookAtPercentage;                          // 0x0800(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustBeOverlapping;                                // 0x0804(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26BB[0x3];                                     // 0x0805(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractCircleSize;                                // 0x0808(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractIconSize;                                  // 0x080C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDistanceFadeIcon : 1;                             // 0x0810(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideUponInteraction : 1;                          // 0x0810(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideUponPlayerMovement : 1;                       // 0x0810(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bImprintIconOnHUDUponInteraction : 1;              // 0x0810(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_26BC[0x7];                                     // 0x0811(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerController*>              DisallowedPlayerControllers;                       // 0x0818(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreInteractionBlockingActors;                   // 0x0828(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         CurrentProgress;                                   // 0x0838(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26BD[0x4];                                     // 0x083C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimatedIcon                          AnimatedIcon;                                      // 0x0840(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class AActor*                                 UseActor;                                          // 0x0858(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClientInteract;                                   // 0x0860(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExecuteOnServer;                                  // 0x0861(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26BE[0x6];                                     // 0x0862(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerCharacter*>               PlayersFocusing;                                   // 0x0868(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                CachedWidgetClass;                                 // 0x0878(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimatedIconWidgetWithActionPrompt*    IconWidget;                                        // 0x0880(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                ImprintIconWidgetClass;                            // 0x0888(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimatedIconWidget_Imprint*            IconWidget_Imprint;                                // 0x0890(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FAnimatedIcon>       AnimatedIconMap;                                   // 0x0898(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_26BF[0xE8];                                    // 0x08E8(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableInteractable();
	void DisableInteractionFor(class APlayerCharacter* InCharacter);
	void EnableInteractable();
	void EnableInteractionFor(class APlayerCharacter* InCharacter);
	bool InputActionNameMatchesAnySlot(class FName InInputActionName);
	bool InputActionNameMatchesAnyValidSlot(class FName InInputActionName);
	bool IsBeingLookedAt(class APlayerController* InPlayerController, float MaxRange, float LookatThreshold, bool bUseActorLocation);
	bool IsInteractionEnabledFor(class APlayerCharacter* InCharacter);
	void OnInteract(class APlayerCharacter* InteractInstigator);
	void ResetToOriginalLocation();
	void SetAnimatedIconName(class FName& NewIconName);
	void SetInteractionIconSize(float InInteractCircleSize, float InInteractIconSize);
	void SetInteractionIconState(bool bValid);

	bool AnyActionSlotValid() const;
	bool CanInteract(bool bLog) const;
	float GetDistanceFromPlayer() const;
	class FName GetOriginalIconName() const;
	struct FVector GetOriginalLocation() const;
	struct FVector GetOriginalLocation_Relative() const;
	TArray<class APlayerCharacter*> GetPlayersFocusing() const;
	class AActor* GetUseActor() const;
	bool IsFocused() const;
	bool IsIconVisible() const;
	bool IsInteractionEnabledForController(class APlayerController* InController) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableComponent">();
	}
	static class UInteractableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractableComponent>();
	}
};
static_assert(alignof(UInteractableComponent) == 0x000010, "Wrong alignment on UInteractableComponent");
static_assert(sizeof(UInteractableComponent) == 0x0009D0, "Wrong size on UInteractableComponent");
static_assert(offsetof(UInteractableComponent, AnimatedIconName) == 0x0005A4, "Member 'UInteractableComponent::AnimatedIconName' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bShowActionPromptInWorld) == 0x0005AC, "Member 'UInteractableComponent::bShowActionPromptInWorld' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bEnableActionPromptBackground) == 0x0005AD, "Member 'UInteractableComponent::bEnableActionPromptBackground' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bOverrideActionPromptUserSettings) == 0x0005AE, "Member 'UInteractableComponent::bOverrideActionPromptUserSettings' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ActionSlot1) == 0x0005B0, "Member 'UInteractableComponent::ActionSlot1' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ActionSlot2) == 0x000640, "Member 'UInteractableComponent::ActionSlot2' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ActionSlot3) == 0x0006D0, "Member 'UInteractableComponent::ActionSlot3' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ActionSlot4) == 0x000760, "Member 'UInteractableComponent::ActionSlot4' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bDistanceChecksEnabled) == 0x0007F0, "Member 'UInteractableComponent::bDistanceChecksEnabled' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, MinShowPromptAtDistance) == 0x0007F4, "Member 'UInteractableComponent::MinShowPromptAtDistance' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ShowPromptAtDistance) == 0x0007F8, "Member 'UInteractableComponent::ShowPromptAtDistance' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, RequiredLookAtPercentage) == 0x000800, "Member 'UInteractableComponent::RequiredLookAtPercentage' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bMustBeOverlapping) == 0x000804, "Member 'UInteractableComponent::bMustBeOverlapping' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractCircleSize) == 0x000808, "Member 'UInteractableComponent::InteractCircleSize' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractIconSize) == 0x00080C, "Member 'UInteractableComponent::InteractIconSize' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, DisallowedPlayerControllers) == 0x000818, "Member 'UInteractableComponent::DisallowedPlayerControllers' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, IgnoreInteractionBlockingActors) == 0x000828, "Member 'UInteractableComponent::IgnoreInteractionBlockingActors' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, CurrentProgress) == 0x000838, "Member 'UInteractableComponent::CurrentProgress' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, AnimatedIcon) == 0x000840, "Member 'UInteractableComponent::AnimatedIcon' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, UseActor) == 0x000858, "Member 'UInteractableComponent::UseActor' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bClientInteract) == 0x000860, "Member 'UInteractableComponent::bClientInteract' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bExecuteOnServer) == 0x000861, "Member 'UInteractableComponent::bExecuteOnServer' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, PlayersFocusing) == 0x000868, "Member 'UInteractableComponent::PlayersFocusing' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, CachedWidgetClass) == 0x000878, "Member 'UInteractableComponent::CachedWidgetClass' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, IconWidget) == 0x000880, "Member 'UInteractableComponent::IconWidget' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ImprintIconWidgetClass) == 0x000888, "Member 'UInteractableComponent::ImprintIconWidgetClass' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, IconWidget_Imprint) == 0x000890, "Member 'UInteractableComponent::IconWidget_Imprint' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, AnimatedIconMap) == 0x000898, "Member 'UInteractableComponent::AnimatedIconMap' has a wrong offset!");

// Class ReadyOrNot.Quadrotor
// 0x0080 (0x0A50 - 0x09D0)
class AQuadrotor final  : public ABaseItem
{
public:
	class USkeletalMeshComponent*                 ViewfinderMesh;                                    // 0x09D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneCaptureComponent2D*               SceneCapture2D;                                    // 0x09D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x09E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bToggleDroneControl;                               // 0x09E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C5[0x7];                                     // 0x09E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterial*                              DefaultViewfinderMaterial;                         // 0x09F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ViewfinderScreenMaterial;                          // 0x09F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LocalPlayerCaptureResolution;                      // 0x0A00(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SimulatedPlayerCaptureResolution;                  // 0x0A08(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C6[0x8];                                     // 0x0A10(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ViewfinderSocket_Hands;                            // 0x0A18(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ViewfinderSocket_Body;                             // 0x0A20(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ThrowDrone_1P;                                     // 0x0A28(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ThrowDrone_3P;                                     // 0x0A30(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AQuadrotorPawn>             DronePawnClass;                                    // 0x0A38(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQuadrotorPawn*                         SpawnedDrone;                                      // 0x0A40(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C7[0x8];                                     // 0x0A48(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_SpawnDrone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Quadrotor">();
	}
	static class AQuadrotor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AQuadrotor>();
	}
};
static_assert(alignof(AQuadrotor) == 0x000010, "Wrong alignment on AQuadrotor");
static_assert(sizeof(AQuadrotor) == 0x000A50, "Wrong size on AQuadrotor");
static_assert(offsetof(AQuadrotor, ViewfinderMesh) == 0x0009D0, "Member 'AQuadrotor::ViewfinderMesh' has a wrong offset!");
static_assert(offsetof(AQuadrotor, SceneCapture2D) == 0x0009D8, "Member 'AQuadrotor::SceneCapture2D' has a wrong offset!");
static_assert(offsetof(AQuadrotor, RenderTarget) == 0x0009E0, "Member 'AQuadrotor::RenderTarget' has a wrong offset!");
static_assert(offsetof(AQuadrotor, bToggleDroneControl) == 0x0009E8, "Member 'AQuadrotor::bToggleDroneControl' has a wrong offset!");
static_assert(offsetof(AQuadrotor, DefaultViewfinderMaterial) == 0x0009F0, "Member 'AQuadrotor::DefaultViewfinderMaterial' has a wrong offset!");
static_assert(offsetof(AQuadrotor, ViewfinderScreenMaterial) == 0x0009F8, "Member 'AQuadrotor::ViewfinderScreenMaterial' has a wrong offset!");
static_assert(offsetof(AQuadrotor, LocalPlayerCaptureResolution) == 0x000A00, "Member 'AQuadrotor::LocalPlayerCaptureResolution' has a wrong offset!");
static_assert(offsetof(AQuadrotor, SimulatedPlayerCaptureResolution) == 0x000A08, "Member 'AQuadrotor::SimulatedPlayerCaptureResolution' has a wrong offset!");
static_assert(offsetof(AQuadrotor, ViewfinderSocket_Hands) == 0x000A18, "Member 'AQuadrotor::ViewfinderSocket_Hands' has a wrong offset!");
static_assert(offsetof(AQuadrotor, ViewfinderSocket_Body) == 0x000A20, "Member 'AQuadrotor::ViewfinderSocket_Body' has a wrong offset!");
static_assert(offsetof(AQuadrotor, ThrowDrone_1P) == 0x000A28, "Member 'AQuadrotor::ThrowDrone_1P' has a wrong offset!");
static_assert(offsetof(AQuadrotor, ThrowDrone_3P) == 0x000A30, "Member 'AQuadrotor::ThrowDrone_3P' has a wrong offset!");
static_assert(offsetof(AQuadrotor, DronePawnClass) == 0x000A38, "Member 'AQuadrotor::DronePawnClass' has a wrong offset!");
static_assert(offsetof(AQuadrotor, SpawnedDrone) == 0x000A40, "Member 'AQuadrotor::SpawnedDrone' has a wrong offset!");

// Class ReadyOrNot.InteractionsData
// 0x0078 (0x00A8 - 0x0030)
class UInteractionsData final  : public UDataAsset
{
public:
	class FName                                   InteractionName;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLooping : 1;                                      // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowDeadDriverInteraction : 1;                   // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowDeadSlaveInteraction : 1;                    // 0x0038(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowAimOffsetDuringInteraction : 1;              // 0x0038(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyRelativeOffsetBeforePlaying : 1;             // 0x0038(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseSyncBone : 1;                                  // 0x0038(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSweepEnvironment : 1;                             // 0x0038(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDoNotApplyRelativeOffset : 1;                     // 0x0038(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_26C8[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RelativePosOffsetToDriver;                         // 0x003C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotOffsetToDriver;                         // 0x0048(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CancelDurationLength;                              // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHolsterItemBeforePlaying : 1;                     // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInstantHolster : 1;                               // 0x0058(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEquipLastItemAfterPlaying : 1;                    // 0x0058(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdateSlaveTransform : 1;                         // 0x0058(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdateTransformsInstantly : 1;                    // 0x0058(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIndependentFinishes : 1;                          // 0x0058(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseDriverFPMotion : 1;                            // 0x0058(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_26C9[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           DriverMontage;                                     // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DriverMontage_FP;                                  // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerTolerance;                                  // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DriverBlendDuration;                               // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseSlaveFPMotion : 1;                             // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_26CA[0x7];                                     // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           SlaveMontage;                                      // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SlaveMontage_FP;                                   // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMatchDriverYaw : 1;                               // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_26CB[0x3];                                     // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MatchedYawOffset;                                  // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasSharedItemAnim : 1;                            // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_26CC[0x7];                                     // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           SharedItemMontage;                                 // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class APairedInteractionDriver* IsPairedInteractionPlayingOn(class AActor* Target);

	class APairedInteractionDriver* PlayPairedInteraction(class AActor* Driver, class AActor* Slave, class ABaseItem* OptionalItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionsData">();
	}
	static class UInteractionsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionsData>();
	}
};
static_assert(alignof(UInteractionsData) == 0x000008, "Wrong alignment on UInteractionsData");
static_assert(sizeof(UInteractionsData) == 0x0000A8, "Wrong size on UInteractionsData");
static_assert(offsetof(UInteractionsData, InteractionName) == 0x000030, "Member 'UInteractionsData::InteractionName' has a wrong offset!");
static_assert(offsetof(UInteractionsData, RelativePosOffsetToDriver) == 0x00003C, "Member 'UInteractionsData::RelativePosOffsetToDriver' has a wrong offset!");
static_assert(offsetof(UInteractionsData, RelativeRotOffsetToDriver) == 0x000048, "Member 'UInteractionsData::RelativeRotOffsetToDriver' has a wrong offset!");
static_assert(offsetof(UInteractionsData, CancelDurationLength) == 0x000054, "Member 'UInteractionsData::CancelDurationLength' has a wrong offset!");
static_assert(offsetof(UInteractionsData, DriverMontage) == 0x000060, "Member 'UInteractionsData::DriverMontage' has a wrong offset!");
static_assert(offsetof(UInteractionsData, DriverMontage_FP) == 0x000068, "Member 'UInteractionsData::DriverMontage_FP' has a wrong offset!");
static_assert(offsetof(UInteractionsData, TriggerTolerance) == 0x000070, "Member 'UInteractionsData::TriggerTolerance' has a wrong offset!");
static_assert(offsetof(UInteractionsData, DriverBlendDuration) == 0x000074, "Member 'UInteractionsData::DriverBlendDuration' has a wrong offset!");
static_assert(offsetof(UInteractionsData, SlaveMontage) == 0x000080, "Member 'UInteractionsData::SlaveMontage' has a wrong offset!");
static_assert(offsetof(UInteractionsData, SlaveMontage_FP) == 0x000088, "Member 'UInteractionsData::SlaveMontage_FP' has a wrong offset!");
static_assert(offsetof(UInteractionsData, MatchedYawOffset) == 0x000094, "Member 'UInteractionsData::MatchedYawOffset' has a wrong offset!");
static_assert(offsetof(UInteractionsData, SharedItemMontage) == 0x0000A0, "Member 'UInteractionsData::SharedItemMontage' has a wrong offset!");

// Class ReadyOrNot.MoveIntoLOSActivity
// 0x0008 (0x01B0 - 0x01A8)
class UMoveIntoLOSActivity final  : public UBaseActivity
{
public:
	class AActor*                                 LOSActor;                                          // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveIntoLOSActivity">();
	}
	static class UMoveIntoLOSActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveIntoLOSActivity>();
	}
};
static_assert(alignof(UMoveIntoLOSActivity) == 0x000008, "Wrong alignment on UMoveIntoLOSActivity");
static_assert(sizeof(UMoveIntoLOSActivity) == 0x0001B0, "Wrong size on UMoveIntoLOSActivity");
static_assert(offsetof(UMoveIntoLOSActivity, LOSActor) == 0x0001A8, "Member 'UMoveIntoLOSActivity::LOSActor' has a wrong offset!");

// Class ReadyOrNot.InterestOverrideZone
// 0x00D0 (0x0328 - 0x0258)
class AInterestOverrideZone final  : public AVolume
{
public:
	TArray<struct FInterestPoint>                 InterestPoints;                                    // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<struct FInterestStationPoint>          StationPoints;                                     // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<class ACyberneticCharacter*>           CharactersInZone;                                  // 0x0278(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<class ACyberneticCharacter*, uint8>      FocusIndexMap;                                     // 0x0288(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<class ACyberneticCharacter*, uint8>      MoveIndexMap;                                      // 0x02D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnWorldBeginPlay();

	bool GetCurrentInterestInfo(class ACyberneticCharacter* AI, struct FVector* OutLocation, class AActor** OutActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterestOverrideZone">();
	}
	static class AInterestOverrideZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInterestOverrideZone>();
	}
};
static_assert(alignof(AInterestOverrideZone) == 0x000008, "Wrong alignment on AInterestOverrideZone");
static_assert(sizeof(AInterestOverrideZone) == 0x000328, "Wrong size on AInterestOverrideZone");
static_assert(offsetof(AInterestOverrideZone, InterestPoints) == 0x000258, "Member 'AInterestOverrideZone::InterestPoints' has a wrong offset!");
static_assert(offsetof(AInterestOverrideZone, StationPoints) == 0x000268, "Member 'AInterestOverrideZone::StationPoints' has a wrong offset!");
static_assert(offsetof(AInterestOverrideZone, CharactersInZone) == 0x000278, "Member 'AInterestOverrideZone::CharactersInZone' has a wrong offset!");
static_assert(offsetof(AInterestOverrideZone, FocusIndexMap) == 0x000288, "Member 'AInterestOverrideZone::FocusIndexMap' has a wrong offset!");
static_assert(offsetof(AInterestOverrideZone, MoveIndexMap) == 0x0002D8, "Member 'AInterestOverrideZone::MoveIndexMap' has a wrong offset!");

// Class ReadyOrNot.WorldBuildingActivity
// 0x0098 (0x0240 - 0x01A8)
class UWorldBuildingActivity : public UBaseActivity
{
public:
	bool                                          bShouldHolsterWeapon;                              // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldSurrenderFromActivity;                      // 0x01A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireRotationMatch;                             // 0x01AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26CF[0x19];                                    // 0x01AB(0x0019)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FinalRotationOffset;                               // 0x01C4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bOneShotAnimationDataTable;                        // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D0[0x7];                                     // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TableMontageName;                                  // 0x01D8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Loop;                                              // 0x01E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageStart;                                      // 0x01F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           MontageEnd;                                        // 0x01F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           MontageAbruptEnd;                                  // 0x0200(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 StartActivitySpeech;                               // 0x0208(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 FinishActivitySpeech;                              // 0x0218(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           TableMontageAnim;                                  // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26D1[0x10];                                    // 0x0230(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterAbruptEndState();
	void EnterCompleteState();
	void EnterEndState();
	void EnterLoopState();
	void EnterMoveToState();
	void EnterStartState();
	void SetRotation(const struct FRotator& NewRotator);
	void TickLoopState(float DeltaTime, float Uptime);
	void TickMoveToState(float DeltaTime, float Uptime);

	struct FRotator GetRotationOffset() const;
	bool IsSetupCorrectly() const;
	bool ShouldComplete() const;
	bool ShouldEnd() const;
	bool ShouldEndAbruptly() const;
	bool ShouldLoop() const;
	bool ShouldStart() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldBuildingActivity">();
	}
	static class UWorldBuildingActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldBuildingActivity>();
	}
};
static_assert(alignof(UWorldBuildingActivity) == 0x000008, "Wrong alignment on UWorldBuildingActivity");
static_assert(sizeof(UWorldBuildingActivity) == 0x000240, "Wrong size on UWorldBuildingActivity");
static_assert(offsetof(UWorldBuildingActivity, bShouldHolsterWeapon) == 0x0001A8, "Member 'UWorldBuildingActivity::bShouldHolsterWeapon' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, bShouldSurrenderFromActivity) == 0x0001A9, "Member 'UWorldBuildingActivity::bShouldSurrenderFromActivity' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, bRequireRotationMatch) == 0x0001AA, "Member 'UWorldBuildingActivity::bRequireRotationMatch' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, FinalRotationOffset) == 0x0001C4, "Member 'UWorldBuildingActivity::FinalRotationOffset' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, bOneShotAnimationDataTable) == 0x0001D0, "Member 'UWorldBuildingActivity::bOneShotAnimationDataTable' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, TableMontageName) == 0x0001D8, "Member 'UWorldBuildingActivity::TableMontageName' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, Loop) == 0x0001E8, "Member 'UWorldBuildingActivity::Loop' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, MontageStart) == 0x0001F0, "Member 'UWorldBuildingActivity::MontageStart' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, MontageEnd) == 0x0001F8, "Member 'UWorldBuildingActivity::MontageEnd' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, MontageAbruptEnd) == 0x000200, "Member 'UWorldBuildingActivity::MontageAbruptEnd' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, StartActivitySpeech) == 0x000208, "Member 'UWorldBuildingActivity::StartActivitySpeech' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, FinishActivitySpeech) == 0x000218, "Member 'UWorldBuildingActivity::FinishActivitySpeech' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, TableMontageAnim) == 0x000228, "Member 'UWorldBuildingActivity::TableMontageAnim' has a wrong offset!");

// Class ReadyOrNot.InvestigateActivity
// 0x0000 (0x0240 - 0x0240)
class UInvestigateActivity final  : public UWorldBuildingActivity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvestigateActivity">();
	}
	static class UInvestigateActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvestigateActivity>();
	}
};
static_assert(alignof(UInvestigateActivity) == 0x000008, "Wrong alignment on UInvestigateActivity");
static_assert(sizeof(UInvestigateActivity) == 0x000240, "Wrong size on UInvestigateActivity");

// Class ReadyOrNot.SearchAndDestroyGS
// 0x0010 (0x07F0 - 0x07E0)
class ASearchAndDestroyGS final  : public AReadyOrNotGameState
{
public:
	float                                         BombCountActive;                                   // 0x07E0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBombPlanted;                                      // 0x07E4(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBombDetonate;                                     // 0x07E5(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBombDefused;                                      // 0x07E6(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D2[0x1];                                     // 0x07E7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       bHasBomb;                                          // 0x07E8(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchAndDestroyGS">();
	}
	static class ASearchAndDestroyGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASearchAndDestroyGS>();
	}
};
static_assert(alignof(ASearchAndDestroyGS) == 0x000008, "Wrong alignment on ASearchAndDestroyGS");
static_assert(sizeof(ASearchAndDestroyGS) == 0x0007F0, "Wrong size on ASearchAndDestroyGS");
static_assert(offsetof(ASearchAndDestroyGS, BombCountActive) == 0x0007E0, "Member 'ASearchAndDestroyGS::BombCountActive' has a wrong offset!");
static_assert(offsetof(ASearchAndDestroyGS, bBombPlanted) == 0x0007E4, "Member 'ASearchAndDestroyGS::bBombPlanted' has a wrong offset!");
static_assert(offsetof(ASearchAndDestroyGS, bBombDetonate) == 0x0007E5, "Member 'ASearchAndDestroyGS::bBombDetonate' has a wrong offset!");
static_assert(offsetof(ASearchAndDestroyGS, bBombDefused) == 0x0007E6, "Member 'ASearchAndDestroyGS::bBombDefused' has a wrong offset!");
static_assert(offsetof(ASearchAndDestroyGS, bHasBomb) == 0x0007E8, "Member 'ASearchAndDestroyGS::bHasBomb' has a wrong offset!");

// Class ReadyOrNot.InvestigateStimulusActivity
// 0x0068 (0x0210 - 0x01A8)
class UInvestigateStimulusActivity final  : public UBaseActivity
{
public:
	struct FAIStimulus                            Stimulus;                                          // 0x01A8(0x003C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D3[0x4];                                     // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   Instigator;                                        // 0x01E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D4[0x20];                                    // 0x01F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvestigateStimulusActivity">();
	}
	static class UInvestigateStimulusActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvestigateStimulusActivity>();
	}
};
static_assert(alignof(UInvestigateStimulusActivity) == 0x000008, "Wrong alignment on UInvestigateStimulusActivity");
static_assert(sizeof(UInvestigateStimulusActivity) == 0x000210, "Wrong size on UInvestigateStimulusActivity");
static_assert(offsetof(UInvestigateStimulusActivity, Stimulus) == 0x0001A8, "Member 'UInvestigateStimulusActivity::Stimulus' has a wrong offset!");
static_assert(offsetof(UInvestigateStimulusActivity, Instigator) == 0x0001E8, "Member 'UInvestigateStimulusActivity::Instigator' has a wrong offset!");

// Class ReadyOrNot.ProgressionRequirement
// 0x0000 (0x0028 - 0x0028)
class UProgressionRequirement : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressionRequirement">();
	}
	static class UProgressionRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProgressionRequirement>();
	}
};
static_assert(alignof(UProgressionRequirement) == 0x000008, "Wrong alignment on UProgressionRequirement");
static_assert(sizeof(UProgressionRequirement) == 0x000028, "Wrong size on UProgressionRequirement");

// Class ReadyOrNot.ItemSlot_V2
// 0x0038 (0x02C0 - 0x0288)
class UItemSlot_V2 : public UCommonUserWidget
{
public:
	class ABaseItem*                              BaseItem;                                          // 0x0288(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArmourMaterial*                        ArmorMaterial;                                     // 0x0290(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemName;                                          // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemType;                                          // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         PrefixText;                                        // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PresetName;                                        // 0x02B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetArmorMaterial(class UArmourMaterial* Armor);
	void SetItem(class ABaseItem* Item);
	void SetTexts(class FText Param_Name, class FText Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSlot_V2">();
	}
	static class UItemSlot_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSlot_V2>();
	}
};
static_assert(alignof(UItemSlot_V2) == 0x000008, "Wrong alignment on UItemSlot_V2");
static_assert(sizeof(UItemSlot_V2) == 0x0002C0, "Wrong size on UItemSlot_V2");
static_assert(offsetof(UItemSlot_V2, BaseItem) == 0x000288, "Member 'UItemSlot_V2::BaseItem' has a wrong offset!");
static_assert(offsetof(UItemSlot_V2, ArmorMaterial) == 0x000290, "Member 'UItemSlot_V2::ArmorMaterial' has a wrong offset!");
static_assert(offsetof(UItemSlot_V2, ItemName) == 0x000298, "Member 'UItemSlot_V2::ItemName' has a wrong offset!");
static_assert(offsetof(UItemSlot_V2, ItemType) == 0x0002A0, "Member 'UItemSlot_V2::ItemType' has a wrong offset!");
static_assert(offsetof(UItemSlot_V2, PrefixText) == 0x0002A8, "Member 'UItemSlot_V2::PrefixText' has a wrong offset!");
static_assert(offsetof(UItemSlot_V2, PresetName) == 0x0002B0, "Member 'UItemSlot_V2::PresetName' has a wrong offset!");

// Class ReadyOrNot.MissionPlanWidget
// 0x00D0 (0x0330 - 0x0260)
class UMissionPlanWidget : public UUserWidget
{
public:
	uint8                                         Pad_26D5[0x40];                                    // 0x0260(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class AMissionPlanManager*                    MissionPlanManager;                                // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODAudioComponent*                    DrawingAudioComponent;                             // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LineThickness;                                     // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x02B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ActiveLineColor;                                   // 0x02C8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlanLineWidth;                                     // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstNodeRadius;                                   // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NodeRadius;                                        // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D6[0x4];                                     // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     PlanLineMaterial;                                  // 0x02E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DrawingSoundEvent;                                 // 0x02F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DrawingFloor;                                      // 0x02F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D7[0x4];                                     // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                DrawingTargetWidget;                               // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlanningLine                          PreviewLine;                                       // 0x0308(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void AddLine(struct FPlanningLine& Line);
	void AddMarker(struct FPlanningMarker& Marker);
	void OnEntryPointChanged(const struct FEntryPoint& NewEntryPoint);
	void OnLineAdded(int32 ID, struct FPlanningLine& Line);
	void OnLineRemoved(int32 ID);
	void OnMarkerAdded(int32 ID, struct FPlanningMarker& Marker);
	void OnMarkerRemoved(int32 ID);
	void OnMissionChanged(const class FString& URL, struct FLevelDataLookupTable& LevelData);
	void RemoveLine(int32 ID);
	void RemoveMarker(int32 ID);
	void SetEntryPoint(class FName EntryPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionPlanWidget">();
	}
	static class UMissionPlanWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionPlanWidget>();
	}
};
static_assert(alignof(UMissionPlanWidget) == 0x000008, "Wrong alignment on UMissionPlanWidget");
static_assert(sizeof(UMissionPlanWidget) == 0x000330, "Wrong size on UMissionPlanWidget");
static_assert(offsetof(UMissionPlanWidget, MissionPlanManager) == 0x0002A0, "Member 'UMissionPlanWidget::MissionPlanManager' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, DrawingAudioComponent) == 0x0002A8, "Member 'UMissionPlanWidget::DrawingAudioComponent' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, LineThickness) == 0x0002B0, "Member 'UMissionPlanWidget::LineThickness' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, FadeTime) == 0x0002B4, "Member 'UMissionPlanWidget::FadeTime' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, LineColor) == 0x0002B8, "Member 'UMissionPlanWidget::LineColor' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, ActiveLineColor) == 0x0002C8, "Member 'UMissionPlanWidget::ActiveLineColor' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, PlanLineWidth) == 0x0002D8, "Member 'UMissionPlanWidget::PlanLineWidth' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, FirstNodeRadius) == 0x0002DC, "Member 'UMissionPlanWidget::FirstNodeRadius' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, NodeRadius) == 0x0002E0, "Member 'UMissionPlanWidget::NodeRadius' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, PlanLineMaterial) == 0x0002E8, "Member 'UMissionPlanWidget::PlanLineMaterial' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, DrawingSoundEvent) == 0x0002F0, "Member 'UMissionPlanWidget::DrawingSoundEvent' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, DrawingFloor) == 0x0002F8, "Member 'UMissionPlanWidget::DrawingFloor' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, DrawingTargetWidget) == 0x000300, "Member 'UMissionPlanWidget::DrawingTargetWidget' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, PreviewLine) == 0x000308, "Member 'UMissionPlanWidget::PreviewLine' has a wrong offset!");

// Class ReadyOrNot.ItemVisualizationComponent
// 0x0030 (0x0F00 - 0x0ED0)
class UItemVisualizationComponent final  : public USkeletalMeshComponent
{
public:
	EItemVisualizationType                        VisualizationType;                                 // 0x0EC8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D9[0x7];                                     // 0x0EC9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseItem*                              BasedOfItem;                                       // 0x0ED0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   MagazineComp;                                      // 0x0ED8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 ScopeAttachment;                                   // 0x0EE0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MuzzleAttachment;                                  // 0x0EE8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 UnderbarrelAttachment;                             // 0x0EF0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 OverbarrelAttachment;                              // 0x0EF8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemVisualizationComponent">();
	}
	static class UItemVisualizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemVisualizationComponent>();
	}
};
static_assert(alignof(UItemVisualizationComponent) == 0x000010, "Wrong alignment on UItemVisualizationComponent");
static_assert(sizeof(UItemVisualizationComponent) == 0x000F00, "Wrong size on UItemVisualizationComponent");
static_assert(offsetof(UItemVisualizationComponent, VisualizationType) == 0x000EC8, "Member 'UItemVisualizationComponent::VisualizationType' has a wrong offset!");
static_assert(offsetof(UItemVisualizationComponent, BasedOfItem) == 0x000ED0, "Member 'UItemVisualizationComponent::BasedOfItem' has a wrong offset!");
static_assert(offsetof(UItemVisualizationComponent, MagazineComp) == 0x000ED8, "Member 'UItemVisualizationComponent::MagazineComp' has a wrong offset!");
static_assert(offsetof(UItemVisualizationComponent, ScopeAttachment) == 0x000EE0, "Member 'UItemVisualizationComponent::ScopeAttachment' has a wrong offset!");
static_assert(offsetof(UItemVisualizationComponent, MuzzleAttachment) == 0x000EE8, "Member 'UItemVisualizationComponent::MuzzleAttachment' has a wrong offset!");
static_assert(offsetof(UItemVisualizationComponent, UnderbarrelAttachment) == 0x000EF0, "Member 'UItemVisualizationComponent::UnderbarrelAttachment' has a wrong offset!");
static_assert(offsetof(UItemVisualizationComponent, OverbarrelAttachment) == 0x000EF8, "Member 'UItemVisualizationComponent::OverbarrelAttachment' has a wrong offset!");

// Class ReadyOrNot.PlayerSpeedIndicator_V2
// 0x0078 (0x02F0 - 0x0278)
class UPlayerSpeedIndicator_V2 final  : public UBaseWidget
{
public:
	class USizeBox*                               Twenty_Box;                                        // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Twenty_Image;                                      // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               Fourty_Box;                                        // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Fourty_Image;                                      // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               Sixty_Box;                                         // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Sixty_Image;                                       // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               Eighty_Box;                                        // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Eighty_Image;                                      // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               OneHundred_Box;                                    // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 OneHundred_Image;                                  // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SpeedPercentage_Text;                              // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaselineOpacity;                                   // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeSpeed;                                         // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastSetRunSpeedPercent;                            // 0x02E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinRunSpeedPercent;                                // 0x02E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRunSpeedPercent;                                // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NormalizedRunSpeedPercent;                         // 0x02EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerSpeedIndicator_V2">();
	}
	static class UPlayerSpeedIndicator_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerSpeedIndicator_V2>();
	}
};
static_assert(alignof(UPlayerSpeedIndicator_V2) == 0x000008, "Wrong alignment on UPlayerSpeedIndicator_V2");
static_assert(sizeof(UPlayerSpeedIndicator_V2) == 0x0002F0, "Wrong size on UPlayerSpeedIndicator_V2");
static_assert(offsetof(UPlayerSpeedIndicator_V2, Twenty_Box) == 0x000278, "Member 'UPlayerSpeedIndicator_V2::Twenty_Box' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, Twenty_Image) == 0x000280, "Member 'UPlayerSpeedIndicator_V2::Twenty_Image' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, Fourty_Box) == 0x000288, "Member 'UPlayerSpeedIndicator_V2::Fourty_Box' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, Fourty_Image) == 0x000290, "Member 'UPlayerSpeedIndicator_V2::Fourty_Image' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, Sixty_Box) == 0x000298, "Member 'UPlayerSpeedIndicator_V2::Sixty_Box' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, Sixty_Image) == 0x0002A0, "Member 'UPlayerSpeedIndicator_V2::Sixty_Image' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, Eighty_Box) == 0x0002A8, "Member 'UPlayerSpeedIndicator_V2::Eighty_Box' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, Eighty_Image) == 0x0002B0, "Member 'UPlayerSpeedIndicator_V2::Eighty_Image' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, OneHundred_Box) == 0x0002B8, "Member 'UPlayerSpeedIndicator_V2::OneHundred_Box' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, OneHundred_Image) == 0x0002C0, "Member 'UPlayerSpeedIndicator_V2::OneHundred_Image' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, SpeedPercentage_Text) == 0x0002C8, "Member 'UPlayerSpeedIndicator_V2::SpeedPercentage_Text' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, PlayerCharacter) == 0x0002D0, "Member 'UPlayerSpeedIndicator_V2::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, BaselineOpacity) == 0x0002D8, "Member 'UPlayerSpeedIndicator_V2::BaselineOpacity' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, FadeSpeed) == 0x0002DC, "Member 'UPlayerSpeedIndicator_V2::FadeSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, LastSetRunSpeedPercent) == 0x0002E0, "Member 'UPlayerSpeedIndicator_V2::LastSetRunSpeedPercent' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, MinRunSpeedPercent) == 0x0002E4, "Member 'UPlayerSpeedIndicator_V2::MinRunSpeedPercent' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, MaxRunSpeedPercent) == 0x0002E8, "Member 'UPlayerSpeedIndicator_V2::MaxRunSpeedPercent' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, NormalizedRunSpeedPercent) == 0x0002EC, "Member 'UPlayerSpeedIndicator_V2::NormalizedRunSpeedPercent' has a wrong offset!");

// Class ReadyOrNot.KillHostageChanceAnimNotify
// 0x0000 (0x0038 - 0x0038)
class UKillHostageChanceAnimNotify final  : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillHostageChanceAnimNotify">();
	}
	static class UKillHostageChanceAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillHostageChanceAnimNotify>();
	}
};
static_assert(alignof(UKillHostageChanceAnimNotify) == 0x000008, "Wrong alignment on UKillHostageChanceAnimNotify");
static_assert(sizeof(UKillHostageChanceAnimNotify) == 0x000038, "Wrong size on UKillHostageChanceAnimNotify");

// Class ReadyOrNot.ReadyOrNotAudioVolume
// 0x0040 (0x0298 - 0x0258)
class AReadyOrNotAudioVolume final  : public AVolume
{
public:
	TArray<class UFMODEvent*>                     ReverbEvents;                                      // 0x0258(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bLocalEffectsPlayed;                               // 0x0268(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26DA[0x7];                                     // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFMODEventInstance>             EventInstances;                                    // 0x0270(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UFMODAudioComponent*>            AttachedAudioComponents;                           // 0x0280(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_26DB[0x8];                                     // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasRanOnce() const;
	bool IsAnotherVolumeActivatedAndPlayingEvent(class UFMODEvent* Event, struct FFMODEventInstance* EventInstance) const;
	bool IsAnotherVolumeActivatedAndPlayingEventInst(const struct FFMODEventInstance& EventInst) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotAudioVolume">();
	}
	static class AReadyOrNotAudioVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotAudioVolume>();
	}
};
static_assert(alignof(AReadyOrNotAudioVolume) == 0x000008, "Wrong alignment on AReadyOrNotAudioVolume");
static_assert(sizeof(AReadyOrNotAudioVolume) == 0x000298, "Wrong size on AReadyOrNotAudioVolume");
static_assert(offsetof(AReadyOrNotAudioVolume, ReverbEvents) == 0x000258, "Member 'AReadyOrNotAudioVolume::ReverbEvents' has a wrong offset!");
static_assert(offsetof(AReadyOrNotAudioVolume, bLocalEffectsPlayed) == 0x000268, "Member 'AReadyOrNotAudioVolume::bLocalEffectsPlayed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotAudioVolume, EventInstances) == 0x000270, "Member 'AReadyOrNotAudioVolume::EventInstances' has a wrong offset!");
static_assert(offsetof(AReadyOrNotAudioVolume, AttachedAudioComponents) == 0x000280, "Member 'AReadyOrNotAudioVolume::AttachedAudioComponents' has a wrong offset!");

// Class ReadyOrNot.KingOfTheHillGS
// 0x0008 (0x07E8 - 0x07E0)
class AKingOfTheHillGS final  : public AReadyOrNotGameState
{
public:
	class ATugOfWarMover*                         Mover;                                             // 0x07E0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KingOfTheHillGS">();
	}
	static class AKingOfTheHillGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKingOfTheHillGS>();
	}
};
static_assert(alignof(AKingOfTheHillGS) == 0x000008, "Wrong alignment on AKingOfTheHillGS");
static_assert(sizeof(AKingOfTheHillGS) == 0x0007E8, "Wrong size on AKingOfTheHillGS");
static_assert(offsetof(AKingOfTheHillGS, Mover) == 0x0007E0, "Member 'AKingOfTheHillGS::Mover' has a wrong offset!");

// Class ReadyOrNot.SoundSource
// 0x0248 (0x0270 - 0x0028)
class USoundSource final  : public UObject
{
public:
	uint8                                         Pad_26DE[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsRunning;                                        // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPaused;                                         // 0x0032(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26DF[0x1];                                     // 0x0033(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSincePrimaryUpdate;                            // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSincePropagationUpdate;                        // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrimaryUpdateInterval;                             // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PropagationUpdateInterval;                         // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOcclusionType                                OcclusionType;                                     // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPropagationType                              PropagationType;                                   // 0x0045(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESoundSourceType                              SoundSourceType;                                   // 0x0046(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHierarchyType                                HierarchyType;                                     // 0x0047(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundSource*>                   ChildrenSoundSources;                              // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class USoundSource*                           ParentSoundSource;                                 // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  InstanceGuid;                                      // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             Event;                                             // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E0[0x8];                                     // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0080(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachToComponent;                                 // 0x00B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugMode;                                        // 0x00C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoorAttachedSound;                              // 0x00C1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E1[0x6];                                     // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRegisterLater;                                    // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayLater;                                        // 0x00D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E2[0xE];                                     // 0x00D2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSoundStopped;                                    // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E3[0x38];                                    // 0x00F0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ProgrammerSoundName;                               // 0x0128(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E4[0x50];                                    // 0x0138(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnEventStopped;                                    // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSoundFinished;                                   // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTimelineMarker;                                  // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTimelineBeat;                                    // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ParameterCache;                                    // 0x01C8(0x0050)(Edit, BlueprintVisible, SimpleDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E5[0x58];                                    // 0x0218(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USoundSource* CreateFirstPersonSound(class UWorld* InWorld, class UFMODEvent* InEvent, const struct FTransform& InTransform, const TArray<struct FMODParam>& Params_0, bool InbDebugMode);
	static class USoundSource* CreateThirdPersonSound(class UWorld* InWorld, class UFMODEvent* InEvent, const struct FTransform& InTransform, const TArray<struct FMODParam>& Params_0, EOcclusionType InOcclusionType, EPropagationType InPropagationType, bool InbDebugMode);
	static void ReplaceAnimNotifies(class UAnimSequenceBase* AnimationSequence);

	void AddChild(class USoundSource* Child);
	void Attach(class USceneComponent* InAttachToComponent, class FName InAttachPointName);
	void Detach();
	void Initialize(class UFMODEvent* InEvent, const struct FTransform& InTransform, const TArray<struct FMODParam>& Params_0, EOcclusionType InOcclusionType, EPropagationType InPropagationType, bool InbDebugMode);
	void Play();
	void ResetSoundSource();
	void SetDebugMode(bool InbDebugMode);
	void SetOcclusionType(EOcclusionType InOcclusionType);
	void SetParameter(class FName Param_Name, float Value);
	void SetPaused(bool Paused);
	void SetPrimaryTickInterval(float Interval);
	void SetProgrammerSoundName(const class FString& Value);
	void SetPropagationTickInterval(float Interval);
	void SetPropagationType(EPropagationType InPropagationType);
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundSource">();
	}
	static class USoundSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundSource>();
	}
};
static_assert(alignof(USoundSource) == 0x000010, "Wrong alignment on USoundSource");
static_assert(sizeof(USoundSource) == 0x000270, "Wrong size on USoundSource");
static_assert(offsetof(USoundSource, bIsRunning) == 0x000030, "Member 'USoundSource::bIsRunning' has a wrong offset!");
static_assert(offsetof(USoundSource, bIsActive) == 0x000031, "Member 'USoundSource::bIsActive' has a wrong offset!");
static_assert(offsetof(USoundSource, bIsPaused) == 0x000032, "Member 'USoundSource::bIsPaused' has a wrong offset!");
static_assert(offsetof(USoundSource, TimeSincePrimaryUpdate) == 0x000034, "Member 'USoundSource::TimeSincePrimaryUpdate' has a wrong offset!");
static_assert(offsetof(USoundSource, TimeSincePropagationUpdate) == 0x000038, "Member 'USoundSource::TimeSincePropagationUpdate' has a wrong offset!");
static_assert(offsetof(USoundSource, PrimaryUpdateInterval) == 0x00003C, "Member 'USoundSource::PrimaryUpdateInterval' has a wrong offset!");
static_assert(offsetof(USoundSource, PropagationUpdateInterval) == 0x000040, "Member 'USoundSource::PropagationUpdateInterval' has a wrong offset!");
static_assert(offsetof(USoundSource, OcclusionType) == 0x000044, "Member 'USoundSource::OcclusionType' has a wrong offset!");
static_assert(offsetof(USoundSource, PropagationType) == 0x000045, "Member 'USoundSource::PropagationType' has a wrong offset!");
static_assert(offsetof(USoundSource, SoundSourceType) == 0x000046, "Member 'USoundSource::SoundSourceType' has a wrong offset!");
static_assert(offsetof(USoundSource, HierarchyType) == 0x000047, "Member 'USoundSource::HierarchyType' has a wrong offset!");
static_assert(offsetof(USoundSource, ChildrenSoundSources) == 0x000048, "Member 'USoundSource::ChildrenSoundSources' has a wrong offset!");
static_assert(offsetof(USoundSource, ParentSoundSource) == 0x000058, "Member 'USoundSource::ParentSoundSource' has a wrong offset!");
static_assert(offsetof(USoundSource, InstanceGuid) == 0x000060, "Member 'USoundSource::InstanceGuid' has a wrong offset!");
static_assert(offsetof(USoundSource, Event) == 0x000070, "Member 'USoundSource::Event' has a wrong offset!");
static_assert(offsetof(USoundSource, Transform) == 0x000080, "Member 'USoundSource::Transform' has a wrong offset!");
static_assert(offsetof(USoundSource, AttachToComponent) == 0x0000B0, "Member 'USoundSource::AttachToComponent' has a wrong offset!");
static_assert(offsetof(USoundSource, AttachPointName) == 0x0000B8, "Member 'USoundSource::AttachPointName' has a wrong offset!");
static_assert(offsetof(USoundSource, bDebugMode) == 0x0000C0, "Member 'USoundSource::bDebugMode' has a wrong offset!");
static_assert(offsetof(USoundSource, bIsDoorAttachedSound) == 0x0000C1, "Member 'USoundSource::bIsDoorAttachedSound' has a wrong offset!");
static_assert(offsetof(USoundSource, World) == 0x0000C8, "Member 'USoundSource::World' has a wrong offset!");
static_assert(offsetof(USoundSource, bRegisterLater) == 0x0000D0, "Member 'USoundSource::bRegisterLater' has a wrong offset!");
static_assert(offsetof(USoundSource, bPlayLater) == 0x0000D1, "Member 'USoundSource::bPlayLater' has a wrong offset!");
static_assert(offsetof(USoundSource, OnSoundStopped) == 0x0000E0, "Member 'USoundSource::OnSoundStopped' has a wrong offset!");
static_assert(offsetof(USoundSource, ProgrammerSoundName) == 0x000128, "Member 'USoundSource::ProgrammerSoundName' has a wrong offset!");
static_assert(offsetof(USoundSource, OnEventStopped) == 0x000188, "Member 'USoundSource::OnEventStopped' has a wrong offset!");
static_assert(offsetof(USoundSource, OnSoundFinished) == 0x000198, "Member 'USoundSource::OnSoundFinished' has a wrong offset!");
static_assert(offsetof(USoundSource, OnTimelineMarker) == 0x0001A8, "Member 'USoundSource::OnTimelineMarker' has a wrong offset!");
static_assert(offsetof(USoundSource, OnTimelineBeat) == 0x0001B8, "Member 'USoundSource::OnTimelineBeat' has a wrong offset!");
static_assert(offsetof(USoundSource, ParameterCache) == 0x0001C8, "Member 'USoundSource::ParameterCache' has a wrong offset!");

// Class ReadyOrNot.KingOfTheHostageGS
// 0x0008 (0x07E8 - 0x07E0)
class AKingOfTheHostageGS final  : public AReadyOrNotGameState
{
public:
	float                                         RedTeam_RoundTimeRemaining;                        // 0x07E0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlueTeam_RoundTimeRemaining;                       // 0x07E4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KingOfTheHostageGS">();
	}
	static class AKingOfTheHostageGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKingOfTheHostageGS>();
	}
};
static_assert(alignof(AKingOfTheHostageGS) == 0x000008, "Wrong alignment on AKingOfTheHostageGS");
static_assert(sizeof(AKingOfTheHostageGS) == 0x0007E8, "Wrong size on AKingOfTheHostageGS");
static_assert(offsetof(AKingOfTheHostageGS, RedTeam_RoundTimeRemaining) == 0x0007E0, "Member 'AKingOfTheHostageGS::RedTeam_RoundTimeRemaining' has a wrong offset!");
static_assert(offsetof(AKingOfTheHostageGS, BlueTeam_RoundTimeRemaining) == 0x0007E4, "Member 'AKingOfTheHostageGS::BlueTeam_RoundTimeRemaining' has a wrong offset!");

// Class ReadyOrNot.LadderSnapZone
// 0x0048 (0x0268 - 0x0220)
class ALadderSnapZone : public AActor
{
public:
	class UBoxComponent*                          SelectionZone;                                     // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 GhostLadder;                                       // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          Collision;                                         // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SceneRoot;                                         // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              ValidPlacementMaterial;                            // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              InvalidPlacementMaterial;                          // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRetractedRungCount;                             // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHorizontal;                                       // 0x0254(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26EA[0x3];                                     // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ATelescopicLadder*                      AttachedLadder;                                    // 0x0258(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnableToPlace;                                    // 0x0260(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26EB[0x3];                                     // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOverlappers;                                 // 0x0264(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DisableCollision();
	void EnableCollision();
	void Multicast_StartShowingGhostMesh(bool bAbleToPlace);
	void Multicast_StopShowingGhostMesh();
	void OnCollisionOverlapBegin(class UPrimitiveComponent* Comp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void OnCollisionOverlapEnd(class UPrimitiveComponent* Comp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LadderSnapZone">();
	}
	static class ALadderSnapZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALadderSnapZone>();
	}
};
static_assert(alignof(ALadderSnapZone) == 0x000008, "Wrong alignment on ALadderSnapZone");
static_assert(sizeof(ALadderSnapZone) == 0x000268, "Wrong size on ALadderSnapZone");
static_assert(offsetof(ALadderSnapZone, SelectionZone) == 0x000220, "Member 'ALadderSnapZone::SelectionZone' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, GhostLadder) == 0x000228, "Member 'ALadderSnapZone::GhostLadder' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, Collision) == 0x000230, "Member 'ALadderSnapZone::Collision' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, SceneRoot) == 0x000238, "Member 'ALadderSnapZone::SceneRoot' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, ValidPlacementMaterial) == 0x000240, "Member 'ALadderSnapZone::ValidPlacementMaterial' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, InvalidPlacementMaterial) == 0x000248, "Member 'ALadderSnapZone::InvalidPlacementMaterial' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, MaxRetractedRungCount) == 0x000250, "Member 'ALadderSnapZone::MaxRetractedRungCount' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, bHorizontal) == 0x000254, "Member 'ALadderSnapZone::bHorizontal' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, AttachedLadder) == 0x000258, "Member 'ALadderSnapZone::AttachedLadder' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, bUnableToPlace) == 0x000260, "Member 'ALadderSnapZone::bUnableToPlace' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, NumberOverlappers) == 0x000264, "Member 'ALadderSnapZone::NumberOverlappers' has a wrong offset!");

// Class ReadyOrNot.MissionPlanManager
// 0x0290 (0x04B0 - 0x0220)
class AMissionPlanManager final  : public AInfo
{
public:
	struct FPlanningMarkerArray                   MarkerArray;                                       // 0x0220(0x0148)(Net, NativeAccessSpecifierPublic)
	struct FPlanningLineArray                     LineArray;                                         // 0x0368(0x0148)(Net, NativeAccessSpecifierPublic)

public:
	static class AReadyOrNotPlayerState* GetPlayerStateFromPlanningNumber(class UObject* WorldContextObject, int32 Number);

	void OnMissionChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionPlanManager">();
	}
	static class AMissionPlanManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMissionPlanManager>();
	}
};
static_assert(alignof(AMissionPlanManager) == 0x000008, "Wrong alignment on AMissionPlanManager");
static_assert(sizeof(AMissionPlanManager) == 0x0004B0, "Wrong size on AMissionPlanManager");
static_assert(offsetof(AMissionPlanManager, MarkerArray) == 0x000220, "Member 'AMissionPlanManager::MarkerArray' has a wrong offset!");
static_assert(offsetof(AMissionPlanManager, LineArray) == 0x000368, "Member 'AMissionPlanManager::LineArray' has a wrong offset!");

// Class ReadyOrNot.LaserAttachment
// 0x0040 (0x1040 - 0x1000)
class ULaserAttachment : public UWeaponAttachment
{
public:
	bool                                          bRequireNVG;                                       // 0x0FF8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26EF[0x7];                                     // 0x0FF9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               LaserParticleComponent;                            // 0x1000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               LaserBeamEndComponent;                             // 0x1008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        LaserParticle;                                     // 0x1010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        LaserBeamEnd;                                      // 0x1018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepOn;                                            // 0x1020(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26F0[0x7];                                     // 0x1021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ALensFlare>                 LensFlareClass;                                    // 0x1028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALensFlare*                             SpawnedLensFlare;                                  // 0x1030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26F1[0x8];                                     // 0x1038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_On();
	void ToggleLaser(bool bOn);

	bool IsLaserOn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LaserAttachment">();
	}
	static class ULaserAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULaserAttachment>();
	}
};
static_assert(alignof(ULaserAttachment) == 0x000010, "Wrong alignment on ULaserAttachment");
static_assert(sizeof(ULaserAttachment) == 0x001040, "Wrong size on ULaserAttachment");
static_assert(offsetof(ULaserAttachment, bRequireNVG) == 0x000FF8, "Member 'ULaserAttachment::bRequireNVG' has a wrong offset!");
static_assert(offsetof(ULaserAttachment, LaserParticleComponent) == 0x001000, "Member 'ULaserAttachment::LaserParticleComponent' has a wrong offset!");
static_assert(offsetof(ULaserAttachment, LaserBeamEndComponent) == 0x001008, "Member 'ULaserAttachment::LaserBeamEndComponent' has a wrong offset!");
static_assert(offsetof(ULaserAttachment, LaserParticle) == 0x001010, "Member 'ULaserAttachment::LaserParticle' has a wrong offset!");
static_assert(offsetof(ULaserAttachment, LaserBeamEnd) == 0x001018, "Member 'ULaserAttachment::LaserBeamEnd' has a wrong offset!");
static_assert(offsetof(ULaserAttachment, bRepOn) == 0x001020, "Member 'ULaserAttachment::bRepOn' has a wrong offset!");
static_assert(offsetof(ULaserAttachment, LensFlareClass) == 0x001028, "Member 'ULaserAttachment::LensFlareClass' has a wrong offset!");
static_assert(offsetof(ULaserAttachment, SpawnedLensFlare) == 0x001030, "Member 'ULaserAttachment::SpawnedLensFlare' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotAISense_Sight
// 0x00C8 (0x0148 - 0x0080)
class UReadyOrNotAISense_Sight final  : public UAISense
{
public:
	uint8                                         Pad_26F2[0xC8];                                    // 0x0080(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotAISense_Sight">();
	}
	static class UReadyOrNotAISense_Sight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotAISense_Sight>();
	}
};
static_assert(alignof(UReadyOrNotAISense_Sight) == 0x000008, "Wrong alignment on UReadyOrNotAISense_Sight");
static_assert(sizeof(UReadyOrNotAISense_Sight) == 0x000148, "Wrong size on UReadyOrNotAISense_Sight");

// Class ReadyOrNot.ModLevelData
// 0x0798 (0x07C8 - 0x0030)
class UModLevelData final  : public UPrimaryDataAsset
{
public:
	class FName                                   LevelName;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInMissionSelect;                              // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F3[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLevelDataLookupTable                  Data;                                              // 0x0040(0x0788)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModLevelData">();
	}
	static class UModLevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModLevelData>();
	}
};
static_assert(alignof(UModLevelData) == 0x000008, "Wrong alignment on UModLevelData");
static_assert(sizeof(UModLevelData) == 0x0007C8, "Wrong size on UModLevelData");
static_assert(offsetof(UModLevelData, LevelName) == 0x000030, "Member 'UModLevelData::LevelName' has a wrong offset!");
static_assert(offsetof(UModLevelData, bShowInMissionSelect) == 0x000038, "Member 'UModLevelData::bShowInMissionSelect' has a wrong offset!");
static_assert(offsetof(UModLevelData, Data) == 0x000040, "Member 'UModLevelData::Data' has a wrong offset!");

// Class ReadyOrNot.LightAttachment
// 0x0100 (0x1100 - 0x1000)
class ULightAttachment : public UWeaponAttachment
{
public:
	class USpotLightComponent*                    SpotLightComponent;                                // 0x0FF8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPointLightComponent*                   PointLightComponent;                               // 0x1000(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepOn;                                            // 0x1008(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F4[0x7];                                     // 0x1009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Intensity;                                         // 0x1010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BouncedIntensity;                                  // 0x1014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Attenuation;                                       // 0x1018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerConeAngle;                                    // 0x101C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterConeAngle;                                    // 0x1020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightColor;                                        // 0x1024(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F5[0x4];                                     // 0x1034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     LightFunctionMaterial;                             // 0x1038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LightFunctionScale;                                // 0x1040(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F6[0x4];                                     // 0x104C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ALensFlare>                 LensFlareClass;                                    // 0x1050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALensFlare*                             SpawnedLensFlare;                                  // 0x1058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumOfFlashLightTrackingPoints;                     // 0x1060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F7[0x4];                                     // 0x1064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFlashLightTrackingPoint*>       FlashLightTrackingPoints;                          // 0x1068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class AFlashLightTrackingPoint*               PrimaryTrackingPoint;                              // 0x1078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F8[0x80];                                    // 0x1080(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsLightOn();
	void OnRep_On();
	void ToggleLight(bool bOn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightAttachment">();
	}
	static class ULightAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightAttachment>();
	}
};
static_assert(alignof(ULightAttachment) == 0x000010, "Wrong alignment on ULightAttachment");
static_assert(sizeof(ULightAttachment) == 0x001100, "Wrong size on ULightAttachment");
static_assert(offsetof(ULightAttachment, SpotLightComponent) == 0x000FF8, "Member 'ULightAttachment::SpotLightComponent' has a wrong offset!");
static_assert(offsetof(ULightAttachment, PointLightComponent) == 0x001000, "Member 'ULightAttachment::PointLightComponent' has a wrong offset!");
static_assert(offsetof(ULightAttachment, bRepOn) == 0x001008, "Member 'ULightAttachment::bRepOn' has a wrong offset!");
static_assert(offsetof(ULightAttachment, Intensity) == 0x001010, "Member 'ULightAttachment::Intensity' has a wrong offset!");
static_assert(offsetof(ULightAttachment, BouncedIntensity) == 0x001014, "Member 'ULightAttachment::BouncedIntensity' has a wrong offset!");
static_assert(offsetof(ULightAttachment, Attenuation) == 0x001018, "Member 'ULightAttachment::Attenuation' has a wrong offset!");
static_assert(offsetof(ULightAttachment, InnerConeAngle) == 0x00101C, "Member 'ULightAttachment::InnerConeAngle' has a wrong offset!");
static_assert(offsetof(ULightAttachment, OuterConeAngle) == 0x001020, "Member 'ULightAttachment::OuterConeAngle' has a wrong offset!");
static_assert(offsetof(ULightAttachment, LightColor) == 0x001024, "Member 'ULightAttachment::LightColor' has a wrong offset!");
static_assert(offsetof(ULightAttachment, LightFunctionMaterial) == 0x001038, "Member 'ULightAttachment::LightFunctionMaterial' has a wrong offset!");
static_assert(offsetof(ULightAttachment, LightFunctionScale) == 0x001040, "Member 'ULightAttachment::LightFunctionScale' has a wrong offset!");
static_assert(offsetof(ULightAttachment, LensFlareClass) == 0x001050, "Member 'ULightAttachment::LensFlareClass' has a wrong offset!");
static_assert(offsetof(ULightAttachment, SpawnedLensFlare) == 0x001058, "Member 'ULightAttachment::SpawnedLensFlare' has a wrong offset!");
static_assert(offsetof(ULightAttachment, NumOfFlashLightTrackingPoints) == 0x001060, "Member 'ULightAttachment::NumOfFlashLightTrackingPoints' has a wrong offset!");
static_assert(offsetof(ULightAttachment, FlashLightTrackingPoints) == 0x001068, "Member 'ULightAttachment::FlashLightTrackingPoints' has a wrong offset!");
static_assert(offsetof(ULightAttachment, PrimaryTrackingPoint) == 0x001078, "Member 'ULightAttachment::PrimaryTrackingPoint' has a wrong offset!");

// Class ReadyOrNot.NavArea_SwatAlpha
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SwatAlpha final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SwatAlpha">();
	}
	static class UNavArea_SwatAlpha* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SwatAlpha>();
	}
};
static_assert(alignof(UNavArea_SwatAlpha) == 0x000008, "Wrong alignment on UNavArea_SwatAlpha");
static_assert(sizeof(UNavArea_SwatAlpha) == 0x000048, "Wrong size on UNavArea_SwatAlpha");

// Class ReadyOrNot.ListenForDeath
// 0x0000 (0x0028 - 0x0028)
class IListenForDeath final  : public IInterface
{
public:
	void OnCharacterDied(class AReadyOrNotCharacter* Victim, class AReadyOrNotCharacter* Killer, class AActor* Inflictor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ListenForDeath">();
	}
	static class IListenForDeath* GetDefaultObj()
	{
		return GetDefaultObjImpl<IListenForDeath>();
	}
};
static_assert(alignof(IListenForDeath) == 0x000008, "Wrong alignment on IListenForDeath");
static_assert(sizeof(IListenForDeath) == 0x000028, "Wrong size on IListenForDeath");

// Class ReadyOrNot.ListenForGameStart
// 0x0000 (0x0028 - 0x0028)
class IListenForGameStart final  : public IInterface
{
public:
	void OnGameStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ListenForGameStart">();
	}
	static class IListenForGameStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<IListenForGameStart>();
	}
};
static_assert(alignof(IListenForGameStart) == 0x000008, "Wrong alignment on IListenForGameStart");
static_assert(sizeof(IListenForGameStart) == 0x000028, "Wrong size on IListenForGameStart");

// Class ReadyOrNot.ReadyOrNotGameInstance
// 0x0E48 (0x1070 - 0x0228)
class UReadyOrNotGameInstance : public UAdvancedFriendsGameInstance
{
public:
	uint8                                         Pad_26F9[0x8];                                     // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LobbyLevel;                                        // 0x0230(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TrainingLevel;                                     // 0x0240(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULoadoutManager>            LoadoutManagerClass;                               // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26FA[0x8];                                     // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UReadyOrNotBackend*                     ReadyOrNotBackend;                                 // 0x0260(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULoadoutManager*                        LoadoutManager;                                    // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModioManager*                          ModioManager;                                      // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotAIConfig*                    AIConfig;                                          // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26FB[0x40];                                    // 0x0280(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           GlobalMaterialParameterCollection;                 // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           WeaponFOVMaterialCollection;                       // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26FC[0x8];                                     // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMetaGameProfile*                       MetaGameProfile;                                   // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESessionType                                  SessionType;                                       // 0x02E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26FD[0x7];                                     // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           LazyLoadedClasses;                                 // 0x02E8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UObject>>         LazyLoadedObjects;                                 // 0x02F8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_26FE[0x8];                                     // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                SpawnWidgetOnLevelLoad;                            // 0x0310(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26FF[0x8];                                     // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, bool>                             OwnedDLCMap;                                       // 0x0320(0x0050)(NativeAccessSpecifierPublic)
	TArray<class AActor*>                         DecalMeshActors;                                   // 0x0370(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2700[0x250];                                   // 0x0380(0x0250)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         PreviouslyJoinedGames;                             // 0x05D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         DedicatedServerGamesPlayedWithoutReturningToLobby; // 0x05E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DedicatedServerMapIdx;                             // 0x05E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2701[0x158];                                   // 0x05E8(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnConnectSteamServerByIP;                          // 0x0740(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2702[0x50];                                    // 0x0750(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHostedGame;                                       // 0x07A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2703[0x3];                                     // 0x07A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Saved_RoundTimerGameStart;                         // 0x07A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Saved_RoundTimerBetweenMaps;                       // 0x07A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Saved_ReinforcementTimer;                          // 0x07AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Saved_Timelimit;                                   // 0x07B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Saved_RoundsPerMap;                                // 0x07B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Saved_Scorelimit;                                  // 0x07B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Saved_AiEnabled;                                   // 0x07BC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSinglePlayerMode;                               // 0x07BD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2704[0x2];                                     // 0x07BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ActivePauseConditions;                             // 0x07C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UHostMigrationManager*                  HostMigrationManager;                              // 0x07D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NextLevel;                                         // 0x07D8(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MainMenuDisplayMessage;                            // 0x07E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2705[0x8];                                     // 0x07F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLevelDataLookupTable                  ModdedMapLookUpData;                               // 0x0800(0x0788)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_2706[0x60];                                    // 0x0F88(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UModLevelData*>                  ModdedLevelDataAssets;                             // 0x0FE8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         BuiltMapList;                                      // 0x0FF8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShowingFPS;                                       // 0x1008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2707[0x1];                                     // 0x1009(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsRecordingReplay;                                // 0x100A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayingReplay;                                  // 0x100B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bReplayBeginTime;                                  // 0x100C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReplayNumPlayers;                                  // 0x1010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2708[0x4];                                     // 0x1014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            ReplayLoadingScreen;                               // 0x1018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FReplayEvent>                   ReplayEvents;                                      // 0x1020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2709[0x30];                                    // 0x1030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UOnlineActivityManager*                 OnlineActivityManager;                             // 0x1060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConsoleMultiplayerManager*             ConsoleMultiplayerManager;                         // 0x1068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static bool IsGameModded();

	void AddPauseGameCondition(const class FString& PauseCondition);
	void AddReplayEvent(EReplayEventType EventType, const struct FVector& Location, float Timestamp, const class FString& AdditionalInformation);
	void ApplyDecalSettings();
	void BuildMapList();
	void CommanderCompleteMission(const class FString& Mission);
	void CommanderDeleteProfile(int32 Slot);
	void CommanderGenerateProfile(int32 Slot);
	void ConnectSteamServer(const class FString& ServerConnect);
	void CreateReplayLoadingScreen();
	void DelegateSetLocalMutedStateCompleted__DelegateSignature();
	void DeleteReplay(const class FString& ReplayName);
	TMap<class FString, struct FReplayData> FindReplays();
	void GenerateURLMap();
	TArray<class AReadyOrNotGameMode*> GetAllGameModes();
	TArray<class AReadyOrNotGameState*> GetAllGameStates();
	ELastMenuStateBeforeJoin GetAndClearLastJoinState();
	class FString GetAndClearMainMenuDisplayMessage();
	bool GetAvailableAudioDevices(TArray<class FString>* OutAudioDevices);
	bool GetBanned();
	class FString GetBestGuessMapName(const class FString& MapName);
	TArray<class FString> GetBuiltMapList();
	TArray<class FString> GetBuiltModdedMapList();
	class FString GetDiscordOneTimeUseCode();
	class FString GetFriendlyGamemodeName(const class FString& UnfriendlyName);
	uint32 GetLocalNetworkVersion();
	TArray<struct FReplayEvent> GetReplayEvents();
	class FString GetSessionTicket();
	void Gratr();
	bool IsHostMigrationInProgress(class FString* MigratedHostToName);
	bool IsNetworkCompatible(uint32 LocalNetworkVersion, uint32 RemoteNetworkVersion);
	bool IsPublicMissionInProgress();
	bool IsReplaySystemEnabled();
	bool IsSinglePlayer();
	void OnConnectSteamServer(const class FString& URL);
	void OnGameServerPinged__DelegateSignature(const class FString& ConnectionAddress);
	bool OnWindowCloseRequested();
	void OpenReplayFolder();
	void PlayReplayFromBP(const class FString& ReplayName);
	void RemovePauseGameCondition(const class FString& PauseCondition);
	void RemoveReplayLoadingScreen();
	void RenameReplay(const class FString& ReplayName, const class FString& NewFriendlyReplayName);
	void RetryLogin();
	bool SetInputAudioDevice(const class FString& DeviceName, bool bShouldSave);
	void SetLastJoinState(ELastMenuStateBeforeJoin LastJoiNState);
	void StartGeneratingPSOCache();
	void StartRecordingReplay();
	void StopGeneratingPSOCache();
	void StopRecordingReplay();
	void StopRecordingReplayFromBP();

	uint8 GetBackendState() const;
	bool IsLoggedIntoBackend() const;
	bool IsSafeMode() const;
	bool SupportsDisablingMods() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotGameInstance">();
	}
	static class UReadyOrNotGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotGameInstance>();
	}
};
static_assert(alignof(UReadyOrNotGameInstance) == 0x000008, "Wrong alignment on UReadyOrNotGameInstance");
static_assert(sizeof(UReadyOrNotGameInstance) == 0x001070, "Wrong size on UReadyOrNotGameInstance");
static_assert(offsetof(UReadyOrNotGameInstance, LobbyLevel) == 0x000230, "Member 'UReadyOrNotGameInstance::LobbyLevel' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, TrainingLevel) == 0x000240, "Member 'UReadyOrNotGameInstance::TrainingLevel' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, LoadoutManagerClass) == 0x000250, "Member 'UReadyOrNotGameInstance::LoadoutManagerClass' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ReadyOrNotBackend) == 0x000260, "Member 'UReadyOrNotGameInstance::ReadyOrNotBackend' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, LoadoutManager) == 0x000268, "Member 'UReadyOrNotGameInstance::LoadoutManager' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ModioManager) == 0x000270, "Member 'UReadyOrNotGameInstance::ModioManager' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, AIConfig) == 0x000278, "Member 'UReadyOrNotGameInstance::AIConfig' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, GlobalMaterialParameterCollection) == 0x0002C0, "Member 'UReadyOrNotGameInstance::GlobalMaterialParameterCollection' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, WeaponFOVMaterialCollection) == 0x0002C8, "Member 'UReadyOrNotGameInstance::WeaponFOVMaterialCollection' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, MetaGameProfile) == 0x0002D8, "Member 'UReadyOrNotGameInstance::MetaGameProfile' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, SessionType) == 0x0002E0, "Member 'UReadyOrNotGameInstance::SessionType' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, LazyLoadedClasses) == 0x0002E8, "Member 'UReadyOrNotGameInstance::LazyLoadedClasses' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, LazyLoadedObjects) == 0x0002F8, "Member 'UReadyOrNotGameInstance::LazyLoadedObjects' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, SpawnWidgetOnLevelLoad) == 0x000310, "Member 'UReadyOrNotGameInstance::SpawnWidgetOnLevelLoad' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, OwnedDLCMap) == 0x000320, "Member 'UReadyOrNotGameInstance::OwnedDLCMap' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, DecalMeshActors) == 0x000370, "Member 'UReadyOrNotGameInstance::DecalMeshActors' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, PreviouslyJoinedGames) == 0x0005D0, "Member 'UReadyOrNotGameInstance::PreviouslyJoinedGames' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, DedicatedServerGamesPlayedWithoutReturningToLobby) == 0x0005E0, "Member 'UReadyOrNotGameInstance::DedicatedServerGamesPlayedWithoutReturningToLobby' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, DedicatedServerMapIdx) == 0x0005E4, "Member 'UReadyOrNotGameInstance::DedicatedServerMapIdx' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, OnConnectSteamServerByIP) == 0x000740, "Member 'UReadyOrNotGameInstance::OnConnectSteamServerByIP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, bHostedGame) == 0x0007A0, "Member 'UReadyOrNotGameInstance::bHostedGame' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, Saved_RoundTimerGameStart) == 0x0007A4, "Member 'UReadyOrNotGameInstance::Saved_RoundTimerGameStart' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, Saved_RoundTimerBetweenMaps) == 0x0007A8, "Member 'UReadyOrNotGameInstance::Saved_RoundTimerBetweenMaps' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, Saved_ReinforcementTimer) == 0x0007AC, "Member 'UReadyOrNotGameInstance::Saved_ReinforcementTimer' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, Saved_Timelimit) == 0x0007B0, "Member 'UReadyOrNotGameInstance::Saved_Timelimit' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, Saved_RoundsPerMap) == 0x0007B4, "Member 'UReadyOrNotGameInstance::Saved_RoundsPerMap' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, Saved_Scorelimit) == 0x0007B8, "Member 'UReadyOrNotGameInstance::Saved_Scorelimit' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, Saved_AiEnabled) == 0x0007BC, "Member 'UReadyOrNotGameInstance::Saved_AiEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, bIsSinglePlayerMode) == 0x0007BD, "Member 'UReadyOrNotGameInstance::bIsSinglePlayerMode' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ActivePauseConditions) == 0x0007C0, "Member 'UReadyOrNotGameInstance::ActivePauseConditions' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, HostMigrationManager) == 0x0007D0, "Member 'UReadyOrNotGameInstance::HostMigrationManager' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, NextLevel) == 0x0007D8, "Member 'UReadyOrNotGameInstance::NextLevel' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, MainMenuDisplayMessage) == 0x0007E8, "Member 'UReadyOrNotGameInstance::MainMenuDisplayMessage' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ModdedMapLookUpData) == 0x000800, "Member 'UReadyOrNotGameInstance::ModdedMapLookUpData' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ModdedLevelDataAssets) == 0x000FE8, "Member 'UReadyOrNotGameInstance::ModdedLevelDataAssets' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, BuiltMapList) == 0x000FF8, "Member 'UReadyOrNotGameInstance::BuiltMapList' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, bShowingFPS) == 0x001008, "Member 'UReadyOrNotGameInstance::bShowingFPS' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, bIsRecordingReplay) == 0x00100A, "Member 'UReadyOrNotGameInstance::bIsRecordingReplay' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, bIsPlayingReplay) == 0x00100B, "Member 'UReadyOrNotGameInstance::bIsPlayingReplay' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, bReplayBeginTime) == 0x00100C, "Member 'UReadyOrNotGameInstance::bReplayBeginTime' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ReplayNumPlayers) == 0x001010, "Member 'UReadyOrNotGameInstance::ReplayNumPlayers' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ReplayLoadingScreen) == 0x001018, "Member 'UReadyOrNotGameInstance::ReplayLoadingScreen' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ReplayEvents) == 0x001020, "Member 'UReadyOrNotGameInstance::ReplayEvents' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, OnlineActivityManager) == 0x001060, "Member 'UReadyOrNotGameInstance::OnlineActivityManager' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ConsoleMultiplayerManager) == 0x001068, "Member 'UReadyOrNotGameInstance::ConsoleMultiplayerManager' has a wrong offset!");

// Class ReadyOrNot.Loadout_ArmorSelection_V2
// 0x0000 (0x0320 - 0x0320)
class ULoadout_ArmorSelection_V2 final  : public UCommonActivatableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Loadout_ArmorSelection_V2">();
	}
	static class ULoadout_ArmorSelection_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadout_ArmorSelection_V2>();
	}
};
static_assert(alignof(ULoadout_ArmorSelection_V2) == 0x000008, "Wrong alignment on ULoadout_ArmorSelection_V2");
static_assert(sizeof(ULoadout_ArmorSelection_V2) == 0x000320, "Wrong size on ULoadout_ArmorSelection_V2");

// Class ReadyOrNot.SubtitlesSubsystem
// 0x0168 (0x0198 - 0x0030)
class USubtitlesSubsystem final  : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_2710[0x168];                                   // 0x0030(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitlesSubsystem">();
	}
	static class USubtitlesSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitlesSubsystem>();
	}
};
static_assert(alignof(USubtitlesSubsystem) == 0x000008, "Wrong alignment on USubtitlesSubsystem");
static_assert(sizeof(USubtitlesSubsystem) == 0x000198, "Wrong size on USubtitlesSubsystem");

// Class ReadyOrNot.Loadout_InformationBox
// 0x0040 (0x02C8 - 0x0288)
class ULoadout_InformationBox : public UCommonUserWidget
{
public:
	class UTextBlock*                             Txt_Category;                                      // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Class;                                         // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_ItemName;                                      // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Description;                                   // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_Attachments;                                    // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_Effects;                                        // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotGameState*                   Gs;                                                // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UReadyOrNotLoadoutManager*              LoadoutFunctionLibrary;                            // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CreateAttachmentElement(TArray<class UWeaponAttachment*>& Attachments, TArray<EWeaponAttachmentType>& AttachmentTypes);
	void CreateEffectsElement(TArray<struct FAttachmentEffects>& AttachmentEffects);
	void SetAttachments(TSubclassOf<class ABaseWeapon> BaseWeapon, bool IsSecondary);
	void SetCategory(class FText CurrentItemCategory);
	TArray<struct FAttachmentEffects> SetEffects(class UWeaponAttachment* Attachment);
	void UpdateEffectsInfo(class UWeaponAttachment* Attachment, class FText CurrentItemCategory);
	void UpdateInfoBox(class ABaseItem* Item, class FText CurrentItemCategory, bool IsItemWeapon);
	void UpdateMaterialInfo(class UArmourMaterial* ArmorMaterial, class FText CurrentItemCategory);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Loadout_InformationBox">();
	}
	static class ULoadout_InformationBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadout_InformationBox>();
	}
};
static_assert(alignof(ULoadout_InformationBox) == 0x000008, "Wrong alignment on ULoadout_InformationBox");
static_assert(sizeof(ULoadout_InformationBox) == 0x0002C8, "Wrong size on ULoadout_InformationBox");
static_assert(offsetof(ULoadout_InformationBox, Txt_Category) == 0x000288, "Member 'ULoadout_InformationBox::Txt_Category' has a wrong offset!");
static_assert(offsetof(ULoadout_InformationBox, Txt_Class) == 0x000290, "Member 'ULoadout_InformationBox::Txt_Class' has a wrong offset!");
static_assert(offsetof(ULoadout_InformationBox, Txt_ItemName) == 0x000298, "Member 'ULoadout_InformationBox::Txt_ItemName' has a wrong offset!");
static_assert(offsetof(ULoadout_InformationBox, Txt_Description) == 0x0002A0, "Member 'ULoadout_InformationBox::Txt_Description' has a wrong offset!");
static_assert(offsetof(ULoadout_InformationBox, VB_Attachments) == 0x0002A8, "Member 'ULoadout_InformationBox::VB_Attachments' has a wrong offset!");
static_assert(offsetof(ULoadout_InformationBox, VB_Effects) == 0x0002B0, "Member 'ULoadout_InformationBox::VB_Effects' has a wrong offset!");
static_assert(offsetof(ULoadout_InformationBox, Gs) == 0x0002B8, "Member 'ULoadout_InformationBox::Gs' has a wrong offset!");
static_assert(offsetof(ULoadout_InformationBox, LoadoutFunctionLibrary) == 0x0002C0, "Member 'ULoadout_InformationBox::LoadoutFunctionLibrary' has a wrong offset!");

// Class ReadyOrNot.Loadout_TacticalSelection_V2
// 0x0000 (0x0320 - 0x0320)
class ULoadout_TacticalSelection_V2 final  : public UCommonActivatableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Loadout_TacticalSelection_V2">();
	}
	static class ULoadout_TacticalSelection_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadout_TacticalSelection_V2>();
	}
};
static_assert(alignof(ULoadout_TacticalSelection_V2) == 0x000008, "Wrong alignment on ULoadout_TacticalSelection_V2");
static_assert(sizeof(ULoadout_TacticalSelection_V2) == 0x000320, "Wrong size on ULoadout_TacticalSelection_V2");

// Class ReadyOrNot.MunitionsSlotElement
// 0x0010 (0x0270 - 0x0260)
class UMunitionsSlotElement : public UUserWidget
{
public:
	class UImage*                                 ElementImage;                                      // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ElementText;                                       // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MunitionsSlotElement">();
	}
	static class UMunitionsSlotElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMunitionsSlotElement>();
	}
};
static_assert(alignof(UMunitionsSlotElement) == 0x000008, "Wrong alignment on UMunitionsSlotElement");
static_assert(sizeof(UMunitionsSlotElement) == 0x000270, "Wrong size on UMunitionsSlotElement");
static_assert(offsetof(UMunitionsSlotElement, ElementImage) == 0x000260, "Member 'UMunitionsSlotElement::ElementImage' has a wrong offset!");
static_assert(offsetof(UMunitionsSlotElement, ElementText) == 0x000268, "Member 'UMunitionsSlotElement::ElementText' has a wrong offset!");

// Class ReadyOrNot.SteamworksIntegration
// 0x0000 (0x0028 - 0x0028)
class USteamworksIntegration final  : public UObject
{
public:
	static EGameVersionRestriction GetDLCENum(int32 InDLC);
	static int32 GetDLCNumber(EGameVersionRestriction InDLC);
	static bool IsDLCInstalled(int32 AppId);
	static bool IsDLCInstalledEnum(EGameVersionRestriction GameFeature);
	static bool IsSteamEnabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamworksIntegration">();
	}
	static class USteamworksIntegration* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamworksIntegration>();
	}
};
static_assert(alignof(USteamworksIntegration) == 0x000008, "Wrong alignment on USteamworksIntegration");
static_assert(sizeof(USteamworksIntegration) == 0x000028, "Wrong size on USteamworksIntegration");

// Class ReadyOrNot.Loadout_WeaponSelection_V2
// 0x0008 (0x0328 - 0x0320)
class ULoadout_WeaponSelection_V2 final  : public UCommonActivatableWidget
{
public:
	int32                                         ActiveSwitcherIndex;                               // 0x0320(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldUpdateWorkbench;                             // 0x0324(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2716[0x3];                                     // 0x0325(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetShouldUpdateWorkbench();
	void SetShouldUpdateWorkbench(bool ShouldUpdate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Loadout_WeaponSelection_V2">();
	}
	static class ULoadout_WeaponSelection_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadout_WeaponSelection_V2>();
	}
};
static_assert(alignof(ULoadout_WeaponSelection_V2) == 0x000008, "Wrong alignment on ULoadout_WeaponSelection_V2");
static_assert(sizeof(ULoadout_WeaponSelection_V2) == 0x000328, "Wrong size on ULoadout_WeaponSelection_V2");
static_assert(offsetof(ULoadout_WeaponSelection_V2, ActiveSwitcherIndex) == 0x000320, "Member 'ULoadout_WeaponSelection_V2::ActiveSwitcherIndex' has a wrong offset!");
static_assert(offsetof(ULoadout_WeaponSelection_V2, ShouldUpdateWorkbench) == 0x000324, "Member 'ULoadout_WeaponSelection_V2::ShouldUpdateWorkbench' has a wrong offset!");

// Class ReadyOrNot.LoadoutInformationTableWidget
// 0x0050 (0x02B0 - 0x0260)
class ULoadoutInformationTableWidget final  : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnModifyWeaponButtonClicked;                       // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInfoPanelRemoved;                                // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancelRefresh;                                   // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInfoPanelAttachmentClicked;                      // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInfoPanelRemoveAttachmentClicked;                // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnCancelRefresh__DelegateSignature();
	void OnInfoPanelAttachmentClicked__DelegateSignature(EWeaponAttachmentType WeaponSlot, class UWeaponAttachment* AttachmentData);
	void OnInfoPanelRemoveAttachmentClicked__DelegateSignature(EWeaponAttachmentType WeaponSlot);
	void OnInfoPanelRemoved__DelegateSignature();
	void OnModifyWeaponButtonClicked__DelegateSignature(class ABaseItem* ItemToModify);
	void RefreshPanelAmmoInfo(const struct FAmmoTypeData& AmmoType, TSubclassOf<class ABaseItem> ItemClass);
	void RefreshPanelArmourMaterial(class UArmourMaterial* ArmourMaterial);
	void RefreshPanelItemInfo(const struct FSavedLoadout& ActiveLoadout, TSubclassOf<class ABaseItem> ItemClass, EItemCategory LoadoutSlot, bool bRestricted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutInformationTableWidget">();
	}
	static class ULoadoutInformationTableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutInformationTableWidget>();
	}
};
static_assert(alignof(ULoadoutInformationTableWidget) == 0x000008, "Wrong alignment on ULoadoutInformationTableWidget");
static_assert(sizeof(ULoadoutInformationTableWidget) == 0x0002B0, "Wrong size on ULoadoutInformationTableWidget");
static_assert(offsetof(ULoadoutInformationTableWidget, OnModifyWeaponButtonClicked) == 0x000260, "Member 'ULoadoutInformationTableWidget::OnModifyWeaponButtonClicked' has a wrong offset!");
static_assert(offsetof(ULoadoutInformationTableWidget, OnInfoPanelRemoved) == 0x000270, "Member 'ULoadoutInformationTableWidget::OnInfoPanelRemoved' has a wrong offset!");
static_assert(offsetof(ULoadoutInformationTableWidget, OnCancelRefresh) == 0x000280, "Member 'ULoadoutInformationTableWidget::OnCancelRefresh' has a wrong offset!");
static_assert(offsetof(ULoadoutInformationTableWidget, OnInfoPanelAttachmentClicked) == 0x000290, "Member 'ULoadoutInformationTableWidget::OnInfoPanelAttachmentClicked' has a wrong offset!");
static_assert(offsetof(ULoadoutInformationTableWidget, OnInfoPanelRemoveAttachmentClicked) == 0x0002A0, "Member 'ULoadoutInformationTableWidget::OnInfoPanelRemoveAttachmentClicked' has a wrong offset!");

// Class ReadyOrNot.LoadoutManager
// 0x00E0 (0x0108 - 0x0028)
class ULoadoutManager final  : public UObject
{
public:
	TArray<class ABaseItem*>                      AllItems;                                          // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      PrimaryWeapons;                                    // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      SecondaryWeapons;                                  // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      LongTacticalItems;                                 // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      TacticalItems;                                     // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      BodyArmors;                                        // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      Helmets;                                           // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UArmourMaterial*>                ArmorMaterials;                                    // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCustomizationDataBase*>         CustomizationAssets;                               // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, class ABaseItem*>           ItemLookupMap;                                     // 0x00B8(0x0050)(NativeAccessSpecifierPrivate)

public:
	static TArray<TSubclassOf<class ABaseItem>> GetAllItems(class UObject* WorldContextObject);
	static TSubclassOf<class ABaseItem> GetItemByLookupIdx(class UObject* WorldContextObject, class FName LookupIdx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutManager">();
	}
	static class ULoadoutManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutManager>();
	}
};
static_assert(alignof(ULoadoutManager) == 0x000008, "Wrong alignment on ULoadoutManager");
static_assert(sizeof(ULoadoutManager) == 0x000108, "Wrong size on ULoadoutManager");
static_assert(offsetof(ULoadoutManager, AllItems) == 0x000028, "Member 'ULoadoutManager::AllItems' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, PrimaryWeapons) == 0x000038, "Member 'ULoadoutManager::PrimaryWeapons' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, SecondaryWeapons) == 0x000048, "Member 'ULoadoutManager::SecondaryWeapons' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, LongTacticalItems) == 0x000058, "Member 'ULoadoutManager::LongTacticalItems' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, TacticalItems) == 0x000068, "Member 'ULoadoutManager::TacticalItems' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, BodyArmors) == 0x000078, "Member 'ULoadoutManager::BodyArmors' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, Helmets) == 0x000088, "Member 'ULoadoutManager::Helmets' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, ArmorMaterials) == 0x000098, "Member 'ULoadoutManager::ArmorMaterials' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, CustomizationAssets) == 0x0000A8, "Member 'ULoadoutManager::CustomizationAssets' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, ItemLookupMap) == 0x0000B8, "Member 'ULoadoutManager::ItemLookupMap' has a wrong offset!");

// Class ReadyOrNot.Mirror
// 0x0040 (0x0260 - 0x0220)
class AMirror final  : public AActor
{
public:
	struct FTransform                             VisibilityBoundsTransform;                         // 0x0220(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                VisibilityBoundsExtent;                            // 0x0250(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDynamicShadowsDisabled : 1;                       // 0x025C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2719[0x3];                                     // 0x025D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mirror">();
	}
	static class AMirror* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMirror>();
	}
};
static_assert(alignof(AMirror) == 0x000010, "Wrong alignment on AMirror");
static_assert(sizeof(AMirror) == 0x000260, "Wrong size on AMirror");
static_assert(offsetof(AMirror, VisibilityBoundsTransform) == 0x000220, "Member 'AMirror::VisibilityBoundsTransform' has a wrong offset!");
static_assert(offsetof(AMirror, VisibilityBoundsExtent) == 0x000250, "Member 'AMirror::VisibilityBoundsExtent' has a wrong offset!");

// Class ReadyOrNot.Overview_V2
// 0x0018 (0x0338 - 0x0320)
class UOverview_V2 : public UCommonActivatableWidget
{
public:
	class FString                                 ActiveLoadoutName;                                 // 0x0320(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       SwitchCharacter;                                   // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SavePresets(const struct FSavedLoadout& Loadout, bool IsNPC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Overview_V2">();
	}
	static class UOverview_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOverview_V2>();
	}
};
static_assert(alignof(UOverview_V2) == 0x000008, "Wrong alignment on UOverview_V2");
static_assert(sizeof(UOverview_V2) == 0x000338, "Wrong size on UOverview_V2");
static_assert(offsetof(UOverview_V2, ActiveLoadoutName) == 0x000320, "Member 'UOverview_V2::ActiveLoadoutName' has a wrong offset!");
static_assert(offsetof(UOverview_V2, SwitchCharacter) == 0x000330, "Member 'UOverview_V2::SwitchCharacter' has a wrong offset!");

// Class ReadyOrNot.LoadoutPortal
// 0x0068 (0x0288 - 0x0220)
class ALoadoutPortal final  : public AActor
{
public:
	uint8                                         Pad_271B[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 InteractableComponent;                             // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStaticMeshComponent*>           CompsToOutline;                                    // 0x0230(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class ULightComponent*>                LightsToEnable;                                    // 0x0240(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class ULevelSequence*                         LevelSequence;                                     // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelSequencePlayer*                   LevelSequencePlayer;                               // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelSequenceActor*                    LevelSequenceActor;                                // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOpenCustomization;                                // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271C[0x3];                                     // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LightActorsOfTag;                                  // 0x026C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsActive;                                          // 0x0274(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271D[0x3];                                     // 0x0275(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoadout_V2*                            LoadoutWidget;                                     // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271E[0x8];                                     // 0x0280(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LoadLoadout();
	void OnLoadoutFadeIn();
	void OnLoadoutFadeOut();
	void OnLoadoutHidden();
	void OnLoadoutLoaded();
	void OnLoadoutShown();
	void OnLoadoutUnloaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutPortal">();
	}
	static class ALoadoutPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALoadoutPortal>();
	}
};
static_assert(alignof(ALoadoutPortal) == 0x000008, "Wrong alignment on ALoadoutPortal");
static_assert(sizeof(ALoadoutPortal) == 0x000288, "Wrong size on ALoadoutPortal");
static_assert(offsetof(ALoadoutPortal, InteractableComponent) == 0x000228, "Member 'ALoadoutPortal::InteractableComponent' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, CompsToOutline) == 0x000230, "Member 'ALoadoutPortal::CompsToOutline' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, LightsToEnable) == 0x000240, "Member 'ALoadoutPortal::LightsToEnable' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, LevelSequence) == 0x000250, "Member 'ALoadoutPortal::LevelSequence' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, LevelSequencePlayer) == 0x000258, "Member 'ALoadoutPortal::LevelSequencePlayer' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, LevelSequenceActor) == 0x000260, "Member 'ALoadoutPortal::LevelSequenceActor' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, bOpenCustomization) == 0x000268, "Member 'ALoadoutPortal::bOpenCustomization' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, LightActorsOfTag) == 0x00026C, "Member 'ALoadoutPortal::LightActorsOfTag' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, IsActive) == 0x000274, "Member 'ALoadoutPortal::IsActive' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, LoadoutWidget) == 0x000278, "Member 'ALoadoutPortal::LoadoutWidget' has a wrong offset!");

// Class ReadyOrNot.LoadoutSlot_V2
// 0x00B8 (0x0340 - 0x0288)
class ULoadoutSlot_V2 : public UCommonUserWidget
{
public:
	class ABaseItem*                              BaseItem;                                          // 0x0288(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABaseItem>                  BaseItemClass;                                     // 0x0290(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseWeapon*                            BaseWeapon;                                        // 0x0298(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseArmour*                            BaseArmor;                                         // 0x02A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArmourMaterial*                        ArmorMaterial;                                     // 0x02A8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AmmunitionName;                                    // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ItemImage;                                         // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             EmptyImage;                                        // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ItemName;                                          // 0x02C8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ItemType;                                          // 0x02E0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ItemSubtext;                                       // 0x02F8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         SlotCount;                                         // 0x0310(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWeaponAttachmentType                         AttachmentType;                                    // 0x0314(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271F[0x3];                                     // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponAttachment*                      Attachment;                                        // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELoadoutMunitionSlotType                      MunitionType;                                      // 0x0320(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHovered;                                          // 0x0321(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPressed;                                          // 0x0322(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseGamepad;                                       // 0x0323(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachment;                                       // 0x0324(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2720[0x3];                                     // 0x0325(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotGameState*                   Gs;                                                // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UReadyOrNotLoadoutManager*              LoadoutFunctionLibrary;                            // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEquipped;                                         // 0x0338(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2721[0x7];                                     // 0x0339(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecrementSlots();
	TSubclassOf<class UWeaponAttachment> GetAttachmentClass();
	bool GetEquipped();
	void IncrementSlots();
	void OnEquipped();
	void OnSlotsUpdated();
	void RefreshAttachmentImage();
	void RefreshInfo();
	void RefreshItemImage();
	void SetAmmoMunition(class FName AmmoName, bool Secondary);
	void SetArmorMaterial(class UArmourMaterial* Item);
	void SetAttachment(class UWeaponAttachment* WeaponAttachment);
	void SetEquipped(bool IsEquipped);
	void SetItem(class ABaseItem* Item);
	void SetStyle(bool UseGamepad);
	void SetTacticalMunition(ELoadoutMunitionSlotType Munition, class ABaseItem* TacticalItem);
	void SetVisualState(bool Hovered, bool Pressed, bool Equipped);
	void ShowSubtext(class FText& Text, bool Show);
	void UpdateSlotCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutSlot_V2">();
	}
	static class ULoadoutSlot_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutSlot_V2>();
	}
};
static_assert(alignof(ULoadoutSlot_V2) == 0x000008, "Wrong alignment on ULoadoutSlot_V2");
static_assert(sizeof(ULoadoutSlot_V2) == 0x000340, "Wrong size on ULoadoutSlot_V2");
static_assert(offsetof(ULoadoutSlot_V2, BaseItem) == 0x000288, "Member 'ULoadoutSlot_V2::BaseItem' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, BaseItemClass) == 0x000290, "Member 'ULoadoutSlot_V2::BaseItemClass' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, BaseWeapon) == 0x000298, "Member 'ULoadoutSlot_V2::BaseWeapon' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, BaseArmor) == 0x0002A0, "Member 'ULoadoutSlot_V2::BaseArmor' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, ArmorMaterial) == 0x0002A8, "Member 'ULoadoutSlot_V2::ArmorMaterial' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, AmmunitionName) == 0x0002B0, "Member 'ULoadoutSlot_V2::AmmunitionName' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, ItemImage) == 0x0002B8, "Member 'ULoadoutSlot_V2::ItemImage' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, EmptyImage) == 0x0002C0, "Member 'ULoadoutSlot_V2::EmptyImage' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, ItemName) == 0x0002C8, "Member 'ULoadoutSlot_V2::ItemName' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, ItemType) == 0x0002E0, "Member 'ULoadoutSlot_V2::ItemType' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, ItemSubtext) == 0x0002F8, "Member 'ULoadoutSlot_V2::ItemSubtext' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, SlotCount) == 0x000310, "Member 'ULoadoutSlot_V2::SlotCount' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, AttachmentType) == 0x000314, "Member 'ULoadoutSlot_V2::AttachmentType' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, Attachment) == 0x000318, "Member 'ULoadoutSlot_V2::Attachment' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, MunitionType) == 0x000320, "Member 'ULoadoutSlot_V2::MunitionType' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, bHovered) == 0x000321, "Member 'ULoadoutSlot_V2::bHovered' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, bPressed) == 0x000322, "Member 'ULoadoutSlot_V2::bPressed' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, bUseGamepad) == 0x000323, "Member 'ULoadoutSlot_V2::bUseGamepad' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, bAttachment) == 0x000324, "Member 'ULoadoutSlot_V2::bAttachment' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, Gs) == 0x000328, "Member 'ULoadoutSlot_V2::Gs' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, LoadoutFunctionLibrary) == 0x000330, "Member 'ULoadoutSlot_V2::LoadoutFunctionLibrary' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, bEquipped) == 0x000338, "Member 'ULoadoutSlot_V2::bEquipped' has a wrong offset!");

// Class ReadyOrNot.RadialWidgetThemeData
// 0x00A0 (0x00D0 - 0x0030)
class URadialWidgetThemeData final  : public UDataAsset
{
public:
	class FName                                   Name_RadialWidgetThemeData;                        // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         StartingSectorIndex;                               // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingSectorAngle;                               // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IconSize;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IconPadding;                                       // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SectorInnerRadius;                                 // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SectorOuterRadius;                                 // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GapSize;                                           // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WheelSize;                                         // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WheelCursorDistanceFromCenterWheel;                // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHideRadialWheelCursorOnMenuOpened : 1;            // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2725[0x3];                                     // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           SelectedColor;                                     // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           UnselectedColor;                                   // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           UnselectableColor;                                 // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  Font;                                              // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SelectionSound;                                    // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MenuOpenSound;                                     // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MenuCloseSound;                                    // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MenuCloseSound_NoSelection;                        // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadialWidgetThemeData">();
	}
	static class URadialWidgetThemeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URadialWidgetThemeData>();
	}
};
static_assert(alignof(URadialWidgetThemeData) == 0x000008, "Wrong alignment on URadialWidgetThemeData");
static_assert(sizeof(URadialWidgetThemeData) == 0x0000D0, "Wrong size on URadialWidgetThemeData");
static_assert(offsetof(URadialWidgetThemeData, Name_RadialWidgetThemeData) == 0x000030, "Member 'URadialWidgetThemeData::Name_RadialWidgetThemeData' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, Description) == 0x000038, "Member 'URadialWidgetThemeData::Description' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, StartingSectorIndex) == 0x000050, "Member 'URadialWidgetThemeData::StartingSectorIndex' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, StartingSectorAngle) == 0x000054, "Member 'URadialWidgetThemeData::StartingSectorAngle' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, IconSize) == 0x000058, "Member 'URadialWidgetThemeData::IconSize' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, IconPadding) == 0x00005C, "Member 'URadialWidgetThemeData::IconPadding' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, SectorInnerRadius) == 0x000060, "Member 'URadialWidgetThemeData::SectorInnerRadius' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, SectorOuterRadius) == 0x000064, "Member 'URadialWidgetThemeData::SectorOuterRadius' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, GapSize) == 0x000068, "Member 'URadialWidgetThemeData::GapSize' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, WheelSize) == 0x00006C, "Member 'URadialWidgetThemeData::WheelSize' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, WheelCursorDistanceFromCenterWheel) == 0x000070, "Member 'URadialWidgetThemeData::WheelCursorDistanceFromCenterWheel' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, SelectedColor) == 0x000078, "Member 'URadialWidgetThemeData::SelectedColor' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, UnselectedColor) == 0x000088, "Member 'URadialWidgetThemeData::UnselectedColor' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, UnselectableColor) == 0x000098, "Member 'URadialWidgetThemeData::UnselectableColor' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, Font) == 0x0000A8, "Member 'URadialWidgetThemeData::Font' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, SelectionSound) == 0x0000B0, "Member 'URadialWidgetThemeData::SelectionSound' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, MenuOpenSound) == 0x0000B8, "Member 'URadialWidgetThemeData::MenuOpenSound' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, MenuCloseSound) == 0x0000C0, "Member 'URadialWidgetThemeData::MenuCloseSound' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, MenuCloseSound_NoSelection) == 0x0000C8, "Member 'URadialWidgetThemeData::MenuCloseSound_NoSelection' has a wrong offset!");

// Class ReadyOrNot.LoadoutSlotAttachmentWidget
// 0x0000 (0x0260 - 0x0260)
class ULoadoutSlotAttachmentWidget final  : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutSlotAttachmentWidget">();
	}
	static class ULoadoutSlotAttachmentWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutSlotAttachmentWidget>();
	}
};
static_assert(alignof(ULoadoutSlotAttachmentWidget) == 0x000008, "Wrong alignment on ULoadoutSlotAttachmentWidget");
static_assert(sizeof(ULoadoutSlotAttachmentWidget) == 0x000260, "Wrong size on ULoadoutSlotAttachmentWidget");

// Class ReadyOrNot.LoadoutSlotWidget
// 0x01A0 (0x0428 - 0x0288)
class ULoadoutSlotWidget : public UCommonUserWidget
{
public:
	bool                                          IsActive;                                          // 0x0288(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 LoadoutSlot;                                       // 0x0289(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2726[0x6];                                     // 0x028A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseItem>                  ItemData;                                          // 0x0290(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPrimary;                                        // 0x0298(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAmmunition;                                     // 0x0299(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2727[0x6];                                     // 0x029A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAmmoTypeData                          AmmoType;                                          // 0x02A0(0x0160)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsArmourMaterial;                                 // 0x0400(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2728[0x7];                                     // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmourMaterial*                        ArmourMaterialData;                                // 0x0408(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponAttachmentType                         AttachmentSlot;                                    // 0x0410(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2729[0x7];                                     // 0x0411(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct ReadyOrNot::FLoadoutCategory>   GearCategoryClasses;                               // 0x0418(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void SetActive(bool Param_IsActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutSlotWidget">();
	}
	static class ULoadoutSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutSlotWidget>();
	}
};
static_assert(alignof(ULoadoutSlotWidget) == 0x000008, "Wrong alignment on ULoadoutSlotWidget");
static_assert(sizeof(ULoadoutSlotWidget) == 0x000428, "Wrong size on ULoadoutSlotWidget");
static_assert(offsetof(ULoadoutSlotWidget, IsActive) == 0x000288, "Member 'ULoadoutSlotWidget::IsActive' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, LoadoutSlot) == 0x000289, "Member 'ULoadoutSlotWidget::LoadoutSlot' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, ItemData) == 0x000290, "Member 'ULoadoutSlotWidget::ItemData' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, bIsPrimary) == 0x000298, "Member 'ULoadoutSlotWidget::bIsPrimary' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, bIsAmmunition) == 0x000299, "Member 'ULoadoutSlotWidget::bIsAmmunition' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, AmmoType) == 0x0002A0, "Member 'ULoadoutSlotWidget::AmmoType' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, bIsArmourMaterial) == 0x000400, "Member 'ULoadoutSlotWidget::bIsArmourMaterial' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, ArmourMaterialData) == 0x000408, "Member 'ULoadoutSlotWidget::ArmourMaterialData' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, AttachmentSlot) == 0x000410, "Member 'ULoadoutSlotWidget::AttachmentSlot' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, GearCategoryClasses) == 0x000418, "Member 'ULoadoutSlotWidget::GearCategoryClasses' has a wrong offset!");

// Class ReadyOrNot.LoadoutUnitSelectWidget
// 0x0000 (0x0260 - 0x0260)
class ULoadoutUnitSelectWidget final  : public UUserWidget
{
public:
	void Init();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutUnitSelectWidget">();
	}
	static class ULoadoutUnitSelectWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutUnitSelectWidget>();
	}
};
static_assert(alignof(ULoadoutUnitSelectWidget) == 0x000008, "Wrong alignment on ULoadoutUnitSelectWidget");
static_assert(sizeof(ULoadoutUnitSelectWidget) == 0x000260, "Wrong size on ULoadoutUnitSelectWidget");

// Class ReadyOrNot.NavArea_TrappedDoor
// 0x0000 (0x0048 - 0x0048)
class UNavArea_TrappedDoor final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_TrappedDoor">();
	}
	static class UNavArea_TrappedDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_TrappedDoor>();
	}
};
static_assert(alignof(UNavArea_TrappedDoor) == 0x000008, "Wrong alignment on UNavArea_TrappedDoor");
static_assert(sizeof(UNavArea_TrappedDoor) == 0x000048, "Wrong size on UNavArea_TrappedDoor");

// Class ReadyOrNot.LobbyGM
// 0x0080 (0x07F0 - 0x0770)
class ALobbyGM final  : public AReadyOrNotGameMode
{
public:
	uint8                                         Pad_272A[0x8];                                     // 0x0770(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotPlayerController*>    InitalizedPlayerControllers;                       // 0x0778(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_272B[0x48];                                    // 0x0788(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommanderProfile*                      CommanderProfile;                                  // 0x07D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URosterManager*                         RosterManager;                                     // 0x07D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_272C[0x10];                                    // 0x07E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGenericPlayerInitialization__DelegateSignature(class AReadyOrNotPlayerController* ReadyOrNotPlayerController);
	void OpenMissionSelect();
	void OpenRosterSelection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyGM">();
	}
	static class ALobbyGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyGM>();
	}
};
static_assert(alignof(ALobbyGM) == 0x000010, "Wrong alignment on ALobbyGM");
static_assert(sizeof(ALobbyGM) == 0x0007F0, "Wrong size on ALobbyGM");
static_assert(offsetof(ALobbyGM, InitalizedPlayerControllers) == 0x000778, "Member 'ALobbyGM::InitalizedPlayerControllers' has a wrong offset!");
static_assert(offsetof(ALobbyGM, CommanderProfile) == 0x0007D0, "Member 'ALobbyGM::CommanderProfile' has a wrong offset!");
static_assert(offsetof(ALobbyGM, RosterManager) == 0x0007D8, "Member 'ALobbyGM::RosterManager' has a wrong offset!");

// Class ReadyOrNot.Optiwand
// 0x00F0 (0x0AC0 - 0x09D0)
class AOptiwand : public ABaseItem
{
public:
	class UAnimMontage*                           Montage_StartOptiwandADS;                          // 0x09D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage_EndOptiwandADS;                            // 0x09D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionTraceDistance;                            // 0x09E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_272D[0x4];                                     // 0x09E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             FMODOptiwandMove;                                  // 0x09E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODOptiwandEnterView;                             // 0x09F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODOptiwandExitView;                              // 0x09F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      MI_AIOutline;                                      // 0x0A00(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_272E[0x8];                                     // 0x0A08(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneCaptureComponent2D*               SceneCapture2D;                                    // 0x0A10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 CameraRenderTarget;                                // 0x0A18(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACameraActor*                           CameraActor;                                       // 0x0A20(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LookAtPosition;                                    // 0x0A28(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               LookAtRotation;                                    // 0x0A34(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               OptiwandCaptureRotation;                           // 0x0A40(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bMirorring : 1;                                    // 0x0A4C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	bool                                          bRepMirroring;                                     // 0x0A4D(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInUse : 1;                                        // 0x0A4E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_272F[0x1];                                     // 0x0A4F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  LastUsedDoor;                                      // 0x0A50(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODAudioComponent*                    FMODOptiwandMoveAudioComp;                         // 0x0A58(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODAudioComponent*                    FMODOptiwandEnterViewComp;                         // 0x0A60(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODAudioComponent*                    FMODOptiwandExitViewComp;                          // 0x0A68(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2730[0x50];                                    // 0x0A70(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_NotifyMirroring(bool bIsMirroring);

	EOptiwandViewMode GetViewMode() const;
	bool IsCameraBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Optiwand">();
	}
	static class AOptiwand* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOptiwand>();
	}
};
static_assert(alignof(AOptiwand) == 0x000010, "Wrong alignment on AOptiwand");
static_assert(sizeof(AOptiwand) == 0x000AC0, "Wrong size on AOptiwand");
static_assert(offsetof(AOptiwand, Montage_StartOptiwandADS) == 0x0009D0, "Member 'AOptiwand::Montage_StartOptiwandADS' has a wrong offset!");
static_assert(offsetof(AOptiwand, Montage_EndOptiwandADS) == 0x0009D8, "Member 'AOptiwand::Montage_EndOptiwandADS' has a wrong offset!");
static_assert(offsetof(AOptiwand, CollisionTraceDistance) == 0x0009E0, "Member 'AOptiwand::CollisionTraceDistance' has a wrong offset!");
static_assert(offsetof(AOptiwand, FMODOptiwandMove) == 0x0009E8, "Member 'AOptiwand::FMODOptiwandMove' has a wrong offset!");
static_assert(offsetof(AOptiwand, FMODOptiwandEnterView) == 0x0009F0, "Member 'AOptiwand::FMODOptiwandEnterView' has a wrong offset!");
static_assert(offsetof(AOptiwand, FMODOptiwandExitView) == 0x0009F8, "Member 'AOptiwand::FMODOptiwandExitView' has a wrong offset!");
static_assert(offsetof(AOptiwand, MI_AIOutline) == 0x000A00, "Member 'AOptiwand::MI_AIOutline' has a wrong offset!");
static_assert(offsetof(AOptiwand, SceneCapture2D) == 0x000A10, "Member 'AOptiwand::SceneCapture2D' has a wrong offset!");
static_assert(offsetof(AOptiwand, CameraRenderTarget) == 0x000A18, "Member 'AOptiwand::CameraRenderTarget' has a wrong offset!");
static_assert(offsetof(AOptiwand, CameraActor) == 0x000A20, "Member 'AOptiwand::CameraActor' has a wrong offset!");
static_assert(offsetof(AOptiwand, LookAtPosition) == 0x000A28, "Member 'AOptiwand::LookAtPosition' has a wrong offset!");
static_assert(offsetof(AOptiwand, LookAtRotation) == 0x000A34, "Member 'AOptiwand::LookAtRotation' has a wrong offset!");
static_assert(offsetof(AOptiwand, OptiwandCaptureRotation) == 0x000A40, "Member 'AOptiwand::OptiwandCaptureRotation' has a wrong offset!");
static_assert(offsetof(AOptiwand, bRepMirroring) == 0x000A4D, "Member 'AOptiwand::bRepMirroring' has a wrong offset!");
static_assert(offsetof(AOptiwand, LastUsedDoor) == 0x000A50, "Member 'AOptiwand::LastUsedDoor' has a wrong offset!");
static_assert(offsetof(AOptiwand, FMODOptiwandMoveAudioComp) == 0x000A58, "Member 'AOptiwand::FMODOptiwandMoveAudioComp' has a wrong offset!");
static_assert(offsetof(AOptiwand, FMODOptiwandEnterViewComp) == 0x000A60, "Member 'AOptiwand::FMODOptiwandEnterViewComp' has a wrong offset!");
static_assert(offsetof(AOptiwand, FMODOptiwandExitViewComp) == 0x000A68, "Member 'AOptiwand::FMODOptiwandExitViewComp' has a wrong offset!");

// Class ReadyOrNot.SWATCharacter
// 0x0050 (0x1FE0 - 0x1F90)
class ASWATCharacter : public ACyberneticCharacter
{
public:
	uint8                                         Pad_2731[0x40];                                    // 0x1F90(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class URosterCharacter*                       RosterCharacter;                                   // 0x1FD0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2732[0x8];                                     // 0x1FD8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayOnShotDialogue(bool bIsFriendly);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SWATCharacter">();
	}
	static class ASWATCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASWATCharacter>();
	}
};
static_assert(alignof(ASWATCharacter) == 0x000010, "Wrong alignment on ASWATCharacter");
static_assert(sizeof(ASWATCharacter) == 0x001FE0, "Wrong size on ASWATCharacter");
static_assert(offsetof(ASWATCharacter, RosterCharacter) == 0x001FD0, "Member 'ASWATCharacter::RosterCharacter' has a wrong offset!");

// Class ReadyOrNot.LockPickDoorActivity
// 0x0000 (0x01F8 - 0x01F8)
class ULockPickDoorActivity final  : public UDoorInteractionActivity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockPickDoorActivity">();
	}
	static class ULockPickDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockPickDoorActivity>();
	}
};
static_assert(alignof(ULockPickDoorActivity) == 0x000008, "Wrong alignment on ULockPickDoorActivity");
static_assert(sizeof(ULockPickDoorActivity) == 0x0001F8, "Wrong size on ULockPickDoorActivity");

// Class ReadyOrNot.LockpickGun
// 0x0000 (0x09F0 - 0x09F0)
class ALockpickGun : public ATool
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockpickGun">();
	}
	static class ALockpickGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALockpickGun>();
	}
};
static_assert(alignof(ALockpickGun) == 0x000010, "Wrong alignment on ALockpickGun");
static_assert(sizeof(ALockpickGun) == 0x0009F0, "Wrong size on ALockpickGun");

// Class ReadyOrNot.MoveToExitActivity
// 0x0000 (0x01A8 - 0x01A8)
class UMoveToExitActivity final  : public UBaseActivity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveToExitActivity">();
	}
	static class UMoveToExitActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveToExitActivity>();
	}
};
static_assert(alignof(UMoveToExitActivity) == 0x000008, "Wrong alignment on UMoveToExitActivity");
static_assert(sizeof(UMoveToExitActivity) == 0x0001A8, "Wrong size on UMoveToExitActivity");

// Class ReadyOrNot.MapStatisticsSystem
// 0x0090 (0x02B0 - 0x0220)
class AMapStatisticsSystem final  : public AInfo
{
public:
	uint8                                         Pad_2733[0xC];                                     // 0x0220(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  GameId;                                            // 0x022C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2734[0x14];                                    // 0x023C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, uint8>                    ActorIdMap;                                        // 0x0250(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FAnalyticsStatus>               Statuses;                                          // 0x02A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void EndLevel();
	void StartRecording(const class FString& InLevelName, const class FString& InGameMode);

	struct FGuid GetGameId() const;
	class FString GetRecordingStatus() const;
	bool IsRecording() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapStatisticsSystem">();
	}
	static class AMapStatisticsSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapStatisticsSystem>();
	}
};
static_assert(alignof(AMapStatisticsSystem) == 0x000008, "Wrong alignment on AMapStatisticsSystem");
static_assert(sizeof(AMapStatisticsSystem) == 0x0002B0, "Wrong size on AMapStatisticsSystem");
static_assert(offsetof(AMapStatisticsSystem, GameId) == 0x00022C, "Member 'AMapStatisticsSystem::GameId' has a wrong offset!");
static_assert(offsetof(AMapStatisticsSystem, ActorIdMap) == 0x000250, "Member 'AMapStatisticsSystem::ActorIdMap' has a wrong offset!");
static_assert(offsetof(AMapStatisticsSystem, Statuses) == 0x0002A0, "Member 'AMapStatisticsSystem::Statuses' has a wrong offset!");

// Class ReadyOrNot.LoudnessMeterWidget
// 0x0018 (0x0290 - 0x0278)
class ULoudnessMeterWidget final  : public UBaseWidget
{
public:
	class UWidgetSwitcher*                        MovementSound_WidgetSwitcher;                      // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0280(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2735[0x8];                                     // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudnessMeterWidget">();
	}
	static class ULoudnessMeterWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoudnessMeterWidget>();
	}
};
static_assert(alignof(ULoudnessMeterWidget) == 0x000008, "Wrong alignment on ULoudnessMeterWidget");
static_assert(sizeof(ULoudnessMeterWidget) == 0x000290, "Wrong size on ULoudnessMeterWidget");
static_assert(offsetof(ULoudnessMeterWidget, MovementSound_WidgetSwitcher) == 0x000278, "Member 'ULoudnessMeterWidget::MovementSound_WidgetSwitcher' has a wrong offset!");
static_assert(offsetof(ULoudnessMeterWidget, PlayerCharacter) == 0x000280, "Member 'ULoudnessMeterWidget::PlayerCharacter' has a wrong offset!");

// Class ReadyOrNot.PlaceTrapActivity
// 0x0010 (0x0250 - 0x0240)
class UPlaceTrapActivity final  : public UWorldBuildingActivity
{
public:
	class ADoor*                                  Door;                                              // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2736[0x8];                                     // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTrapPlacementInterrupted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaceTrapActivity">();
	}
	static class UPlaceTrapActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaceTrapActivity>();
	}
};
static_assert(alignof(UPlaceTrapActivity) == 0x000008, "Wrong alignment on UPlaceTrapActivity");
static_assert(sizeof(UPlaceTrapActivity) == 0x000250, "Wrong size on UPlaceTrapActivity");
static_assert(offsetof(UPlaceTrapActivity, Door) == 0x000240, "Member 'UPlaceTrapActivity::Door' has a wrong offset!");

// Class ReadyOrNot.MagMaskingAnimNotify
// 0x0008 (0x0040 - 0x0038)
class UMagMaskingAnimNotify final  : public UAnimNotify
{
public:
	bool                                          bIsFirstPerson;                                    // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMaskMag                                      MaskMag;                                           // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMaskMagState                                 MagState;                                          // 0x003A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDummyCopyMag02;                                   // 0x003B(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2737[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagMaskingAnimNotify">();
	}
	static class UMagMaskingAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagMaskingAnimNotify>();
	}
};
static_assert(alignof(UMagMaskingAnimNotify) == 0x000008, "Wrong alignment on UMagMaskingAnimNotify");
static_assert(sizeof(UMagMaskingAnimNotify) == 0x000040, "Wrong size on UMagMaskingAnimNotify");
static_assert(offsetof(UMagMaskingAnimNotify, bIsFirstPerson) == 0x000038, "Member 'UMagMaskingAnimNotify::bIsFirstPerson' has a wrong offset!");
static_assert(offsetof(UMagMaskingAnimNotify, MaskMag) == 0x000039, "Member 'UMagMaskingAnimNotify::MaskMag' has a wrong offset!");
static_assert(offsetof(UMagMaskingAnimNotify, MagState) == 0x00003A, "Member 'UMagMaskingAnimNotify::MagState' has a wrong offset!");
static_assert(offsetof(UMagMaskingAnimNotify, bDummyCopyMag02) == 0x00003B, "Member 'UMagMaskingAnimNotify::bDummyCopyMag02' has a wrong offset!");

// Class ReadyOrNot.MainMenu_BaseButton
// 0x0068 (0x0C38 - 0x0BD0)
class UMainMenu_BaseButton : public UCommonButtonFMOD
{
public:
	class FText                                   ButtonText;                                        // 0x0BD0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            NormalTextColor;                                   // 0x0BE8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            HoveredTextColor;                                  // 0x0C10(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenu_BaseButton">();
	}
	static class UMainMenu_BaseButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenu_BaseButton>();
	}
};
static_assert(alignof(UMainMenu_BaseButton) == 0x000008, "Wrong alignment on UMainMenu_BaseButton");
static_assert(sizeof(UMainMenu_BaseButton) == 0x000C38, "Wrong size on UMainMenu_BaseButton");
static_assert(offsetof(UMainMenu_BaseButton, ButtonText) == 0x000BD0, "Member 'UMainMenu_BaseButton::ButtonText' has a wrong offset!");
static_assert(offsetof(UMainMenu_BaseButton, NormalTextColor) == 0x000BE8, "Member 'UMainMenu_BaseButton::NormalTextColor' has a wrong offset!");
static_assert(offsetof(UMainMenu_BaseButton, HoveredTextColor) == 0x000C10, "Member 'UMainMenu_BaseButton::HoveredTextColor' has a wrong offset!");

// Class ReadyOrNot.NavArea_SuspectD
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SuspectD final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SuspectD">();
	}
	static class UNavArea_SuspectD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SuspectD>();
	}
};
static_assert(alignof(UNavArea_SuspectD) == 0x000008, "Wrong alignment on UNavArea_SuspectD");
static_assert(sizeof(UNavArea_SuspectD) == 0x000048, "Wrong size on UNavArea_SuspectD");

// Class ReadyOrNot.MainMenu_Wrapper
// 0x0000 (0x0320 - 0x0320)
class UMainMenu_Wrapper final  : public UCommonActivatableWidget
{
public:
	void CloseModMenu();
	void OpenModMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenu_Wrapper">();
	}
	static class UMainMenu_Wrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenu_Wrapper>();
	}
};
static_assert(alignof(UMainMenu_Wrapper) == 0x000008, "Wrong alignment on UMainMenu_Wrapper");
static_assert(sizeof(UMainMenu_Wrapper) == 0x000320, "Wrong size on UMainMenu_Wrapper");

// Class ReadyOrNot.MapActorComponent
// 0x00E0 (0x02E0 - 0x0200)
class UMapActorComponent final  : public USceneComponent
{
public:
	uint8                                         bCondition : 1;                                    // 0x01F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnabled : 1;                                      // 0x01F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2738[0x7];                                     // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMapActorWidget>            MapActorWidgetClass;                               // 0x0200(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   IconText;                                          // 0x0208(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           IconTextColor;                                     // 0x0220(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            IconBrush;                                         // 0x0230(0x0088)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           IconColor;                                         // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUseActorRotation : 1;                             // 0x02C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2739[0x3];                                     // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationOffset;                                    // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAddedToMap;                                       // 0x02D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_273A[0x7];                                     // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMapActorIconWidget*                    MapIconWidget;                                     // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DisableMapActor();
	void EnableMapActor();
	void SetIconColor(struct FLinearColor& InIconColor);
	void SetIconText(class FText& InIconText);
	void SetIconTextColor(struct FLinearColor& InIconTextColor);

	class FText GetIconText() const;
	bool IsUsingActorRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorComponent">();
	}
	static class UMapActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActorComponent>();
	}
};
static_assert(alignof(UMapActorComponent) == 0x000010, "Wrong alignment on UMapActorComponent");
static_assert(sizeof(UMapActorComponent) == 0x0002E0, "Wrong size on UMapActorComponent");
static_assert(offsetof(UMapActorComponent, MapActorWidgetClass) == 0x000200, "Member 'UMapActorComponent::MapActorWidgetClass' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, IconText) == 0x000208, "Member 'UMapActorComponent::IconText' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, IconTextColor) == 0x000220, "Member 'UMapActorComponent::IconTextColor' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, IconBrush) == 0x000230, "Member 'UMapActorComponent::IconBrush' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, IconColor) == 0x0002B8, "Member 'UMapActorComponent::IconColor' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, RotationOffset) == 0x0002CC, "Member 'UMapActorComponent::RotationOffset' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, bAddedToMap) == 0x0002D0, "Member 'UMapActorComponent::bAddedToMap' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, MapIconWidget) == 0x0002D8, "Member 'UMapActorComponent::MapIconWidget' has a wrong offset!");

// Class ReadyOrNot.PickupEvidenceByTag
// 0x0008 (0x02B0 - 0x02A8)
class APickupEvidenceByTag final  : public AObjective
{
public:
	class FName                                   EvidenceTag;                                       // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static bool HasCollectedEvidenceByTag(class FName& Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupEvidenceByTag">();
	}
	static class APickupEvidenceByTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<APickupEvidenceByTag>();
	}
};
static_assert(alignof(APickupEvidenceByTag) == 0x000008, "Wrong alignment on APickupEvidenceByTag");
static_assert(sizeof(APickupEvidenceByTag) == 0x0002B0, "Wrong size on APickupEvidenceByTag");
static_assert(offsetof(APickupEvidenceByTag, EvidenceTag) == 0x0002A8, "Member 'APickupEvidenceByTag::EvidenceTag' has a wrong offset!");

// Class ReadyOrNot.MapActorIconWidget
// 0x0010 (0x02C0 - 0x02B0)
class UMapActorIconWidget final  : public UMapActorWidget
{
public:
	class UImage*                                 Icon_Image;                                        // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Icon_Image_BG;                                     // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetIconBrushStyle(const struct FSlateBrush& InIconBrush, const struct FLinearColor& InIconColor);
	void SetIconColor(const struct FLinearColor& InIconColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorIconWidget">();
	}
	static class UMapActorIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActorIconWidget>();
	}
};
static_assert(alignof(UMapActorIconWidget) == 0x000008, "Wrong alignment on UMapActorIconWidget");
static_assert(sizeof(UMapActorIconWidget) == 0x0002C0, "Wrong size on UMapActorIconWidget");
static_assert(offsetof(UMapActorIconWidget, Icon_Image) == 0x0002B0, "Member 'UMapActorIconWidget::Icon_Image' has a wrong offset!");
static_assert(offsetof(UMapActorIconWidget, Icon_Image_BG) == 0x0002B8, "Member 'UMapActorIconWidget::Icon_Image_BG' has a wrong offset!");

// Class ReadyOrNot.MapReferendum
// 0x0010 (0x02B8 - 0x02A8)
class AMapReferendum final  : public AReferendum
{
public:
	class FString                                 MapURL;                                            // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapReferendum">();
	}
	static class AMapReferendum* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapReferendum>();
	}
};
static_assert(alignof(AMapReferendum) == 0x000008, "Wrong alignment on AMapReferendum");
static_assert(sizeof(AMapReferendum) == 0x0002B8, "Wrong size on AMapReferendum");
static_assert(offsetof(AMapReferendum, MapURL) == 0x0002A8, "Member 'AMapReferendum::MapURL' has a wrong offset!");

// Class ReadyOrNot.MatchStatusCardWidget
// 0x0010 (0x0288 - 0x0278)
class UMatchStatusCardWidget final  : public UBaseWidget
{
public:
	class UMatchTimeRemainingWidget*              MatchTimeRemaining;                                // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurrentMatchRoundWidget*               CurrentMatchRound;                                 // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchStatusCardWidget">();
	}
	static class UMatchStatusCardWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchStatusCardWidget>();
	}
};
static_assert(alignof(UMatchStatusCardWidget) == 0x000008, "Wrong alignment on UMatchStatusCardWidget");
static_assert(sizeof(UMatchStatusCardWidget) == 0x000288, "Wrong size on UMatchStatusCardWidget");
static_assert(offsetof(UMatchStatusCardWidget, MatchTimeRemaining) == 0x000278, "Member 'UMatchStatusCardWidget::MatchTimeRemaining' has a wrong offset!");
static_assert(offsetof(UMatchStatusCardWidget, CurrentMatchRound) == 0x000280, "Member 'UMatchStatusCardWidget::CurrentMatchRound' has a wrong offset!");

// Class ReadyOrNot.MeleeWeapon
// 0x0020 (0x1020 - 0x1000)
class AMeleeWeapon : public ABaseWeapon
{
public:
	class FString                                 MeleeMontage;                                      // 0x1000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyBleed;                                       // 0x1010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_273C[0x3];                                     // 0x1011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeleeDamage;                                       // 0x1014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_273D[0x8];                                     // 0x1018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeleeWeapon">();
	}
	static class AMeleeWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMeleeWeapon>();
	}
};
static_assert(alignof(AMeleeWeapon) == 0x000010, "Wrong alignment on AMeleeWeapon");
static_assert(sizeof(AMeleeWeapon) == 0x001020, "Wrong size on AMeleeWeapon");
static_assert(offsetof(AMeleeWeapon, MeleeMontage) == 0x001000, "Member 'AMeleeWeapon::MeleeMontage' has a wrong offset!");
static_assert(offsetof(AMeleeWeapon, bApplyBleed) == 0x001010, "Member 'AMeleeWeapon::bApplyBleed' has a wrong offset!");
static_assert(offsetof(AMeleeWeapon, MeleeDamage) == 0x001014, "Member 'AMeleeWeapon::MeleeDamage' has a wrong offset!");

// Class ReadyOrNot.MemorialViewer
// 0x0020 (0x0240 - 0x0220)
class AMemorialViewer final  : public AActor
{
public:
	uint8                                         Pad_273E[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        RootSceneComponent;                                // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractableComponent*                 InteractableComponent;                             // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            Widget;                                            // 0x0238(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MemorialViewer">();
	}
	static class AMemorialViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMemorialViewer>();
	}
};
static_assert(alignof(AMemorialViewer) == 0x000008, "Wrong alignment on AMemorialViewer");
static_assert(sizeof(AMemorialViewer) == 0x000240, "Wrong size on AMemorialViewer");
static_assert(offsetof(AMemorialViewer, RootSceneComponent) == 0x000228, "Member 'AMemorialViewer::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AMemorialViewer, InteractableComponent) == 0x000230, "Member 'AMemorialViewer::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AMemorialViewer, Widget) == 0x000238, "Member 'AMemorialViewer::Widget' has a wrong offset!");

// Class ReadyOrNot.MessageDisplayBox
// 0x0028 (0x0288 - 0x0260)
class UMessageDisplayBox : public UUserWidget
{
public:
	class FString                                 MessageTxt;                                        // 0x0260(0x0010)(BlueprintVisible, ZeroConstructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ButtonTxt;                                         // 0x0270(0x0010)(BlueprintVisible, ZeroConstructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldQuitOnButtonPress;                          // 0x0280(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_273F[0x7];                                     // 0x0281(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageDisplayBox">();
	}
	static class UMessageDisplayBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMessageDisplayBox>();
	}
};
static_assert(alignof(UMessageDisplayBox) == 0x000008, "Wrong alignment on UMessageDisplayBox");
static_assert(sizeof(UMessageDisplayBox) == 0x000288, "Wrong size on UMessageDisplayBox");
static_assert(offsetof(UMessageDisplayBox, MessageTxt) == 0x000260, "Member 'UMessageDisplayBox::MessageTxt' has a wrong offset!");
static_assert(offsetof(UMessageDisplayBox, ButtonTxt) == 0x000270, "Member 'UMessageDisplayBox::ButtonTxt' has a wrong offset!");
static_assert(offsetof(UMessageDisplayBox, bShouldQuitOnButtonPress) == 0x000280, "Member 'UMessageDisplayBox::bShouldQuitOnButtonPress' has a wrong offset!");

// Class ReadyOrNot.MetaGameProfile
// 0x00F8 (0x0368 - 0x0270)
class UMetaGameProfile final  : public UBaseProfile
{
public:
	int32                                         MetaGameVersion;                                   // 0x0270(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2740[0x4];                                     // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LastCampaignSave;                                  // 0x0278(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalLobbyLogins;                                  // 0x0288(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasCompletedTutorial;                             // 0x028C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2741[0x3];                                     // 0x028D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         CompletedLevels;                                   // 0x0290(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         CompletedMultiplayerLevels;                        // 0x02A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TSet<class FName>                             ProgressionTags;                                   // 0x02B0(0x0050)(NativeAccessSpecifierPrivate)
	struct FMetaGameProfileTemporaryData          TemporaryData;                                     // 0x0300(0x0068)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaGameProfile">();
	}
	static class UMetaGameProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMetaGameProfile>();
	}
};
static_assert(alignof(UMetaGameProfile) == 0x000008, "Wrong alignment on UMetaGameProfile");
static_assert(sizeof(UMetaGameProfile) == 0x000368, "Wrong size on UMetaGameProfile");
static_assert(offsetof(UMetaGameProfile, MetaGameVersion) == 0x000270, "Member 'UMetaGameProfile::MetaGameVersion' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, LastCampaignSave) == 0x000278, "Member 'UMetaGameProfile::LastCampaignSave' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, TotalLobbyLogins) == 0x000288, "Member 'UMetaGameProfile::TotalLobbyLogins' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, bHasCompletedTutorial) == 0x00028C, "Member 'UMetaGameProfile::bHasCompletedTutorial' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, CompletedLevels) == 0x000290, "Member 'UMetaGameProfile::CompletedLevels' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, CompletedMultiplayerLevels) == 0x0002A0, "Member 'UMetaGameProfile::CompletedMultiplayerLevels' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, ProgressionTags) == 0x0002B0, "Member 'UMetaGameProfile::ProgressionTags' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, TemporaryData) == 0x000300, "Member 'UMetaGameProfile::TemporaryData' has a wrong offset!");

// Class ReadyOrNot.MirrorPortalComponent
// 0x0000 (0x0470 - 0x0470)
class UMirrorPortalComponent final  : public UArrowComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MirrorPortalComponent">();
	}
	static class UMirrorPortalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMirrorPortalComponent>();
	}
};
static_assert(alignof(UMirrorPortalComponent) == 0x000010, "Wrong alignment on UMirrorPortalComponent");
static_assert(sizeof(UMirrorPortalComponent) == 0x000470, "Wrong size on UMirrorPortalComponent");

// Class ReadyOrNot.MissionPortal
// 0x0120 (0x0370 - 0x0250)
class AMissionPortal final  : public AReadyOrNotTriggerVolume
{
public:
	uint8                                         Pad_2742[0x8];                                     // 0x0250(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 InteractableComponent;                             // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AReadyOrNotGameMode>> SelectableGameModes;                               // 0x0260(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class AMissionSelect*                         MissionSelect;                                     // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UReadyOrNotProfile*                     Profile;                                           // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommanderProfile*                      CommanderProfile;                                  // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMetaGameProfile*                       MetaGameProfile;                                   // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextRenderComponent*                   WhiteboardText;                                    // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2743[0x8];                                     // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMissionSelected_Delegate;                        // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 MissionURL;                                        // 0x02B0(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ModeURL;                                           // 0x02C0(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SelectedEntryPoint;                                // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           CompsToOutline;                                    // 0x02D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class ULightComponent*>                LightsToEnable;                                    // 0x02E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           CompsToOutlineMissionSelected;                     // 0x02F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class ULightComponent*>                LightsToEnableMissionSelected;                     // 0x0308(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2744[0x18];                                    // 0x0318(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCountdownStarted;                                // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCountdownCancelled;                              // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         NumReadyPlayers;                                   // 0x0350(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2745[0x4];                                     // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotPlayerController*>    ReadiedPlayers;                                    // 0x0358(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2746[0x8];                                     // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool DoesLevelExistInBuild(const class FString& InUrl);
	static bool GetPlayersReady(int32* Ready, int32* Total);
	static void GetSelectedMission(class FString* OutMissionURL);
	static bool GetSelectedMode(class FString* OutMode);
	static bool GetSelectedModeName(class FString* OutName);
	static bool IsGameModeSelectable(ECOOPMode InMode);
	static bool IsLevelUnlocked(const class FString& InUrl, bool* OutIsUnlocked, float* OutScoreRequired, class FString* OutLockedUrl);
	static bool IsMissionStarting(bool* bStarting, float* Countdown);
	static void SetSelectedEntryPoint(class FName EntryPoint);
	static void SetSelectedMission(const class FString& InMissionURL);
	static void SetSelectedMode(class FName InMode);

	void Multicast_SetTimer(bool bEnabled, float SetTime);
	void OnCountdownCancelled__DelegateSignature();
	void OnCountdownStarted__DelegateSignature(float Countdown);
	void OnMissionSelected();
	void OnMissionSelected__DelegateSignature();
	void OnPlayerJoinedLobby(class AReadyOrNotPlayerController* PlayerController);
	void OnPlayerReadyChange(class AReadyOrNotPlayerController* ReadyOrNotPlayerController, bool bReady);
	void OnRep_MissionURL();
	void OnRep_ReadiedPlayersChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionPortal">();
	}
	static class AMissionPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMissionPortal>();
	}
};
static_assert(alignof(AMissionPortal) == 0x000008, "Wrong alignment on AMissionPortal");
static_assert(sizeof(AMissionPortal) == 0x000370, "Wrong size on AMissionPortal");
static_assert(offsetof(AMissionPortal, InteractableComponent) == 0x000258, "Member 'AMissionPortal::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AMissionPortal, SelectableGameModes) == 0x000260, "Member 'AMissionPortal::SelectableGameModes' has a wrong offset!");
static_assert(offsetof(AMissionPortal, MissionSelect) == 0x000270, "Member 'AMissionPortal::MissionSelect' has a wrong offset!");
static_assert(offsetof(AMissionPortal, Profile) == 0x000278, "Member 'AMissionPortal::Profile' has a wrong offset!");
static_assert(offsetof(AMissionPortal, CommanderProfile) == 0x000280, "Member 'AMissionPortal::CommanderProfile' has a wrong offset!");
static_assert(offsetof(AMissionPortal, MetaGameProfile) == 0x000288, "Member 'AMissionPortal::MetaGameProfile' has a wrong offset!");
static_assert(offsetof(AMissionPortal, WhiteboardText) == 0x000290, "Member 'AMissionPortal::WhiteboardText' has a wrong offset!");
static_assert(offsetof(AMissionPortal, OnMissionSelected_Delegate) == 0x0002A0, "Member 'AMissionPortal::OnMissionSelected_Delegate' has a wrong offset!");
static_assert(offsetof(AMissionPortal, MissionURL) == 0x0002B0, "Member 'AMissionPortal::MissionURL' has a wrong offset!");
static_assert(offsetof(AMissionPortal, ModeURL) == 0x0002C0, "Member 'AMissionPortal::ModeURL' has a wrong offset!");
static_assert(offsetof(AMissionPortal, SelectedEntryPoint) == 0x0002D0, "Member 'AMissionPortal::SelectedEntryPoint' has a wrong offset!");
static_assert(offsetof(AMissionPortal, CompsToOutline) == 0x0002D8, "Member 'AMissionPortal::CompsToOutline' has a wrong offset!");
static_assert(offsetof(AMissionPortal, LightsToEnable) == 0x0002E8, "Member 'AMissionPortal::LightsToEnable' has a wrong offset!");
static_assert(offsetof(AMissionPortal, CompsToOutlineMissionSelected) == 0x0002F8, "Member 'AMissionPortal::CompsToOutlineMissionSelected' has a wrong offset!");
static_assert(offsetof(AMissionPortal, LightsToEnableMissionSelected) == 0x000308, "Member 'AMissionPortal::LightsToEnableMissionSelected' has a wrong offset!");
static_assert(offsetof(AMissionPortal, OnCountdownStarted) == 0x000330, "Member 'AMissionPortal::OnCountdownStarted' has a wrong offset!");
static_assert(offsetof(AMissionPortal, OnCountdownCancelled) == 0x000340, "Member 'AMissionPortal::OnCountdownCancelled' has a wrong offset!");
static_assert(offsetof(AMissionPortal, NumReadyPlayers) == 0x000350, "Member 'AMissionPortal::NumReadyPlayers' has a wrong offset!");
static_assert(offsetof(AMissionPortal, ReadiedPlayers) == 0x000358, "Member 'AMissionPortal::ReadiedPlayers' has a wrong offset!");

// Class ReadyOrNot.ModioManager
// 0x0210 (0x0238 - 0x0028)
class UModioManager final  : public UObject
{
public:
	uint8                                         Pad_2751[0x210];                                   // 0x0028(0x0210)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UModioManager* GetInstance();
	static bool IsModIoEnabled();

	void ClearUserData();
	bool IsModUpdating();

	bool IsRestartRequired() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioManager">();
	}
	static class UModioManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioManager>();
	}
};
static_assert(alignof(UModioManager) == 0x000008, "Wrong alignment on UModioManager");
static_assert(sizeof(UModioManager) == 0x000238, "Wrong size on UModioManager");

// Class ReadyOrNot.MoveActivity
// 0x0010 (0x01C8 - 0x01B8)
class UMoveActivity final  : public UTeamBaseActivity
{
public:
	uint8                                         Pad_2752[0x10];                                    // 0x01B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveActivity">();
	}
	static class UMoveActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveActivity>();
	}
};
static_assert(alignof(UMoveActivity) == 0x000008, "Wrong alignment on UMoveActivity");
static_assert(sizeof(UMoveActivity) == 0x0001C8, "Wrong size on UMoveActivity");

// Class ReadyOrNot.MoveToActivity
// 0x0000 (0x01A8 - 0x01A8)
class UMoveToActivity final  : public UBaseActivity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveToActivity">();
	}
	static class UMoveToActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveToActivity>();
	}
};
static_assert(alignof(UMoveToActivity) == 0x000008, "Wrong alignment on UMoveToActivity");
static_assert(sizeof(UMoveToActivity) == 0x0001A8, "Wrong size on UMoveToActivity");

// Class ReadyOrNot.MoveToPlayerSpawn
// 0x0008 (0x01E0 - 0x01D8)
class UMoveToPlayerSpawn final  : public UBaseCombatMoveActivity
{
public:
	bool                                          bBeArrestedOnceReachedLocation;                    // 0x01D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2753[0x7];                                     // 0x01D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveToPlayerSpawn">();
	}
	static class UMoveToPlayerSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveToPlayerSpawn>();
	}
};
static_assert(alignof(UMoveToPlayerSpawn) == 0x000008, "Wrong alignment on UMoveToPlayerSpawn");
static_assert(sizeof(UMoveToPlayerSpawn) == 0x0001E0, "Wrong size on UMoveToPlayerSpawn");
static_assert(offsetof(UMoveToPlayerSpawn, bBeArrestedOnceReachedLocation) == 0x0001D8, "Member 'UMoveToPlayerSpawn::bBeArrestedOnceReachedLocation' has a wrong offset!");

// Class ReadyOrNot.MusicData
// 0x0088 (0x00B8 - 0x0030)
class UMusicData final  : public UDataAsset
{
public:
	struct FMusicTrack                            PreplanningTrack;                                  // 0x0030(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMusicTrack                            AmbientTrack;                                      // 0x0058(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMusicTrack                            ActionTrack;                                       // 0x0080(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMusicTrackFMOD                        FMODTracks;                                        // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicData">();
	}
	static class UMusicData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMusicData>();
	}
};
static_assert(alignof(UMusicData) == 0x000008, "Wrong alignment on UMusicData");
static_assert(sizeof(UMusicData) == 0x0000B8, "Wrong size on UMusicData");
static_assert(offsetof(UMusicData, PreplanningTrack) == 0x000030, "Member 'UMusicData::PreplanningTrack' has a wrong offset!");
static_assert(offsetof(UMusicData, AmbientTrack) == 0x000058, "Member 'UMusicData::AmbientTrack' has a wrong offset!");
static_assert(offsetof(UMusicData, ActionTrack) == 0x000080, "Member 'UMusicData::ActionTrack' has a wrong offset!");
static_assert(offsetof(UMusicData, FMODTracks) == 0x0000A8, "Member 'UMusicData::FMODTracks' has a wrong offset!");

// Class ReadyOrNot.NeutralizeSuspectByTag
// 0x0018 (0x02C0 - 0x02A8)
class ANeutralizeSuspectByTag final  : public AObjective
{
public:
	class ACyberneticCharacter*                   Suspect;                                           // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SuspectTag;                                        // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireArrest;                                    // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowIncapacitation;                              // 0x02B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2754[0x6];                                     // 0x02BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAISpawned();
	void OnSuspectKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeutralizeSuspectByTag">();
	}
	static class ANeutralizeSuspectByTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANeutralizeSuspectByTag>();
	}
};
static_assert(alignof(ANeutralizeSuspectByTag) == 0x000008, "Wrong alignment on ANeutralizeSuspectByTag");
static_assert(sizeof(ANeutralizeSuspectByTag) == 0x0002C0, "Wrong size on ANeutralizeSuspectByTag");
static_assert(offsetof(ANeutralizeSuspectByTag, Suspect) == 0x0002A8, "Member 'ANeutralizeSuspectByTag::Suspect' has a wrong offset!");
static_assert(offsetof(ANeutralizeSuspectByTag, SuspectTag) == 0x0002B0, "Member 'ANeutralizeSuspectByTag::SuspectTag' has a wrong offset!");
static_assert(offsetof(ANeutralizeSuspectByTag, bRequireArrest) == 0x0002B8, "Member 'ANeutralizeSuspectByTag::bRequireArrest' has a wrong offset!");
static_assert(offsetof(ANeutralizeSuspectByTag, bAllowIncapacitation) == 0x0002B9, "Member 'ANeutralizeSuspectByTag::bAllowIncapacitation' has a wrong offset!");

// Class ReadyOrNot.NinebangDamageType
// 0x0000 (0x0620 - 0x0620)
class UNinebangDamageType : public UStunDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NinebangDamageType">();
	}
	static class UNinebangDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNinebangDamageType>();
	}
};
static_assert(alignof(UNinebangDamageType) == 0x000010, "Wrong alignment on UNinebangDamageType");
static_assert(sizeof(UNinebangDamageType) == 0x000620, "Wrong size on UNinebangDamageType");

// Class ReadyOrNot.ObjectiveMarkerComponent
// 0x0120 (0x06C0 - 0x05A0)
class UObjectiveMarkerComponent final  : public UWidgetComponent
{
public:
	uint8                                         bEnabled : 1;                                      // 0x05A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStartHidden : 1;                                  // 0x05A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_47 : 1;                                     // 0x05A0(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bCustomLocation : 1;                               // 0x05A0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFadeOffscreen : 1;                                // 0x05A0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDistanceScaleIcon : 1;                            // 0x05A0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideIconOffscreen : 1;                            // 0x05A0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCompletelyFadeWhenOverlappingOtherWidgets : 1;    // 0x05A0(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCompletelyFadeWhenClose : 1;                      // 0x05A1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2755[0x2];                                     // 0x05A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeAtDistance_Close;                              // 0x05A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCompletelyFadeWhenFar : 1;                        // 0x05A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2756[0x3];                                     // 0x05A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeAtDistance_Far;                                // 0x05AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHideDistanceInfo : 1;                             // 0x05B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2757[0x3];                                     // 0x05B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HideDistanceInfoAtDistance;                        // 0x05B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHideDirectionalArrow : 1;                         // 0x05B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisplayMarkerText : 1;                            // 0x05B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2758[0x7];                                     // 0x05B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MarkerText;                                        // 0x05C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class UObjectiveMarkerWidget>     MarkerWidgetClass;                                 // 0x05D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            IconBrush;                                         // 0x05E0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLinearColor                           IconColorAndOpacity;                               // 0x0668(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              IconSize;                                          // 0x0678(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDebug : 1;                                        // 0x0680(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2759[0x7];                                     // 0x0681(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectiveMarkerWidget*                 ObjectiveMarkerWidget_Offscreen;                   // 0x0688(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectiveMarkerWidget*                 ObjectiveMarkerWidget_Onscreen;                    // 0x0690(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOffscreen;                                      // 0x0698(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequestingFadeOut;                                // 0x0699(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_275A[0x26];                                    // 0x069A(0x0026)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableObjectiveMarker();
	void EnableObjectiveMarker();
	void HideIcon();
	void HideMarkerText();
	void HideObjectiveMarker(bool bFadeOut);
	void SetIconBrush(const struct FSlateBrush& NewIconBrush);
	void SetIconColor(const struct FLinearColor& InIconColorAndOpacity);
	void SetIconSize(const struct FVector2D& NewIconSize);
	void SetMarkerText(class FText NewMarkerText);
	void SetMarkerTextColor(const struct FLinearColor& InIconColorAndOpacity);
	void SetMarkerTextFontSize(int32 NewFontSize);
	void SetNewFadeDistance(float NewDistance);
	void ShowIcon();
	void ShowMarkerText();
	void ShowObjectiveMarker();
	void ToggleObjectiveMarkerVisibility();

	bool CanShowObjectiveMarker() const;
	bool IsObjectiveMarkerOffscreen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveMarkerComponent">();
	}
	static class UObjectiveMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveMarkerComponent>();
	}
};
static_assert(alignof(UObjectiveMarkerComponent) == 0x000010, "Wrong alignment on UObjectiveMarkerComponent");
static_assert(sizeof(UObjectiveMarkerComponent) == 0x0006C0, "Wrong size on UObjectiveMarkerComponent");
static_assert(offsetof(UObjectiveMarkerComponent, FadeAtDistance_Close) == 0x0005A4, "Member 'UObjectiveMarkerComponent::FadeAtDistance_Close' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, FadeAtDistance_Far) == 0x0005AC, "Member 'UObjectiveMarkerComponent::FadeAtDistance_Far' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, HideDistanceInfoAtDistance) == 0x0005B4, "Member 'UObjectiveMarkerComponent::HideDistanceInfoAtDistance' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, MarkerText) == 0x0005C0, "Member 'UObjectiveMarkerComponent::MarkerText' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, MarkerWidgetClass) == 0x0005D8, "Member 'UObjectiveMarkerComponent::MarkerWidgetClass' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, IconBrush) == 0x0005E0, "Member 'UObjectiveMarkerComponent::IconBrush' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, IconColorAndOpacity) == 0x000668, "Member 'UObjectiveMarkerComponent::IconColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, IconSize) == 0x000678, "Member 'UObjectiveMarkerComponent::IconSize' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, ObjectiveMarkerWidget_Offscreen) == 0x000688, "Member 'UObjectiveMarkerComponent::ObjectiveMarkerWidget_Offscreen' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, ObjectiveMarkerWidget_Onscreen) == 0x000690, "Member 'UObjectiveMarkerComponent::ObjectiveMarkerWidget_Onscreen' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, bIsOffscreen) == 0x000698, "Member 'UObjectiveMarkerComponent::bIsOffscreen' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, bRequestingFadeOut) == 0x000699, "Member 'UObjectiveMarkerComponent::bRequestingFadeOut' has a wrong offset!");

// Class ReadyOrNot.ObjectivePoint
// 0x0018 (0x0238 - 0x0220)
class AObjectivePoint final  : public AActor
{
public:
	class AActor*                                 TiedToActor;                                       // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObjectiveMarkerComponent*              ObjectiveMarkerComponent;                          // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapActorComponent*                     MapActorComponent;                                 // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HideObjectiveMarker();
	void InitSettings(const struct FSlateBrush& Icon, class FText Text, float ShowMarkerAtDistance);
	void ShowObjectiveMarker();
	void ToggleObjectiveMarkerVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectivePoint">();
	}
	static class AObjectivePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AObjectivePoint>();
	}
};
static_assert(alignof(AObjectivePoint) == 0x000008, "Wrong alignment on AObjectivePoint");
static_assert(sizeof(AObjectivePoint) == 0x000238, "Wrong size on AObjectivePoint");
static_assert(offsetof(AObjectivePoint, TiedToActor) == 0x000220, "Member 'AObjectivePoint::TiedToActor' has a wrong offset!");
static_assert(offsetof(AObjectivePoint, ObjectiveMarkerComponent) == 0x000228, "Member 'AObjectivePoint::ObjectiveMarkerComponent' has a wrong offset!");
static_assert(offsetof(AObjectivePoint, MapActorComponent) == 0x000230, "Member 'AObjectivePoint::MapActorComponent' has a wrong offset!");

// Class ReadyOrNot.OutOfBoundsVolume
// 0x0008 (0x0228 - 0x0220)
class AOutOfBoundsVolume final  : public AActor
{
public:
	class UBoxComponent*                          Bounds;                                            // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutOfBoundsVolume">();
	}
	static class AOutOfBoundsVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutOfBoundsVolume>();
	}
};
static_assert(alignof(AOutOfBoundsVolume) == 0x000008, "Wrong alignment on AOutOfBoundsVolume");
static_assert(sizeof(AOutOfBoundsVolume) == 0x000228, "Wrong size on AOutOfBoundsVolume");
static_assert(offsetof(AOutOfBoundsVolume, Bounds) == 0x000220, "Member 'AOutOfBoundsVolume::Bounds' has a wrong offset!");

// Class ReadyOrNot.PenetrationData
// 0x04C8 (0x04F8 - 0x0030)
class UPenetrationData final  : public UDataAsset
{
public:
	struct FMaterialPenetration                   DefaultPenetrationData;                            // 0x0030(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Aluminium;                                     // 0x0048(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Asphalt;                                       // 0x0060(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Brick;                                         // 0x0078(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_CarbonFibre;                                   // 0x0090(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Cardboard;                                     // 0x00A8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Ceramic;                                       // 0x00C0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_ConcreteSoft;                                  // 0x00D8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_ConcreteStrong;                                // 0x00F0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Dirt;                                          // 0x0108(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Drywall;                                       // 0x0120(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Electrical;                                    // 0x0138(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_EnergyShield;                                  // 0x0150(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Fabric_Carpet;                                 // 0x0168(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Fabric_Stuffing;                               // 0x0180(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Fabric_Thin;                                   // 0x0198(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Flesh;                                         // 0x01B0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Galvanized;                                    // 0x01C8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Glass_Plate;                                   // 0x01E0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Glass_Windshield;                              // 0x01F8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Grass;                                         // 0x0210(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Gravel;                                        // 0x0228(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Ice;                                           // 0x0240(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Lava;                                          // 0x0258(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Lead;                                          // 0x0270(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Leaves;                                        // 0x0288(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Limestone;                                     // 0x02A0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Mahogany;                                      // 0x02B8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Marble_Coated;                                 // 0x02D0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Marble_Thick;                                  // 0x02E8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Mud;                                           // 0x0300(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Oil;                                           // 0x0318(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Paper;                                         // 0x0330(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Pine;                                          // 0x0348(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Plaster;                                       // 0x0360(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Plastic;                                       // 0x0378(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Plywood;                                       // 0x0390(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Polystyrene;                                   // 0x03A8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Powder;                                        // 0x03C0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Rock;                                          // 0x03D8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Rubber;                                        // 0x03F0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Sand;                                          // 0x0408(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Snow;                                          // 0x0420(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Soil;                                          // 0x0438(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Steel;                                         // 0x0450(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Tin;                                           // 0x0468(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Treewood;                                      // 0x0480(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Wallpaper;                                     // 0x0498(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Water;                                         // 0x04B0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Vehicle;                                       // 0x04C8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Bulletproof_Glass;                             // 0x04E0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	struct FMaterialPenetration GetPenetrationData(EPhysicalSurface Surface);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PenetrationData">();
	}
	static class UPenetrationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPenetrationData>();
	}
};
static_assert(alignof(UPenetrationData) == 0x000008, "Wrong alignment on UPenetrationData");
static_assert(sizeof(UPenetrationData) == 0x0004F8, "Wrong size on UPenetrationData");
static_assert(offsetof(UPenetrationData, DefaultPenetrationData) == 0x000030, "Member 'UPenetrationData::DefaultPenetrationData' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Aluminium) == 0x000048, "Member 'UPenetrationData::RON_Aluminium' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Asphalt) == 0x000060, "Member 'UPenetrationData::RON_Asphalt' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Brick) == 0x000078, "Member 'UPenetrationData::RON_Brick' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_CarbonFibre) == 0x000090, "Member 'UPenetrationData::RON_CarbonFibre' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Cardboard) == 0x0000A8, "Member 'UPenetrationData::RON_Cardboard' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Ceramic) == 0x0000C0, "Member 'UPenetrationData::RON_Ceramic' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_ConcreteSoft) == 0x0000D8, "Member 'UPenetrationData::RON_ConcreteSoft' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_ConcreteStrong) == 0x0000F0, "Member 'UPenetrationData::RON_ConcreteStrong' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Dirt) == 0x000108, "Member 'UPenetrationData::RON_Dirt' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Drywall) == 0x000120, "Member 'UPenetrationData::RON_Drywall' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Electrical) == 0x000138, "Member 'UPenetrationData::RON_Electrical' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_EnergyShield) == 0x000150, "Member 'UPenetrationData::RON_EnergyShield' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Fabric_Carpet) == 0x000168, "Member 'UPenetrationData::RON_Fabric_Carpet' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Fabric_Stuffing) == 0x000180, "Member 'UPenetrationData::RON_Fabric_Stuffing' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Fabric_Thin) == 0x000198, "Member 'UPenetrationData::RON_Fabric_Thin' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Flesh) == 0x0001B0, "Member 'UPenetrationData::RON_Flesh' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Galvanized) == 0x0001C8, "Member 'UPenetrationData::RON_Galvanized' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Glass_Plate) == 0x0001E0, "Member 'UPenetrationData::RON_Glass_Plate' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Glass_Windshield) == 0x0001F8, "Member 'UPenetrationData::RON_Glass_Windshield' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Grass) == 0x000210, "Member 'UPenetrationData::RON_Grass' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Gravel) == 0x000228, "Member 'UPenetrationData::RON_Gravel' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Ice) == 0x000240, "Member 'UPenetrationData::RON_Ice' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Lava) == 0x000258, "Member 'UPenetrationData::RON_Lava' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Lead) == 0x000270, "Member 'UPenetrationData::RON_Lead' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Leaves) == 0x000288, "Member 'UPenetrationData::RON_Leaves' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Limestone) == 0x0002A0, "Member 'UPenetrationData::RON_Limestone' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Mahogany) == 0x0002B8, "Member 'UPenetrationData::RON_Mahogany' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Marble_Coated) == 0x0002D0, "Member 'UPenetrationData::RON_Marble_Coated' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Marble_Thick) == 0x0002E8, "Member 'UPenetrationData::RON_Marble_Thick' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Mud) == 0x000300, "Member 'UPenetrationData::RON_Mud' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Oil) == 0x000318, "Member 'UPenetrationData::RON_Oil' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Paper) == 0x000330, "Member 'UPenetrationData::RON_Paper' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Pine) == 0x000348, "Member 'UPenetrationData::RON_Pine' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Plaster) == 0x000360, "Member 'UPenetrationData::RON_Plaster' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Plastic) == 0x000378, "Member 'UPenetrationData::RON_Plastic' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Plywood) == 0x000390, "Member 'UPenetrationData::RON_Plywood' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Polystyrene) == 0x0003A8, "Member 'UPenetrationData::RON_Polystyrene' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Powder) == 0x0003C0, "Member 'UPenetrationData::RON_Powder' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Rock) == 0x0003D8, "Member 'UPenetrationData::RON_Rock' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Rubber) == 0x0003F0, "Member 'UPenetrationData::RON_Rubber' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Sand) == 0x000408, "Member 'UPenetrationData::RON_Sand' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Snow) == 0x000420, "Member 'UPenetrationData::RON_Snow' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Soil) == 0x000438, "Member 'UPenetrationData::RON_Soil' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Steel) == 0x000450, "Member 'UPenetrationData::RON_Steel' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Tin) == 0x000468, "Member 'UPenetrationData::RON_Tin' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Treewood) == 0x000480, "Member 'UPenetrationData::RON_Treewood' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Wallpaper) == 0x000498, "Member 'UPenetrationData::RON_Wallpaper' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Water) == 0x0004B0, "Member 'UPenetrationData::RON_Water' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Vehicle) == 0x0004C8, "Member 'UPenetrationData::RON_Vehicle' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Bulletproof_Glass) == 0x0004E0, "Member 'UPenetrationData::RON_Bulletproof_Glass' has a wrong offset!");

// Class ReadyOrNot.PepperballGun
// 0x0030 (0x1460 - 0x1430)
class APepperballGun : public ABaseMagazineWeapon
{
public:
	class UParticleSystemComponent*               ShootTrailComponent;                               // 0x1430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleShootTrail;                                // 0x1438(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeadshotsUntilAbuse;                               // 0x1440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentHeadshotCounter;                            // 0x1444(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StunShotsUntilAbuse;                               // 0x1448(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentStunShotCounter;                            // 0x144C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBallsInHopper;                                  // 0x1450(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BallsInHopper;                                     // 0x1454(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_275D[0x8];                                     // 0x1458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void IncrementHeadshotCounter(class ACyberneticCharacter* HeadshottedPerson);
	void IncrementStunShotCounter(class ACyberneticCharacter* StunnedPerson);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PepperballGun">();
	}
	static class APepperballGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<APepperballGun>();
	}
};
static_assert(alignof(APepperballGun) == 0x000010, "Wrong alignment on APepperballGun");
static_assert(sizeof(APepperballGun) == 0x001460, "Wrong size on APepperballGun");
static_assert(offsetof(APepperballGun, ShootTrailComponent) == 0x001430, "Member 'APepperballGun::ShootTrailComponent' has a wrong offset!");
static_assert(offsetof(APepperballGun, ParticleShootTrail) == 0x001438, "Member 'APepperballGun::ParticleShootTrail' has a wrong offset!");
static_assert(offsetof(APepperballGun, HeadshotsUntilAbuse) == 0x001440, "Member 'APepperballGun::HeadshotsUntilAbuse' has a wrong offset!");
static_assert(offsetof(APepperballGun, CurrentHeadshotCounter) == 0x001444, "Member 'APepperballGun::CurrentHeadshotCounter' has a wrong offset!");
static_assert(offsetof(APepperballGun, StunShotsUntilAbuse) == 0x001448, "Member 'APepperballGun::StunShotsUntilAbuse' has a wrong offset!");
static_assert(offsetof(APepperballGun, CurrentStunShotCounter) == 0x00144C, "Member 'APepperballGun::CurrentStunShotCounter' has a wrong offset!");
static_assert(offsetof(APepperballGun, MaxBallsInHopper) == 0x001450, "Member 'APepperballGun::MaxBallsInHopper' has a wrong offset!");
static_assert(offsetof(APepperballGun, BallsInHopper) == 0x001454, "Member 'APepperballGun::BallsInHopper' has a wrong offset!");

// Class ReadyOrNot.PepperProjectile
// 0x0008 (0x0370 - 0x0368)
class APepperProjectile : public ABulletProjectile
{
public:
	class UParticleSystem*                        GasEffect;                                         // 0x0368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PepperProjectile">();
	}
	static class APepperProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<APepperProjectile>();
	}
};
static_assert(alignof(APepperProjectile) == 0x000008, "Wrong alignment on APepperProjectile");
static_assert(sizeof(APepperProjectile) == 0x000370, "Wrong size on APepperProjectile");
static_assert(offsetof(APepperProjectile, GasEffect) == 0x000368, "Member 'APepperProjectile::GasEffect' has a wrong offset!");

// Class ReadyOrNot.PepperSprayDamageType
// 0x0000 (0x0620 - 0x0620)
class UPepperSprayDamageType : public UStunDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PepperSprayDamageType">();
	}
	static class UPepperSprayDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPepperSprayDamageType>();
	}
};
static_assert(alignof(UPepperSprayDamageType) == 0x000010, "Wrong alignment on UPepperSprayDamageType");
static_assert(sizeof(UPepperSprayDamageType) == 0x000620, "Wrong size on UPepperSprayDamageType");

// Class ReadyOrNot.PickupItemActivity
// 0x0018 (0x01C0 - 0x01A8)
class UPickupItemActivity final  : public UBaseActivity
{
public:
	float                                         SearchRadius;                                      // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_275E[0x4];                                     // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeaponCacheActor*                      WeaponCacheActor;                                  // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              PickupItem;                                        // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnPickupItemComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupItemActivity">();
	}
	static class UPickupItemActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPickupItemActivity>();
	}
};
static_assert(alignof(UPickupItemActivity) == 0x000008, "Wrong alignment on UPickupItemActivity");
static_assert(sizeof(UPickupItemActivity) == 0x0001C0, "Wrong size on UPickupItemActivity");
static_assert(offsetof(UPickupItemActivity, SearchRadius) == 0x0001A8, "Member 'UPickupItemActivity::SearchRadius' has a wrong offset!");
static_assert(offsetof(UPickupItemActivity, WeaponCacheActor) == 0x0001B0, "Member 'UPickupItemActivity::WeaponCacheActor' has a wrong offset!");
static_assert(offsetof(UPickupItemActivity, PickupItem) == 0x0001B8, "Member 'UPickupItemActivity::PickupItem' has a wrong offset!");

// Class ReadyOrNot.PickupMagazineActor
// 0x0028 (0x02B0 - 0x0288)
class APickupMagazineActor final  : public APickupActor
{
public:
	class FName                                   MagazineLabel;                                     // 0x0288(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumHitThreshold;                               // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_275F[0x4];                                     // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             DroppedMagazineHitEvent;                           // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMagazine                              MagazineData;                                      // 0x02A0(0x0004)(Net, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2760[0x4];                                     // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseMagazineWeapon*                    CameFromWeapon;                                    // 0x02A8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class ABaseMagazineWeapon* GetValidWeaponForPickerUpper(class APlayerCharacter* PlayerCharacter);
	void Multicast_SetWeapon(class ABaseMagazineWeapon* Weapon);
	void OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit);
	void Server_Pickup(class AActor* InPickupInstigator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupMagazineActor">();
	}
	static class APickupMagazineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APickupMagazineActor>();
	}
};
static_assert(alignof(APickupMagazineActor) == 0x000008, "Wrong alignment on APickupMagazineActor");
static_assert(sizeof(APickupMagazineActor) == 0x0002B0, "Wrong size on APickupMagazineActor");
static_assert(offsetof(APickupMagazineActor, MagazineLabel) == 0x000288, "Member 'APickupMagazineActor::MagazineLabel' has a wrong offset!");
static_assert(offsetof(APickupMagazineActor, MinimumHitThreshold) == 0x000290, "Member 'APickupMagazineActor::MinimumHitThreshold' has a wrong offset!");
static_assert(offsetof(APickupMagazineActor, DroppedMagazineHitEvent) == 0x000298, "Member 'APickupMagazineActor::DroppedMagazineHitEvent' has a wrong offset!");
static_assert(offsetof(APickupMagazineActor, MagazineData) == 0x0002A0, "Member 'APickupMagazineActor::MagazineData' has a wrong offset!");
static_assert(offsetof(APickupMagazineActor, CameFromWeapon) == 0x0002A8, "Member 'APickupMagazineActor::CameFromWeapon' has a wrong offset!");

// Class ReadyOrNot.PickupWeaponActor
// 0x0030 (0x02B8 - 0x0288)
class APickupWeaponActor final  : public APickupActor
{
public:
	TSubclassOf<class ABaseWeapon>                Weapon;                                            // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKillOnPickup;                                     // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSecondaryWeapon;                                  // 0x0291(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModifyLoadout;                                    // 0x0292(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2762[0x5];                                     // 0x0293(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UWeaponAttachment>          ScopeAttachment;                                   // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          MuzzleAttachment;                                  // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          UnderbarrelAttachment;                             // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          OverbarrelAttachment;                              // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupWeaponActor">();
	}
	static class APickupWeaponActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APickupWeaponActor>();
	}
};
static_assert(alignof(APickupWeaponActor) == 0x000008, "Wrong alignment on APickupWeaponActor");
static_assert(sizeof(APickupWeaponActor) == 0x0002B8, "Wrong size on APickupWeaponActor");
static_assert(offsetof(APickupWeaponActor, Weapon) == 0x000288, "Member 'APickupWeaponActor::Weapon' has a wrong offset!");
static_assert(offsetof(APickupWeaponActor, bKillOnPickup) == 0x000290, "Member 'APickupWeaponActor::bKillOnPickup' has a wrong offset!");
static_assert(offsetof(APickupWeaponActor, bSecondaryWeapon) == 0x000291, "Member 'APickupWeaponActor::bSecondaryWeapon' has a wrong offset!");
static_assert(offsetof(APickupWeaponActor, bModifyLoadout) == 0x000292, "Member 'APickupWeaponActor::bModifyLoadout' has a wrong offset!");
static_assert(offsetof(APickupWeaponActor, ScopeAttachment) == 0x000298, "Member 'APickupWeaponActor::ScopeAttachment' has a wrong offset!");
static_assert(offsetof(APickupWeaponActor, MuzzleAttachment) == 0x0002A0, "Member 'APickupWeaponActor::MuzzleAttachment' has a wrong offset!");
static_assert(offsetof(APickupWeaponActor, UnderbarrelAttachment) == 0x0002A8, "Member 'APickupWeaponActor::UnderbarrelAttachment' has a wrong offset!");
static_assert(offsetof(APickupWeaponActor, OverbarrelAttachment) == 0x0002B0, "Member 'APickupWeaponActor::OverbarrelAttachment' has a wrong offset!");

// Class ReadyOrNot.PingInterface
// 0x0000 (0x0028 - 0x0028)
class IPingInterface final  : public IInterface
{
public:
	bool CanPing();
	float GetPingDuration();
	struct FSlateBrush GetPingIcon();
	struct FVector GetPingLocation();
	class FText GetPingText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingInterface">();
	}
	static class IPingInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPingInterface>();
	}
};
static_assert(alignof(IPingInterface) == 0x000008, "Wrong alignment on IPingInterface");
static_assert(sizeof(IPingInterface) == 0x000028, "Wrong size on IPingInterface");

// Class ReadyOrNot.PlacedC2Explosive
// 0x0168 (0x0388 - 0x0220)
class APlacedC2Explosive : public AActor
{
public:
	uint8                                         Pad_2763[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               ExplosionComp;                                     // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    AudioComponent;                                    // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 C2InteractableComponent;                           // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIPerceptionStimuliSourceComponent*    PerceptionStimuliComp;                             // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARadialForceActor*                      RadialForce;                                       // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AC2Explosive*                           ConnectedC2Explosive;                              // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            PlacedByController;                                // 0x0260(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseItem>                  ItemInventoryClass;                                // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageToInflict;                                   // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDamageToInflict;                                // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageInnerRadius;                                 // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageOuterRadius;                                 // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionPostKillTime;                             // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetonated;                                        // 0x028C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2764[0x3];                                     // 0x028D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorIntegrityDamage;                               // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2765[0x4];                                     // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetItem;                                        // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODC2ExplosionAudio;                              // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             PlacementHit;                                      // 0x02A8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseScreenShake;                                   // 0x0330(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2766[0x7];                                     // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMatineeCameraShake>        ExplosionScreenShake;                              // 0x0338(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraShakeBase*                       ExplosionScreenShakeInst;                          // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShakeRadius;                                 // 0x0348(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2767[0x4];                                     // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStunDamage>                StunDamageType;                                    // 0x0350(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemovedViaMultitool;                              // 0x0358(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2768[0xF];                                     // 0x0359(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsBeingRemoved;                                   // 0x0368(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2769[0x7];                                     // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   IsBeingRemovedBy;                                  // 0x0370(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         C2OcclusionMultiplier;                             // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         C2FullOcclusionDepth;                              // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_276A[0x8];                                     // 0x0380(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USkeletalMeshComponent* GetMeshComp();
	void Multicast_OnC2Detonated();
	void PostExplosionKill();
	void RemoveFromTarget();
	void Server_DetonateC2();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlacedC2Explosive">();
	}
	static class APlacedC2Explosive* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlacedC2Explosive>();
	}
};
static_assert(alignof(APlacedC2Explosive) == 0x000008, "Wrong alignment on APlacedC2Explosive");
static_assert(sizeof(APlacedC2Explosive) == 0x000388, "Wrong size on APlacedC2Explosive");
static_assert(offsetof(APlacedC2Explosive, ExplosionComp) == 0x000228, "Member 'APlacedC2Explosive::ExplosionComp' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, MeshComp) == 0x000230, "Member 'APlacedC2Explosive::MeshComp' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, AudioComponent) == 0x000238, "Member 'APlacedC2Explosive::AudioComponent' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, C2InteractableComponent) == 0x000240, "Member 'APlacedC2Explosive::C2InteractableComponent' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, PerceptionStimuliComp) == 0x000248, "Member 'APlacedC2Explosive::PerceptionStimuliComp' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, RadialForce) == 0x000250, "Member 'APlacedC2Explosive::RadialForce' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, ConnectedC2Explosive) == 0x000258, "Member 'APlacedC2Explosive::ConnectedC2Explosive' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, PlacedByController) == 0x000260, "Member 'APlacedC2Explosive::PlacedByController' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, ItemInventoryClass) == 0x000268, "Member 'APlacedC2Explosive::ItemInventoryClass' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, DamageToInflict) == 0x000270, "Member 'APlacedC2Explosive::DamageToInflict' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, MinDamageToInflict) == 0x000274, "Member 'APlacedC2Explosive::MinDamageToInflict' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, DamageType) == 0x000278, "Member 'APlacedC2Explosive::DamageType' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, DamageInnerRadius) == 0x000280, "Member 'APlacedC2Explosive::DamageInnerRadius' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, DamageOuterRadius) == 0x000284, "Member 'APlacedC2Explosive::DamageOuterRadius' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, ExplosionPostKillTime) == 0x000288, "Member 'APlacedC2Explosive::ExplosionPostKillTime' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, bDetonated) == 0x00028C, "Member 'APlacedC2Explosive::bDetonated' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, DoorIntegrityDamage) == 0x000290, "Member 'APlacedC2Explosive::DoorIntegrityDamage' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, TargetItem) == 0x000298, "Member 'APlacedC2Explosive::TargetItem' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, FMODC2ExplosionAudio) == 0x0002A0, "Member 'APlacedC2Explosive::FMODC2ExplosionAudio' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, PlacementHit) == 0x0002A8, "Member 'APlacedC2Explosive::PlacementHit' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, bUseScreenShake) == 0x000330, "Member 'APlacedC2Explosive::bUseScreenShake' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, ExplosionScreenShake) == 0x000338, "Member 'APlacedC2Explosive::ExplosionScreenShake' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, ExplosionScreenShakeInst) == 0x000340, "Member 'APlacedC2Explosive::ExplosionScreenShakeInst' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, CameraShakeRadius) == 0x000348, "Member 'APlacedC2Explosive::CameraShakeRadius' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, StunDamageType) == 0x000350, "Member 'APlacedC2Explosive::StunDamageType' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, bRemovedViaMultitool) == 0x000358, "Member 'APlacedC2Explosive::bRemovedViaMultitool' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, bIsBeingRemoved) == 0x000368, "Member 'APlacedC2Explosive::bIsBeingRemoved' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, IsBeingRemovedBy) == 0x000370, "Member 'APlacedC2Explosive::IsBeingRemovedBy' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, C2OcclusionMultiplier) == 0x000378, "Member 'APlacedC2Explosive::C2OcclusionMultiplier' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, C2FullOcclusionDepth) == 0x00037C, "Member 'APlacedC2Explosive::C2FullOcclusionDepth' has a wrong offset!");

// Class ReadyOrNot.PlacedZipcuffs
// 0x0008 (0x0228 - 0x0220)
class APlacedZipcuffs : public AActor
{
public:
	class USkeletalMeshComponent*                 ZipcuffMesh;                                       // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlacedZipcuffs">();
	}
	static class APlacedZipcuffs* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlacedZipcuffs>();
	}
};
static_assert(alignof(APlacedZipcuffs) == 0x000008, "Wrong alignment on APlacedZipcuffs");
static_assert(sizeof(APlacedZipcuffs) == 0x000228, "Wrong size on APlacedZipcuffs");
static_assert(offsetof(APlacedZipcuffs, ZipcuffMesh) == 0x000220, "Member 'APlacedZipcuffs::ZipcuffMesh' has a wrong offset!");

// Class ReadyOrNot.PlanningMapWidget
// 0x0018 (0x0278 - 0x0260)
class UPlanningMapWidget final  : public UUserWidget
{
public:
	bool                                          bDrawable;                                         // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_276B[0x7];                                     // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFloorMapPointData>             DrawPointData;                                     // 0x0268(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void AddPointData(const struct FVector2D& PointData, int32 FloorNum, EFreeDrawColor Color, bool bNewPoint, float Thickness);
	void ClearPointData(bool bClearAll, int32 FloorNum, bool bClearAllFloors);
	class UWorld* GetWorldContext();
	void OnForceMapRefresh();
	void OnPersonnelAdded(int32 PersonnelNum, int32 PersonnelZone);
	void OnPersonnelRemoved(int32 PersonnelNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlanningMapWidget">();
	}
	static class UPlanningMapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlanningMapWidget>();
	}
};
static_assert(alignof(UPlanningMapWidget) == 0x000008, "Wrong alignment on UPlanningMapWidget");
static_assert(sizeof(UPlanningMapWidget) == 0x000278, "Wrong size on UPlanningMapWidget");
static_assert(offsetof(UPlanningMapWidget, bDrawable) == 0x000260, "Member 'UPlanningMapWidget::bDrawable' has a wrong offset!");
static_assert(offsetof(UPlanningMapWidget, DrawPointData) == 0x000268, "Member 'UPlanningMapWidget::DrawPointData' has a wrong offset!");

// Class ReadyOrNot.PlayableCharacterData
// 0x0100 (0x0130 - 0x0030)
class UPlayableCharacterData final  : public UDataAsset
{
public:
	class FText                                   CharacterNameUI;                                   // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CharacterName;                                     // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CharacterRole;                                     // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CharacterBio;                                      // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CharacterRealName;                                 // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CharacterYearsOfService;                           // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CharacterDateOfBirth;                              // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   HandleName;                                        // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           FaceMesh;                                          // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPoseAsset>              FaceROM;                                           // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayableCharacterData">();
	}
	static class UPlayableCharacterData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayableCharacterData>();
	}
};
static_assert(alignof(UPlayableCharacterData) == 0x000008, "Wrong alignment on UPlayableCharacterData");
static_assert(sizeof(UPlayableCharacterData) == 0x000130, "Wrong size on UPlayableCharacterData");
static_assert(offsetof(UPlayableCharacterData, CharacterNameUI) == 0x000030, "Member 'UPlayableCharacterData::CharacterNameUI' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, CharacterName) == 0x000048, "Member 'UPlayableCharacterData::CharacterName' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, CharacterRole) == 0x000060, "Member 'UPlayableCharacterData::CharacterRole' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, CharacterBio) == 0x000078, "Member 'UPlayableCharacterData::CharacterBio' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, CharacterRealName) == 0x000090, "Member 'UPlayableCharacterData::CharacterRealName' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, CharacterYearsOfService) == 0x0000A8, "Member 'UPlayableCharacterData::CharacterYearsOfService' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, CharacterDateOfBirth) == 0x0000C0, "Member 'UPlayableCharacterData::CharacterDateOfBirth' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, HandleName) == 0x0000D8, "Member 'UPlayableCharacterData::HandleName' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, FaceMesh) == 0x0000E0, "Member 'UPlayableCharacterData::FaceMesh' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, FaceROM) == 0x000108, "Member 'UPlayableCharacterData::FaceROM' has a wrong offset!");

// Class ReadyOrNot.PlayDeadSpot
// 0x0000 (0x0220 - 0x0220)
class APlayDeadSpot final  : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayDeadSpot">();
	}
	static class APlayDeadSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayDeadSpot>();
	}
};
static_assert(alignof(APlayDeadSpot) == 0x000008, "Wrong alignment on APlayDeadSpot");
static_assert(sizeof(APlayDeadSpot) == 0x000220, "Wrong size on APlayDeadSpot");

// Class ReadyOrNot.PlayerActionPromptWidget
// 0x0030 (0x02A8 - 0x0278)
class UPlayerActionPromptWidget : public UBaseWidget
{
public:
	class FText                                   ActionText;                                        // 0x0278(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	class URichTextBlock*                         Action_RichText;                                   // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_OnShow;                                       // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInUse : 1;                                        // 0x02A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_276F[0x7];                                     // 0x02A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearText();
	void UpdateActionSlot(class FText& InText, bool ClearText, bool bAnimate, bool bLoopAnimation);
	void UpdateText(class FText& InText, bool bAnimate, bool bLoopAnimation);

	bool IsInUse() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerActionPromptWidget">();
	}
	static class UPlayerActionPromptWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerActionPromptWidget>();
	}
};
static_assert(alignof(UPlayerActionPromptWidget) == 0x000008, "Wrong alignment on UPlayerActionPromptWidget");
static_assert(sizeof(UPlayerActionPromptWidget) == 0x0002A8, "Wrong size on UPlayerActionPromptWidget");
static_assert(offsetof(UPlayerActionPromptWidget, ActionText) == 0x000278, "Member 'UPlayerActionPromptWidget::ActionText' has a wrong offset!");
static_assert(offsetof(UPlayerActionPromptWidget, Action_RichText) == 0x000290, "Member 'UPlayerActionPromptWidget::Action_RichText' has a wrong offset!");
static_assert(offsetof(UPlayerActionPromptWidget, Anim_OnShow) == 0x000298, "Member 'UPlayerActionPromptWidget::Anim_OnShow' has a wrong offset!");

// Class ReadyOrNot.PlayerCharacter
// 0x0EF0 (0x2520 - 0x1630)
#pragma pack(push, 0x1)
class alignas(0x10) APlayerCharacter : public AReadyOrNotCharacter
{
public:
	TArray<class UMeshComponent*>                 CustomizationFirstPersonMeshes;                    // 0x1628(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UMeshComponent*>                 CustomizationFirstPersonBodyMeshes;                // 0x1638(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       CustomizationActorMaterials;                       // 0x1648(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	bool                                          bFirstPersonMeshesDirty;                           // 0x1658(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2772[0x7];                                     // 0x1659(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       ThirdPersonCameraComponent;                        // 0x1660(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    ThirdPersonCameraArm;                              // 0x1668(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Mesh1P;                                            // 0x1670(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MeshBody1P;                                        // 0x1678(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       FirstPersonCameraComponent;                        // 0x1680(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerPostProcessing*                  PlayerPostProcessingComp;                          // 0x1688(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    FMODBreathingAudioComp;                            // 0x1690(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBleedComponent*                        BleedComponent;                                    // 0x1698(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScoringComponent*                      ScoringComponent;                                  // 0x16A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemVisualizationComponent*            PrimaryItemVisualizationComponent;                 // 0x16A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemVisualizationComponent*            SecondaryItemVisualizationComponent;               // 0x16B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemVisualizationComponent*            LongTacticalVisualizationComponent;                // 0x16B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemVisualizationComponent*            HelmetVisualizationComponent;                      // 0x16C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemVisualizationComponent*            ArmorVisualizationComponent;                       // 0x16C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemVisualizationComponent*            EquippedItemVisualizationComponent;                // 0x16D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2773[0x8];                                     // 0x16D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          Rep_FPBodyMesh;                                    // 0x16E0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     LastSetMesh1PDynamicMaterial;                      // 0x16E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       DynamicWeaponFovMats;                              // 0x16F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2774[0x10];                                    // 0x1700(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USkeletalMeshComponent*>         MeshComps;                                         // 0x1710(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2775[0x8];                                     // 0x1720(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerState*                           LastKnownPlayerState;                              // 0x1728(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2776[0x4];                                     // 0x1730(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReplicatedFPMesh;                                  // 0x1734(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2777[0x14];                                    // 0x1740(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurInputVector;                                    // 0x1754(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           PushOverlappingAI_Handle;                          // 0x1760(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               Body1PMat;                                         // 0x1768(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   CurrentViewCharacter;                              // 0x1770(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDefaultCommandIssued;                            // 0x1778(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeamViewSet;                                     // 0x1788(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         CurrentTeamViewIndex;                              // 0x1798(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2778[0x4];                                     // 0x179C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerViewActor*                       PlayerViewActor;                                   // 0x17A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APlayerViewActor>           PlayerViewActorClass;                              // 0x17A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TH_TeamViewInput;                                  // 0x17B0(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeamViewInputHoldTime;                             // 0x17B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurfaceType;                                       // 0x17BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoomType;                                          // 0x17C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2779[0x4];                                     // 0x17C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PVPSpeakerName;                                    // 0x17C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSwatCommandOpen;                                // 0x17D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_277A[0x7];                                     // 0x17D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USwatCommandWidget*                     SwatCommandWidget;                                 // 0x17E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_277B[0x2];                                     // 0x17E8(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInCommandMenu;                                    // 0x17EA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInDevicesMenu;                                    // 0x17EB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInTabMenu;                                        // 0x17EC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFadeToGray;                                       // 0x17ED(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_277C[0x1A];                                    // 0x17EE(0x001A)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Sensitivity;                                       // 0x1808(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertYaw;                                        // 0x180C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertPitch;                                      // 0x180D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_277D[0x2];                                     // 0x180E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamepadLookSensitivity;                            // 0x1810(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadAimSensitivity;                             // 0x1814(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertGamepadHorizontal;                          // 0x1818(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertGamepadVertical;                            // 0x1819(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldCrouchGamepad;                                // 0x181A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleADSGamepad;                                 // 0x181B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsingAlternateControls;                           // 0x181C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_277E[0x3];                                     // 0x181D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                HUD_Widget;                                        // 0x1820(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHumanCharacterHUD_V2*                  HumanCharacterWidget_V2;                           // 0x1828(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            MagCheckUI;                                        // 0x1830(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTeamViewWidget*                        TeamViewWidget;                                    // 0x1838(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 LastInteractableComponent;                         // 0x1840(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingTrigger*                       LastBuildingEntered;                               // 0x1848(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingTrigger*                       InsideCurrentBuilding;                             // 0x1850(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADoor*                                  LastHighlightedDoor;                               // 0x1858(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              LastHighlightedEvidence;                           // 0x1860(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APickupMagazineActor*                   LastHighlightedPickupMagazine;                     // 0x1868(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExitWithFireSelect;                               // 0x1870(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_277F[0x7];                                     // 0x1871(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       PreviousPosessedCharacter;                         // 0x1878(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClientPossessed;                                 // 0x1880(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerTakenDamageDetails;                        // 0x1890(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFMODEvent*                             CriticalInjuredEvent;                              // 0x18A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FlatlineEvent;                                     // 0x18A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FlatlineEventPvP;                                  // 0x18B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             HeadshotEvent;                                     // 0x18B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SAPIPlateHitEvent;                                 // 0x18C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMirroring : 1;                                    // 0x18C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2780[0x7];                                     // 0x18C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSpawnInventoryItemsOnPossess;                     // 0x18D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2781[0x3];                                     // 0x18D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FreeLookCache;                                     // 0x18D4(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2782[0x10];                                    // 0x18E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YellOutEffectLength;                               // 0x18F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YelloutEffectRadius;                               // 0x18F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowReadyStatus;                                  // 0x18F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2783[0x7];                                     // 0x18F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotPlayerState*                 LastPlayerState;                                   // 0x1900(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           HitBones;                                          // 0x1908(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        Camera_Hit_Arm_L;                                  // 0x1918(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        Camera_Hit_Arm_R;                                  // 0x1920(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        Camera_Hit_Low;                                    // 0x1928(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        Camera_Hit_Leg_L;                                  // 0x1930(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        Camera_Hit_Leg_R;                                  // 0x1938(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        Camera_Hit_Head_Front;                             // 0x1940(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        Camera_Hit_Head_Back;                              // 0x1948(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchHeight;                                      // 0x1950(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2784[0x4];                                     // 0x1954(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              BodyImpactGroundSound;                             // 0x1958(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Camera_RotationRate;                               // 0x1960(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2785[0x4];                                     // 0x196C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  CurrentlyPiloting;                                 // 0x1970(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2786[0x88];                                    // 0x1978(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       RevivingPlayer;                                    // 0x1A00(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       BeingRevivedByPlayer;                              // 0x1A08(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RevivingOperatingTime;                             // 0x1A10(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StunMovementSpeedMultiplier;                       // 0x1A14(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStunAimLocked;                                    // 0x1A18(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2787[0x7];                                     // 0x1A19(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseItem*                              LastEquippedItemBeforeStun;                        // 0x1A20(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2788[0x4];                                     // 0x1A28(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FirstPersonShakeAmount;                            // 0x1A2C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewBlendMultiplier;                               // 0x1A30(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2789[0x4];                                     // 0x1A34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BlendedBone;                                       // 0x1A38(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_278A[0x8];                                     // 0x1A40(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAnimInstance>              Replicated_3PAnimInstance;                         // 0x1A48(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              Replicated_1PAnimInstance;                         // 0x1A50(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   MontageQueue_3P;                                   // 0x1A58(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   MontageQueue_1P;                                   // 0x1A68(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         HoldingUseTime;                                    // 0x1A78(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldingUse;                                       // 0x1A7C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookingAtEvidenceItem;                            // 0x1A7D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookingAtDoor;                                    // 0x1A7E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookingAtHuman;                                   // 0x1A7F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookingAtTarget;                                  // 0x1A80(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUserLowReady;                                     // 0x1A81(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceLowReady;                                    // 0x1A82(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_278B[0x5];                                     // 0x1A83(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowReadyTraceDistance;                             // 0x1A88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_278C[0x4];                                     // 0x1A8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AEvidenceActor*                         LastCollectedEvidence;                             // 0x1A90(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseArmour>, class USkeletalMesh*> ArmorOverrideMapFP;                                // 0x1A98(0x0050)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_278D[0x8];                                     // 0x1AE8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             ChemlightClasses;                                  // 0x1AF0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UBasePlayerEffect*>              PlayerEffects;                                     // 0x1B00(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UBasePlayerEffect*                      RecoilNerfEffect;                                  // 0x1B10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideHeadwearPaperdollTexture : 1;             // 0x1B18(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_278E[0x7];                                     // 0x1B19(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             HeadwearPaperdollTexture_Override;                 // 0x1B20(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             HeadwearPaperdollTexture_Crouch_Override;          // 0x1B28(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLoadout                               DefaultItems;                                      // 0x1B30(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         EquipIndex;                                        // 0x1B50(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_278F[0x4];                                     // 0x1B54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLoadout>                       RandomLoadoutSelection;                            // 0x1B58(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        ForwardShake;                                      // 0x1B68(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        RightShake;                                        // 0x1B70(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponFireModeChanged;                           // 0x1B78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponFired;                                     // 0x1B88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2790[0x10];                                    // 0x1B98(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ABloodPool*                             BloodPool;                                         // 0x1BA8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraRotationRateMeshSpaceMultiplier;             // 0x1BB0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MeshspaceRecoilMovementMultiplier;                 // 0x1BBC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshSpaceMovementMultiplier1P;                     // 0x1BC8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MeshspaceRecoilMovementMinMax;                     // 0x1BCC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteract;                                        // 0x1BD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2791[0x29];                                    // 0x1BE8(0x0029)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWeaponDown3P;                                     // 0x1C11(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWearingHeavyArmour;                             // 0x1C12(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireLoop;                                         // 0x1C13(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2792[0x4];                                     // 0x1C14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           FullAutoLoop_Handle;                               // 0x1C18(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2793[0x8];                                     // 0x1C20(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceAiming;                                   // 0x1C28(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2794[0xC];                                     // 0x1C2C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bServerIsBlockingAnimationPlaying;                 // 0x1C38(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2795[0x7];                                     // 0x1C39(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnItemGroupSelection_Pressed;                      // 0x1C40(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemGroupSelection_Held;                         // 0x1C50(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemGroupSelection_Released;                     // 0x1C60(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemGroupSelection_ItemChanged;                  // 0x1C70(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bItemGroupSelectionHeld;                           // 0x1C80(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2796[0x7];                                     // 0x1C81(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAttachmentLightToggled;                          // 0x1C88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2797[0x10];                                    // 0x1C98(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMelee;                                           // 0x1CA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2798[0xC];                                     // 0x1CB8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintFovFactor;                                   // 0x1CC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintFovInterpTime;                               // 0x1CC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultFovInterpTime;                              // 0x1CCC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2799[0x10];                                    // 0x1CD0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnWeaponSwitchAmmoType;                            // 0x1CE0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChemlightThrown;                                 // 0x1CF0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_279A[0x8];                                     // 0x1D00(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlacedC2Explosive*                     PendingC2Removal;                                  // 0x1D08(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseGrenade*                           QuickThrowItem;                                    // 0x1D10(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279B[0x1];                                     // 0x1D18(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bQuickThrowing;                                    // 0x1D19(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279C[0x6];                                     // 0x1D1A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClearingScore;                                     // 0x1D20(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimTime;                                           // 0x1D24(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279D[0x6];                                     // 0x1D28(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bReloadLoop;                                       // 0x1D2E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279E[0x11];                                    // 0x1D2F(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnWeaponReload;                                    // 0x1D40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponTacticalReload;                            // 0x1D50(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_279F[0x10];                                    // 0x1D60(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnWeaponMagCheck;                                  // 0x1D70(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A0[0x4];                                     // 0x1D80(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForwardStrafeSpeedMultiplier;                      // 0x1D84(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardStrafeSpeedMultiplier;                     // 0x1D88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideStrafeSpeedMultiplier;                         // 0x1D8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanSpeedMultiplier;                               // 0x1D90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedPercentLossPerLegInjury;                      // 0x1D94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedPercentLossWhenCarrying;                      // 0x1D98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCameraFreelookSetting                 FreelookSetting;                                   // 0x1D9C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A1[0x4];                                     // 0x1DAC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             VaultTraceForward;                                 // 0x1DB0(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             VaultTraceDownClose;                               // 0x1E38(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             VaultTraceDownMiddle;                              // 0x1EC0(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             VaultTraceDownFar;                                 // 0x1F48(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bLedgeFound;                                       // 0x1FD0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVaulting;                                         // 0x1FD1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A2[0x2E];                                    // 0x1FD2(0x002E)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           LastPlayedVaultMontage;                            // 0x2000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A3[0x4];                                     // 0x2008(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RunSpeed;                                          // 0x200C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x2010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedModifier_AimFocus;                            // 0x2014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedModifier_Aim;                                 // 0x2018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedModifier_Crouch;                              // 0x201C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedModifier_Sprint;                              // 0x2020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedModifier_SprintMax;                           // 0x2024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedModifier_SprintTime;                          // 0x2028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitSpeedMultiplier;                                // 0x202C(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SlowDownSpeedMultiplier;                           // 0x2030(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WalkSpeedRampMultiplier;                           // 0x2034(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SprintSpeedRampUpMultiplier;                       // 0x2038(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentRunSpeedPercent;                            // 0x203C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A4[0x4];                                     // 0x2040(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRunSpeedPercent;                                // 0x2044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCrouchRunSpeedPercent;                          // 0x2048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinWalkSpeedPercent;                               // 0x204C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A5[0x10];                                    // 0x2050(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastSetRunSpeed;                                   // 0x2060(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedMultiplier;                               // 0x2064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeployableWalkSpeedMultiplier;                     // 0x2068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldingFastWalk;                                  // 0x206C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldingSprint;                                    // 0x206D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A6[0xE];                                     // 0x206E(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDisableSprinting : 1;                             // 0x207C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bWalking;                                          // 0x207D(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPlacement;                                   // 0x207E(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A7[0x55];                                    // 0x207F(0x0055)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeshspaceInterp;                                   // 0x20D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityCameraRollMultiplier;                      // 0x20D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PendingRecoil;                                     // 0x20DC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A8[0xC];                                     // 0x20E8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoilSpeed;                                       // 0x20F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A9[0x8];                                     // 0x20F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Last1PMontage;                                     // 0x2100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class UAnimMontage*>      PlayedTableMontageMap1P;                           // 0x2108(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_27AA[0x8];                                     // 0x2158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             JumpStartSound;                                    // 0x2160(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             JumpLandSound;                                     // 0x2168(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODSnapshot*                          InMix;                                             // 0x2170(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODSnapshot*                          OutMix;                                            // 0x2178(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutMixPlaying;                                    // 0x2180(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27AB[0x7];                                     // 0x2181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             InjuredScreamPVP;                                  // 0x2188(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27AC[0x8];                                     // 0x2190(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             DeathScreamPVP;                                    // 0x2198(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    InjuredScreamComponent;                            // 0x21A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27AD[0x4];                                     // 0x21A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementRequiredPerSound;                          // 0x21AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationRequiredPerSound;                          // 0x21B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NegativeVelocityRequiredForLandingSound;           // 0x21B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27AE[0x20];                                    // 0x21B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMovementSound>                 WalkSounds;                                        // 0x21D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WalkSounds_Environmental;                          // 0x21E8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMovementSound>                 RunSounds;                                         // 0x2210(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   RunSounds_Environmental;                           // 0x2220(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMovementSound>                 TurningSounds;                                     // 0x2248(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMovementSound>                 LandingSounds;                                     // 0x2258(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27AF[0x10];                                    // 0x2268(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitDirectionForward;                               // 0x2278(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitDirectionRight;                                 // 0x227C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B0[0x10];                                    // 0x2280(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             BreathingBaseEvent;                                // 0x2290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExhaustionLevel;                                   // 0x2298(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExhaustionDissipationRate;                         // 0x229C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExhaustionIncreaseRate;                            // 0x22A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExhaustionThreshold;                               // 0x22A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FearLevel;                                         // 0x22A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B1[0x4];                                     // 0x22AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FearDissipationRate;                               // 0x22B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FearSuppressionScale;                              // 0x22B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FearThreshold;                                     // 0x22B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSightTweakMode;                                 // 0x22BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B2[0x3];                                     // 0x22BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                SightTweakerWidgetTemplate;                        // 0x22C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            SightTweakerOverlay;                               // 0x22C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SightTweakerPosOffset;                             // 0x22D0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SightTweakerRotOffset;                             // 0x22DC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B3[0x10];                                    // 0x22E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnProtectionTime;                               // 0x22F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsThirdPerson;                                    // 0x22FC(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B4[0x3];                                     // 0x22FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Server_BaseAimRotation;                            // 0x2300(0x000C)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               FreeAimCache;                                      // 0x230C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B5[0x8];                                     // 0x2318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsPlayingInteraction;                              // 0x2320(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B6[0x4F];                                    // 0x2321(0x004F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsStopping;                                       // 0x2370(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B7[0x7];                                     // 0x2371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ALadderSnapZone*                        LadderPlacementZone;                               // 0x2378(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B8[0xC];                                     // 0x2380(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveForwardInput;                                  // 0x238C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveRightInput;                                    // 0x2390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B9[0x18];                                    // 0x2394(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LeftFootSocketName;                                // 0x23AC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RighttFootSocketName;                              // 0x23B4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFootConstEnum                                LeftFootEnum;                                      // 0x23BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFootConstEnum                                RightFootEnum;                                     // 0x23BD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27BA[0x2];                                     // 0x23BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootAdjustOffset;                                  // 0x23C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootInterpSpeed;                                   // 0x23C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootRotationInterpSpeed;                           // 0x23C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipInterpSpeed;                                    // 0x23CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x23D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceOffset;                                       // 0x23D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityThreshold;                                 // 0x23D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedBubbleAmount;                                 // 0x23DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CurrentMeshRot;                                    // 0x23E0(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27BB[0x2];                                     // 0x23EC(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIgnoreRotationOverride;                           // 0x23EE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27BC[0x15];                                    // 0x23EF(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CameraBobTrans;                                    // 0x2404(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WeaponBobTrans;                                    // 0x2410(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               WeaponBobRot;                                      // 0x241C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CameraBobRot;                                      // 0x2428(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsSecondarySightActive;                           // 0x2434(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27BD[0x3];                                     // 0x2435(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCantedSightToggled;                              // 0x2438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_27BE[0x10];                                    // 0x2448(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSecondarySightToggled;                           // 0x2458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsPelvisFPMovementBobActive;                      // 0x2468(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27BF[0x3];                                     // 0x2469(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PelvisFPMovementDamping;                           // 0x246C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCopyTPMeshTransformsToFP;                         // 0x2470(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C0[0x1F];                                    // 0x2471(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            ScoreboardWidget;                                  // 0x2490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27C1[0x8];                                     // 0x2498(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommandInterface*                      CommandInterface;                                  // 0x24A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27C2[0x10];                                    // 0x24A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bItemWheelActive;                                  // 0x24B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27C3[0xF];                                     // 0x24B9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCommandWheelActive;                               // 0x24C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27C4[0x4F];                                    // 0x24C9(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustScopeOffsetHorizontal(float NewOffset);
	void AdjustScopeOffsetVertical(float NewOffset);
	void ApplyPlayerEffect(class UBasePlayerEffect* InPlayerEffect, bool bResettable);
	void ApplyPlayerEffectFor(class UBasePlayerEffect* InPlayerEffect, float Seconds);
	void C2Door(class ADoor* Door);
	bool CalculateStopLocation(struct FVector* OutStopLocation, struct FVector& CurrentLocation, struct FVector& Velocity, struct FVector& Acceleration, float Friction, float BrakingDeceleration, float TimeStep, int32 MaxSimulationIterations);
	bool CanQuickThrow();
	void CaptureFPCamera(float DeltaTime);
	void Client_ApplyPlayerEffect(TSubclassOf<class UBasePlayerEffect> InPlayerEffectClass, bool bResettable, bool bMulticast);
	void Client_AutoSelectNewQuickthrowItem(class ABaseGrenade* CallingGrenade);
	void Client_BulletHit(const struct FHitResult& BulletImpact);
	void Client_OnBeginRemoveC2(class APlacedC2Explosive* C2);
	void Client_OnEndRemoveC2();
	void Client_OnPlayerDamage(bool bTakenDamage, float InDamage, class AReadyOrNotCharacter* InstigatorCharacter, class AActor* DamageCauser);
	void Client_OnTakenDamageDetail(bool bWasHeadshot, bool bTorsoShot, bool bLeftArm, bool bLeftLeg, bool bRightArm, bool bRightLeg, float DamageTaken, float RemainingHealth, bool bBlockedByArmour, bool bBlockedByHelmet);
	void Client_PlayPostProcessEffect(class FName& InPostProcessEffect, class AActor* DamageCauser);
	void Client_PossessedBy(class AController* NewController);
	void Client_ResetPlayerEffect(TSubclassOf<class UBasePlayerEffect> InPlayerEffectClass);
	void Client_SetWalkSpeed(float NewWalkSpeed, float NewCrouchWalkSpeed);
	void Client_StartPepperSprayed(class APepperspray* Pepperspray, const struct FVector& DamageCauserLocation);
	void Client_StartStun(EStunType StunType, class AActor* StunCauser, const struct FVector& DamageCauserLocation);
	void ClosePlayerView();
	void CreateHUDWidget();
	void CreateTeamViewWidget();
	void CycleFireMode();
	void DebugDetachAllComponentsAndSubComponents();
	void DestroyNonDevelopmentComponents();
	void DrawPermanentMarker();
	void Drone_MoveForward(float Val);
	void Drone_Right(float Val);
	void Drone_Steady();
	void Drone_Throttle(float Val);
	void Drone_Yaw(float Val);
	void EndQuickThrow();
	void EndSecondaryUse();
	void EquipBatteringRam();
	void EquipBreachingShotgun();
	void EquipC2();
	void EquipCSGas();
	void EquipDetonator();
	void EquipDoorJam();
	void EquipFlashbang();
	class ABaseItem* EquipItemFromGroup_Index(int32 GroupIndex, int32 ItemCategoryIndex);
	class ABaseItem* EquipItemFromGroup_Name(class FName GroupName, int32 ItemCategoryIndex);
	class ABaseItem* EquipItemOfType(EItemCategory ItemCategory);
	void EquipLongTactical();
	void EquipMirrorgun();
	void EquipMultitool();
	bool EquippedWeaponHasFireModes();
	void EquipPepperspray();
	void EquipPrimaryItem();
	void EquipSecondaryItem();
	void EquipStinger();
	void EquipZipcuffs();
	void FadeToBlackDisable();
	void FadeToBlackEnable();
	void FireLaserEyes();
	void ForceFirstDraw();
	void ForceMaxLODs_Items();
	void ForceMaxLODs_Player();
	TArray<class APlayerCharacter*> GetAllOtherPlayerCharacters(ETeamType Team);
	class APlayerCharacter* GetClosestPlayerCharacter(ETeamType Team, float* OutClosestDistance, bool bExcludeArrested);
	EFireMode GetFiringMode();
	struct FHitResult GetHitFromCamera(float MaxDistance, const TArray<ECollisionChannel>& CollisionChannels, const struct FRotator& OffsetRotation, const struct FVector& OffsetVector, bool bDrawTrace);
	bool HasBSG();
	bool HasC2();
	bool HasLockpick();
	bool HasNVG();
	bool HasOptiwand();
	bool HasWedge();
	void HidePlayer();
	void IncrementalUse(float Val);
	bool IsInLightSource(int32* VisibleLightSources, float MinimumLightLevel);
	void JamDoor(class ADoor* Door);
	void LocalArrestFeed(class APlayerCharacter* Arrester, class APlayerCharacter* Victim);
	void LocalDeathFeed(class AReadyOrNotPlayerController* PlayerController);
	void LocalFreeFeed(class APlayerCharacter* Freer, class APlayerCharacter* Victim);
	void LocalKillFeed(class APlayerCharacter* Killer, class APlayerCharacter* Victim, class ABaseItem* Weapon);
	void MagCheck();
	void Melee();
	void Multicast_HideThirdPerson();
	void Multicast_PlayArmourRelatedEffects(class ABaseArmour* Armour, class UParticleSystem* Particle, struct FTransform& AtTransform);
	void Multicast_PlayInjuredScream();
	void Multicast_PlayPVPSpeech(const class FString& SpeechRowName, ETeamType TeamType);
	void Multicast_PlaySound(class USoundCue* Cue);
	void Multicast_ShowThirdPerson();
	void Multicast_ToggleLaserLight();
	void OnAttachmentLightToggled__DelegateSignature();
	void OnBulletImpact(float DirectionForward, float DirectionRight);
	void OnBulletImpact__DelegateSignature(float DirectionForward, float DirectionRight);
	void OnCantedSightToggled__DelegateSignature(bool bUsingCantedSight);
	void OnChatPressed();
	void OnClientPossessed__DelegateSignature(class AController* NewController);
	void OnDefaultCommandIssued__DelegateSignature(class APlayerCharacter* Issuer, ESwatCommand CommandIssued);
	void OnFullHealth();
	void OnInteract__DelegateSignature(class UInteractableComponent* InteractableComp);
	void OnItemGroupSelection__DelegateSignature(int32 GroupIndex, int32 CategoryIndex);
	void OnItemPrimaryUse(class ABaseItem* Item);
	void OnItemPrimaryUseCompleted(class ABaseItem* Item);
	void OnItemSelectionStyleChanged(EItemSelectionInterfaceType NewItemSelectionInterface);
	void OnItemUseCompleted__DelegateSignature(class ABaseItem* Item);
	void OnItemUseStart__DelegateSignature(class ABaseItem* Item);
	void OnJumpLand();
	void OnJumpStart();
	void OnKilledOrGoneUnconciousBP();
	void OnLowHealth(float CurrentHealth);
	void OnLowReadyButtonDown();
	void OnLowReadyButtonUp();
	void OnMelee__DelegateSignature();
	void OnPlayerEffectExpired(TSubclassOf<class UReadyOrNotGameplayEffect> InPlayerEffectClass);
	void OnPlayerTakeDamageDetails__DelegateSignature(bool bWasHeadshot, float DamageTaken, float HealthRemaining, bool bBlockedByArmour, bool bBlockedByHelmet);
	void OnRep_BaseAimRotation();
	void OnRep_RunSpeedUpdate();
	void OnRep_StartBoneBlend();
	void OnRep_UpdateAnimInstance();
	void OnSecondarySightToggled__DelegateSignature(bool bUsingSecondarySight, class ABaseMagazineWeapon* Weapon);
	void OnSelectDevicePressed(const struct FKey& Key);
	void OnSelectDeviceReleased(const struct FKey& Key);
	void OnStartChemThrow__DelegateSignature(class APlayerCharacter* PlayerCharacter);
	void OnSupression(float Strength);
	void OnSupression__DelegateSignature(float Strength);
	void OnTeamChatPressed();
	void OnTeamViewSet__DelegateSignature(class AReadyOrNotCharacter* NewViewCharacter);
	void OnTurn();
	void OnWeaponFired__DelegateSignature(class ABaseWeapon* Weapon);
	void OnWeaponFireModeChanged__DelegateSignature(class APlayerCharacter* PlayerCharacter, EFireMode NewFireMode, EFireMode LastFireMode);
	void OnWeaponMagCheckSignature__DelegateSignature(class ABaseMagazineWeapon* MagazineWeapon);
	void OnWeaponReloadSignature__DelegateSignature(class APlayerCharacter* PlayerCharacter);
	void OnWeaponSwitchAmmoType__DelegateSignature(class APlayerCharacter* PlayerCharacter);
	void OnWeaponTacticalReloadSignature__DelegateSignature(class APlayerCharacter* PlayerCharacter);
	void Ping();
	void PlayVaultAnimation(const struct FVector& Ledge, const struct FVector& LedgeWallNormal, const struct FVector& LedgeTraceDown, float LedgeZ, ELedgeWidth LedgeWidth, ELedgeHeight LedgeHeight);
	void PrimaryUse();
	void PrintItemAttachmentListToLog();
	void Reload();
	void ReloadOrMagCheck();
	void ReloadOrMagCheck_Released();
	void RemovePendingC2();
	void ReplenishAllGrenadeAmmo();
	void ReplenishAllMagazineAmmo();
	void ResetLODs_Items();
	void ResetLODS_Player();
	void ScreenPositionToWeaponFOV(struct FVector2D& ScreenPosition, struct FVector* WorldPosition, struct FVector* WorldDirection);
	void SecondaryUse();
	void Server_ActorPickedUp(class APickupActor* PickupActor);
	void Server_ApplyPlayerEffect(TSubclassOf<class UBasePlayerEffect> InPlayerEffectClass, bool bResettable, bool bMulticast);
	void Server_ApplyPlayerEffectFor(TSubclassOf<class UBasePlayerEffect> InPlayerEffectClass, float Seconds, bool bMulticast);
	void Server_ArrestfeedMessage(class APlayerCharacter* Arrester, class APlayerCharacter* Victim);
	void Server_ChangeFPMesh(class USkeletalMesh* NewFPMesh);
	void Server_ChangeMesh(class USkeletalMesh* FPMesh, class USkeletalMesh* TPMesh, class USkeletalMesh* TPHeadMesh);
	void Server_EndFastWalk();
	void Server_EndPrimaryUse();
	void Server_EquipMultitool(EMultitoolFunctions MultitoolFunction);
	void Server_FastWalk();
	void Server_FinishHealing();
	void Server_FreefeedMessage(class APlayerCharacter* Freer, class APlayerCharacter* Victim);
	void Server_GiveAIMoveTo(class ACyberneticCharacter* AI, const struct FVector& Location);
	void Server_GiveAIMoveToExit(class ACyberneticCharacter* AI);
	void Server_GiveAITurnAroundOrder(class ACyberneticCharacter* AI);
	void Server_InstantSurrenderTarget();
	void Server_InstaStartArrest(class APlayerCharacter* Target);
	void Server_InstaStartFree(class APlayerCharacter* Target);
	void Server_KillfeedMessage(class APlayerCharacter* Killer, class APlayerCharacter* Victim, class ABaseItem* Weapon);
	void Server_LockAim();
	void Server_LockAllActions();
	void Server_LockMovement();
	void Server_LockMovementAndActions();
	void Server_LockMovementAndAim();
	void Server_MarkWeaponCleaned(class ABaseItem* Item);
	void Server_OnReloadComplete();
	void Server_OnReviveComplete(class APlayerCharacter* PlayerCharacter);
	void Server_Ping();
	void Server_PlayPVPSpeech(const class FString& SpeechRowName, ETeamType TeamType);
	void Server_PlaySound(class USoundCue* Cue);
	void Server_PlayVaultAnimation(const struct FVector& Ledge, const struct FVector& LegeWallNormal, const struct FVector& LedgeTraceDown, float LedgeZ, ELedgeWidth LedgeWidth, ELedgeHeight LedgeHeight);
	void Server_PrepareForHeal();
	void Server_PrimaryUse();
	void Server_RemoveLadder(class ATelescopicLadder* Ladder);
	void Server_ResetPlayerEffect(TSubclassOf<class UBasePlayerEffect> InPlayerEffectClass, bool bMulticast);
	void Server_SecondaryUse();
	void Server_SetLowReady(bool bUp, bool bLowReady, bool bIsUserLowReady);
	void Server_SetUserLowReady(bool bShouldUserLowReady);
	void Server_SetWalkSpeed(float NewWalkSpeed, float NewCrouchWalkSpeed);
	void Server_SpawnEjectedMagazine(const struct FTransform& SpawnTransform, class ABaseMagazineWeapon* Weapon);
	void Server_Sprint();
	void Server_StopAIMoveTo(class ACyberneticCharacter* AI);
	void Server_TakeDamage(float Damage, struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void Server_TeleportPlayerToLocation(const struct FVector& Location);
	void Server_ToggleFastMovement();
	void Server_ToggleGodMode();
	void Server_ToggleLightByClass(ELightRadialSelection LightType);
	void Server_ToggleNoTarget();
	void Server_ToggleWalk();
	void Server_UnlockAim();
	void Server_UnlockAllActions();
	void Server_UnlockMovement();
	void Server_UnlockMovementAndActions();
	void Server_UnlockMovementAndAim();
	void Server_UpdateADS(bool bADS);
	void Server_UpdateCameraRotationRate(const struct FRotator& NewCameraRotRate);
	void Server_UpdateFreeLookCache(const struct FRotator& NewFreeLookCache);
	void Server_UpdateIsBlockingAnimationPlaying(bool bIsBlockingAnimationPlaying);
	void Server_UpdateLastSetRunSpeed(float NewRunSpeed);
	void Server_Walk();
	void SetAmmo(const class FString& AmmoType);
	void SetCommandInterfaceActive(bool CommandInterfaceActive);
	void SetForceLowReady(bool bShouldForceLowReady);
	void SetFreelookPitchMax(float NewPitchMaxValue);
	void SetFreelookPitchMin(float NewPitchMinValue);
	void SetFreelookYawMax(float NewYawMaxValue);
	void SetFreelookYawMin(float NewYawMinValue);
	void SetHumanCharacterWidget_V2(class UHumanCharacterHUD_V2* NewHumanCharacterWidget);
	void SetMaxRunSpeed(float NewMaxSpeed);
	void SetRunSpeed(float NewRunSpeed);
	void SetTabletFocused(bool bFocused);
	void ShowPlayer();
	void StartBleeding();
	void StartChemThrow();
	void StartFreeLook();
	void StartLockPicking(class AActor* Target);
	void StartQuickThrow();
	void StartUsingMultitool(class AActor* Target);
	void StopFPMontageFromTable(const class FString& Animation, float BlendoutTime);
	void StopFreeLook();
	void StopLockPicking(class AActor* Target);
	void StopUsingMultitool(class AActor* Target);
	void TeleportPlayerToLocation(const struct FVector& Location);
	void ToggleCrosshairOverlay();
	void ToggleCrouch();
	void ToggleFastMovement();
	void ToggleFreeLook();
	void ToggleFreeThirdPerson();
	void ToggleGodMode();
	void ToggleHUD();
	void ToggleLowReady();
	void ToggleNoTarget();
	void ToggleSecondarySight();
	void ToggleSightTweaker();
	void ToggleSprint();
	void ToggleThirdPerson();
	void ToggleUnderbarrelAttachment();
	void TryNextPlayerView_Released();
	void UpdatePictureInPictureVisibility();

	bool CanPingActor(class AActor* Actor) const;
	bool CanUseIncrementalSystem() const;
	bool EquippedWeaponHasLaserAttachment() const;
	bool EquippedWeaponHasLightAttachment() const;
	bool EquippedWeaponHasSecondarySight() const;
	struct FRotator GetAimOffsets() const;
	TArray<class AReadyOrNotCharacter*> GetAvaliablePlayersForTeamView(bool bIncludeDeadViews) const;
	int32 GetChemlightAmmo() const;
	struct FCameraFreelookSetting GetCurrentFreelookSettings() const;
	int32 GetQuickthrowGrenadeAmmo() const;
	float GetViewPitch() const;
	bool HasChemlightsInInventory() const;
	bool HasGrenadesInInventory() const;
	bool Is1PMontagePlaying(class UAnimMontage* Montage) const;
	bool IsAny1PMontagePlaying() const;
	bool IsFireModeSelectPlaying() const;
	bool IsFreelooking() const;
	bool IsHoldingFastWalk() const;
	bool IsHoldingSprint() const;
	bool IsInCinematicAnimation() const;
	bool IsMagCheckPlaying() const;
	bool IsMoving() const;
	bool IsMovingForward() const;
	bool IsSprinting() const;
	bool IsTabletFocused() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCharacter">();
	}
	static class APlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerCharacter>();
	}
};
#pragma pack(pop)
static_assert(alignof(APlayerCharacter) == 0x000010, "Wrong alignment on APlayerCharacter");
static_assert(sizeof(APlayerCharacter) == 0x002520, "Wrong size on APlayerCharacter");
static_assert(offsetof(APlayerCharacter, CustomizationFirstPersonMeshes) == 0x001628, "Member 'APlayerCharacter::CustomizationFirstPersonMeshes' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CustomizationFirstPersonBodyMeshes) == 0x001638, "Member 'APlayerCharacter::CustomizationFirstPersonBodyMeshes' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CustomizationActorMaterials) == 0x001648, "Member 'APlayerCharacter::CustomizationActorMaterials' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bFirstPersonMeshesDirty) == 0x001658, "Member 'APlayerCharacter::bFirstPersonMeshesDirty' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ThirdPersonCameraComponent) == 0x001660, "Member 'APlayerCharacter::ThirdPersonCameraComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ThirdPersonCameraArm) == 0x001668, "Member 'APlayerCharacter::ThirdPersonCameraArm' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Mesh1P) == 0x001670, "Member 'APlayerCharacter::Mesh1P' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MeshBody1P) == 0x001678, "Member 'APlayerCharacter::MeshBody1P' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FirstPersonCameraComponent) == 0x001680, "Member 'APlayerCharacter::FirstPersonCameraComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PlayerPostProcessingComp) == 0x001688, "Member 'APlayerCharacter::PlayerPostProcessingComp' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FMODBreathingAudioComp) == 0x001690, "Member 'APlayerCharacter::FMODBreathingAudioComp' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BleedComponent) == 0x001698, "Member 'APlayerCharacter::BleedComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ScoringComponent) == 0x0016A0, "Member 'APlayerCharacter::ScoringComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PrimaryItemVisualizationComponent) == 0x0016A8, "Member 'APlayerCharacter::PrimaryItemVisualizationComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SecondaryItemVisualizationComponent) == 0x0016B0, "Member 'APlayerCharacter::SecondaryItemVisualizationComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LongTacticalVisualizationComponent) == 0x0016B8, "Member 'APlayerCharacter::LongTacticalVisualizationComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HelmetVisualizationComponent) == 0x0016C0, "Member 'APlayerCharacter::HelmetVisualizationComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ArmorVisualizationComponent) == 0x0016C8, "Member 'APlayerCharacter::ArmorVisualizationComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, EquippedItemVisualizationComponent) == 0x0016D0, "Member 'APlayerCharacter::EquippedItemVisualizationComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Rep_FPBodyMesh) == 0x0016E0, "Member 'APlayerCharacter::Rep_FPBodyMesh' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastSetMesh1PDynamicMaterial) == 0x0016E8, "Member 'APlayerCharacter::LastSetMesh1PDynamicMaterial' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DynamicWeaponFovMats) == 0x0016F0, "Member 'APlayerCharacter::DynamicWeaponFovMats' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MeshComps) == 0x001710, "Member 'APlayerCharacter::MeshComps' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastKnownPlayerState) == 0x001728, "Member 'APlayerCharacter::LastKnownPlayerState' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ReplicatedFPMesh) == 0x001734, "Member 'APlayerCharacter::ReplicatedFPMesh' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurInputVector) == 0x001754, "Member 'APlayerCharacter::CurInputVector' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PushOverlappingAI_Handle) == 0x001760, "Member 'APlayerCharacter::PushOverlappingAI_Handle' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Body1PMat) == 0x001768, "Member 'APlayerCharacter::Body1PMat' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentViewCharacter) == 0x001770, "Member 'APlayerCharacter::CurrentViewCharacter' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnDefaultCommandIssued) == 0x001778, "Member 'APlayerCharacter::OnDefaultCommandIssued' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnTeamViewSet) == 0x001788, "Member 'APlayerCharacter::OnTeamViewSet' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentTeamViewIndex) == 0x001798, "Member 'APlayerCharacter::CurrentTeamViewIndex' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PlayerViewActor) == 0x0017A0, "Member 'APlayerCharacter::PlayerViewActor' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PlayerViewActorClass) == 0x0017A8, "Member 'APlayerCharacter::PlayerViewActorClass' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TH_TeamViewInput) == 0x0017B0, "Member 'APlayerCharacter::TH_TeamViewInput' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TeamViewInputHoldTime) == 0x0017B8, "Member 'APlayerCharacter::TeamViewInputHoldTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SurfaceType) == 0x0017BC, "Member 'APlayerCharacter::SurfaceType' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RoomType) == 0x0017C0, "Member 'APlayerCharacter::RoomType' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PVPSpeakerName) == 0x0017C8, "Member 'APlayerCharacter::PVPSpeakerName' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsSwatCommandOpen) == 0x0017D8, "Member 'APlayerCharacter::bIsSwatCommandOpen' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SwatCommandWidget) == 0x0017E0, "Member 'APlayerCharacter::SwatCommandWidget' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInCommandMenu) == 0x0017EA, "Member 'APlayerCharacter::bInCommandMenu' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInDevicesMenu) == 0x0017EB, "Member 'APlayerCharacter::bInDevicesMenu' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInTabMenu) == 0x0017EC, "Member 'APlayerCharacter::bInTabMenu' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bFadeToGray) == 0x0017ED, "Member 'APlayerCharacter::bFadeToGray' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Sensitivity) == 0x001808, "Member 'APlayerCharacter::Sensitivity' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInvertYaw) == 0x00180C, "Member 'APlayerCharacter::bInvertYaw' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInvertPitch) == 0x00180D, "Member 'APlayerCharacter::bInvertPitch' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GamepadLookSensitivity) == 0x001810, "Member 'APlayerCharacter::GamepadLookSensitivity' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GamepadAimSensitivity) == 0x001814, "Member 'APlayerCharacter::GamepadAimSensitivity' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInvertGamepadHorizontal) == 0x001818, "Member 'APlayerCharacter::bInvertGamepadHorizontal' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInvertGamepadVertical) == 0x001819, "Member 'APlayerCharacter::bInvertGamepadVertical' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bHoldCrouchGamepad) == 0x00181A, "Member 'APlayerCharacter::bHoldCrouchGamepad' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bToggleADSGamepad) == 0x00181B, "Member 'APlayerCharacter::bToggleADSGamepad' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bUsingAlternateControls) == 0x00181C, "Member 'APlayerCharacter::bUsingAlternateControls' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HUD_Widget) == 0x001820, "Member 'APlayerCharacter::HUD_Widget' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HumanCharacterWidget_V2) == 0x001828, "Member 'APlayerCharacter::HumanCharacterWidget_V2' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MagCheckUI) == 0x001830, "Member 'APlayerCharacter::MagCheckUI' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TeamViewWidget) == 0x001838, "Member 'APlayerCharacter::TeamViewWidget' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastInteractableComponent) == 0x001840, "Member 'APlayerCharacter::LastInteractableComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastBuildingEntered) == 0x001848, "Member 'APlayerCharacter::LastBuildingEntered' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, InsideCurrentBuilding) == 0x001850, "Member 'APlayerCharacter::InsideCurrentBuilding' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastHighlightedDoor) == 0x001858, "Member 'APlayerCharacter::LastHighlightedDoor' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastHighlightedEvidence) == 0x001860, "Member 'APlayerCharacter::LastHighlightedEvidence' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastHighlightedPickupMagazine) == 0x001868, "Member 'APlayerCharacter::LastHighlightedPickupMagazine' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bExitWithFireSelect) == 0x001870, "Member 'APlayerCharacter::bExitWithFireSelect' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PreviousPosessedCharacter) == 0x001878, "Member 'APlayerCharacter::PreviousPosessedCharacter' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnClientPossessed) == 0x001880, "Member 'APlayerCharacter::OnClientPossessed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnPlayerTakenDamageDetails) == 0x001890, "Member 'APlayerCharacter::OnPlayerTakenDamageDetails' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CriticalInjuredEvent) == 0x0018A0, "Member 'APlayerCharacter::CriticalInjuredEvent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FlatlineEvent) == 0x0018A8, "Member 'APlayerCharacter::FlatlineEvent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FlatlineEventPvP) == 0x0018B0, "Member 'APlayerCharacter::FlatlineEventPvP' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HeadshotEvent) == 0x0018B8, "Member 'APlayerCharacter::HeadshotEvent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SAPIPlateHitEvent) == 0x0018C0, "Member 'APlayerCharacter::SAPIPlateHitEvent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bSpawnInventoryItemsOnPossess) == 0x0018D0, "Member 'APlayerCharacter::bSpawnInventoryItemsOnPossess' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FreeLookCache) == 0x0018D4, "Member 'APlayerCharacter::FreeLookCache' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, YellOutEffectLength) == 0x0018F0, "Member 'APlayerCharacter::YellOutEffectLength' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, YelloutEffectRadius) == 0x0018F4, "Member 'APlayerCharacter::YelloutEffectRadius' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bShowReadyStatus) == 0x0018F8, "Member 'APlayerCharacter::bShowReadyStatus' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastPlayerState) == 0x001900, "Member 'APlayerCharacter::LastPlayerState' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HitBones) == 0x001908, "Member 'APlayerCharacter::HitBones' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Camera_Hit_Arm_L) == 0x001918, "Member 'APlayerCharacter::Camera_Hit_Arm_L' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Camera_Hit_Arm_R) == 0x001920, "Member 'APlayerCharacter::Camera_Hit_Arm_R' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Camera_Hit_Low) == 0x001928, "Member 'APlayerCharacter::Camera_Hit_Low' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Camera_Hit_Leg_L) == 0x001930, "Member 'APlayerCharacter::Camera_Hit_Leg_L' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Camera_Hit_Leg_R) == 0x001938, "Member 'APlayerCharacter::Camera_Hit_Leg_R' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Camera_Hit_Head_Front) == 0x001940, "Member 'APlayerCharacter::Camera_Hit_Head_Front' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Camera_Hit_Head_Back) == 0x001948, "Member 'APlayerCharacter::Camera_Hit_Head_Back' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CrouchHeight) == 0x001950, "Member 'APlayerCharacter::CrouchHeight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BodyImpactGroundSound) == 0x001958, "Member 'APlayerCharacter::BodyImpactGroundSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Camera_RotationRate) == 0x001960, "Member 'APlayerCharacter::Camera_RotationRate' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentlyPiloting) == 0x001970, "Member 'APlayerCharacter::CurrentlyPiloting' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RevivingPlayer) == 0x001A00, "Member 'APlayerCharacter::RevivingPlayer' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BeingRevivedByPlayer) == 0x001A08, "Member 'APlayerCharacter::BeingRevivedByPlayer' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RevivingOperatingTime) == 0x001A10, "Member 'APlayerCharacter::RevivingOperatingTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StunMovementSpeedMultiplier) == 0x001A14, "Member 'APlayerCharacter::StunMovementSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bStunAimLocked) == 0x001A18, "Member 'APlayerCharacter::bStunAimLocked' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastEquippedItemBeforeStun) == 0x001A20, "Member 'APlayerCharacter::LastEquippedItemBeforeStun' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FirstPersonShakeAmount) == 0x001A2C, "Member 'APlayerCharacter::FirstPersonShakeAmount' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ViewBlendMultiplier) == 0x001A30, "Member 'APlayerCharacter::ViewBlendMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BlendedBone) == 0x001A38, "Member 'APlayerCharacter::BlendedBone' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Replicated_3PAnimInstance) == 0x001A48, "Member 'APlayerCharacter::Replicated_3PAnimInstance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Replicated_1PAnimInstance) == 0x001A50, "Member 'APlayerCharacter::Replicated_1PAnimInstance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MontageQueue_3P) == 0x001A58, "Member 'APlayerCharacter::MontageQueue_3P' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MontageQueue_1P) == 0x001A68, "Member 'APlayerCharacter::MontageQueue_1P' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HoldingUseTime) == 0x001A78, "Member 'APlayerCharacter::HoldingUseTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bHoldingUse) == 0x001A7C, "Member 'APlayerCharacter::bHoldingUse' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bLookingAtEvidenceItem) == 0x001A7D, "Member 'APlayerCharacter::bLookingAtEvidenceItem' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bLookingAtDoor) == 0x001A7E, "Member 'APlayerCharacter::bLookingAtDoor' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bLookingAtHuman) == 0x001A7F, "Member 'APlayerCharacter::bLookingAtHuman' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bLookingAtTarget) == 0x001A80, "Member 'APlayerCharacter::bLookingAtTarget' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bUserLowReady) == 0x001A81, "Member 'APlayerCharacter::bUserLowReady' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bForceLowReady) == 0x001A82, "Member 'APlayerCharacter::bForceLowReady' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LowReadyTraceDistance) == 0x001A88, "Member 'APlayerCharacter::LowReadyTraceDistance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastCollectedEvidence) == 0x001A90, "Member 'APlayerCharacter::LastCollectedEvidence' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ArmorOverrideMapFP) == 0x001A98, "Member 'APlayerCharacter::ArmorOverrideMapFP' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ChemlightClasses) == 0x001AF0, "Member 'APlayerCharacter::ChemlightClasses' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PlayerEffects) == 0x001B00, "Member 'APlayerCharacter::PlayerEffects' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RecoilNerfEffect) == 0x001B10, "Member 'APlayerCharacter::RecoilNerfEffect' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HeadwearPaperdollTexture_Override) == 0x001B20, "Member 'APlayerCharacter::HeadwearPaperdollTexture_Override' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HeadwearPaperdollTexture_Crouch_Override) == 0x001B28, "Member 'APlayerCharacter::HeadwearPaperdollTexture_Crouch_Override' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DefaultItems) == 0x001B30, "Member 'APlayerCharacter::DefaultItems' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, EquipIndex) == 0x001B50, "Member 'APlayerCharacter::EquipIndex' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RandomLoadoutSelection) == 0x001B58, "Member 'APlayerCharacter::RandomLoadoutSelection' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ForwardShake) == 0x001B68, "Member 'APlayerCharacter::ForwardShake' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RightShake) == 0x001B70, "Member 'APlayerCharacter::RightShake' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnWeaponFireModeChanged) == 0x001B78, "Member 'APlayerCharacter::OnWeaponFireModeChanged' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnWeaponFired) == 0x001B88, "Member 'APlayerCharacter::OnWeaponFired' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BloodPool) == 0x001BA8, "Member 'APlayerCharacter::BloodPool' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CameraRotationRateMeshSpaceMultiplier) == 0x001BB0, "Member 'APlayerCharacter::CameraRotationRateMeshSpaceMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MeshspaceRecoilMovementMultiplier) == 0x001BBC, "Member 'APlayerCharacter::MeshspaceRecoilMovementMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MeshSpaceMovementMultiplier1P) == 0x001BC8, "Member 'APlayerCharacter::MeshSpaceMovementMultiplier1P' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MeshspaceRecoilMovementMinMax) == 0x001BCC, "Member 'APlayerCharacter::MeshspaceRecoilMovementMinMax' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnInteract) == 0x001BD8, "Member 'APlayerCharacter::OnInteract' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bWeaponDown3P) == 0x001C11, "Member 'APlayerCharacter::bWeaponDown3P' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsWearingHeavyArmour) == 0x001C12, "Member 'APlayerCharacter::bIsWearingHeavyArmour' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bFireLoop) == 0x001C13, "Member 'APlayerCharacter::bFireLoop' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FullAutoLoop_Handle) == 0x001C18, "Member 'APlayerCharacter::FullAutoLoop_Handle' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TimeSinceAiming) == 0x001C28, "Member 'APlayerCharacter::TimeSinceAiming' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bServerIsBlockingAnimationPlaying) == 0x001C38, "Member 'APlayerCharacter::bServerIsBlockingAnimationPlaying' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnItemGroupSelection_Pressed) == 0x001C40, "Member 'APlayerCharacter::OnItemGroupSelection_Pressed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnItemGroupSelection_Held) == 0x001C50, "Member 'APlayerCharacter::OnItemGroupSelection_Held' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnItemGroupSelection_Released) == 0x001C60, "Member 'APlayerCharacter::OnItemGroupSelection_Released' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnItemGroupSelection_ItemChanged) == 0x001C70, "Member 'APlayerCharacter::OnItemGroupSelection_ItemChanged' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bItemGroupSelectionHeld) == 0x001C80, "Member 'APlayerCharacter::bItemGroupSelectionHeld' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnAttachmentLightToggled) == 0x001C88, "Member 'APlayerCharacter::OnAttachmentLightToggled' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnMelee) == 0x001CA8, "Member 'APlayerCharacter::OnMelee' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SprintFovFactor) == 0x001CC4, "Member 'APlayerCharacter::SprintFovFactor' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SprintFovInterpTime) == 0x001CC8, "Member 'APlayerCharacter::SprintFovInterpTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DefaultFovInterpTime) == 0x001CCC, "Member 'APlayerCharacter::DefaultFovInterpTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnWeaponSwitchAmmoType) == 0x001CE0, "Member 'APlayerCharacter::OnWeaponSwitchAmmoType' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnChemlightThrown) == 0x001CF0, "Member 'APlayerCharacter::OnChemlightThrown' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PendingC2Removal) == 0x001D08, "Member 'APlayerCharacter::PendingC2Removal' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, QuickThrowItem) == 0x001D10, "Member 'APlayerCharacter::QuickThrowItem' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bQuickThrowing) == 0x001D19, "Member 'APlayerCharacter::bQuickThrowing' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ClearingScore) == 0x001D20, "Member 'APlayerCharacter::ClearingScore' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AimTime) == 0x001D24, "Member 'APlayerCharacter::AimTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bReloadLoop) == 0x001D2E, "Member 'APlayerCharacter::bReloadLoop' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnWeaponReload) == 0x001D40, "Member 'APlayerCharacter::OnWeaponReload' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnWeaponTacticalReload) == 0x001D50, "Member 'APlayerCharacter::OnWeaponTacticalReload' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnWeaponMagCheck) == 0x001D70, "Member 'APlayerCharacter::OnWeaponMagCheck' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ForwardStrafeSpeedMultiplier) == 0x001D84, "Member 'APlayerCharacter::ForwardStrafeSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BackwardStrafeSpeedMultiplier) == 0x001D88, "Member 'APlayerCharacter::BackwardStrafeSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SideStrafeSpeedMultiplier) == 0x001D8C, "Member 'APlayerCharacter::SideStrafeSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LeanSpeedMultiplier) == 0x001D90, "Member 'APlayerCharacter::LeanSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedPercentLossPerLegInjury) == 0x001D94, "Member 'APlayerCharacter::SpeedPercentLossPerLegInjury' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedPercentLossWhenCarrying) == 0x001D98, "Member 'APlayerCharacter::SpeedPercentLossWhenCarrying' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FreelookSetting) == 0x001D9C, "Member 'APlayerCharacter::FreelookSetting' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, VaultTraceForward) == 0x001DB0, "Member 'APlayerCharacter::VaultTraceForward' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, VaultTraceDownClose) == 0x001E38, "Member 'APlayerCharacter::VaultTraceDownClose' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, VaultTraceDownMiddle) == 0x001EC0, "Member 'APlayerCharacter::VaultTraceDownMiddle' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, VaultTraceDownFar) == 0x001F48, "Member 'APlayerCharacter::VaultTraceDownFar' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bLedgeFound) == 0x001FD0, "Member 'APlayerCharacter::bLedgeFound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bVaulting) == 0x001FD1, "Member 'APlayerCharacter::bVaulting' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastPlayedVaultMontage) == 0x002000, "Member 'APlayerCharacter::LastPlayedVaultMontage' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RunSpeed) == 0x00200C, "Member 'APlayerCharacter::RunSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MaxAcceleration) == 0x002010, "Member 'APlayerCharacter::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedModifier_AimFocus) == 0x002014, "Member 'APlayerCharacter::SpeedModifier_AimFocus' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedModifier_Aim) == 0x002018, "Member 'APlayerCharacter::SpeedModifier_Aim' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedModifier_Crouch) == 0x00201C, "Member 'APlayerCharacter::SpeedModifier_Crouch' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedModifier_Sprint) == 0x002020, "Member 'APlayerCharacter::SpeedModifier_Sprint' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedModifier_SprintMax) == 0x002024, "Member 'APlayerCharacter::SpeedModifier_SprintMax' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedModifier_SprintTime) == 0x002028, "Member 'APlayerCharacter::SpeedModifier_SprintTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HitSpeedMultiplier) == 0x00202C, "Member 'APlayerCharacter::HitSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlowDownSpeedMultiplier) == 0x002030, "Member 'APlayerCharacter::SlowDownSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WalkSpeedRampMultiplier) == 0x002034, "Member 'APlayerCharacter::WalkSpeedRampMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SprintSpeedRampUpMultiplier) == 0x002038, "Member 'APlayerCharacter::SprintSpeedRampUpMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentRunSpeedPercent) == 0x00203C, "Member 'APlayerCharacter::CurrentRunSpeedPercent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MaxRunSpeedPercent) == 0x002044, "Member 'APlayerCharacter::MaxRunSpeedPercent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MaxCrouchRunSpeedPercent) == 0x002048, "Member 'APlayerCharacter::MaxCrouchRunSpeedPercent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MinWalkSpeedPercent) == 0x00204C, "Member 'APlayerCharacter::MinWalkSpeedPercent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastSetRunSpeed) == 0x002060, "Member 'APlayerCharacter::LastSetRunSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WalkSpeedMultiplier) == 0x002064, "Member 'APlayerCharacter::WalkSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DeployableWalkSpeedMultiplier) == 0x002068, "Member 'APlayerCharacter::DeployableWalkSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bHoldingFastWalk) == 0x00206C, "Member 'APlayerCharacter::bHoldingFastWalk' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bHoldingSprint) == 0x00206D, "Member 'APlayerCharacter::bHoldingSprint' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bWalking) == 0x00207D, "Member 'APlayerCharacter::bWalking' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bAllowPlacement) == 0x00207E, "Member 'APlayerCharacter::bAllowPlacement' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MeshspaceInterp) == 0x0020D4, "Member 'APlayerCharacter::MeshspaceInterp' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, VelocityCameraRollMultiplier) == 0x0020D8, "Member 'APlayerCharacter::VelocityCameraRollMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PendingRecoil) == 0x0020DC, "Member 'APlayerCharacter::PendingRecoil' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RecoilSpeed) == 0x0020F4, "Member 'APlayerCharacter::RecoilSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Last1PMontage) == 0x002100, "Member 'APlayerCharacter::Last1PMontage' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PlayedTableMontageMap1P) == 0x002108, "Member 'APlayerCharacter::PlayedTableMontageMap1P' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, JumpStartSound) == 0x002160, "Member 'APlayerCharacter::JumpStartSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, JumpLandSound) == 0x002168, "Member 'APlayerCharacter::JumpLandSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, InMix) == 0x002170, "Member 'APlayerCharacter::InMix' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OutMix) == 0x002178, "Member 'APlayerCharacter::OutMix' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bOutMixPlaying) == 0x002180, "Member 'APlayerCharacter::bOutMixPlaying' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, InjuredScreamPVP) == 0x002188, "Member 'APlayerCharacter::InjuredScreamPVP' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DeathScreamPVP) == 0x002198, "Member 'APlayerCharacter::DeathScreamPVP' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, InjuredScreamComponent) == 0x0021A0, "Member 'APlayerCharacter::InjuredScreamComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MovementRequiredPerSound) == 0x0021AC, "Member 'APlayerCharacter::MovementRequiredPerSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RotationRequiredPerSound) == 0x0021B0, "Member 'APlayerCharacter::RotationRequiredPerSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, NegativeVelocityRequiredForLandingSound) == 0x0021B4, "Member 'APlayerCharacter::NegativeVelocityRequiredForLandingSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WalkSounds) == 0x0021D8, "Member 'APlayerCharacter::WalkSounds' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WalkSounds_Environmental) == 0x0021E8, "Member 'APlayerCharacter::WalkSounds_Environmental' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RunSounds) == 0x002210, "Member 'APlayerCharacter::RunSounds' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RunSounds_Environmental) == 0x002220, "Member 'APlayerCharacter::RunSounds_Environmental' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TurningSounds) == 0x002248, "Member 'APlayerCharacter::TurningSounds' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LandingSounds) == 0x002258, "Member 'APlayerCharacter::LandingSounds' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HitDirectionForward) == 0x002278, "Member 'APlayerCharacter::HitDirectionForward' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HitDirectionRight) == 0x00227C, "Member 'APlayerCharacter::HitDirectionRight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BreathingBaseEvent) == 0x002290, "Member 'APlayerCharacter::BreathingBaseEvent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ExhaustionLevel) == 0x002298, "Member 'APlayerCharacter::ExhaustionLevel' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ExhaustionDissipationRate) == 0x00229C, "Member 'APlayerCharacter::ExhaustionDissipationRate' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ExhaustionIncreaseRate) == 0x0022A0, "Member 'APlayerCharacter::ExhaustionIncreaseRate' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ExhaustionThreshold) == 0x0022A4, "Member 'APlayerCharacter::ExhaustionThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FearLevel) == 0x0022A8, "Member 'APlayerCharacter::FearLevel' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FearDissipationRate) == 0x0022B0, "Member 'APlayerCharacter::FearDissipationRate' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FearSuppressionScale) == 0x0022B4, "Member 'APlayerCharacter::FearSuppressionScale' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FearThreshold) == 0x0022B8, "Member 'APlayerCharacter::FearThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsSightTweakMode) == 0x0022BC, "Member 'APlayerCharacter::bIsSightTweakMode' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SightTweakerWidgetTemplate) == 0x0022C0, "Member 'APlayerCharacter::SightTweakerWidgetTemplate' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SightTweakerOverlay) == 0x0022C8, "Member 'APlayerCharacter::SightTweakerOverlay' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SightTweakerPosOffset) == 0x0022D0, "Member 'APlayerCharacter::SightTweakerPosOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SightTweakerRotOffset) == 0x0022DC, "Member 'APlayerCharacter::SightTweakerRotOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpawnProtectionTime) == 0x0022F8, "Member 'APlayerCharacter::SpawnProtectionTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsThirdPerson) == 0x0022FC, "Member 'APlayerCharacter::bIsThirdPerson' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Server_BaseAimRotation) == 0x002300, "Member 'APlayerCharacter::Server_BaseAimRotation' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FreeAimCache) == 0x00230C, "Member 'APlayerCharacter::FreeAimCache' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, IsPlayingInteraction) == 0x002320, "Member 'APlayerCharacter::IsPlayingInteraction' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsStopping) == 0x002370, "Member 'APlayerCharacter::bIsStopping' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LadderPlacementZone) == 0x002378, "Member 'APlayerCharacter::LadderPlacementZone' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MoveForwardInput) == 0x00238C, "Member 'APlayerCharacter::MoveForwardInput' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MoveRightInput) == 0x002390, "Member 'APlayerCharacter::MoveRightInput' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LeftFootSocketName) == 0x0023AC, "Member 'APlayerCharacter::LeftFootSocketName' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RighttFootSocketName) == 0x0023B4, "Member 'APlayerCharacter::RighttFootSocketName' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LeftFootEnum) == 0x0023BC, "Member 'APlayerCharacter::LeftFootEnum' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RightFootEnum) == 0x0023BD, "Member 'APlayerCharacter::RightFootEnum' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FootAdjustOffset) == 0x0023C0, "Member 'APlayerCharacter::FootAdjustOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FootInterpSpeed) == 0x0023C4, "Member 'APlayerCharacter::FootInterpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FootRotationInterpSpeed) == 0x0023C8, "Member 'APlayerCharacter::FootRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HipInterpSpeed) == 0x0023CC, "Member 'APlayerCharacter::HipInterpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TraceDistance) == 0x0023D0, "Member 'APlayerCharacter::TraceDistance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TraceOffset) == 0x0023D4, "Member 'APlayerCharacter::TraceOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, VelocityThreshold) == 0x0023D8, "Member 'APlayerCharacter::VelocityThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedBubbleAmount) == 0x0023DC, "Member 'APlayerCharacter::SpeedBubbleAmount' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentMeshRot) == 0x0023E0, "Member 'APlayerCharacter::CurrentMeshRot' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIgnoreRotationOverride) == 0x0023EE, "Member 'APlayerCharacter::bIgnoreRotationOverride' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CameraBobTrans) == 0x002404, "Member 'APlayerCharacter::CameraBobTrans' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WeaponBobTrans) == 0x002410, "Member 'APlayerCharacter::WeaponBobTrans' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WeaponBobRot) == 0x00241C, "Member 'APlayerCharacter::WeaponBobRot' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CameraBobRot) == 0x002428, "Member 'APlayerCharacter::CameraBobRot' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsSecondarySightActive) == 0x002434, "Member 'APlayerCharacter::bIsSecondarySightActive' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnCantedSightToggled) == 0x002438, "Member 'APlayerCharacter::OnCantedSightToggled' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnSecondarySightToggled) == 0x002458, "Member 'APlayerCharacter::OnSecondarySightToggled' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsPelvisFPMovementBobActive) == 0x002468, "Member 'APlayerCharacter::bIsPelvisFPMovementBobActive' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PelvisFPMovementDamping) == 0x00246C, "Member 'APlayerCharacter::PelvisFPMovementDamping' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bCopyTPMeshTransformsToFP) == 0x002470, "Member 'APlayerCharacter::bCopyTPMeshTransformsToFP' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ScoreboardWidget) == 0x002490, "Member 'APlayerCharacter::ScoreboardWidget' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CommandInterface) == 0x0024A0, "Member 'APlayerCharacter::CommandInterface' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bItemWheelActive) == 0x0024B8, "Member 'APlayerCharacter::bItemWheelActive' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bCommandWheelActive) == 0x0024C8, "Member 'APlayerCharacter::bCommandWheelActive' has a wrong offset!");

// Class ReadyOrNot.PlayerEffect_ModifyRecoil
// 0x00B0 (0x0110 - 0x0060)
class UPlayerEffect_ModifyRecoil : public UBasePlayerEffect
{
public:
	ERecoilModifierOption                         ModificationOption;                                // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27EB[0x7];                                     // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EItemClass>                            WeaponFilter;                                      // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         RecoilFireStrength;                                // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilFireStrengthFirst;                           // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilDampStrength;                                // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilAngleStrength;                               // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilRandomness;                                  // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilFireADSModifier;                             // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilBuildupADSModifier;                          // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilAngleADSModifier;                            // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilBuildupDampStrength;                         // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bApplySpecific : 1;                                // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_27EC[0x3];                                     // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpecificWeaponRecoilMod>       SpecificWeaponRecoilMods;                          // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class ABaseMagazineWeapon*, struct FSpecificWeaponRecoilMod> OriginalRecoilValues;                              // 0x00B0(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class ABaseMagazineWeapon*>            AffectedWeapons;                                   // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerEffect_ModifyRecoil">();
	}
	static class UPlayerEffect_ModifyRecoil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerEffect_ModifyRecoil>();
	}
};
static_assert(alignof(UPlayerEffect_ModifyRecoil) == 0x000008, "Wrong alignment on UPlayerEffect_ModifyRecoil");
static_assert(sizeof(UPlayerEffect_ModifyRecoil) == 0x000110, "Wrong size on UPlayerEffect_ModifyRecoil");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, ModificationOption) == 0x000060, "Member 'UPlayerEffect_ModifyRecoil::ModificationOption' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, WeaponFilter) == 0x000068, "Member 'UPlayerEffect_ModifyRecoil::WeaponFilter' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilFireStrength) == 0x000078, "Member 'UPlayerEffect_ModifyRecoil::RecoilFireStrength' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilFireStrengthFirst) == 0x00007C, "Member 'UPlayerEffect_ModifyRecoil::RecoilFireStrengthFirst' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilDampStrength) == 0x000080, "Member 'UPlayerEffect_ModifyRecoil::RecoilDampStrength' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilAngleStrength) == 0x000084, "Member 'UPlayerEffect_ModifyRecoil::RecoilAngleStrength' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilRandomness) == 0x000088, "Member 'UPlayerEffect_ModifyRecoil::RecoilRandomness' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilFireADSModifier) == 0x00008C, "Member 'UPlayerEffect_ModifyRecoil::RecoilFireADSModifier' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilBuildupADSModifier) == 0x000090, "Member 'UPlayerEffect_ModifyRecoil::RecoilBuildupADSModifier' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilAngleADSModifier) == 0x000094, "Member 'UPlayerEffect_ModifyRecoil::RecoilAngleADSModifier' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilBuildupDampStrength) == 0x000098, "Member 'UPlayerEffect_ModifyRecoil::RecoilBuildupDampStrength' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, SpecificWeaponRecoilMods) == 0x0000A0, "Member 'UPlayerEffect_ModifyRecoil::SpecificWeaponRecoilMods' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, OriginalRecoilValues) == 0x0000B0, "Member 'UPlayerEffect_ModifyRecoil::OriginalRecoilValues' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, AffectedWeapons) == 0x000100, "Member 'UPlayerEffect_ModifyRecoil::AffectedWeapons' has a wrong offset!");

// Class ReadyOrNot.PlayerHealthStatusWidget
// 0x0020 (0x0280 - 0x0260)
class UPlayerHealthStatusWidget final  : public UUserWidget
{
public:
	class UHealthStatusWidget*                    Health;                                            // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHealthStatusWidget*                    Armor;                                             // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHealthStatusWidget*                    Helmet;                                            // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0278(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerHealthStatusWidget">();
	}
	static class UPlayerHealthStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerHealthStatusWidget>();
	}
};
static_assert(alignof(UPlayerHealthStatusWidget) == 0x000008, "Wrong alignment on UPlayerHealthStatusWidget");
static_assert(sizeof(UPlayerHealthStatusWidget) == 0x000280, "Wrong size on UPlayerHealthStatusWidget");
static_assert(offsetof(UPlayerHealthStatusWidget, Health) == 0x000260, "Member 'UPlayerHealthStatusWidget::Health' has a wrong offset!");
static_assert(offsetof(UPlayerHealthStatusWidget, Armor) == 0x000268, "Member 'UPlayerHealthStatusWidget::Armor' has a wrong offset!");
static_assert(offsetof(UPlayerHealthStatusWidget, Helmet) == 0x000270, "Member 'UPlayerHealthStatusWidget::Helmet' has a wrong offset!");
static_assert(offsetof(UPlayerHealthStatusWidget, PlayerCharacter) == 0x000278, "Member 'UPlayerHealthStatusWidget::PlayerCharacter' has a wrong offset!");

// Class ReadyOrNot.PlayerHUD
// 0x0008 (0x0318 - 0x0310)
class APlayerHUD final  : public AHUD
{
public:
	class UUserWidget*                            PlayerHUD;                                         // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static void SetCanvasTranslationByMouseDelta(class APlayerController* Controller, class UCanvasPanel* Widget, float DeltaSeconds, float InterpSpeed, float InputScale, float ClampAt);
	static void SetWidgetTranslationByMouseDelta(class APlayerController* Controller, class UUserWidget* Widget, float DeltaSeconds, float InterpSpeed, float InputScale, float ClampAt);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerHUD">();
	}
	static class APlayerHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerHUD>();
	}
};
static_assert(alignof(APlayerHUD) == 0x000008, "Wrong alignment on APlayerHUD");
static_assert(sizeof(APlayerHUD) == 0x000318, "Wrong size on APlayerHUD");
static_assert(offsetof(APlayerHUD, PlayerHUD) == 0x000310, "Member 'APlayerHUD::PlayerHUD' has a wrong offset!");

// Class ReadyOrNot.PlayerPaperdollWidget
// 0x0148 (0x03A8 - 0x0260)
class UPlayerPaperdollWidget : public UUserWidget
{
public:
	class UWidgetSwitcher*                        StanceSwitcher;                                    // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        Stand_CarrySwitcher;                               // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        Crouch_CarrySwitcher;                              // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Stand_Overlay;                                     // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Crouch_Overlay;                                    // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               StandCarry_Overlay;                                // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               StandNoCarry_Overlay;                              // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               CrouchCarry_Overlay;                               // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               CrouchNoCarry_Overlay;                             // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Outline_Image;                                     // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Head_Image;                                        // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Body_Image;                                        // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RightArm_Image;                                    // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LeftArm_Image;                                     // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RightLeg_Image;                                    // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LeftLeg_Image;                                     // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Headwear_Image;                                    // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BodyArmor_Image;                                   // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_Outline_Image;                               // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_Head_Image;                                  // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_Body_Image;                                  // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_RightArm_Image;                              // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_LeftArm_Image;                               // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_BodyArmor_Image;                             // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Outline_Crouch_Image;                              // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Head_Crouch_Image;                                 // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Body_Crouch_Image;                                 // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RightArm_Crouch_Image;                             // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LeftArm_Crouch_Image;                              // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RightLeg_Crouch_Image;                             // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LeftLeg_Crouch_Image;                              // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Headwear_Crouch_Image;                             // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BodyArmor_Crouch_Image;                            // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_Outline_Crouch_Image;                        // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_Head_Crouch_Image;                           // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_Body_Crouch_Image;                           // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_RightArm_Crouch_Image;                       // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_LeftArm_Crouch_Image;                        // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_RightLeg_Crouch_Image;                       // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_LeftLeg_Crouch_Image;                        // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_BodyArmor_Crouch_Image;                      // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateHealth(class ABaseItem* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerPaperdollWidget">();
	}
	static class UPlayerPaperdollWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerPaperdollWidget>();
	}
};
static_assert(alignof(UPlayerPaperdollWidget) == 0x000008, "Wrong alignment on UPlayerPaperdollWidget");
static_assert(sizeof(UPlayerPaperdollWidget) == 0x0003A8, "Wrong size on UPlayerPaperdollWidget");
static_assert(offsetof(UPlayerPaperdollWidget, StanceSwitcher) == 0x000260, "Member 'UPlayerPaperdollWidget::StanceSwitcher' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Stand_CarrySwitcher) == 0x000268, "Member 'UPlayerPaperdollWidget::Stand_CarrySwitcher' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Crouch_CarrySwitcher) == 0x000270, "Member 'UPlayerPaperdollWidget::Crouch_CarrySwitcher' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Stand_Overlay) == 0x000278, "Member 'UPlayerPaperdollWidget::Stand_Overlay' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Crouch_Overlay) == 0x000280, "Member 'UPlayerPaperdollWidget::Crouch_Overlay' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, StandCarry_Overlay) == 0x000288, "Member 'UPlayerPaperdollWidget::StandCarry_Overlay' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, StandNoCarry_Overlay) == 0x000290, "Member 'UPlayerPaperdollWidget::StandNoCarry_Overlay' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, CrouchCarry_Overlay) == 0x000298, "Member 'UPlayerPaperdollWidget::CrouchCarry_Overlay' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, CrouchNoCarry_Overlay) == 0x0002A0, "Member 'UPlayerPaperdollWidget::CrouchNoCarry_Overlay' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Outline_Image) == 0x0002A8, "Member 'UPlayerPaperdollWidget::Outline_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Head_Image) == 0x0002B0, "Member 'UPlayerPaperdollWidget::Head_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Body_Image) == 0x0002B8, "Member 'UPlayerPaperdollWidget::Body_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, RightArm_Image) == 0x0002C0, "Member 'UPlayerPaperdollWidget::RightArm_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, LeftArm_Image) == 0x0002C8, "Member 'UPlayerPaperdollWidget::LeftArm_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, RightLeg_Image) == 0x0002D0, "Member 'UPlayerPaperdollWidget::RightLeg_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, LeftLeg_Image) == 0x0002D8, "Member 'UPlayerPaperdollWidget::LeftLeg_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Headwear_Image) == 0x0002E0, "Member 'UPlayerPaperdollWidget::Headwear_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, BodyArmor_Image) == 0x0002E8, "Member 'UPlayerPaperdollWidget::BodyArmor_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_Outline_Image) == 0x0002F0, "Member 'UPlayerPaperdollWidget::Carry_Outline_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_Head_Image) == 0x0002F8, "Member 'UPlayerPaperdollWidget::Carry_Head_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_Body_Image) == 0x000300, "Member 'UPlayerPaperdollWidget::Carry_Body_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_RightArm_Image) == 0x000308, "Member 'UPlayerPaperdollWidget::Carry_RightArm_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_LeftArm_Image) == 0x000310, "Member 'UPlayerPaperdollWidget::Carry_LeftArm_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_BodyArmor_Image) == 0x000318, "Member 'UPlayerPaperdollWidget::Carry_BodyArmor_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Outline_Crouch_Image) == 0x000320, "Member 'UPlayerPaperdollWidget::Outline_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Head_Crouch_Image) == 0x000328, "Member 'UPlayerPaperdollWidget::Head_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Body_Crouch_Image) == 0x000330, "Member 'UPlayerPaperdollWidget::Body_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, RightArm_Crouch_Image) == 0x000338, "Member 'UPlayerPaperdollWidget::RightArm_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, LeftArm_Crouch_Image) == 0x000340, "Member 'UPlayerPaperdollWidget::LeftArm_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, RightLeg_Crouch_Image) == 0x000348, "Member 'UPlayerPaperdollWidget::RightLeg_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, LeftLeg_Crouch_Image) == 0x000350, "Member 'UPlayerPaperdollWidget::LeftLeg_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Headwear_Crouch_Image) == 0x000358, "Member 'UPlayerPaperdollWidget::Headwear_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, BodyArmor_Crouch_Image) == 0x000360, "Member 'UPlayerPaperdollWidget::BodyArmor_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_Outline_Crouch_Image) == 0x000368, "Member 'UPlayerPaperdollWidget::Carry_Outline_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_Head_Crouch_Image) == 0x000370, "Member 'UPlayerPaperdollWidget::Carry_Head_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_Body_Crouch_Image) == 0x000378, "Member 'UPlayerPaperdollWidget::Carry_Body_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_RightArm_Crouch_Image) == 0x000380, "Member 'UPlayerPaperdollWidget::Carry_RightArm_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_LeftArm_Crouch_Image) == 0x000388, "Member 'UPlayerPaperdollWidget::Carry_LeftArm_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_RightLeg_Crouch_Image) == 0x000390, "Member 'UPlayerPaperdollWidget::Carry_RightLeg_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_LeftLeg_Crouch_Image) == 0x000398, "Member 'UPlayerPaperdollWidget::Carry_LeftLeg_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_BodyArmor_Crouch_Image) == 0x0003A0, "Member 'UPlayerPaperdollWidget::Carry_BodyArmor_Crouch_Image' has a wrong offset!");

// Class ReadyOrNot.PlayerPostProcessing
// 0x0670 (0x0DE0 - 0x0770)
class UPlayerPostProcessing final  : public UPostProcessComponent
{
public:
	TArray<class UPostProcessEffectData*>         DebugPPEffects;                                    // 0x0770(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       DebugPPEffects_MIDs;                               // 0x0780(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_27ED[0x38];                                    // 0x0790(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPostProcessEffect>             PostProcessEffects;                                // 0x07C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_27EE[0x18];                                    // 0x07D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             DevPostProcessMaterials;                           // 0x07F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FNVGPostProcessSettings                NVG_Settings;                                      // 0x0800(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_27EF[0x568];                                   // 0x0858(0x0568)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       OwningCharacter;                                   // 0x0DC0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 RecentDamageCauser;                                // 0x0DC8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27F0[0x10];                                    // 0x0DD0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeToGrey();
	bool FulfillsAllRequirements(TArray<TSubclassOf<class UPostProcessRequirement>>& InRequirementClasses, class AActor* InDamageCauser, bool bForceFulfillment);
	int32 GetPostProcessFromFloatParam(struct FPostProcessEffect& InPostProcessEffect, class FName& InParameterName, int32 Instance);
	int32 InitializePostProcessFloatParam(struct FPostProcessEffect& InPostProcessEffect, class FName& InParameterName, float Value, int32 Instance, int32 CurveKey);
	void OnBulletImpact(float DirectionForward, float DirectionRight);
	void OnDamageTaken(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnDamageTakenDetails(bool bWasHeadshot, float DamageTaken, float HealthRemaining, bool bBlockedByArmour, bool bBlockedByHelmet);
	void OnFire();
	void OnItemEquipped(class ABaseItem* Item);
	void OnItemHolstered(class ABaseItem* Item);
	void OnPlayerKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnPlayerPepperSprayed(class AActor* DamageCauser);
	void OnPlayerStunned(class AReadyOrNotCharacter* Character, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnSupression(float Strength);
	void PlayPostProcessEffect_Name(class FName EffectName, class AActor* DamageCauser);
	void ProcessPostProcessEffect(struct FPostProcessEffect* InPostProcessEffect, float DeltaTime);
	void ResetInjuryRadialBlur(float DeltaTime);
	void StartBleedingEffect();
	void StartDeathEffect(class AActor* DamageCauser);
	void StartFlashbangEffect(class AActor* DamageCauser);
	void StartGasEffect(class AActor* DamageCauser);
	void StartHealingEffect();
	void StartHeartbeatEffect();
	void StartInjuryEffects(class AActor* DamageCauser);
	void StartPeppersprayEffect(class AActor* DamageCauser);
	void StartPostProcessEffect(struct FPostProcessEffect* InPostProcessEffect, class AActor* DamageCauser);
	void StartPostProcessEffect_FromDataAsset(class UPostProcessEffectData* InPostProcessEffectData, class AActor* DamageCauser);
	void StartPostProcessEffect_Specific(struct FPostProcessEffectPlayer* InPostProcessSetting, class AActor* DamageCauser);
	void StartStingerEffect(class AActor* DamageCauser);
	void StartSuppressionEffects(class AActor* DamageCauser);
	void StartTaserEffect(class AActor* DamageCauser);
	void StopBleedingEffect();
	void StopDeathEffect();
	void StopFlashbangEffect();
	void StopGasEffect();
	void StopHealingEffect();
	void StopHeartbeatEffect();
	void StopInjuryEffects();
	void StopPeppersprayEffect();
	void StopPostProcessEffect(struct FPostProcessEffect* InPostProcessEffect);
	void StopPostProcessEffect_FromDataAsset(class UPostProcessEffectData* InPostProcessEffectData);
	void StopPostProcessEffect_Name(class FName EffectName);
	void StopStingerEffect();
	void StopSuppressionEffects();
	void StopTaserEffect();
	void UpdateWeaponHighlightVisibility();

	bool IsPostProcessEffectPlaying(class UPostProcessEffectData* InPostProcessEffectData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerPostProcessing">();
	}
	static class UPlayerPostProcessing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerPostProcessing>();
	}
};
static_assert(alignof(UPlayerPostProcessing) == 0x000010, "Wrong alignment on UPlayerPostProcessing");
static_assert(sizeof(UPlayerPostProcessing) == 0x000DE0, "Wrong size on UPlayerPostProcessing");
static_assert(offsetof(UPlayerPostProcessing, DebugPPEffects) == 0x000770, "Member 'UPlayerPostProcessing::DebugPPEffects' has a wrong offset!");
static_assert(offsetof(UPlayerPostProcessing, DebugPPEffects_MIDs) == 0x000780, "Member 'UPlayerPostProcessing::DebugPPEffects_MIDs' has a wrong offset!");
static_assert(offsetof(UPlayerPostProcessing, PostProcessEffects) == 0x0007C8, "Member 'UPlayerPostProcessing::PostProcessEffects' has a wrong offset!");
static_assert(offsetof(UPlayerPostProcessing, DevPostProcessMaterials) == 0x0007F0, "Member 'UPlayerPostProcessing::DevPostProcessMaterials' has a wrong offset!");
static_assert(offsetof(UPlayerPostProcessing, NVG_Settings) == 0x000800, "Member 'UPlayerPostProcessing::NVG_Settings' has a wrong offset!");
static_assert(offsetof(UPlayerPostProcessing, OwningCharacter) == 0x000DC0, "Member 'UPlayerPostProcessing::OwningCharacter' has a wrong offset!");
static_assert(offsetof(UPlayerPostProcessing, RecentDamageCauser) == 0x000DC8, "Member 'UPlayerPostProcessing::RecentDamageCauser' has a wrong offset!");

// Class ReadyOrNot.PlayerReferendum
// 0x0008 (0x02B0 - 0x02A8)
class APlayerReferendum final  : public AReferendum
{
public:
	class AReadyOrNotPlayerState*                 TargetPlayerState;                                 // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerReferendum">();
	}
	static class APlayerReferendum* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerReferendum>();
	}
};
static_assert(alignof(APlayerReferendum) == 0x000008, "Wrong alignment on APlayerReferendum");
static_assert(sizeof(APlayerReferendum) == 0x0002B0, "Wrong size on APlayerReferendum");
static_assert(offsetof(APlayerReferendum, TargetPlayerState) == 0x0002A8, "Member 'APlayerReferendum::TargetPlayerState' has a wrong offset!");

// Class ReadyOrNot.PlayerViewActor
// 0x00C0 (0x02E0 - 0x0220)
class APlayerViewActor : public AActor
{
public:
	uint8                                         bShouldCaptureScene : 1;                           // 0x0220(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_27F7[0x7];                                     // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               CameraCaptureComponent;                            // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPostProcessEffect                     SwitchViewEffects;                                 // 0x0238(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UFMODEvent*                             SwitchViewEvent;                                   // 0x0260(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathViewTime;                                     // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27F8[0x4];                                     // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             DeathViewEvent;                                    // 0x0270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             CloseViewEvent;                                    // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 CameraRenderTarget;                                // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       OwningPlayerCharacter;                             // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   ViewCharacter;                                     // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x0298(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               TargetRotation;                                    // 0x02A4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      MI_PostProcess_Greyscale;                          // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      MI_PostProcess_Bump;                               // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      MI_PostProcess_Glitch;                             // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDeathEffectsApplied : 1;                          // 0x02C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSwitchViewEffectsApplied : 1;                     // 0x02C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_27F9[0x17];                                    // 0x02C9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOwningPlayer(class APlayerCharacter* NewOwnerCharacter);
	void SetViewPlayer(class AReadyOrNotCharacter* NewViewCharacter);
	void TryNextView(bool bRequestClose, bool bIncludeDeadViews);
	void UpdateViewTarget(struct FVector& NewLocation, struct FRotator& NewRotation);

	void ClearHiddenComponents() const;
	void HideActor(class AActor* ActorToHide, bool bIncludeChildActors) const;
	void HideComponent(class UPrimitiveComponent* ComponentToHide) const;
	bool IsSwitchingView() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerViewActor">();
	}
	static class APlayerViewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerViewActor>();
	}
};
static_assert(alignof(APlayerViewActor) == 0x000008, "Wrong alignment on APlayerViewActor");
static_assert(sizeof(APlayerViewActor) == 0x0002E0, "Wrong size on APlayerViewActor");
static_assert(offsetof(APlayerViewActor, SceneComponent) == 0x000228, "Member 'APlayerViewActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, CameraCaptureComponent) == 0x000230, "Member 'APlayerViewActor::CameraCaptureComponent' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, SwitchViewEffects) == 0x000238, "Member 'APlayerViewActor::SwitchViewEffects' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, SwitchViewEvent) == 0x000260, "Member 'APlayerViewActor::SwitchViewEvent' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, DeathViewTime) == 0x000268, "Member 'APlayerViewActor::DeathViewTime' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, DeathViewEvent) == 0x000270, "Member 'APlayerViewActor::DeathViewEvent' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, CloseViewEvent) == 0x000278, "Member 'APlayerViewActor::CloseViewEvent' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, CameraRenderTarget) == 0x000280, "Member 'APlayerViewActor::CameraRenderTarget' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, OwningPlayerCharacter) == 0x000288, "Member 'APlayerViewActor::OwningPlayerCharacter' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, ViewCharacter) == 0x000290, "Member 'APlayerViewActor::ViewCharacter' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, TargetLocation) == 0x000298, "Member 'APlayerViewActor::TargetLocation' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, TargetRotation) == 0x0002A4, "Member 'APlayerViewActor::TargetRotation' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, MI_PostProcess_Greyscale) == 0x0002B0, "Member 'APlayerViewActor::MI_PostProcess_Greyscale' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, MI_PostProcess_Bump) == 0x0002B8, "Member 'APlayerViewActor::MI_PostProcess_Bump' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, MI_PostProcess_Glitch) == 0x0002C0, "Member 'APlayerViewActor::MI_PostProcess_Glitch' has a wrong offset!");

// Class ReadyOrNot.PolicePresenceTestActor
// 0x0018 (0x0238 - 0x0220)
class APolicePresenceTestActor final  : public AActor
{
public:
	class USceneComponent*                        Scene;                                             // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBillboardComponent*                    Police;                                            // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBillboardComponent*                    Suspect;                                           // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PolicePresenceTestActor">();
	}
	static class APolicePresenceTestActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APolicePresenceTestActor>();
	}
};
static_assert(alignof(APolicePresenceTestActor) == 0x000008, "Wrong alignment on APolicePresenceTestActor");
static_assert(sizeof(APolicePresenceTestActor) == 0x000238, "Wrong size on APolicePresenceTestActor");
static_assert(offsetof(APolicePresenceTestActor, Scene) == 0x000220, "Member 'APolicePresenceTestActor::Scene' has a wrong offset!");
static_assert(offsetof(APolicePresenceTestActor, Police) == 0x000228, "Member 'APolicePresenceTestActor::Police' has a wrong offset!");
static_assert(offsetof(APolicePresenceTestActor, Suspect) == 0x000230, "Member 'APolicePresenceTestActor::Suspect' has a wrong offset!");

// Class ReadyOrNot.PopupTarget
// 0x0028 (0x0248 - 0x0220)
class APopupTarget final  : public AActor
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxHealth;                                         // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PopupTime;                                         // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Health;                                            // 0x0230(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27FB[0xC];                                     // 0x0234(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFallDown;                                         // 0x0240(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27FC[0x7];                                     // 0x0241(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsAlive();
	void Popup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupTarget">();
	}
	static class APopupTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<APopupTarget>();
	}
};
static_assert(alignof(APopupTarget) == 0x000008, "Wrong alignment on APopupTarget");
static_assert(sizeof(APopupTarget) == 0x000248, "Wrong size on APopupTarget");
static_assert(offsetof(APopupTarget, Mesh) == 0x000220, "Member 'APopupTarget::Mesh' has a wrong offset!");
static_assert(offsetof(APopupTarget, MaxHealth) == 0x000228, "Member 'APopupTarget::MaxHealth' has a wrong offset!");
static_assert(offsetof(APopupTarget, PopupTime) == 0x00022C, "Member 'APopupTarget::PopupTime' has a wrong offset!");
static_assert(offsetof(APopupTarget, Health) == 0x000230, "Member 'APopupTarget::Health' has a wrong offset!");
static_assert(offsetof(APopupTarget, bFallDown) == 0x000240, "Member 'APopupTarget::bFallDown' has a wrong offset!");

// Class ReadyOrNot.PortalVolume
// 0x0070 (0x02C8 - 0x0258)
class APortalVolume final  : public AVolume
{
public:
	bool                                          bIsOutside;                                        // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPortalType                                   PortalType;                                        // 0x0259(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27FD[0x6];                                     // 0x025A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         OverlappingActors;                                 // 0x0260(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          AttachedObjects;                                   // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          Doors;                                             // 0x0280(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  BreakableGlass_SoftPointer;                        // 0x0290(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ABreakableGlass*>                BreakableGlasses;                                  // 0x02B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PortalVolume">();
	}
	static class APortalVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APortalVolume>();
	}
};
static_assert(alignof(APortalVolume) == 0x000008, "Wrong alignment on APortalVolume");
static_assert(sizeof(APortalVolume) == 0x0002C8, "Wrong size on APortalVolume");
static_assert(offsetof(APortalVolume, bIsOutside) == 0x000258, "Member 'APortalVolume::bIsOutside' has a wrong offset!");
static_assert(offsetof(APortalVolume, PortalType) == 0x000259, "Member 'APortalVolume::PortalType' has a wrong offset!");
static_assert(offsetof(APortalVolume, OverlappingActors) == 0x000260, "Member 'APortalVolume::OverlappingActors' has a wrong offset!");
static_assert(offsetof(APortalVolume, AttachedObjects) == 0x000270, "Member 'APortalVolume::AttachedObjects' has a wrong offset!");
static_assert(offsetof(APortalVolume, Doors) == 0x000280, "Member 'APortalVolume::Doors' has a wrong offset!");
static_assert(offsetof(APortalVolume, BreakableGlass_SoftPointer) == 0x000290, "Member 'APortalVolume::BreakableGlass_SoftPointer' has a wrong offset!");
static_assert(offsetof(APortalVolume, BreakableGlasses) == 0x0002B8, "Member 'APortalVolume::BreakableGlasses' has a wrong offset!");

// Class ReadyOrNot.PostProcessEffectData
// 0x03F8 (0x0428 - 0x0030)
class UPostProcessEffectData final  : public UDataAsset
{
public:
	class UMaterialInterface*                     PostProcess_Material;                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPostProcessSetting_FloatParam> ScalarParameters;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPostProcessSetting_VectorParam> VectorParameters;                                  // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bDebug : 1;                                        // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_27FE[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Note;                                              // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_27FF[0x3B0];                                   // 0x0078(0x03B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessEffectData">();
	}
	static class UPostProcessEffectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPostProcessEffectData>();
	}
};
static_assert(alignof(UPostProcessEffectData) == 0x000008, "Wrong alignment on UPostProcessEffectData");
static_assert(sizeof(UPostProcessEffectData) == 0x000428, "Wrong size on UPostProcessEffectData");
static_assert(offsetof(UPostProcessEffectData, PostProcess_Material) == 0x000030, "Member 'UPostProcessEffectData::PostProcess_Material' has a wrong offset!");
static_assert(offsetof(UPostProcessEffectData, ScalarParameters) == 0x000038, "Member 'UPostProcessEffectData::ScalarParameters' has a wrong offset!");
static_assert(offsetof(UPostProcessEffectData, VectorParameters) == 0x000048, "Member 'UPostProcessEffectData::VectorParameters' has a wrong offset!");
static_assert(offsetof(UPostProcessEffectData, Note) == 0x000060, "Member 'UPostProcessEffectData::Note' has a wrong offset!");

// Class ReadyOrNot.PostProcessRequirement
// 0x0010 (0x0038 - 0x0028)
class UPostProcessRequirement : public UObject
{
public:
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 DamageCauser;                                      // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool EnablePostProcessEffect();
	void Initialize(class APlayerCharacter* InPlayerCharacter, class AActor* InDamageCauser);

	class AActor* GetDamageCauser() const;
	class APlayerCharacter* GetPlayerCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessRequirement">();
	}
	static class UPostProcessRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPostProcessRequirement>();
	}
};
static_assert(alignof(UPostProcessRequirement) == 0x000008, "Wrong alignment on UPostProcessRequirement");
static_assert(sizeof(UPostProcessRequirement) == 0x000038, "Wrong size on UPostProcessRequirement");
static_assert(offsetof(UPostProcessRequirement, PlayerCharacter) == 0x000028, "Member 'UPostProcessRequirement::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UPostProcessRequirement, DamageCauser) == 0x000030, "Member 'UPostProcessRequirement::DamageCauser' has a wrong offset!");

// Class ReadyOrNot.PPR_IsDamageCauserOnScreen
// 0x0000 (0x0038 - 0x0038)
class UPPR_IsDamageCauserOnScreen final  : public UPostProcessRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PPR_IsDamageCauserOnScreen">();
	}
	static class UPPR_IsDamageCauserOnScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPPR_IsDamageCauserOnScreen>();
	}
};
static_assert(alignof(UPPR_IsDamageCauserOnScreen) == 0x000008, "Wrong alignment on UPPR_IsDamageCauserOnScreen");
static_assert(sizeof(UPPR_IsDamageCauserOnScreen) == 0x000038, "Wrong size on UPPR_IsDamageCauserOnScreen");

// Class ReadyOrNot.PredictionPFComponent
// 0x0038 (0x02D0 - 0x0298)
class UPredictionPFComponent final  : public UCrowdFollowingComponent
{
public:
	struct FVector                                PathStopLocation;                                  // 0x0298(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixPathToAlwaysHaveBraking;                       // 0x02A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixPathRemoveClosePoints;                         // 0x02A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2800[0x2];                                     // 0x02A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathPointRemoveDistanceThreshold;                  // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomAcceptanceRadius;                            // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2801[0x20];                                    // 0x02B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PredictionPFComponent">();
	}
	static class UPredictionPFComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPredictionPFComponent>();
	}
};
static_assert(alignof(UPredictionPFComponent) == 0x000008, "Wrong alignment on UPredictionPFComponent");
static_assert(sizeof(UPredictionPFComponent) == 0x0002D0, "Wrong size on UPredictionPFComponent");
static_assert(offsetof(UPredictionPFComponent, PathStopLocation) == 0x000298, "Member 'UPredictionPFComponent::PathStopLocation' has a wrong offset!");
static_assert(offsetof(UPredictionPFComponent, bFixPathToAlwaysHaveBraking) == 0x0002A4, "Member 'UPredictionPFComponent::bFixPathToAlwaysHaveBraking' has a wrong offset!");
static_assert(offsetof(UPredictionPFComponent, bFixPathRemoveClosePoints) == 0x0002A5, "Member 'UPredictionPFComponent::bFixPathRemoveClosePoints' has a wrong offset!");
static_assert(offsetof(UPredictionPFComponent, PathPointRemoveDistanceThreshold) == 0x0002A8, "Member 'UPredictionPFComponent::PathPointRemoveDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UPredictionPFComponent, CustomAcceptanceRadius) == 0x0002AC, "Member 'UPredictionPFComponent::CustomAcceptanceRadius' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotProfile
// 0x00B8 (0x00E0 - 0x0028)
class UReadyOrNotProfile : public USaveGame
{
public:
	class FString                                 SaveSlotName;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UserIndex;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2802[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FBasicLevelStats>  LevelStats;                                        // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      ChallengeProgress;                                 // 0x0090(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UReadyOrNotProfile* CreateDefaultSavegame(TSubclassOf<class UReadyOrNotProfile> ProfileClass, const class FString& LoadSlotName);
	static void LoadLevelStats(struct FBasicLevelStats* OutStats, ECOOPMode Mode, const class FString& MapName);
	static void SaveLevelStats(const struct FBasicLevelStats& InStats, bool* NewBestRating, bool* NewBestTime);

	void ResetProfile();
	void SaveProfile();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotProfile">();
	}
	static class UReadyOrNotProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotProfile>();
	}
};
static_assert(alignof(UReadyOrNotProfile) == 0x000008, "Wrong alignment on UReadyOrNotProfile");
static_assert(sizeof(UReadyOrNotProfile) == 0x0000E0, "Wrong size on UReadyOrNotProfile");
static_assert(offsetof(UReadyOrNotProfile, SaveSlotName) == 0x000028, "Member 'UReadyOrNotProfile::SaveSlotName' has a wrong offset!");
static_assert(offsetof(UReadyOrNotProfile, UserIndex) == 0x000038, "Member 'UReadyOrNotProfile::UserIndex' has a wrong offset!");
static_assert(offsetof(UReadyOrNotProfile, LevelStats) == 0x000040, "Member 'UReadyOrNotProfile::LevelStats' has a wrong offset!");
static_assert(offsetof(UReadyOrNotProfile, ChallengeProgress) == 0x000090, "Member 'UReadyOrNotProfile::ChallengeProgress' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotMultiplayerProfile
// 0x0000 (0x00E0 - 0x00E0)
class UReadyOrNotMultiplayerProfile final  : public UReadyOrNotProfile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotMultiplayerProfile">();
	}
	static class UReadyOrNotMultiplayerProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotMultiplayerProfile>();
	}
};
static_assert(alignof(UReadyOrNotMultiplayerProfile) == 0x000008, "Wrong alignment on UReadyOrNotMultiplayerProfile");
static_assert(sizeof(UReadyOrNotMultiplayerProfile) == 0x0000E0, "Wrong size on UReadyOrNotMultiplayerProfile");

// Class ReadyOrNot.ProgressionComponent
// 0x0010 (0x00C0 - 0x00B0)
class UProgressionComponent final  : public UActorComponent
{
public:
	uint8                                         Pad_2805[0x10];                                    // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddExperience(float XP);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressionComponent">();
	}
	static class UProgressionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProgressionComponent>();
	}
};
static_assert(alignof(UProgressionComponent) == 0x000008, "Wrong alignment on UProgressionComponent");
static_assert(sizeof(UProgressionComponent) == 0x0000C0, "Wrong size on UProgressionComponent");

// Class ReadyOrNot.LevelCompleteRequirement
// 0x0010 (0x0038 - 0x0028)
class ULevelCompleteRequirement final  : public UProgressionRequirement
{
public:
	class FName                                   RequiredLevel;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELevelGrade                                   RequiredGrade;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2806[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FName> GetLevelOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelCompleteRequirement">();
	}
	static class ULevelCompleteRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelCompleteRequirement>();
	}
};
static_assert(alignof(ULevelCompleteRequirement) == 0x000008, "Wrong alignment on ULevelCompleteRequirement");
static_assert(sizeof(ULevelCompleteRequirement) == 0x000038, "Wrong size on ULevelCompleteRequirement");
static_assert(offsetof(ULevelCompleteRequirement, RequiredLevel) == 0x000028, "Member 'ULevelCompleteRequirement::RequiredLevel' has a wrong offset!");
static_assert(offsetof(ULevelCompleteRequirement, RequiredGrade) == 0x000030, "Member 'ULevelCompleteRequirement::RequiredGrade' has a wrong offset!");

// Class ReadyOrNot.PropagationPoint
// 0x0000 (0x0220 - 0x0220)
class APropagationPoint final  : public ATargetPoint
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropagationPoint">();
	}
	static class APropagationPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<APropagationPoint>();
	}
};
static_assert(alignof(APropagationPoint) == 0x000008, "Wrong alignment on APropagationPoint");
static_assert(sizeof(APropagationPoint) == 0x000220, "Wrong size on APropagationPoint");

// Class ReadyOrNot.PropagationTestactor
// 0x0028 (0x0248 - 0x0220)
class APropagationTestactor final  : public AActor
{
public:
	float                                         TickInterval;                                      // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2807[0x4];                                     // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             Event;                                             // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugMode;                                        // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2808[0x7];                                     // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBillboardComponent*                    BillBoard;                                         // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOcclusionType                                OcclusionType;                                     // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPropagationType                              PropagationType;                                   // 0x0241(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2809[0x6];                                     // 0x0242(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropagationTestactor">();
	}
	static class APropagationTestactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APropagationTestactor>();
	}
};
static_assert(alignof(APropagationTestactor) == 0x000008, "Wrong alignment on APropagationTestactor");
static_assert(sizeof(APropagationTestactor) == 0x000248, "Wrong size on APropagationTestactor");
static_assert(offsetof(APropagationTestactor, TickInterval) == 0x000220, "Member 'APropagationTestactor::TickInterval' has a wrong offset!");
static_assert(offsetof(APropagationTestactor, Event) == 0x000228, "Member 'APropagationTestactor::Event' has a wrong offset!");
static_assert(offsetof(APropagationTestactor, bDebugMode) == 0x000230, "Member 'APropagationTestactor::bDebugMode' has a wrong offset!");
static_assert(offsetof(APropagationTestactor, BillBoard) == 0x000238, "Member 'APropagationTestactor::BillBoard' has a wrong offset!");
static_assert(offsetof(APropagationTestactor, OcclusionType) == 0x000240, "Member 'APropagationTestactor::OcclusionType' has a wrong offset!");
static_assert(offsetof(APropagationTestactor, PropagationType) == 0x000241, "Member 'APropagationTestactor::PropagationType' has a wrong offset!");

// Class ReadyOrNot.PropHuntGM
// 0x0030 (0x0800 - 0x07D0)
class APropHuntGM final  : public AReadyOrNotGameMode_PVP
{
public:
	TSubclassOf<class ACharacter>                 PropHuntCharacterClass;                            // 0x07D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotPlayerController*>    Hunters;                                           // 0x07D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotPlayerController*>    Props;                                             // 0x07E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_280A[0x8];                                     // 0x07F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropHuntGM">();
	}
	static class APropHuntGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<APropHuntGM>();
	}
};
static_assert(alignof(APropHuntGM) == 0x000010, "Wrong alignment on APropHuntGM");
static_assert(sizeof(APropHuntGM) == 0x000800, "Wrong size on APropHuntGM");
static_assert(offsetof(APropHuntGM, PropHuntCharacterClass) == 0x0007D0, "Member 'APropHuntGM::PropHuntCharacterClass' has a wrong offset!");
static_assert(offsetof(APropHuntGM, Hunters) == 0x0007D8, "Member 'APropHuntGM::Hunters' has a wrong offset!");
static_assert(offsetof(APropHuntGM, Props) == 0x0007E8, "Member 'APropHuntGM::Props' has a wrong offset!");

// Class ReadyOrNot.PropHuntGS
// 0x0010 (0x07F0 - 0x07E0)
class APropHuntGS final  : public AReadyOrNotGameState
{
public:
	TArray<class UStaticMesh*>                    AvailableProps;                                    // 0x07E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropHuntGS">();
	}
	static class APropHuntGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<APropHuntGS>();
	}
};
static_assert(alignof(APropHuntGS) == 0x000008, "Wrong alignment on APropHuntGS");
static_assert(sizeof(APropHuntGS) == 0x0007F0, "Wrong size on APropHuntGS");
static_assert(offsetof(APropHuntGS, AvailableProps) == 0x0007E0, "Member 'APropHuntGS::AvailableProps' has a wrong offset!");

// Class ReadyOrNot.PushCombatMove
// 0x0000 (0x01D8 - 0x01D8)
class UPushCombatMove final  : public UBaseCombatMoveActivity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PushCombatMove">();
	}
	static class UPushCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPushCombatMove>();
	}
};
static_assert(alignof(UPushCombatMove) == 0x000008, "Wrong alignment on UPushCombatMove");
static_assert(sizeof(UPushCombatMove) == 0x0001D8, "Wrong size on UPushCombatMove");

// Class ReadyOrNot.QuadrotorPawn
// 0x00C0 (0x0340 - 0x0280)
class AQuadrotorPawn final  : public APawn
{
public:
	class UBoxComponent*                          FlightBox;                                         // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 DroneMesh;                                         // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       FirstPersonCamera;                                 // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RPM;                                               // 0x0298(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RPMThrottleMultiplier;                             // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyingInput;                                    // 0x02A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_280B[0x3];                                     // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRPM;                                            // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleRPM;                                           // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RPMForceScale;                                     // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumTilt;                                       // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVelocity;                                       // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEngineOn;                                         // 0x02B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_280C[0x3];                                     // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotorRotation;                                     // 0x02BC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_280D[0x8];                                     // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             DroneTransform;                                    // 0x02D0(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRotation;                                    // 0x0300(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_280E[0x34];                                    // 0x030C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_DroneMovement();
	void Server_UpdateDroneTransform(const struct FTransform& NewTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuadrotorPawn">();
	}
	static class AQuadrotorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AQuadrotorPawn>();
	}
};
static_assert(alignof(AQuadrotorPawn) == 0x000010, "Wrong alignment on AQuadrotorPawn");
static_assert(sizeof(AQuadrotorPawn) == 0x000340, "Wrong size on AQuadrotorPawn");
static_assert(offsetof(AQuadrotorPawn, FlightBox) == 0x000280, "Member 'AQuadrotorPawn::FlightBox' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, DroneMesh) == 0x000288, "Member 'AQuadrotorPawn::DroneMesh' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, FirstPersonCamera) == 0x000290, "Member 'AQuadrotorPawn::FirstPersonCamera' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, RPM) == 0x000298, "Member 'AQuadrotorPawn::RPM' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, RPMThrottleMultiplier) == 0x00029C, "Member 'AQuadrotorPawn::RPMThrottleMultiplier' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, bApplyingInput) == 0x0002A0, "Member 'AQuadrotorPawn::bApplyingInput' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, MaxRPM) == 0x0002A4, "Member 'AQuadrotorPawn::MaxRPM' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, IdleRPM) == 0x0002A8, "Member 'AQuadrotorPawn::IdleRPM' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, RPMForceScale) == 0x0002AC, "Member 'AQuadrotorPawn::RPMForceScale' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, MaximumTilt) == 0x0002B0, "Member 'AQuadrotorPawn::MaximumTilt' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, MaxVelocity) == 0x0002B4, "Member 'AQuadrotorPawn::MaxVelocity' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, bEngineOn) == 0x0002B8, "Member 'AQuadrotorPawn::bEngineOn' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, RotorRotation) == 0x0002BC, "Member 'AQuadrotorPawn::RotorRotation' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, DroneTransform) == 0x0002D0, "Member 'AQuadrotorPawn::DroneTransform' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, TargetRotation) == 0x000300, "Member 'AQuadrotorPawn::TargetRotation' has a wrong offset!");

// Class ReadyOrNot.RadialSectorWidget
// 0x0018 (0x0278 - 0x0260)
class URadialSectorWidget : public UUserWidget
{
public:
	class UPanelWidget*                           SectorImagePanel;                                  // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 SectorImage;                                       // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SectorInnerRadius;                                 // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SectorOuterRadius;                                 // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool InitializeSectorWidget(float Angle, float Percentage, float InSectorInnerRadius, float InSectorOuterRadius, class UMaterialInterface* InSectorMaterial, struct FLinearColor& UnselectedColor, class UImage* InSectorImage);
	bool SetSectorColor(struct FLinearColor& NewColor, class UImage* InSectorImage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadialSectorWidget">();
	}
	static class URadialSectorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URadialSectorWidget>();
	}
};
static_assert(alignof(URadialSectorWidget) == 0x000008, "Wrong alignment on URadialSectorWidget");
static_assert(sizeof(URadialSectorWidget) == 0x000278, "Wrong size on URadialSectorWidget");
static_assert(offsetof(URadialSectorWidget, SectorImagePanel) == 0x000260, "Member 'URadialSectorWidget::SectorImagePanel' has a wrong offset!");
static_assert(offsetof(URadialSectorWidget, SectorImage) == 0x000268, "Member 'URadialSectorWidget::SectorImage' has a wrong offset!");
static_assert(offsetof(URadialSectorWidget, SectorInnerRadius) == 0x000270, "Member 'URadialSectorWidget::SectorInnerRadius' has a wrong offset!");
static_assert(offsetof(URadialSectorWidget, SectorOuterRadius) == 0x000274, "Member 'URadialSectorWidget::SectorOuterRadius' has a wrong offset!");

// Class ReadyOrNot.RadialWidgetBase
// 0x0188 (0x0400 - 0x0278)
class URadialWidgetBase : public UBaseWidget
{
public:
	FMulticastInlineDelegateProperty_             OnRadialMenuOpened_Delegate;                       // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRadialMenuClosed_Delegate;                       // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         CurrentSelectionIndex;                             // 0x0298(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreviousSelectionIndex;                            // 0x029C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Angle;                                             // 0x02A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngleSpread;                                       // 0x02A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentageWithoutGap;                              // 0x02A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentageWithGap;                                 // 0x02AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsWheelCreated : 1;                               // 0x02B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsWheelRefreshed : 1;                             // 0x02B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNavigatingWithGamepad : 1;                        // 0x02B0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2811[0x3];                                     // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RadialCursorPosition;                              // 0x02B4(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2812[0x4];                                     // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 Angles;                                            // 0x02C0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class URadialSectorWidget*>            Sectors;                                           // 0x02D0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UPanelWidget*                           RadialWheel;                                       // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RadialWheelCursor;                                 // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerController*                      OwningPlayer;                                      // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APawn*                                  OwningPawn;                                        // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       OwningPlayerCharacter;                             // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumOfSectors;                                      // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpenDelay;                                         // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloseDelay;                                        // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinWheelSize;                                      // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWheelSize;                                      // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinCursorAngle;                                    // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCursorAngle;                                    // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERadialCursorBehaviour                        RadialCursorBehaviour;                             // 0x0324(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2813[0x3];                                     // 0x0325(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URadialSectorWidget>        RadialSectorWidgetClass;                           // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAlwaysHideRadialWheelCursor : 1;                  // 0x0330(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanMoveWhileMenuIsOpened : 1;                     // 0x0330(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanPerformActionsWhileMenuIsOpened : 1;           // 0x0330(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanAimWhileMenuIsOpened : 1;                      // 0x0330(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowDebugMessages : 1;                            // 0x0330(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowMouseCursor : 1;                              // 0x0330(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2814[0x3];                                     // 0x0331(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartingSectorIndex;                               // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartingSectorAngle;                               // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IconSize;                                          // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IconPadding;                                       // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SectorInnerRadius;                                 // 0x0344(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SectorOuterRadius;                                 // 0x0348(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GapSize;                                           // 0x034C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WheelSize;                                         // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WheelCursorDistanceFromCenterWheel;                // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHideRadialWheelCursorOnMenuOpened : 1;            // 0x0358(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2815[0x3];                                     // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           SelectedColor;                                     // 0x035C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           UnselectedColor;                                   // 0x036C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           UnselectableColor;                                 // 0x037C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2816[0x4];                                     // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFont*                                  Font;                                              // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             SelectionSound;                                    // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             MenuOpenSound;                                     // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             MenuCloseSound;                                    // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             MenuCloseSound_NoSelection;                        // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URadialWidgetThemeData*                 RadialWidgetTheme;                                 // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MousePosition;                                     // 0x03C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MouseAxisDelta;                                    // 0x03C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouseWheelDelta;                                   // 0x03D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouseAngle;                                        // 0x03D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GamepadXAxis;                                      // 0x03D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GamepadYAxis;                                      // 0x03DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GamepadAngle;                                      // 0x03E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GlobalTimeDilation;                                // 0x03E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2817[0x18];                                    // 0x03E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginCloseWheel();
	void BeginOpenWheel();
	struct FVector2D CalculatePositionOnCircleFromWidget(class UPanelWidget* PanelWidget, const struct FVector2D& Origin, const struct FVector2D& InPadding, float InAngle);
	bool CloseWheel(bool bExecuteRadial, bool bRemoveFromParent, bool bHideMouseCursor, ERadialMenuCloseReason CloseReason);
	void CloseWheel_Internal(bool bExecuteRadial, bool bRemoveFromParent, bool bHideMouseCursor, ERadialMenuCloseReason CloseReason);
	bool CreateWheel();
	bool CreateWheelSector(class UPanelWidget* PanelWidget, float InAngle, float InSectorInnerRadius, float InSectorOuterRadius, class UMaterialInterface* InSectorMaterial, bool bCreateGap);
	bool Deselect(int32 Param_Index);
	bool DeselectAll();
	void DetermineInputDevice();
	bool DetermineSelectedSector(float InAngle);
	bool ExecuteRadial();
	float GetCorrectAngle();
	struct FLinearColor GetCorrectSelectionColor();
	float GetDirectionToGamepadAxis();
	float GetDirectionToMouse(const struct FVector2D& MidWidgetCoordinates);
	struct FVector2D GetPixelPositionOfWidget(class UWidget* InWidget, const struct FVector2D& InCoordinates);
	struct FVector2D GetPixelPositionOfWidgetCenter(class UWidget* InWidget);
	struct FVector2D GetViewportPositionOfWidget(class UWidget* InWidget, const struct FVector2D& InCoordinates);
	struct FVector2D GetViewportPositionOfWidgetCenter(class UWidget* InWidget);
	void HideMouseCursor();
	bool HideWheel();
	bool InitializeMenu(int32 Param_Index);
	bool InitializeMenuProperties();
	bool IsMenuClosing();
	bool IsMenuOpening();
	bool IsWheelClosed();
	bool IsWheelCursorVisible();
	bool IsWheelOpen();
	bool Next();
	void OnRadialMenuClosed();
	void OnRadialMenuClosed__DelegateSignature();
	void OnRadialMenuCreated();
	bool OnRadialMenuInitialized();
	void OnRadialMenuOpened();
	void OnRadialMenuOpened__DelegateSignature();
	bool OnRadialSectorCreated(int32 Param_Index, float InAngle);
	void OnSectorDeselected(int32 DeselectedIndex);
	void OnSectorSelected(int32 SelectedIndex);
	bool OpenWheel(bool bForceRefresh);
	void OpenWheel_Internal(bool bForceRefresh);
	bool Previous();
	bool RefreshWheel(int32 InStartingSectorIndex);
	void RestoreMousePosition();
	void SaveMousePosition();
	bool Select(int32 Param_Index);
	void SetCloseDelay(float NewDelay);
	void SetGamepadXAxis(float InGamepadXAxis);
	void SetGamepadXYAxis(float InGamepadXAxis, float InGamepadYAxis);
	void SetGamepadYAxis(float InGamepadYAxis);
	void SetMousePosition(struct FVector2D& NewMousePosition);
	void SetMousePositionToCenterScreen();
	void SetMouseWheelDelta(float InDelta);
	void Setup(struct FRadialWidgetSpawnProperties& RadialWidgetSpawnProperties);
	void ShowMouseCursor();
	bool ShowWheel();
	void UpdateGamepadSelectionLogic(class UWidget* RadialCursorWidget);
	void UpdateMouseSelectionLogic(class UWidget* RadialCursorWidget);
	void UpdateSectorColor(int32 SectorIndex, const struct FLinearColor& SectorColor);
	void UseGamepadControl();
	void UseMouseControl();

	ERadialMenuCloseReason GetLastClosedReason() const;
	bool WasForceClosed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadialWidgetBase">();
	}
	static class URadialWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URadialWidgetBase>();
	}
};
static_assert(alignof(URadialWidgetBase) == 0x000008, "Wrong alignment on URadialWidgetBase");
static_assert(sizeof(URadialWidgetBase) == 0x000400, "Wrong size on URadialWidgetBase");
static_assert(offsetof(URadialWidgetBase, OnRadialMenuOpened_Delegate) == 0x000278, "Member 'URadialWidgetBase::OnRadialMenuOpened_Delegate' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, OnRadialMenuClosed_Delegate) == 0x000288, "Member 'URadialWidgetBase::OnRadialMenuClosed_Delegate' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, CurrentSelectionIndex) == 0x000298, "Member 'URadialWidgetBase::CurrentSelectionIndex' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, PreviousSelectionIndex) == 0x00029C, "Member 'URadialWidgetBase::PreviousSelectionIndex' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, Angle) == 0x0002A0, "Member 'URadialWidgetBase::Angle' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, AngleSpread) == 0x0002A4, "Member 'URadialWidgetBase::AngleSpread' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, PercentageWithoutGap) == 0x0002A8, "Member 'URadialWidgetBase::PercentageWithoutGap' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, PercentageWithGap) == 0x0002AC, "Member 'URadialWidgetBase::PercentageWithGap' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, RadialCursorPosition) == 0x0002B4, "Member 'URadialWidgetBase::RadialCursorPosition' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, Angles) == 0x0002C0, "Member 'URadialWidgetBase::Angles' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, Sectors) == 0x0002D0, "Member 'URadialWidgetBase::Sectors' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, RadialWheel) == 0x0002E0, "Member 'URadialWidgetBase::RadialWheel' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, RadialWheelCursor) == 0x0002E8, "Member 'URadialWidgetBase::RadialWheelCursor' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, OwningPlayer) == 0x0002F0, "Member 'URadialWidgetBase::OwningPlayer' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, OwningPawn) == 0x0002F8, "Member 'URadialWidgetBase::OwningPawn' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, OwningPlayerCharacter) == 0x000300, "Member 'URadialWidgetBase::OwningPlayerCharacter' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, NumOfSectors) == 0x000308, "Member 'URadialWidgetBase::NumOfSectors' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, OpenDelay) == 0x00030C, "Member 'URadialWidgetBase::OpenDelay' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, CloseDelay) == 0x000310, "Member 'URadialWidgetBase::CloseDelay' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MinWheelSize) == 0x000314, "Member 'URadialWidgetBase::MinWheelSize' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MaxWheelSize) == 0x000318, "Member 'URadialWidgetBase::MaxWheelSize' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MinCursorAngle) == 0x00031C, "Member 'URadialWidgetBase::MinCursorAngle' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MaxCursorAngle) == 0x000320, "Member 'URadialWidgetBase::MaxCursorAngle' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, RadialCursorBehaviour) == 0x000324, "Member 'URadialWidgetBase::RadialCursorBehaviour' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, RadialSectorWidgetClass) == 0x000328, "Member 'URadialWidgetBase::RadialSectorWidgetClass' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, StartingSectorIndex) == 0x000334, "Member 'URadialWidgetBase::StartingSectorIndex' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, StartingSectorAngle) == 0x000338, "Member 'URadialWidgetBase::StartingSectorAngle' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, IconSize) == 0x00033C, "Member 'URadialWidgetBase::IconSize' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, IconPadding) == 0x000340, "Member 'URadialWidgetBase::IconPadding' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, SectorInnerRadius) == 0x000344, "Member 'URadialWidgetBase::SectorInnerRadius' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, SectorOuterRadius) == 0x000348, "Member 'URadialWidgetBase::SectorOuterRadius' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, GapSize) == 0x00034C, "Member 'URadialWidgetBase::GapSize' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, WheelSize) == 0x000350, "Member 'URadialWidgetBase::WheelSize' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, WheelCursorDistanceFromCenterWheel) == 0x000354, "Member 'URadialWidgetBase::WheelCursorDistanceFromCenterWheel' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, SelectedColor) == 0x00035C, "Member 'URadialWidgetBase::SelectedColor' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, UnselectedColor) == 0x00036C, "Member 'URadialWidgetBase::UnselectedColor' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, UnselectableColor) == 0x00037C, "Member 'URadialWidgetBase::UnselectableColor' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, Font) == 0x000390, "Member 'URadialWidgetBase::Font' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, SelectionSound) == 0x000398, "Member 'URadialWidgetBase::SelectionSound' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MenuOpenSound) == 0x0003A0, "Member 'URadialWidgetBase::MenuOpenSound' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MenuCloseSound) == 0x0003A8, "Member 'URadialWidgetBase::MenuCloseSound' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MenuCloseSound_NoSelection) == 0x0003B0, "Member 'URadialWidgetBase::MenuCloseSound_NoSelection' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, RadialWidgetTheme) == 0x0003B8, "Member 'URadialWidgetBase::RadialWidgetTheme' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MousePosition) == 0x0003C0, "Member 'URadialWidgetBase::MousePosition' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MouseAxisDelta) == 0x0003C8, "Member 'URadialWidgetBase::MouseAxisDelta' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MouseWheelDelta) == 0x0003D0, "Member 'URadialWidgetBase::MouseWheelDelta' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MouseAngle) == 0x0003D4, "Member 'URadialWidgetBase::MouseAngle' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, GamepadXAxis) == 0x0003D8, "Member 'URadialWidgetBase::GamepadXAxis' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, GamepadYAxis) == 0x0003DC, "Member 'URadialWidgetBase::GamepadYAxis' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, GamepadAngle) == 0x0003E0, "Member 'URadialWidgetBase::GamepadAngle' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, GlobalTimeDilation) == 0x0003E4, "Member 'URadialWidgetBase::GlobalTimeDilation' has a wrong offset!");

// Class ReadyOrNot.RandomizedShippingContainerActor
// 0x0060 (0x0280 - 0x0220)
class ARandomizedShippingContainerActor final  : public AActor
{
public:
	class UStaticMeshComponent*                   ContainerMeshComp;                                 // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   ContainerDecalsComp;                               // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   LeftDoorDecalsComp;                                // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   RightDoorDecalsComp;                               // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInterface*>             ContainerMaterials;                                // 0x0240(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    ContainerDecals;                                   // 0x0250(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    LeftDoorDecals;                                    // 0x0260(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    RightDoorDecals;                                   // 0x0270(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void RandomizeContainer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RandomizedShippingContainerActor">();
	}
	static class ARandomizedShippingContainerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARandomizedShippingContainerActor>();
	}
};
static_assert(alignof(ARandomizedShippingContainerActor) == 0x000008, "Wrong alignment on ARandomizedShippingContainerActor");
static_assert(sizeof(ARandomizedShippingContainerActor) == 0x000280, "Wrong size on ARandomizedShippingContainerActor");
static_assert(offsetof(ARandomizedShippingContainerActor, ContainerMeshComp) == 0x000220, "Member 'ARandomizedShippingContainerActor::ContainerMeshComp' has a wrong offset!");
static_assert(offsetof(ARandomizedShippingContainerActor, ContainerDecalsComp) == 0x000228, "Member 'ARandomizedShippingContainerActor::ContainerDecalsComp' has a wrong offset!");
static_assert(offsetof(ARandomizedShippingContainerActor, LeftDoorDecalsComp) == 0x000230, "Member 'ARandomizedShippingContainerActor::LeftDoorDecalsComp' has a wrong offset!");
static_assert(offsetof(ARandomizedShippingContainerActor, RightDoorDecalsComp) == 0x000238, "Member 'ARandomizedShippingContainerActor::RightDoorDecalsComp' has a wrong offset!");
static_assert(offsetof(ARandomizedShippingContainerActor, ContainerMaterials) == 0x000240, "Member 'ARandomizedShippingContainerActor::ContainerMaterials' has a wrong offset!");
static_assert(offsetof(ARandomizedShippingContainerActor, ContainerDecals) == 0x000250, "Member 'ARandomizedShippingContainerActor::ContainerDecals' has a wrong offset!");
static_assert(offsetof(ARandomizedShippingContainerActor, LeftDoorDecals) == 0x000260, "Member 'ARandomizedShippingContainerActor::LeftDoorDecals' has a wrong offset!");
static_assert(offsetof(ARandomizedShippingContainerActor, RightDoorDecals) == 0x000270, "Member 'ARandomizedShippingContainerActor::RightDoorDecals' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotAIConfig
// 0x0000 (0x0028 - 0x0028)
class UReadyOrNotAIConfig final  : public UGameplayConfig
{
public:
	static class UReadyOrNotAIConfig* Get();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotAIConfig">();
	}
	static class UReadyOrNotAIConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotAIConfig>();
	}
};
static_assert(alignof(UReadyOrNotAIConfig) == 0x000008, "Wrong alignment on UReadyOrNotAIConfig");
static_assert(sizeof(UReadyOrNotAIConfig) == 0x000028, "Wrong size on UReadyOrNotAIConfig");

// Class ReadyOrNot.ReadyOrNotAISenseConfig_Sight
// 0x0000 (0x0070 - 0x0070)
class UReadyOrNotAISenseConfig_Sight final  : public UAISenseConfig_Sight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotAISenseConfig_Sight">();
	}
	static class UReadyOrNotAISenseConfig_Sight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotAISenseConfig_Sight>();
	}
};
static_assert(alignof(UReadyOrNotAISenseConfig_Sight) == 0x000008, "Wrong alignment on UReadyOrNotAISenseConfig_Sight");
static_assert(sizeof(UReadyOrNotAISenseConfig_Sight) == 0x000070, "Wrong size on UReadyOrNotAISenseConfig_Sight");

// Class ReadyOrNot.ReadyOrNotAISystem
// 0x0000 (0x0130 - 0x0130)
class UReadyOrNotAISystem final  : public UAISystem
{
public:
	static bool ProjectPointToNav(const struct FVector& Point, struct FVector* OutLocation, const struct FVector& Extent);
	static bool WasRecentlyInCombat(float SinceSeconds, bool bCivilianCheck);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotAISystem">();
	}
	static class UReadyOrNotAISystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotAISystem>();
	}
};
static_assert(alignof(UReadyOrNotAISystem) == 0x000008, "Wrong alignment on UReadyOrNotAISystem");
static_assert(sizeof(UReadyOrNotAISystem) == 0x000130, "Wrong size on UReadyOrNotAISystem");

// Class ReadyOrNot.ReadyOrNotAvoidanceManager
// 0x0010 (0x0050 - 0x0040)
class UReadyOrNotAvoidanceManager final  : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_2823[0x10];                                    // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotAvoidanceManager">();
	}
	static class UReadyOrNotAvoidanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotAvoidanceManager>();
	}
};
static_assert(alignof(UReadyOrNotAvoidanceManager) == 0x000008, "Wrong alignment on UReadyOrNotAvoidanceManager");
static_assert(sizeof(UReadyOrNotAvoidanceManager) == 0x000050, "Wrong size on UReadyOrNotAvoidanceManager");

// Class ReadyOrNot.ReadyOrNotBackend
// 0x04D8 (0x0500 - 0x0028)
class UReadyOrNotBackend final  : public UObject
{
public:
	uint8                                         Pad_2824[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SteamId;                                           // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SteamName;                                         // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 Ticket;                                            // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CachedDiscordOneTimeUseCode;                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2825[0x10];                                    // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         RgchToken[0x400];                                  // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2826[0x4];                                     // 0x0488(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ReadyOrNot::ELoginState                       LoginState;                                        // 0x048C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2827[0x1B];                                    // 0x048D(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStatsStarted;                                    // 0x04A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStatsUploadProgress;                             // 0x04B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2828[0x10];                                    // 0x04C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStatsSaved;                                      // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bProfileInProgress;                                // 0x04E8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2829[0x17];                                    // 0x04E9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoLogin();
	void OnCheckedBanStatus__DelegateSignature(const class FString& BannedSteamId, bool bIsBanned, const class FString& BanReason, bool bIsMySteamId);
	void OnFinishedCapturingProfile();
	void OnGameCrashedMetric(class FString& InState);
	void OnGameFinishedMetric(class FString& InMap, class FString& InGameType, class FString& InGameResult);
	void OnGameStartedMetric(class FString& InMap, class FString& InGameType, int32 InNumPlayers);
	void OnPlayerGameFinishedMetric(class FString& InMap, class FString& InGameType, float InAverageFps);
	void OnStatsSaved__DelegateSignature(bool bWasSuccessful, const class FString& StatsName);
	void OnStatsStarted__DelegateSignature();
	void OnStatsUploadProgress__DelegateSignature(const class FString& Filename, float Percentage);
	void StartCapturingProfile();
	void TickLoginDelay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotBackend">();
	}
	static class UReadyOrNotBackend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotBackend>();
	}
};
static_assert(alignof(UReadyOrNotBackend) == 0x000008, "Wrong alignment on UReadyOrNotBackend");
static_assert(sizeof(UReadyOrNotBackend) == 0x000500, "Wrong size on UReadyOrNotBackend");
static_assert(offsetof(UReadyOrNotBackend, SteamId) == 0x000038, "Member 'UReadyOrNotBackend::SteamId' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, SteamName) == 0x000048, "Member 'UReadyOrNotBackend::SteamName' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, Ticket) == 0x000058, "Member 'UReadyOrNotBackend::Ticket' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, CachedDiscordOneTimeUseCode) == 0x000068, "Member 'UReadyOrNotBackend::CachedDiscordOneTimeUseCode' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, RgchToken) == 0x000088, "Member 'UReadyOrNotBackend::RgchToken' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, LoginState) == 0x00048C, "Member 'UReadyOrNotBackend::LoginState' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, OnStatsStarted) == 0x0004A8, "Member 'UReadyOrNotBackend::OnStatsStarted' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, OnStatsUploadProgress) == 0x0004B8, "Member 'UReadyOrNotBackend::OnStatsUploadProgress' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, OnStatsSaved) == 0x0004D8, "Member 'UReadyOrNotBackend::OnStatsSaved' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, bProfileInProgress) == 0x0004E8, "Member 'UReadyOrNotBackend::bProfileInProgress' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotCharMovementComp
// 0x0010 (0x0B00 - 0x0AF0)
class UReadyOrNotCharMovementComp final  : public UCharacterMovementComponent
{
public:
	bool                                          bHasReplicatedAcceleration;                        // 0x0AF0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2830[0xF];                                     // 0x0AF1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotCharMovementComp">();
	}
	static class UReadyOrNotCharMovementComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotCharMovementComp>();
	}
};
static_assert(alignof(UReadyOrNotCharMovementComp) == 0x000010, "Wrong alignment on UReadyOrNotCharMovementComp");
static_assert(sizeof(UReadyOrNotCharMovementComp) == 0x000B00, "Wrong size on UReadyOrNotCharMovementComp");
static_assert(offsetof(UReadyOrNotCharMovementComp, bHasReplicatedAcceleration) == 0x000AF0, "Member 'UReadyOrNotCharMovementComp::bHasReplicatedAcceleration' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotCommandFunctionLibrary
// 0x0278 (0x02A0 - 0x0028)
class UReadyOrNotCommandFunctionLibrary final  : public UObject
{
public:
	uint8                                         Pad_2831[0x278];                                   // 0x0028(0x0278)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RespondToSWATCommand(class USWATManager* SWATManager, class UWorld* World, const struct FSwatCommand& Command, ETeamType TeamType, const struct FHitResult& CommandContextualData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotCommandFunctionLibrary">();
	}
	static class UReadyOrNotCommandFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotCommandFunctionLibrary>();
	}
};
static_assert(alignof(UReadyOrNotCommandFunctionLibrary) == 0x000008, "Wrong alignment on UReadyOrNotCommandFunctionLibrary");
static_assert(sizeof(UReadyOrNotCommandFunctionLibrary) == 0x0002A0, "Wrong size on UReadyOrNotCommandFunctionLibrary");

// Class ReadyOrNot.ReadyOrNotCoverData
// 0x00D8 (0x0108 - 0x0030)
class UReadyOrNotCoverData final  : public UDataAsset
{
public:
	struct FCoverDataMain                         CoverData;                                         // 0x0030(0x00D8)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotCoverData">();
	}
	static class UReadyOrNotCoverData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotCoverData>();
	}
};
static_assert(alignof(UReadyOrNotCoverData) == 0x000008, "Wrong alignment on UReadyOrNotCoverData");
static_assert(sizeof(UReadyOrNotCoverData) == 0x000108, "Wrong size on UReadyOrNotCoverData");
static_assert(offsetof(UReadyOrNotCoverData, CoverData) == 0x000030, "Member 'UReadyOrNotCoverData::CoverData' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotCrowdManager
// 0x0000 (0x00F0 - 0x00F0)
class UReadyOrNotCrowdManager final  : public UCrowdManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotCrowdManager">();
	}
	static class UReadyOrNotCrowdManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotCrowdManager>();
	}
};
static_assert(alignof(UReadyOrNotCrowdManager) == 0x000008, "Wrong alignment on UReadyOrNotCrowdManager");
static_assert(sizeof(UReadyOrNotCrowdManager) == 0x0000F0, "Wrong size on UReadyOrNotCrowdManager");

// Class ReadyOrNot.ReadyOrNotDebugSubsystem
// 0x0028 (0x0058 - 0x0030)
class UReadyOrNotDebugSubsystem final  : public UGameInstanceSubsystem
{
public:
	uint8                                         bDrawMeleeRange : 1;                               // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInfiniteHealth : 1;                               // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerGodMode : 1;                                // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInfiniteAmmo : 1;                                 // 0x0030(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawGrenadePath : 1;                              // 0x0030(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRTXOn : 1;                                        // 0x0030(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRTX_GlobalIlluminationOn : 1;                     // 0x0030(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRTX_ReflectionsOn : 1;                            // 0x0030(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRTX_AmbientOcclusionOn : 1;                       // 0x0031(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRTX_ShadowsOn : 1;                                // 0x0031(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRTX_TranslucencyOn : 1;                           // 0x0031(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVSyncOn : 1;                                      // 0x0031(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bOverlayOn_Fibonacci;                              // 0x0032(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverlayOn_LineUp;                                 // 0x0033(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverlayOn_PistolLine;                             // 0x0034(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverlayOn_RifleLine;                              // 0x0035(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverlayOn_RuleOfThirds;                           // 0x0036(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bApplyGlobalDamageMultiplier_Weapons : 1;          // 0x0037(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyGlobalDamageMultiplier_Grenades : 1;         // 0x0037(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	float                                         GlobalDamageMultiplier_Weapons;                    // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalDamageMultiplier_Grenades;                   // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLogWeaponDamageValuesToConsole : 1;               // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowObjectiveMarkers : 1;                         // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowAllEvidenceActors : 1;                        // 0x0040(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowHesitationBar : 1;                            // 0x0040(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLogPlayerAnimationStatus : 1;                     // 0x0040(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawInteractableComponents : 1;                   // 0x0040(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableInteractableComponent : 1;                 // 0x0040(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawDebugTraces : 1;                              // 0x0040(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawDoorKillStunDistances : 1;                    // 0x0041(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMuteFMOD : 1;                                     // 0x0041(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPauseFMOD : 1;                                    // 0x0041(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceOpenAllDoors : 1;                            // 0x0041(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceCloseAllDoors : 1;                           // 0x0041(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLaserEyes : 1;                                    // 0x0041(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableMusic : 1;                                 // 0x0041(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawCoverPoints : 1;                              // 0x0041(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawCoverOctree : 1;                              // 0x0042(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSWATDynamicCover : 1;                             // 0x0042(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSuspectDynamicCover : 1;                          // 0x0042(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawSWATCoverLogic : 1;                           // 0x0042(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawSuspectCoverLogic : 1;                        // 0x0042(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInfiniteSWATItems : 1;                            // 0x0042(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowNavigation : 1;                               // 0x0042(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2834[0x15];                                    // 0x0043(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOrUpdatePostProcessMaterial(class UMaterialInterface* InMaterial, bool* bMaterialOn);
	void CloseAllDoors();
	void DecreaseGlobalDamageMultiplier_Grenades(float Amount);
	void DecreaseGlobalDamageMultiplier_Weapons(float Amount);
	void DisableAllDebugLines();
	void EnableAllDebugLines();
	void IncreaseGlobalDamageMultiplier_Grenades(float Amount);
	void IncreaseGlobalDamageMultiplier_Weapons(float Amount);
	void OpenAllDoors();
	void RTX_ToggleAmbientOcclusion();
	void RTX_ToggleGlobalIllumination();
	void RTX_ToggleReflections();
	void RTX_ToggleShadows();
	void RTX_ToggleTranslucency();
	void SetDebugLinesVisibility(bool bVisible);
	void SetGlobalDamageMultiplier_Grenades(float NewDamageMultiplier);
	void SetGlobalDamageMultiplier_Weapons(float NewDamageMultiplier);
	void SetMeleeDamage(class APlayerCharacter* PlayerCharacter, float NewMeleeDamage);
	void SetMeleeRange(class APlayerCharacter* PlayerCharacter, float NewMeleeRange);
	void ToggleAllEvidenceActorMarkers();
	void ToggleCoverOctree();
	void ToggleCoverPoints();
	void ToggleDrawDebugTraces();
	void ToggleDrawDoorKillStunDistances();
	void ToggleDrawInteractableComponents();
	void ToggleDrawMeleeRange();
	void ToggleDrawSuspectCoverLogic();
	void ToggleDrawSWATCoverLogic();
	void ToggleFibonacciOverlayGuide(class UMaterialInterface* InMaterial);
	void ToggleGlobalDamageMultiplier_Grenades();
	void ToggleGlobalDamageMultiplier_Weapons();
	void ToggleGodMode();
	void ToggleGrenadeDrawDebug();
	void ToggleHesitationBar();
	void ToggleInfiniteAmmo();
	void ToggleInfiniteHealth();
	void ToggleInfiniteSWATItems();
	void ToggleInteractableComponents();
	void ToggleLaserEyes();
	void ToggleLineUpOverlayGuide(class UMaterialInterface* InMaterial);
	void ToggleLogPlayerAnimationStatus();
	void ToggleLogWeaponDamage();
	void ToggleMusic(bool bMusicOn);
	void ToggleMuteFMOD();
	void ToggleNavigation();
	void ToggleObjectiveMarkers();
	void TogglePauseFMOD();
	void TogglePistolLineOverlayGuide(class UMaterialInterface* InMaterial);
	void ToggleRifleLineOverlayGuide(class UMaterialInterface* InMaterial);
	void ToggleRTXSettings();
	void ToggleRuleOfThirdsOverlayGuide(class UMaterialInterface* InMaterial);
	void ToggleSuspectDynamicCover();
	void ToggleSWATDynamicCover();
	void ToggleThreatOctree();
	void ToggleThreatPoints();
	void ToggleThreatRoomNames();
	void ToggleVSync();
	void WeakenAllEnemiesToLowHealth();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotDebugSubsystem">();
	}
	static class UReadyOrNotDebugSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotDebugSubsystem>();
	}
};
static_assert(alignof(UReadyOrNotDebugSubsystem) == 0x000008, "Wrong alignment on UReadyOrNotDebugSubsystem");
static_assert(sizeof(UReadyOrNotDebugSubsystem) == 0x000058, "Wrong size on UReadyOrNotDebugSubsystem");
static_assert(offsetof(UReadyOrNotDebugSubsystem, bOverlayOn_Fibonacci) == 0x000032, "Member 'UReadyOrNotDebugSubsystem::bOverlayOn_Fibonacci' has a wrong offset!");
static_assert(offsetof(UReadyOrNotDebugSubsystem, bOverlayOn_LineUp) == 0x000033, "Member 'UReadyOrNotDebugSubsystem::bOverlayOn_LineUp' has a wrong offset!");
static_assert(offsetof(UReadyOrNotDebugSubsystem, bOverlayOn_PistolLine) == 0x000034, "Member 'UReadyOrNotDebugSubsystem::bOverlayOn_PistolLine' has a wrong offset!");
static_assert(offsetof(UReadyOrNotDebugSubsystem, bOverlayOn_RifleLine) == 0x000035, "Member 'UReadyOrNotDebugSubsystem::bOverlayOn_RifleLine' has a wrong offset!");
static_assert(offsetof(UReadyOrNotDebugSubsystem, bOverlayOn_RuleOfThirds) == 0x000036, "Member 'UReadyOrNotDebugSubsystem::bOverlayOn_RuleOfThirds' has a wrong offset!");
static_assert(offsetof(UReadyOrNotDebugSubsystem, GlobalDamageMultiplier_Weapons) == 0x000038, "Member 'UReadyOrNotDebugSubsystem::GlobalDamageMultiplier_Weapons' has a wrong offset!");
static_assert(offsetof(UReadyOrNotDebugSubsystem, GlobalDamageMultiplier_Grenades) == 0x00003C, "Member 'UReadyOrNotDebugSubsystem::GlobalDamageMultiplier_Grenades' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotFaceAnimInstance
// 0x0030 (0x02F0 - 0x02C0)
class UReadyOrNotFaceAnimInstance : public UAnimInstance
{
public:
	class USkeletalMeshComponent*                 BodyDriverMesh;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseAsset*                             DefaultFaceROMData;                                // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FocalTargetLookRotation;                           // 0x02C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               HeadLookRotation;                                  // 0x02D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EyeTargetLookLeft;                                 // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeTargetLookRight;                                // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeTargetLookUp;                                   // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeTargetLookDown;                                 // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UPoseAsset* GetFaceROM() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotFaceAnimInstance">();
	}
	static class UReadyOrNotFaceAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotFaceAnimInstance>();
	}
};
static_assert(alignof(UReadyOrNotFaceAnimInstance) == 0x000010, "Wrong alignment on UReadyOrNotFaceAnimInstance");
static_assert(sizeof(UReadyOrNotFaceAnimInstance) == 0x0002F0, "Wrong size on UReadyOrNotFaceAnimInstance");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, BodyDriverMesh) == 0x0002B8, "Member 'UReadyOrNotFaceAnimInstance::BodyDriverMesh' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, DefaultFaceROMData) == 0x0002C0, "Member 'UReadyOrNotFaceAnimInstance::DefaultFaceROMData' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, FocalTargetLookRotation) == 0x0002C8, "Member 'UReadyOrNotFaceAnimInstance::FocalTargetLookRotation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, HeadLookRotation) == 0x0002D4, "Member 'UReadyOrNotFaceAnimInstance::HeadLookRotation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, EyeTargetLookLeft) == 0x0002E0, "Member 'UReadyOrNotFaceAnimInstance::EyeTargetLookLeft' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, EyeTargetLookRight) == 0x0002E4, "Member 'UReadyOrNotFaceAnimInstance::EyeTargetLookRight' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, EyeTargetLookUp) == 0x0002E8, "Member 'UReadyOrNotFaceAnimInstance::EyeTargetLookUp' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, EyeTargetLookDown) == 0x0002EC, "Member 'UReadyOrNotFaceAnimInstance::EyeTargetLookDown' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UReadyOrNotFunctionLibrary final  : public UBlueprintFunctionLibrary
{
public:
	static bool AllFalse(TArray<bool>& BoolArray);
	static bool AllTrue(TArray<bool>& BoolArray);
	static bool AnyFalse(TArray<bool>& BoolArray);
	static bool AnyTrue(TArray<bool>& BoolArray);
	static class FString BadAIActionConfigDir();
	static struct FVector2D CalculateOffscreenPositionFromWorldLocation_Ellipse(class UObject* WorldContext, struct FVector& WorldLocation, float ViewportOffset, bool* bIsOffscreen, float* Angle, float* ForwardDotProduct, float* RightDotProduct);
	static struct FVector2D CalculateOffscreenPositionFromWorldLocation_Square(class UObject* WorldContext, struct FVector& WorldLocation, float ViewportOffset, bool* bIsOffscreen, float* Angle, float* ForwardDotProduct, float* RightDotProduct);
	static struct FKey ConvertIntToFKey(int32 Integer);
	static struct FSlateBrush ConvertKeyToIcon(struct FKey& InKey);
	static class FString ConvertUnrealKeyNameToRonKeyName(struct FKey& InKey);
	static struct FRonKey ConvertUnrealKeyToRonKey(struct FKey& InKey);
	static void CopySupporterStringToClipboard(class UObject* WorldContextObject);
	static class FString DevMenuSettingsConfigDir();
	static bool DoesWidgetOverlap(class UObject* WorldContext, class UWidget* ParentWidget, class UWidget* WidgetA, class UWidget* WidgetB);
	static class FString DoorBreachTypeToVoiceline(EDoorBreachType DoorBreachType);
	static class FString DoorBreachTypeToVoiceline_Negative(EDoorBreachType DoorBreachType);
	static class FString DoorCheckResultToVoiceline(EDoorCheckResult DoorBreachType);
	static class AActor* FindClosestActorFromLocation_Blueprint(struct FVector& InTestLocation, TArray<class AActor*>& InActors);
	static bool FindConfigKeyFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static TSubclassOf<class ABaseItem> FindItemClassInItemDataTable(class FName RowName);
	static float FindNearestFloor_BP(class AActor* InActor, TArray<class AActor*>& InActorsToIgnore, TArray<class UPrimitiveComponent*>& InComponentsToIgnore);
	static class FText FormatPlayerActionText(struct FKey& InKey, EInputEvent& InInputEvent, class FText& InActionText, const class FString& InColorLabel);
	static bool FulfillsAllPostProcessRequirements(class UObject* Context, class APlayerCharacter* OwningCharacter, class AActor* DamageCauser, TArray<TSubclassOf<class UPostProcessRequirement>>& InRequirementClasses, bool bForceSuccess);
	static TArray<class UFMODEvent*> GetAll2DFMODAudioEvents();
	static TArray<class UAudioComponent*> GetAllAudioComponents();
	static TArray<class UFMODBus*> GetAllFMODBusObjects();
	static TArray<class ABaseItem*> GetAllItemsInMemory();
	static TArray<class FString> GetAllSectionNamesFromINIFile(const class FString& ConfigFilePath);
	static TArray<class USoundBase*> GetAllSoundsInWorld();
	static class UAnimMontage* GetAnimationFromTable(const class FString& AnimationName, bool bIsCrouching);
	static float GetAspectRatio();
	static bool GetBoolFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static ERONBuildConfiguration GetBuildConfiguration();
	static class UObject* GetClassDefaultObject(class UClass* Param_Class);
	static class UClass* GetClassFromObject(class UObject* Object);
	static ECOOPMode GetCOOPMode();
	static class FName GetCurrentLevelNameForLookupTable(class UObject* Context);
	static float GetFloatFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static float GetFMODBusVolume(class UFMODBus* Bus);
	static struct FSlateBrush GetIconFromInputKeyName(class FName& RonKeyName);
	static int32 GetIntegerFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static float GetInterfaceFovOffset(float InFov);
	static struct FKey GetKeyFromInputActionName(class FName& ActionName, bool bOnlyGamepadKey, int32 Param_Index);
	static struct FKey GetKeyFromInputAxisName(class FName& AxisName, bool bUsingGamepad, int32 Param_Index);
	static struct FVector2D GetPixelPositionOfWidget(class UObject* WorldContext, class UWidget* InParentWidget, class UWidget* InWidget, const struct FVector2D& InCoordinates);
	static struct FVector2D GetPixelPositionOfWidgetCenter(class UObject* WorldContext, class UWidget* InParentWidget, class UWidget* InWidget);
	static class APlayerCharacter* GetPlayerCharacterMutableDefaultObject(class UClass* Param_Class);
	static class UHumanCharacterHUD_V2* GetPlayerHUD(class UObject* WorldContext);
	static class UReadyOrNotGameUserSettings* GetReadyOrNotGameUserSettings();
	static class AReadyOrNotLevelScript* GetReadyOrNotLevelScript(class UObject* Context);
	static struct FRoom GetRoomDataForLocation(const struct FVector& Location);
	static struct FRoom GetRoomDataFromName(class FName Param_Name);
	static class FString GetServerNameFromCurrentSession();
	static TArray<class FString> GetSingleLineArrayFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static TArray<class FString> GetStringArrayFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static class FString GetStringFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static bool GetUseGearListInsteadOfRadial();
	static struct FVector2D GetVector2DFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static struct FVector GetVectorFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static struct FVector2D GetViewportPositionOfWidget(class UObject* WorldContext, class UWidget* InParentWidget, class UWidget* InWidget, const struct FVector2D& InCoordinates);
	static struct FVector2D GetViewportPositionOfWidgetCenter(class UObject* WorldContext, class UWidget* InParentWidget, class UWidget* InWidget);
	static float GetWeaponFOVOffset();
	static struct FVector2D GetWidgetSize_Absolute(class UWidget* InWidget);
	static struct FVector2D GetWidgetSize_Local(class UWidget* InWidget);
	static bool IsActorInsideSplineEnclosure(class ASplineTrigger* InSplineTrigger, class AActor* InActor);
	static bool IsActorOutsideSplineEnclosure(class ASplineTrigger* InSplineTrigger, class AActor* InActor);
	static bool IsAprilFools();
	static bool IsBuildPirated();
	static bool IsDLSSEnabled();
	static bool IsFMODBusMuted(class UFMODBus* Bus);
	static bool IsFMODBusPaused(class UFMODBus* Bus);
	static bool IsFSREnabled();
	static bool IsHalloween();
	static bool IsInDefusalWarmup();
	static bool IsInLobby();
	static bool IsItemEquipped(class AReadyOrNotCharacter* PlayerCharacter, EItemCategory ItemCategory);
	static bool IsItemInInventory(class AReadyOrNotCharacter* PlayerCharacter, EItemCategory ItemCategory);
	static bool IsTableMontagePlaying(class APlayerCharacter* PlayerCharacter, const class FString& AnimationName, bool bIsCrouching);
	static bool IsUsingGamepad(class AReadyOrNotPlayerController* InController);
	static bool LoadStringArrayFromFile(TArray<class FString>* StringArray, int32* ArraySize, const class FString& FullFilePath, bool ExcludeEmptyLines);
	static void MuteFMOD(bool bMuted);
	static void PauseFMOD(bool bPaused);
	static void PlayRandomFMODEvent_2D(class UObject* WorldContextObject, TArray<class UFMODEvent*>& FMODEvents);
	static void PlayRandomFMODEventAtLocation(class UObject* WorldContextObject, const struct FVector& Location, TArray<class UFMODEvent*>& FMODEvents);
	static bool ProcessPostProcessEffect(class UObject* Context, struct FPostProcessSettings* PostProcessSettings, struct FPostProcessEffect* InPostProcessEffect, float DeltaTime);
	static void RegisterTick(class AActor* Actor);
	static void RemoveAllNullElements_BP(TArray<TSubclassOf<class UClass>>& Array);
	static bool RemoveBadAIActionReport(class ABadAIAction* InBadAIActionActor, bool bReportToLog, bool bDrawDebugString);
	static void RemoveFromParentAndClear(TArray<class UWidget*>& InWidgets);
	static bool ReportBadAIAction(class ABadAIAction* InBadAIActionActor, class FText& InSummary, class FText& InDescription, bool bReportToLog, bool bDrawDebugString);
	static void RestartGame(class UObject* WorldContextObject);
	static void ServerTravel(const class FString& URL);
	static void SetDecalSize(class UDecalComponent* InDecalComponent, const struct FVector& DecalSize);
	static void SetFMODVolume(float Volume);
	static void SetPlanarReflectionScreenPercentage(class UPlanarReflectionComponent* InPlanarReflectionComponent, float NewScreenPercentage);
	static void SetSafeZonePadding(class USafeZoneSlot* SafeZoneSlot, const struct FMargin& Padding);
	static void SetupPostProcessEffect(class UObject* Context, struct FPostProcessEffect* InPostProcessEffect);
	static class FString SimulateAnimatedText(class FString& FinalString, int32& Iterator, TArray<class FString>& Chars, float& ElapsedTime, float& CurrentDelay, float DelayBetweenLetters, float DelayBetweenWords, float DeltaTime, bool* bCompleted);
	static void StartPostProcessEffect(class UObject* Context, struct FPostProcessSettings* PostProcessSettings, struct FPostProcessEffect* InPostProcessEffect, class AActor* DamageCauser);
	static void StartPostProcessEffect_Specific(class UObject* Context, struct FPostProcessSettings* PostProcessSettings, struct FPostProcessEffectPlayer* InPostProcessEffectPlayer, class AActor* DamageCauser);
	static void StopPostProcessEffect(struct FPostProcessSettings* PostProcessSettings, struct FPostProcessEffect* InPostProcessEffect);
	static EEasingFunc StringToEasingFunc(class FString& InEasingFunc);
	static class FText SwatCommandToText(ESwatCommand SwatCommand);
	static void UnregisterTick(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotFunctionLibrary">();
	}
	static class UReadyOrNotFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotFunctionLibrary>();
	}
};
static_assert(alignof(UReadyOrNotFunctionLibrary) == 0x000008, "Wrong alignment on UReadyOrNotFunctionLibrary");
static_assert(sizeof(UReadyOrNotFunctionLibrary) == 0x000028, "Wrong size on UReadyOrNotFunctionLibrary");

// Class ReadyOrNot.ReadyOrNotGameSession
// 0x0208 (0x0440 - 0x0238)
class AReadyOrNotGameSession final  : public AGameSession
{
public:
	uint8                                         Pad_2869[0x138];                                   // 0x0238(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	class UReadyOrNotSessionData*                 SessionData;                                       // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_286A[0x18];                                    // 0x0378(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerName;                                        // 0x0390(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         MapList;                                           // 0x03A0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         ReturnToLobbyAfterXMissions;                       // 0x03B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_286B[0x4];                                     // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Password;                                          // 0x03B8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxConnections;                                    // 0x03C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_286C[0x4];                                     // 0x03CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AdminPassword;                                     // 0x03D0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         LoggedInAdmins;                                    // 0x03E0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         BanList;                                           // 0x03F0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         MaxTeamKillsBeforeAutoKick;                        // 0x0400(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTeamKillsBeforeAutoBan;                         // 0x0404(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsUntilKickedForAFK;                          // 0x0408(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsUntilAutostartLobby;                        // 0x040C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPlayersForAutostart;                            // 0x0410(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundTimerGameStart;                               // 0x0414(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundTimerBetweenMaps;                             // 0x0418(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReinforcementTimer;                                // 0x041C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnTimer;                                      // 0x0420(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timelimit;                                         // 0x0424(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Scorelimit;                                        // 0x0428(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundsPerMap;                                      // 0x042C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAiEnabled;                                        // 0x0430(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_286D[0x3];                                     // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EventId;                                           // 0x0434(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClientNetSpeed;                                    // 0x0438(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_286E[0x4];                                     // 0x043C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddServerToMatchMakeQueue();
	void MakeLoadingMapOnlyURL(const class FString& MapURL);
	void OnGetPayloadServerRefresh(struct FZeuzPayloadGetOut& PayloadOut, const class FString& Error);
	void OnGetPayloadsMatchmakingCreateParty(struct FZeuzPayloadGetOut& PayloadOut, const class FString& Error);
	void OnGetRegions(TArray<struct FZeuzRegion>& ZeuzRegions, const class FString& Error);
	void OnMatchmakingCreateParty(struct FZeuzMatchMakingStatus& MatchmakingStatus, const class FString& Error);
	void RefreshMatchmakeServer();
	void SetServerSettings(float NewRoundTimerGameStart, float NewRoundTimerBetweenMaps, float NewReinforcementTimer, float NewTimelimit, int32 NewRoundsPerMap, int32 NewScorelimit, bool NewAiEnabled);
	void UpdateServerMatchmakeQueue();
	void WriteOutConfig();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotGameSession">();
	}
	static class AReadyOrNotGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotGameSession>();
	}
};
static_assert(alignof(AReadyOrNotGameSession) == 0x000008, "Wrong alignment on AReadyOrNotGameSession");
static_assert(sizeof(AReadyOrNotGameSession) == 0x000440, "Wrong size on AReadyOrNotGameSession");
static_assert(offsetof(AReadyOrNotGameSession, SessionData) == 0x000370, "Member 'AReadyOrNotGameSession::SessionData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, ServerName) == 0x000390, "Member 'AReadyOrNotGameSession::ServerName' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, MapList) == 0x0003A0, "Member 'AReadyOrNotGameSession::MapList' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, ReturnToLobbyAfterXMissions) == 0x0003B0, "Member 'AReadyOrNotGameSession::ReturnToLobbyAfterXMissions' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, Password) == 0x0003B8, "Member 'AReadyOrNotGameSession::Password' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, MaxConnections) == 0x0003C8, "Member 'AReadyOrNotGameSession::MaxConnections' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, AdminPassword) == 0x0003D0, "Member 'AReadyOrNotGameSession::AdminPassword' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, LoggedInAdmins) == 0x0003E0, "Member 'AReadyOrNotGameSession::LoggedInAdmins' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, BanList) == 0x0003F0, "Member 'AReadyOrNotGameSession::BanList' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, MaxTeamKillsBeforeAutoKick) == 0x000400, "Member 'AReadyOrNotGameSession::MaxTeamKillsBeforeAutoKick' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, MaxTeamKillsBeforeAutoBan) == 0x000404, "Member 'AReadyOrNotGameSession::MaxTeamKillsBeforeAutoBan' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, SecondsUntilKickedForAFK) == 0x000408, "Member 'AReadyOrNotGameSession::SecondsUntilKickedForAFK' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, SecondsUntilAutostartLobby) == 0x00040C, "Member 'AReadyOrNotGameSession::SecondsUntilAutostartLobby' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, MinPlayersForAutostart) == 0x000410, "Member 'AReadyOrNotGameSession::MinPlayersForAutostart' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, RoundTimerGameStart) == 0x000414, "Member 'AReadyOrNotGameSession::RoundTimerGameStart' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, RoundTimerBetweenMaps) == 0x000418, "Member 'AReadyOrNotGameSession::RoundTimerBetweenMaps' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, ReinforcementTimer) == 0x00041C, "Member 'AReadyOrNotGameSession::ReinforcementTimer' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, RespawnTimer) == 0x000420, "Member 'AReadyOrNotGameSession::RespawnTimer' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, Timelimit) == 0x000424, "Member 'AReadyOrNotGameSession::Timelimit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, Scorelimit) == 0x000428, "Member 'AReadyOrNotGameSession::Scorelimit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, RoundsPerMap) == 0x00042C, "Member 'AReadyOrNotGameSession::RoundsPerMap' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, bAiEnabled) == 0x000430, "Member 'AReadyOrNotGameSession::bAiEnabled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, EventId) == 0x000434, "Member 'AReadyOrNotGameSession::EventId' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, ClientNetSpeed) == 0x000438, "Member 'AReadyOrNotGameSession::ClientNetSpeed' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotGauntletTestController
// 0x0010 (0x0040 - 0x0030)
class UReadyOrNotGauntletTestController final  : public UGauntletTestController
{
public:
	uint8                                         Pad_2870[0x10];                                    // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartTesting();
	void StopProfiling();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotGauntletTestController">();
	}
	static class UReadyOrNotGauntletTestController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotGauntletTestController>();
	}
};
static_assert(alignof(UReadyOrNotGauntletTestController) == 0x000008, "Wrong alignment on UReadyOrNotGauntletTestController");
static_assert(sizeof(UReadyOrNotGauntletTestController) == 0x000040, "Wrong size on UReadyOrNotGauntletTestController");

// Class ReadyOrNot.ReadyOrNotLevelScript
// 0x0908 (0x0B30 - 0x0228)
class AReadyOrNotLevelScript : public ALevelScriptActor
{
public:
	EGenerationType                               WorldGenerationType;                               // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2871[0x7];                                     // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterial*                              TAASharpenFilter;                                  // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         SpawnedFromNotifyActors;                           // 0x0238(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FlashlightIntensity;                               // 0x0248(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlashlightIntensityBoost;                          // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlashlightBouncedIntensityBoost;                   // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2872[0x4];                                     // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABlockingVolume*>                BlockingVolumesInLevel;                            // 0x0258(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AVisibilityBlockingVolume*>      VisibilityBlockingVolumesInLevel;                  // 0x0268(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotTriggerVolume*>       TriggerVolumesInLevel;                             // 0x0278(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class AConversationManager*                   ConversationManager;                               // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ELightType, class FName>                 LightingScenarios;                                 // 0x0290(0x0050)(Edit, NativeAccessSpecifierPublic)
	ELightType                                    LightingType;                                      // 0x02E0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawCoverDebug;                                   // 0x02E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2873[0x6];                                     // 0x02E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLevelDataLookupTable                  LevelData;                                         // 0x02E8(0x0788)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class UMusicData*                             MusicData;                                         // 0x0A70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemData*                              ItemData;                                          // 0x0A78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundData*                             SoundData;                                         // 0x0A80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Delegate_OnOutOfBoundsTimeLimitEnded;              // 0x0A88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         OutOfBounds_MaxTimeLimit;                          // 0x0A98(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfBoundsTimeRemaining;                          // 0x0A9C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2874[0x8];                                     // 0x0AA0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AAmbientSound*>                  AudioSourcesInLevel;                               // 0x0AA8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AFMODAmbientSound*>              FMODAudioSourcesInLevel;                           // 0x0AB8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2875[0x10];                                    // 0x0AC8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotAudioVolume*>         AudioVolumes;                                      // 0x0AD8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ACyberneticCharacter*>           AIRequestingCover;                                 // 0x0AE8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseDarkness;                                      // 0x0AF8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2876[0x3];                                     // 0x0AF9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumLightIntensityForSource;                    // 0x0AFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarknessSightRangeMultiplier;                      // 0x0B00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeWorldLightsAsSources;                      // 0x0B04(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRaining;                                          // 0x0B05(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnOfficerAI;                                   // 0x0B06(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2877[0x1];                                     // 0x0B07(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelSequence*                         LevelSequenceMVP;                                  // 0x0B08(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequence*                         LevelSequenceTeam;                                 // 0x0B10(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequencePlayer*                   LastPlayedSequence;                                // 0x0B18(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2878[0x10];                                    // 0x0B20(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableOutOfBounds();
	void EnableOutOfBounds();
	class AConversationManager* GetConversationManager();
	void OnMVPSequenceFinished();
	void OnOutOfBoundsTimeLimitEnded();
	void OnOutOfBoundsTimeLimitEnded__DelegateSignature();
	void OnPiracyCheckUpdate(bool bIsPirated, const class FString& ProgramDetected);
	void OnPiracyCheckUpdate_Private(bool bIsPirated, const class FString& ProgramDetected);
	void OnTeamSequenceFinished();
	void PlayMVPSequence();
	void Start3DAudioVisualizer();
	void StartOutOfBoundsCountdown();
	void Stop3DAudioVisualizer();
	void StopOutOfBoundsCountdown();

	bool AllAudioVolumesTicked() const;
	bool IsCountingDownForOutOfBounds() const;
	bool IsOutOfBoundsEnabled() const;
	bool IsVisualizingAudioSources() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotLevelScript">();
	}
	static class AReadyOrNotLevelScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotLevelScript>();
	}
};
static_assert(alignof(AReadyOrNotLevelScript) == 0x000008, "Wrong alignment on AReadyOrNotLevelScript");
static_assert(sizeof(AReadyOrNotLevelScript) == 0x000B30, "Wrong size on AReadyOrNotLevelScript");
static_assert(offsetof(AReadyOrNotLevelScript, WorldGenerationType) == 0x000228, "Member 'AReadyOrNotLevelScript::WorldGenerationType' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, TAASharpenFilter) == 0x000230, "Member 'AReadyOrNotLevelScript::TAASharpenFilter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, SpawnedFromNotifyActors) == 0x000238, "Member 'AReadyOrNotLevelScript::SpawnedFromNotifyActors' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, FlashlightIntensity) == 0x000248, "Member 'AReadyOrNotLevelScript::FlashlightIntensity' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, FlashlightIntensityBoost) == 0x00024C, "Member 'AReadyOrNotLevelScript::FlashlightIntensityBoost' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, FlashlightBouncedIntensityBoost) == 0x000250, "Member 'AReadyOrNotLevelScript::FlashlightBouncedIntensityBoost' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, BlockingVolumesInLevel) == 0x000258, "Member 'AReadyOrNotLevelScript::BlockingVolumesInLevel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, VisibilityBlockingVolumesInLevel) == 0x000268, "Member 'AReadyOrNotLevelScript::VisibilityBlockingVolumesInLevel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, TriggerVolumesInLevel) == 0x000278, "Member 'AReadyOrNotLevelScript::TriggerVolumesInLevel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, ConversationManager) == 0x000288, "Member 'AReadyOrNotLevelScript::ConversationManager' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, LightingScenarios) == 0x000290, "Member 'AReadyOrNotLevelScript::LightingScenarios' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, LightingType) == 0x0002E0, "Member 'AReadyOrNotLevelScript::LightingType' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, bDrawCoverDebug) == 0x0002E1, "Member 'AReadyOrNotLevelScript::bDrawCoverDebug' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, LevelData) == 0x0002E8, "Member 'AReadyOrNotLevelScript::LevelData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, MusicData) == 0x000A70, "Member 'AReadyOrNotLevelScript::MusicData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, ItemData) == 0x000A78, "Member 'AReadyOrNotLevelScript::ItemData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, SoundData) == 0x000A80, "Member 'AReadyOrNotLevelScript::SoundData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, Delegate_OnOutOfBoundsTimeLimitEnded) == 0x000A88, "Member 'AReadyOrNotLevelScript::Delegate_OnOutOfBoundsTimeLimitEnded' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, OutOfBounds_MaxTimeLimit) == 0x000A98, "Member 'AReadyOrNotLevelScript::OutOfBounds_MaxTimeLimit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, OutOfBoundsTimeRemaining) == 0x000A9C, "Member 'AReadyOrNotLevelScript::OutOfBoundsTimeRemaining' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, AudioSourcesInLevel) == 0x000AA8, "Member 'AReadyOrNotLevelScript::AudioSourcesInLevel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, FMODAudioSourcesInLevel) == 0x000AB8, "Member 'AReadyOrNotLevelScript::FMODAudioSourcesInLevel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, AudioVolumes) == 0x000AD8, "Member 'AReadyOrNotLevelScript::AudioVolumes' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, AIRequestingCover) == 0x000AE8, "Member 'AReadyOrNotLevelScript::AIRequestingCover' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, bUseDarkness) == 0x000AF8, "Member 'AReadyOrNotLevelScript::bUseDarkness' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, MinimumLightIntensityForSource) == 0x000AFC, "Member 'AReadyOrNotLevelScript::MinimumLightIntensityForSource' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, DarknessSightRangeMultiplier) == 0x000B00, "Member 'AReadyOrNotLevelScript::DarknessSightRangeMultiplier' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, bIncludeWorldLightsAsSources) == 0x000B04, "Member 'AReadyOrNotLevelScript::bIncludeWorldLightsAsSources' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, bRaining) == 0x000B05, "Member 'AReadyOrNotLevelScript::bRaining' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, bSpawnOfficerAI) == 0x000B06, "Member 'AReadyOrNotLevelScript::bSpawnOfficerAI' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, LevelSequenceMVP) == 0x000B08, "Member 'AReadyOrNotLevelScript::LevelSequenceMVP' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, LevelSequenceTeam) == 0x000B10, "Member 'AReadyOrNotLevelScript::LevelSequenceTeam' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, LastPlayedSequence) == 0x000B18, "Member 'AReadyOrNotLevelScript::LastPlayedSequence' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotMathLibrary
// 0x0000 (0x0028 - 0x0028)
class UReadyOrNotMathLibrary final  : public UBlueprintFunctionLibrary
{
public:
	static struct FVector CalculateLocationOnSphere(const struct FVector& Origin, float Radius, float Angle, float Phi);
	static struct FVector2D CalculatePositionOnCircle(const struct FVector2D& Origin, float Radius, float Angle);
	static struct FVector2D CalculatePositionOnEllipse(const struct FVector2D& Origin, float RadiusX, float RadiusY, float Angle);
	static struct FVector GenerateRandomLocationOnSphere(const struct FVector& Origin, float Radius);
	static float GetLastKeyTime_FloatCurve(struct FRuntimeFloatCurve& InCurve);
	static float KeepAngleAbove0(float Angle);
	static float KeepAngleBelow360(float Angle);
	static float WrapAngleIfOutOfBounds(float Angle, float MinBounds, float MaxBounds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotMathLibrary">();
	}
	static class UReadyOrNotMathLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotMathLibrary>();
	}
};
static_assert(alignof(UReadyOrNotMathLibrary) == 0x000008, "Wrong alignment on UReadyOrNotMathLibrary");
static_assert(sizeof(UReadyOrNotMathLibrary) == 0x000028, "Wrong size on UReadyOrNotMathLibrary");

// Class ReadyOrNot.NavArea_NoSuspects
// 0x0000 (0x0048 - 0x0048)
class UNavArea_NoSuspects final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_NoSuspects">();
	}
	static class UNavArea_NoSuspects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_NoSuspects>();
	}
};
static_assert(alignof(UNavArea_NoSuspects) == 0x000008, "Wrong alignment on UNavArea_NoSuspects");
static_assert(sizeof(UNavArea_NoSuspects) == 0x000048, "Wrong size on UNavArea_NoSuspects");

// Class ReadyOrNot.NavArea_FlankingAvoidanceArea
// 0x0000 (0x0048 - 0x0048)
class UNavArea_FlankingAvoidanceArea final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_FlankingAvoidanceArea">();
	}
	static class UNavArea_FlankingAvoidanceArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_FlankingAvoidanceArea>();
	}
};
static_assert(alignof(UNavArea_FlankingAvoidanceArea) == 0x000008, "Wrong alignment on UNavArea_FlankingAvoidanceArea");
static_assert(sizeof(UNavArea_FlankingAvoidanceArea) == 0x000048, "Wrong size on UNavArea_FlankingAvoidanceArea");

// Class ReadyOrNot.NavArea_LockedDoor
// 0x0000 (0x0048 - 0x0048)
class UNavArea_LockedDoor final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_LockedDoor">();
	}
	static class UNavArea_LockedDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_LockedDoor>();
	}
};
static_assert(alignof(UNavArea_LockedDoor) == 0x000008, "Wrong alignment on UNavArea_LockedDoor");
static_assert(sizeof(UNavArea_LockedDoor) == 0x000048, "Wrong size on UNavArea_LockedDoor");

// Class ReadyOrNot.NavArea_LockedDoorSuspect
// 0x0000 (0x0048 - 0x0048)
class UNavArea_LockedDoorSuspect final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_LockedDoorSuspect">();
	}
	static class UNavArea_LockedDoorSuspect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_LockedDoorSuspect>();
	}
};
static_assert(alignof(UNavArea_LockedDoorSuspect) == 0x000008, "Wrong alignment on UNavArea_LockedDoorSuspect");
static_assert(sizeof(UNavArea_LockedDoorSuspect) == 0x000048, "Wrong size on UNavArea_LockedDoorSuspect");

// Class ReadyOrNot.NavArea_ClosedDoor
// 0x0000 (0x0048 - 0x0048)
class UNavArea_ClosedDoor final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_ClosedDoor">();
	}
	static class UNavArea_ClosedDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_ClosedDoor>();
	}
};
static_assert(alignof(UNavArea_ClosedDoor) == 0x000008, "Wrong alignment on UNavArea_ClosedDoor");
static_assert(sizeof(UNavArea_ClosedDoor) == 0x000048, "Wrong size on UNavArea_ClosedDoor");

// Class ReadyOrNot.NavArea_HasBeenOpenedDoor
// 0x0000 (0x0048 - 0x0048)
class UNavArea_HasBeenOpenedDoor final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_HasBeenOpenedDoor">();
	}
	static class UNavArea_HasBeenOpenedDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_HasBeenOpenedDoor>();
	}
};
static_assert(alignof(UNavArea_HasBeenOpenedDoor) == 0x000008, "Wrong alignment on UNavArea_HasBeenOpenedDoor");
static_assert(sizeof(UNavArea_HasBeenOpenedDoor) == 0x000048, "Wrong size on UNavArea_HasBeenOpenedDoor");

// Class ReadyOrNot.NavArea_WallTraversalHole
// 0x0000 (0x0048 - 0x0048)
class UNavArea_WallTraversalHole final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_WallTraversalHole">();
	}
	static class UNavArea_WallTraversalHole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_WallTraversalHole>();
	}
};
static_assert(alignof(UNavArea_WallTraversalHole) == 0x000008, "Wrong alignment on UNavArea_WallTraversalHole");
static_assert(sizeof(UNavArea_WallTraversalHole) == 0x000048, "Wrong size on UNavArea_WallTraversalHole");

// Class ReadyOrNot.NavArea_SwatBeta
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SwatBeta final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SwatBeta">();
	}
	static class UNavArea_SwatBeta* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SwatBeta>();
	}
};
static_assert(alignof(UNavArea_SwatBeta) == 0x000008, "Wrong alignment on UNavArea_SwatBeta");
static_assert(sizeof(UNavArea_SwatBeta) == 0x000048, "Wrong size on UNavArea_SwatBeta");

// Class ReadyOrNot.NavArea_SwatCharlie
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SwatCharlie final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SwatCharlie">();
	}
	static class UNavArea_SwatCharlie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SwatCharlie>();
	}
};
static_assert(alignof(UNavArea_SwatCharlie) == 0x000008, "Wrong alignment on UNavArea_SwatCharlie");
static_assert(sizeof(UNavArea_SwatCharlie) == 0x000048, "Wrong size on UNavArea_SwatCharlie");

// Class ReadyOrNot.NavArea_CivilianA
// 0x0000 (0x0048 - 0x0048)
class UNavArea_CivilianA final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_CivilianA">();
	}
	static class UNavArea_CivilianA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_CivilianA>();
	}
};
static_assert(alignof(UNavArea_CivilianA) == 0x000008, "Wrong alignment on UNavArea_CivilianA");
static_assert(sizeof(UNavArea_CivilianA) == 0x000048, "Wrong size on UNavArea_CivilianA");

// Class ReadyOrNot.NavArea_CivilianB
// 0x0000 (0x0048 - 0x0048)
class UNavArea_CivilianB final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_CivilianB">();
	}
	static class UNavArea_CivilianB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_CivilianB>();
	}
};
static_assert(alignof(UNavArea_CivilianB) == 0x000008, "Wrong alignment on UNavArea_CivilianB");
static_assert(sizeof(UNavArea_CivilianB) == 0x000048, "Wrong size on UNavArea_CivilianB");

// Class ReadyOrNot.NavArea_CivilianC
// 0x0000 (0x0048 - 0x0048)
class UNavArea_CivilianC final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_CivilianC">();
	}
	static class UNavArea_CivilianC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_CivilianC>();
	}
};
static_assert(alignof(UNavArea_CivilianC) == 0x000008, "Wrong alignment on UNavArea_CivilianC");
static_assert(sizeof(UNavArea_CivilianC) == 0x000048, "Wrong size on UNavArea_CivilianC");

// Class ReadyOrNot.NavArea_CivilianD
// 0x0000 (0x0048 - 0x0048)
class UNavArea_CivilianD final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_CivilianD">();
	}
	static class UNavArea_CivilianD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_CivilianD>();
	}
};
static_assert(alignof(UNavArea_CivilianD) == 0x000008, "Wrong alignment on UNavArea_CivilianD");
static_assert(sizeof(UNavArea_CivilianD) == 0x000048, "Wrong size on UNavArea_CivilianD");

// Class ReadyOrNot.NavArea_CivilianE
// 0x0000 (0x0048 - 0x0048)
class UNavArea_CivilianE final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_CivilianE">();
	}
	static class UNavArea_CivilianE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_CivilianE>();
	}
};
static_assert(alignof(UNavArea_CivilianE) == 0x000008, "Wrong alignment on UNavArea_CivilianE");
static_assert(sizeof(UNavArea_CivilianE) == 0x000048, "Wrong size on UNavArea_CivilianE");

// Class ReadyOrNot.NavArea_SuspectA
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SuspectA final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SuspectA">();
	}
	static class UNavArea_SuspectA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SuspectA>();
	}
};
static_assert(alignof(UNavArea_SuspectA) == 0x000008, "Wrong alignment on UNavArea_SuspectA");
static_assert(sizeof(UNavArea_SuspectA) == 0x000048, "Wrong size on UNavArea_SuspectA");

// Class ReadyOrNot.NavArea_SuspectB
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SuspectB final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SuspectB">();
	}
	static class UNavArea_SuspectB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SuspectB>();
	}
};
static_assert(alignof(UNavArea_SuspectB) == 0x000008, "Wrong alignment on UNavArea_SuspectB");
static_assert(sizeof(UNavArea_SuspectB) == 0x000048, "Wrong size on UNavArea_SuspectB");

// Class ReadyOrNot.NavArea_SuspectC
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SuspectC final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SuspectC">();
	}
	static class UNavArea_SuspectC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SuspectC>();
	}
};
static_assert(alignof(UNavArea_SuspectC) == 0x000008, "Wrong alignment on UNavArea_SuspectC");
static_assert(sizeof(UNavArea_SuspectC) == 0x000048, "Wrong size on UNavArea_SuspectC");

// Class ReadyOrNot.NavArea_SuspectE
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SuspectE final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SuspectE">();
	}
	static class UNavArea_SuspectE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SuspectE>();
	}
};
static_assert(alignof(UNavArea_SuspectE) == 0x000008, "Wrong alignment on UNavArea_SuspectE");
static_assert(sizeof(UNavArea_SuspectE) == 0x000048, "Wrong size on UNavArea_SuspectE");

// Class ReadyOrNot.NavArea_CSGas
// 0x0000 (0x0048 - 0x0048)
class UNavArea_CSGas final  : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_CSGas">();
	}
	static class UNavArea_CSGas* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_CSGas>();
	}
};
static_assert(alignof(UNavArea_CSGas) == 0x000008, "Wrong alignment on UNavArea_CSGas");
static_assert(sizeof(UNavArea_CSGas) == 0x000048, "Wrong size on UNavArea_CSGas");

// Class ReadyOrNot.ReadyOrNotNavigationSystem
// 0x0000 (0x15E0 - 0x15E0)
class UReadyOrNotNavigationSystem final  : public UNavigationSystemV1
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotNavigationSystem">();
	}
	static class UReadyOrNotNavigationSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotNavigationSystem>();
	}
};
static_assert(alignof(UReadyOrNotNavigationSystem) == 0x000008, "Wrong alignment on UReadyOrNotNavigationSystem");
static_assert(sizeof(UReadyOrNotNavigationSystem) == 0x0015E0, "Wrong size on UReadyOrNotNavigationSystem");

// Class ReadyOrNot.NavQuery_DoorTest
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_DoorTest final  : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_DoorTest">();
	}
	static class UNavQuery_DoorTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_DoorTest>();
	}
};
static_assert(alignof(UNavQuery_DoorTest) == 0x000008, "Wrong alignment on UNavQuery_DoorTest");
static_assert(sizeof(UNavQuery_DoorTest) == 0x000048, "Wrong size on UNavQuery_DoorTest");

// Class ReadyOrNot.NavQuery_SwatFallIn
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_SwatFallIn final  : public UNavQuery_Swat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_SwatFallIn">();
	}
	static class UNavQuery_SwatFallIn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_SwatFallIn>();
	}
};
static_assert(alignof(UNavQuery_SwatFallIn) == 0x000008, "Wrong alignment on UNavQuery_SwatFallIn");
static_assert(sizeof(UNavQuery_SwatFallIn) == 0x000048, "Wrong size on UNavQuery_SwatFallIn");

// Class ReadyOrNot.NavQuery_SwatBreachAndClear
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_SwatBreachAndClear final  : public UNavQuery_Swat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_SwatBreachAndClear">();
	}
	static class UNavQuery_SwatBreachAndClear* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_SwatBreachAndClear>();
	}
};
static_assert(alignof(UNavQuery_SwatBreachAndClear) == 0x000008, "Wrong alignment on UNavQuery_SwatBreachAndClear");
static_assert(sizeof(UNavQuery_SwatBreachAndClear) == 0x000048, "Wrong size on UNavQuery_SwatBreachAndClear");

// Class ReadyOrNot.NavQuery_SwatAlpha
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_SwatAlpha final  : public UNavQuery_Swat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_SwatAlpha">();
	}
	static class UNavQuery_SwatAlpha* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_SwatAlpha>();
	}
};
static_assert(alignof(UNavQuery_SwatAlpha) == 0x000008, "Wrong alignment on UNavQuery_SwatAlpha");
static_assert(sizeof(UNavQuery_SwatAlpha) == 0x000048, "Wrong size on UNavQuery_SwatAlpha");

// Class ReadyOrNot.NavQuery_SwatBeta
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_SwatBeta final  : public UNavQuery_Swat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_SwatBeta">();
	}
	static class UNavQuery_SwatBeta* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_SwatBeta>();
	}
};
static_assert(alignof(UNavQuery_SwatBeta) == 0x000008, "Wrong alignment on UNavQuery_SwatBeta");
static_assert(sizeof(UNavQuery_SwatBeta) == 0x000048, "Wrong size on UNavQuery_SwatBeta");

// Class ReadyOrNot.NavQuery_SwatCharlie
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_SwatCharlie final  : public UNavQuery_Swat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_SwatCharlie">();
	}
	static class UNavQuery_SwatCharlie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_SwatCharlie>();
	}
};
static_assert(alignof(UNavQuery_SwatCharlie) == 0x000008, "Wrong alignment on UNavQuery_SwatCharlie");
static_assert(sizeof(UNavQuery_SwatCharlie) == 0x000048, "Wrong size on UNavQuery_SwatCharlie");

// Class ReadyOrNot.NavQuery_Civilian
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_Civilian final  : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_Civilian">();
	}
	static class UNavQuery_Civilian* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_Civilian>();
	}
};
static_assert(alignof(UNavQuery_Civilian) == 0x000008, "Wrong alignment on UNavQuery_Civilian");
static_assert(sizeof(UNavQuery_Civilian) == 0x000048, "Wrong size on UNavQuery_Civilian");

// Class ReadyOrNot.NavQuery_Suspect
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_Suspect final  : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_Suspect">();
	}
	static class UNavQuery_Suspect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_Suspect>();
	}
};
static_assert(alignof(UNavQuery_Suspect) == 0x000008, "Wrong alignment on UNavQuery_Suspect");
static_assert(sizeof(UNavQuery_Suspect) == 0x000048, "Wrong size on UNavQuery_Suspect");

// Class ReadyOrNot.NavQuery_FlankingSuspect
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_FlankingSuspect final  : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_FlankingSuspect">();
	}
	static class UNavQuery_FlankingSuspect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_FlankingSuspect>();
	}
};
static_assert(alignof(UNavQuery_FlankingSuspect) == 0x000008, "Wrong alignment on UNavQuery_FlankingSuspect");
static_assert(sizeof(UNavQuery_FlankingSuspect) == 0x000048, "Wrong size on UNavQuery_FlankingSuspect");

// Class ReadyOrNot.NavQuery_NoiseCheck
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_NoiseCheck final  : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_NoiseCheck">();
	}
	static class UNavQuery_NoiseCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_NoiseCheck>();
	}
};
static_assert(alignof(UNavQuery_NoiseCheck) == 0x000008, "Wrong alignment on UNavQuery_NoiseCheck");
static_assert(sizeof(UNavQuery_NoiseCheck) == 0x000048, "Wrong size on UNavQuery_NoiseCheck");

// Class ReadyOrNot.NavQuery_CSGas
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_CSGas final  : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_CSGas">();
	}
	static class UNavQuery_CSGas* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_CSGas>();
	}
};
static_assert(alignof(UNavQuery_CSGas) == 0x000008, "Wrong alignment on UNavQuery_CSGas");
static_assert(sizeof(UNavQuery_CSGas) == 0x000048, "Wrong size on UNavQuery_CSGas");

// Class ReadyOrNot.NavQuery_Awareness
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_Awareness final  : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_Awareness">();
	}
	static class UNavQuery_Awareness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_Awareness>();
	}
};
static_assert(alignof(UNavQuery_Awareness) == 0x000008, "Wrong alignment on UNavQuery_Awareness");
static_assert(sizeof(UNavQuery_Awareness) == 0x000048, "Wrong size on UNavQuery_Awareness");

// Class ReadyOrNot.ReadyOrNotPlayerCameraManager
// 0x0000 (0x2810 - 0x2810)
class AReadyOrNotPlayerCameraManager final  : public APlayerCameraManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotPlayerCameraManager">();
	}
	static class AReadyOrNotPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotPlayerCameraManager>();
	}
};
static_assert(alignof(AReadyOrNotPlayerCameraManager) == 0x000010, "Wrong alignment on AReadyOrNotPlayerCameraManager");
static_assert(sizeof(AReadyOrNotPlayerCameraManager) == 0x002810, "Wrong size on AReadyOrNotPlayerCameraManager");

// Class ReadyOrNot.ReadyOrNotPlayerState
// 0x0700 (0x0A20 - 0x0320)
class AReadyOrNotPlayerState final  : public APlayerState
{
public:
	uint8                                         Pad_287C[0x18];                                    // 0x0320(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasFinishedLoading;                               // 0x0338(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_287D[0x3];                                     // 0x0339(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Kills;                                             // 0x033C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillsThisLife;                                     // 0x0340(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamKills;                                         // 0x0344(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Arrests;                                           // 0x0348(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimesArrested;                                     // 0x034C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArrestsThisLife;                                   // 0x0350(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Objectives;                                        // 0x0354(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Reports;                                           // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Evidence;                                          // 0x035C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AEvidenceActor*>                 EvidenceActorsInPossession;                        // 0x0360(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_287E[0x8];                                     // 0x0370(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       LastCharacter;                                     // 0x0378(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DeathDamageType;                                   // 0x0380(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseMagazineWeapon*                    DeathWeapon;                                       // 0x0388(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFireMode                                     LastFireMode;                                      // 0x0390(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeadToPointDamage;                                // 0x0391(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_287F[0x2];                                     // 0x0392(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             DeathTraceHit;                                     // 0x0394(0x0088)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2880[0x4];                                     // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       DeathKiller;                                       // 0x0420(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Deaths;                                            // 0x0428(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Incapacitations;                                   // 0x042C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageDealt;                                       // 0x0430(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReceived;                                    // 0x0434(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerSpawnTag;                                    // 0x0438(0x0010)(BlueprintVisible, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2881[0x4];                                     // 0x0448(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BulletsFired;                                      // 0x044C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BulletsFiredThisLife;                              // 0x0450(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeamType                                     Team;                                              // 0x0454(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2882[0x3];                                     // 0x0455(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedLoadout                          ServerSavedLoadout;                                // 0x0458(0x0188)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerLoadoutChanged;                            // 0x05E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2883[0x1];                                     // 0x05F0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bReady;                                            // 0x05F1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSquadLeader;                                      // 0x05F2(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2884[0x5];                                     // 0x05F3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedLoadout                          LastLoadout;                                       // 0x05F8(0x0188)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	float                                         PointsFromKills;                                   // 0x0780(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointsFromDamage;                                  // 0x0784(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointsFromArrests;                                 // 0x0788(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointsFromObjective;                               // 0x078C(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointsFromReportingKills;                          // 0x0790(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointsFromReportingArrests;                        // 0x0794(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInGame;                                         // 0x0798(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJoinInProgress;                                   // 0x0799(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVIP;                                            // 0x079A(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasVIP;                                           // 0x079B(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GrenadesThrown;                                    // 0x079C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalYells;                                        // 0x07A0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOrdersGiven;                                 // 0x07A4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletsHit;                                        // 0x07A8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletsHitThisLife;                                // 0x07AC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Headshots;                                         // 0x07B0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeAlive;                                         // 0x07B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2885[0x8];                                     // 0x07B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EVoiceType                                    VoiceType;                                         // 0x07C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTalking;                                        // 0x07C1(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2886[0x6];                                     // 0x07C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnVoiceChannelChanged;                             // 0x07C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2887[0x8];                                     // 0x07D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTorsoInjured;                                     // 0x07E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeftArmInjured;                                   // 0x07E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRightArmInjured;                                  // 0x07E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeftLegInjured;                                   // 0x07E3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRightLegInjured;                                  // 0x07E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeadInjured;                                      // 0x07E5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2888[0x2];                                     // 0x07E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BulletsBlocked;                                    // 0x07E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitsReceived;                                      // 0x07EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2889[0x10];                                    // 0x07F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsReplaySpectator;                                // 0x0800(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_288A[0x3];                                     // 0x0801(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlanningPlayerNumber;                              // 0x0804(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlanningDrawingArray                  DrawingArray;                                      // 0x0808(0x0118)(Net, NativeAccessSpecifierPublic)
	struct FPlanningDrawing                       CurrentDrawing;                                    // 0x0920(0x0028)(Net, NativeAccessSpecifierPublic)
	struct FSavedCustomization                    Customization;                                     // 0x0948(0x00D0)(Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_288B[0x8];                                     // 0x0A18(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool HasEveryoneFinishedLoading(int32* OutTotal, int32* OutLoading, int32* OutLoaded);

	int32 GetDeathCount();
	int32 GetKillCount();
	void GetNetworkStatus(float* AvgLag);
	ETeamType GetPendingTeam();
	ETeamType GetTeam();
	EVoiceType GetVoiceType();
	void IncrementBulletsFired(class ABaseWeapon* Weapon);
	bool IsOwnerOfPlayerState();
	bool IsSquadLeader();
	bool IsVipPlayerState();
	void Notify_PendingChangeTeam(ETeamType NewTeamType);
	void OnPlayerLoadoutChanged__DelegateSignature(const struct FSavedLoadout& NewLoadout);
	void OnRep_Customization();
	void OnRep_UpdateServerSavedLoadout();
	void OnRep_VoiceType();
	void OnVoiceChannelChanged__DelegateSignature();
	void ResetBulletsFired();
	void Server_FinishDrawing();
	void Server_SendUnlockedDLC(EGameVersionRestriction Dlc);
	void Server_SetCustomization(const struct FSavedCustomization& InCustomization);
	void Server_SetIsInGame(bool bNewIsInGame);
	void Server_SetLoadout(const struct FSavedLoadout& NewLoadout);
	void Server_SetPlayerName(class FName NewPlayerName);
	void Server_SetReady(bool bIsReady, const struct FSavedLoadout& NewLoadout);
	void Server_SetTeam(ETeamType NewTeam);
	void Server_SetVoiceType(EVoiceType NewVoiceType);
	void Server_StartDrawing(int32 Floor, const struct FVector2D& StartingPoint);
	void Server_UpdateDrawing(const struct FVector2D& NewPoint);
	void Server_UpdatePlayerSpawnTag(const class FString& NewTag);
	void ServerSetJoinedOnSquadLeader();
	void SetIsTalking(bool bNewTalking);
	void SetReady(bool bIsReady, const struct FSavedLoadout& NewLoadout);
	void SetTeam(ETeamType NewTeam);
	void UpdateScore();

	int32 GetPlanningPlayerNumber() const;
	bool IsTalking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotPlayerState">();
	}
	static class AReadyOrNotPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotPlayerState>();
	}
};
static_assert(alignof(AReadyOrNotPlayerState) == 0x000008, "Wrong alignment on AReadyOrNotPlayerState");
static_assert(sizeof(AReadyOrNotPlayerState) == 0x000A20, "Wrong size on AReadyOrNotPlayerState");
static_assert(offsetof(AReadyOrNotPlayerState, bHasFinishedLoading) == 0x000338, "Member 'AReadyOrNotPlayerState::bHasFinishedLoading' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Kills) == 0x00033C, "Member 'AReadyOrNotPlayerState::Kills' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, KillsThisLife) == 0x000340, "Member 'AReadyOrNotPlayerState::KillsThisLife' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, TeamKills) == 0x000344, "Member 'AReadyOrNotPlayerState::TeamKills' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Arrests) == 0x000348, "Member 'AReadyOrNotPlayerState::Arrests' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, TimesArrested) == 0x00034C, "Member 'AReadyOrNotPlayerState::TimesArrested' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, ArrestsThisLife) == 0x000350, "Member 'AReadyOrNotPlayerState::ArrestsThisLife' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Objectives) == 0x000354, "Member 'AReadyOrNotPlayerState::Objectives' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Reports) == 0x000358, "Member 'AReadyOrNotPlayerState::Reports' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Evidence) == 0x00035C, "Member 'AReadyOrNotPlayerState::Evidence' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, EvidenceActorsInPossession) == 0x000360, "Member 'AReadyOrNotPlayerState::EvidenceActorsInPossession' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, LastCharacter) == 0x000378, "Member 'AReadyOrNotPlayerState::LastCharacter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, DeathDamageType) == 0x000380, "Member 'AReadyOrNotPlayerState::DeathDamageType' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, DeathWeapon) == 0x000388, "Member 'AReadyOrNotPlayerState::DeathWeapon' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, LastFireMode) == 0x000390, "Member 'AReadyOrNotPlayerState::LastFireMode' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bDeadToPointDamage) == 0x000391, "Member 'AReadyOrNotPlayerState::bDeadToPointDamage' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, DeathTraceHit) == 0x000394, "Member 'AReadyOrNotPlayerState::DeathTraceHit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, DeathKiller) == 0x000420, "Member 'AReadyOrNotPlayerState::DeathKiller' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Deaths) == 0x000428, "Member 'AReadyOrNotPlayerState::Deaths' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Incapacitations) == 0x00042C, "Member 'AReadyOrNotPlayerState::Incapacitations' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, DamageDealt) == 0x000430, "Member 'AReadyOrNotPlayerState::DamageDealt' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, DamageReceived) == 0x000434, "Member 'AReadyOrNotPlayerState::DamageReceived' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PlayerSpawnTag) == 0x000438, "Member 'AReadyOrNotPlayerState::PlayerSpawnTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, BulletsFired) == 0x00044C, "Member 'AReadyOrNotPlayerState::BulletsFired' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, BulletsFiredThisLife) == 0x000450, "Member 'AReadyOrNotPlayerState::BulletsFiredThisLife' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Team) == 0x000454, "Member 'AReadyOrNotPlayerState::Team' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, ServerSavedLoadout) == 0x000458, "Member 'AReadyOrNotPlayerState::ServerSavedLoadout' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, OnPlayerLoadoutChanged) == 0x0005E0, "Member 'AReadyOrNotPlayerState::OnPlayerLoadoutChanged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bReady) == 0x0005F1, "Member 'AReadyOrNotPlayerState::bReady' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bSquadLeader) == 0x0005F2, "Member 'AReadyOrNotPlayerState::bSquadLeader' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, LastLoadout) == 0x0005F8, "Member 'AReadyOrNotPlayerState::LastLoadout' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PointsFromKills) == 0x000780, "Member 'AReadyOrNotPlayerState::PointsFromKills' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PointsFromDamage) == 0x000784, "Member 'AReadyOrNotPlayerState::PointsFromDamage' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PointsFromArrests) == 0x000788, "Member 'AReadyOrNotPlayerState::PointsFromArrests' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PointsFromObjective) == 0x00078C, "Member 'AReadyOrNotPlayerState::PointsFromObjective' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PointsFromReportingKills) == 0x000790, "Member 'AReadyOrNotPlayerState::PointsFromReportingKills' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PointsFromReportingArrests) == 0x000794, "Member 'AReadyOrNotPlayerState::PointsFromReportingArrests' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bIsInGame) == 0x000798, "Member 'AReadyOrNotPlayerState::bIsInGame' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bJoinInProgress) == 0x000799, "Member 'AReadyOrNotPlayerState::bJoinInProgress' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bIsVIP) == 0x00079A, "Member 'AReadyOrNotPlayerState::bIsVIP' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bWasVIP) == 0x00079B, "Member 'AReadyOrNotPlayerState::bWasVIP' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, GrenadesThrown) == 0x00079C, "Member 'AReadyOrNotPlayerState::GrenadesThrown' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, TotalYells) == 0x0007A0, "Member 'AReadyOrNotPlayerState::TotalYells' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, NumberOrdersGiven) == 0x0007A4, "Member 'AReadyOrNotPlayerState::NumberOrdersGiven' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, BulletsHit) == 0x0007A8, "Member 'AReadyOrNotPlayerState::BulletsHit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, BulletsHitThisLife) == 0x0007AC, "Member 'AReadyOrNotPlayerState::BulletsHitThisLife' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Headshots) == 0x0007B0, "Member 'AReadyOrNotPlayerState::Headshots' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, TimeAlive) == 0x0007B4, "Member 'AReadyOrNotPlayerState::TimeAlive' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, VoiceType) == 0x0007C0, "Member 'AReadyOrNotPlayerState::VoiceType' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bIsTalking) == 0x0007C1, "Member 'AReadyOrNotPlayerState::bIsTalking' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, OnVoiceChannelChanged) == 0x0007C8, "Member 'AReadyOrNotPlayerState::OnVoiceChannelChanged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bTorsoInjured) == 0x0007E0, "Member 'AReadyOrNotPlayerState::bTorsoInjured' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bLeftArmInjured) == 0x0007E1, "Member 'AReadyOrNotPlayerState::bLeftArmInjured' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bRightArmInjured) == 0x0007E2, "Member 'AReadyOrNotPlayerState::bRightArmInjured' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bLeftLegInjured) == 0x0007E3, "Member 'AReadyOrNotPlayerState::bLeftLegInjured' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bRightLegInjured) == 0x0007E4, "Member 'AReadyOrNotPlayerState::bRightLegInjured' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bHeadInjured) == 0x0007E5, "Member 'AReadyOrNotPlayerState::bHeadInjured' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, BulletsBlocked) == 0x0007E8, "Member 'AReadyOrNotPlayerState::BulletsBlocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, HitsReceived) == 0x0007EC, "Member 'AReadyOrNotPlayerState::HitsReceived' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bIsReplaySpectator) == 0x000800, "Member 'AReadyOrNotPlayerState::bIsReplaySpectator' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PlanningPlayerNumber) == 0x000804, "Member 'AReadyOrNotPlayerState::PlanningPlayerNumber' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, DrawingArray) == 0x000808, "Member 'AReadyOrNotPlayerState::DrawingArray' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, CurrentDrawing) == 0x000920, "Member 'AReadyOrNotPlayerState::CurrentDrawing' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Customization) == 0x000948, "Member 'AReadyOrNotPlayerState::Customization' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotRecastNavMesh
// 0x0008 (0x05B0 - 0x05A8)
class AReadyOrNotRecastNavMesh final  : public ANotifyingRecastNavMesh
{
public:
	bool                                          bDrawStairPoints;                                  // 0x05A8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_288F[0x7];                                     // 0x05A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotRecastNavMesh">();
	}
	static class AReadyOrNotRecastNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotRecastNavMesh>();
	}
};
static_assert(alignof(AReadyOrNotRecastNavMesh) == 0x000008, "Wrong alignment on AReadyOrNotRecastNavMesh");
static_assert(sizeof(AReadyOrNotRecastNavMesh) == 0x0005B0, "Wrong size on AReadyOrNotRecastNavMesh");
static_assert(offsetof(AReadyOrNotRecastNavMesh, bDrawStairPoints) == 0x0005A8, "Member 'AReadyOrNotRecastNavMesh::bDrawStairPoints' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotSignificanceManager
// 0x0210 (0x0250 - 0x0040)
class UReadyOrNotSignificanceManager final  : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_2890[0x18];                                    // 0x0040(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsMadeIrrelevantThisFrame;                     // 0x0058(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         ActorsMadeRelevantThisFrame;                       // 0x0068(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         ActorsMadeIrrelevant;                              // 0x0078(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2891[0x8];                                     // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsRelevantToSignificance;                      // 0x0090(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AReadyOrNotCharacter*>           CharactersRelevantToSignificance;                  // 0x00A0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class USkeletalMeshComponent*, class USkeletalMesh*> SkeletalMeshLookupMap;                             // 0x00B0(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class USceneComponent*, struct FOptimizationAttachmentData> SceneCompAttachmentData;                           // 0x0100(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UStaticMeshComponent*, class UStaticMesh*> StaticMeshLookupMap;                               // 0x0150(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class AReadyOrNotCharacter*>           IrrelevantPlayerCharacters;                        // 0x01A0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2892[0x70];                                    // 0x01B0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     RelevantViewpoints;                                // 0x0220(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         PlayerViewTargets;                                 // 0x0230(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2893[0x10];                                    // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotSignificanceManager">();
	}
	static class UReadyOrNotSignificanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotSignificanceManager>();
	}
};
static_assert(alignof(UReadyOrNotSignificanceManager) == 0x000008, "Wrong alignment on UReadyOrNotSignificanceManager");
static_assert(sizeof(UReadyOrNotSignificanceManager) == 0x000250, "Wrong size on UReadyOrNotSignificanceManager");
static_assert(offsetof(UReadyOrNotSignificanceManager, ActorsMadeIrrelevantThisFrame) == 0x000058, "Member 'UReadyOrNotSignificanceManager::ActorsMadeIrrelevantThisFrame' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, ActorsMadeRelevantThisFrame) == 0x000068, "Member 'UReadyOrNotSignificanceManager::ActorsMadeRelevantThisFrame' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, ActorsMadeIrrelevant) == 0x000078, "Member 'UReadyOrNotSignificanceManager::ActorsMadeIrrelevant' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, ActorsRelevantToSignificance) == 0x000090, "Member 'UReadyOrNotSignificanceManager::ActorsRelevantToSignificance' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, CharactersRelevantToSignificance) == 0x0000A0, "Member 'UReadyOrNotSignificanceManager::CharactersRelevantToSignificance' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, SkeletalMeshLookupMap) == 0x0000B0, "Member 'UReadyOrNotSignificanceManager::SkeletalMeshLookupMap' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, SceneCompAttachmentData) == 0x000100, "Member 'UReadyOrNotSignificanceManager::SceneCompAttachmentData' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, StaticMeshLookupMap) == 0x000150, "Member 'UReadyOrNotSignificanceManager::StaticMeshLookupMap' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, IrrelevantPlayerCharacters) == 0x0001A0, "Member 'UReadyOrNotSignificanceManager::IrrelevantPlayerCharacters' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, RelevantViewpoints) == 0x000220, "Member 'UReadyOrNotSignificanceManager::RelevantViewpoints' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, PlayerViewTargets) == 0x000230, "Member 'UReadyOrNotSignificanceManager::PlayerViewTargets' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotStatics
// 0x0000 (0x0028 - 0x0028)
class UReadyOrNotStatics final  : public UBlueprintFunctionLibrary
{
public:
	static bool DoesMapExist(const class FString& Map);
	static class AConversationManager* GetConversationManager();
	static class UReadyOrNotGameInstance* GetReadyOrNotGameInstance();
	static class AReadyOrNotGameMode* GetReadyOrNotGameMode();
	static class AReadyOrNotGameState* GetReadyOrNotGameState();
	static class AReadyOrNotLevelScript* GetReadyOrNotLevelScript();
	static class AReadyOrNotPlayerController* GetReadyOrNotPlayerController();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotStatics">();
	}
	static class UReadyOrNotStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotStatics>();
	}
};
static_assert(alignof(UReadyOrNotStatics) == 0x000008, "Wrong alignment on UReadyOrNotStatics");
static_assert(sizeof(UReadyOrNotStatics) == 0x000028, "Wrong size on UReadyOrNotStatics");

// Class ReadyOrNot.ReadyOrNotVoiceConfig
// 0x00B0 (0x00D8 - 0x0028)
class UReadyOrNotVoiceConfig final  : public UGameplayConfig
{
public:
	TMap<class FString, struct FSequencedVOLookup> SequencedLookup;                                   // 0x0028(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2895[0x60];                                    // 0x0078(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UReadyOrNotVoiceConfig* Get();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotVoiceConfig">();
	}
	static class UReadyOrNotVoiceConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotVoiceConfig>();
	}
};
static_assert(alignof(UReadyOrNotVoiceConfig) == 0x000008, "Wrong alignment on UReadyOrNotVoiceConfig");
static_assert(sizeof(UReadyOrNotVoiceConfig) == 0x0000D8, "Wrong size on UReadyOrNotVoiceConfig");
static_assert(offsetof(UReadyOrNotVoiceConfig, SequencedLookup) == 0x000028, "Member 'UReadyOrNotVoiceConfig::SequencedLookup' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotWeaponAnimData
// 0x1048 (0x1078 - 0x0030)
class UReadyOrNotWeaponAnimData final  : public UDataAsset
{
public:
	class UAnimSequenceBase*                      IdlePose_FP;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_FP;                                           // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Run_FP;                                            // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Walk_FP;                                           // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Run_Limp_FP;                                       // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Walk_Limp_FP;                                      // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        Look_BS_FP;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Lowered_Up_Pose_FP;                                // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Lowered_Down_Pose_FP;                              // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      ADS_Run_FP;                                        // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      ADS_Walk_FP;                                       // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      ADS_Run_Limp_FP;                                   // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      ADS_Walk_Limp_FP;                                  // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_AFG_FP;                                   // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_VFG_FP;                                   // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_HSTOP_FP;                                 // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_Low_TP;                                   // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_Up_TP;                                    // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_Shld_TP;                                  // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_Sights_TP;                                // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_Ret_TP;                                   // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_Ovr_TP;                                   // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_IdlePose_Low_TP;                            // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_IdlePose_Up_TP;                             // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_IdlePose_Shld_TP;                           // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_IdlePose_Sights_TP;                         // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_IdlePose_Ret_TP;                            // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_IdlePose_Ovr_TP;                            // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload;                                            // 0x0110(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReloadEmpty;                                       // 0x0130(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Reload;                                     // 0x0150(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_ReloadEmpty;                                // 0x0170(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Tactical_Reload;                                   // 0x0190(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Tactical_ReloadEmpty;                              // 0x01B0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponAnim>                    ShellRack_Reload;                                  // 0x01D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponAnim>                    ShellRack_ReloadEmpty;                             // 0x01E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponAnim>                    ShellRack_ReloadRack;                              // 0x01F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Tactical_Crouch_Reload;                            // 0x0200(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Tactical_Crouch_ReloadEmpty;                       // 0x0220(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            MeleeHit;                                          // 0x0240(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            MeleeMiss;                                         // 0x0260(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireSelect_Auto;                                   // 0x0280(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireSelect_Burst;                                  // 0x02A0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireSelect_Semi;                                   // 0x02C0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireSelect_Safe;                                   // 0x02E0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireSelect_Auto;                            // 0x0300(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireSelect_Burst;                           // 0x0320(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireSelect_Semi;                            // 0x0340(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireSelect_Safe;                            // 0x0360(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_Start;                                      // 0x0380(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_Loop;                                       // 0x03A0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_End;                                        // 0x03C0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_Start_Empty;                                // 0x03E0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_Loop_Empty;                                 // 0x0400(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_End_Empty;                                  // 0x0420(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Reload_Start;                               // 0x0440(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Reload_Loop;                                // 0x0460(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Reload_End;                                 // 0x0480(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Reload_Start_Empty;                         // 0x04A0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Reload_Loop_Empty;                          // 0x04C0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Reload_End_Empty;                           // 0x04E0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            MagazineCheck;                                     // 0x0500(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_MagazineCheck;                              // 0x0520(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            MagazineCheckSights;                               // 0x0540(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_MagazineCheckSights;                        // 0x0560(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponAnim>                    FireSingle;                                        // 0x0580(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponAnim>                    FireSingleSights;                                  // 0x0590(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireSingleLast;                                    // 0x05A0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireSingleSightsLast;                              // 0x05C0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            DryFire;                                           // 0x05E0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponAnim>                    Crouch_FireSingle;                                 // 0x0600(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponAnim>                    Crouch_FireSingleSights;                           // 0x0610(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireSingleLast;                             // 0x0620(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireSingleSightsLast;                       // 0x0640(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Dryfire;                                    // 0x0660(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireLoop;                                          // 0x0680(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireLoopEnd;                                       // 0x06A0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireLoopSights;                                    // 0x06C0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireLoopSightsEnd;                                 // 0x06E0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireLoop;                                   // 0x0700(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireLoopEnd;                                // 0x0720(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireLoopSights;                             // 0x0740(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireLoopSightsEnd;                          // 0x0760(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Draw;                                              // 0x0780(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            DrawFirst;                                         // 0x07A0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Draw;                                       // 0x07C0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_DrawFirst;                                  // 0x07E0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Holster;                                           // 0x0800(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Holster;                                    // 0x0820(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            PullPin;                                           // 0x0840(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Throw;                                             // 0x0860(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            PullPinUnderarm;                                   // 0x0880(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ThrowUnderarm;                                     // 0x08A0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_PullPin;                                    // 0x08C0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Throw;                                      // 0x08E0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_PullPinUnderarm;                            // 0x0900(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_ThrowUnderarm;                              // 0x0920(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            QuickThrow_PinPull;                                // 0x0940(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Quickthrow_Throw;                                  // 0x0960(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_QuickThrow_PinPull;                         // 0x0980(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_QuickThrow_Throw;                           // 0x09A0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            QuickThrow_Fast;                                   // 0x09C0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_QuickThrow_Fast;                            // 0x09E0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Multitool_Use;                                     // 0x0A00(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Multitool_Use_End;                                 // 0x0A20(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Multitool_Cutters_To_Lockpick;                     // 0x0A40(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Multitool_Cutters_To_Knife;                        // 0x0A60(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Multitool_Lockpick_To_Cutters;                     // 0x0A80(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Multitool_Lockpick_To_Knife;                       // 0x0AA0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Multitool_Knife_To_Lockpick;                       // 0x0AC0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Multitool_Knife_To_Cutters;                        // 0x0AE0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Optiwand_Start_Screening;                          // 0x0B00(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Optiwand_End_Screening;                            // 0x0B20(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Charge_Valid_Plant_Start;                          // 0x0B40(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Charge_Valid_Plant_End;                            // 0x0B60(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            PlantCharge;                                       // 0x0B80(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            DetonateCharge;                                    // 0x0BA0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            EnableNVG;                                         // 0x0BC0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            DisableNVG;                                        // 0x0BE0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ShieldDownToUp;                                    // 0x0C00(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ShieldUpToDown;                                    // 0x0C20(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_ShieldDownToUp;                             // 0x0C40(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_ShieldUpToDown;                             // 0x0C60(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ShieldHit;                                         // 0x0C80(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            TabletDownToUp;                                    // 0x0CA0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            TabletUpToDown;                                    // 0x0CC0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            TabletSwitchCameraDown;                            // 0x0CE0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            TabletSwitchCameraUp;                              // 0x0D00(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            EvidencePickup;                                    // 0x0D20(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Yell;                                              // 0x0D40(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            RadioSelect;                                       // 0x0D60(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRadioUsesNotifies;                                // 0x0D80(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2896[0x7];                                     // 0x0D81(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponAnim                            DoorPush;                                          // 0x0D88(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ButtonPush;                                        // 0x0DA8(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            WeaponClearing;                                    // 0x0DC8(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToSting;                                      // 0x0DE8(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToFlash;                                      // 0x0E08(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToTaser;                                      // 0x0E28(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToGas;                                        // 0x0E48(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToPepperSpray;                                // 0x0E68(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToSting_End;                                  // 0x0E88(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToFlash_End;                                  // 0x0EA8(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToTaser_End;                                  // 0x0EC8(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToGas_End;                                    // 0x0EE8(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToPepperSpray_End;                            // 0x0F08(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_Level_01;                                   // 0x0F28(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_Level_02;                                   // 0x0F48(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_Level_03;                                   // 0x0F68(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Recoil_Level_01;                                   // 0x0F88(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Recoil_Level_02;                                   // 0x0FA8(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Recoil_Level_03;                                   // 0x0FC8(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Grip_VFG_Body_FP_Fire;                             // 0x0FE8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Grip_VFG_Body_FP_Fire_Last;                        // 0x0FF0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Grip_VFG_Body_FP_Fire_Aim;                         // 0x0FF8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Grip_VFG_Body_FP_Fire_Aim_Last;                    // 0x1000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Grip_AFG_Body_FP_Fire;                             // 0x1008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Grip_AFG_Body_FP_Fire_Last;                        // 0x1010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Grip_AFG_Body_FP_Fire_Aim;                         // 0x1018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Grip_AFG_Body_FP_Fire_Aim_Last;                    // 0x1020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Reload_FP_Ads;                                     // 0x1028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReloadEmpty_FP_Ads;                                // 0x1030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Tactical_Reload_FP_Ads;                            // 0x1038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Tactical_ReloadEmpty_FP_Ads;                       // 0x1040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEmptyReload;                                      // 0x1048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasRetentionAdditives;                            // 0x1049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLoweredAdditives;                              // 0x104A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSightAdditives;                                // 0x104B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideFireAnimForGrip;                          // 0x104C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2897[0x3];                                     // 0x104D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      IdlePose_AFG_TP;                                   // 0x1050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_VFG_TP;                                   // 0x1058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_HSTOP_TP;                                 // 0x1060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_AI_Calm;                                  // 0x1068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_AI_Aiming;                                // 0x1070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotWeaponAnimData">();
	}
	static class UReadyOrNotWeaponAnimData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotWeaponAnimData>();
	}
};
static_assert(alignof(UReadyOrNotWeaponAnimData) == 0x000008, "Wrong alignment on UReadyOrNotWeaponAnimData");
static_assert(sizeof(UReadyOrNotWeaponAnimData) == 0x001078, "Wrong size on UReadyOrNotWeaponAnimData");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_FP) == 0x000030, "Member 'UReadyOrNotWeaponAnimData::IdlePose_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Idle_FP) == 0x000038, "Member 'UReadyOrNotWeaponAnimData::Idle_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Run_FP) == 0x000040, "Member 'UReadyOrNotWeaponAnimData::Run_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Walk_FP) == 0x000048, "Member 'UReadyOrNotWeaponAnimData::Walk_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Run_Limp_FP) == 0x000050, "Member 'UReadyOrNotWeaponAnimData::Run_Limp_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Walk_Limp_FP) == 0x000058, "Member 'UReadyOrNotWeaponAnimData::Walk_Limp_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Look_BS_FP) == 0x000060, "Member 'UReadyOrNotWeaponAnimData::Look_BS_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Lowered_Up_Pose_FP) == 0x000068, "Member 'UReadyOrNotWeaponAnimData::Lowered_Up_Pose_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Lowered_Down_Pose_FP) == 0x000070, "Member 'UReadyOrNotWeaponAnimData::Lowered_Down_Pose_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ADS_Run_FP) == 0x000078, "Member 'UReadyOrNotWeaponAnimData::ADS_Run_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ADS_Walk_FP) == 0x000080, "Member 'UReadyOrNotWeaponAnimData::ADS_Walk_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ADS_Run_Limp_FP) == 0x000088, "Member 'UReadyOrNotWeaponAnimData::ADS_Run_Limp_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ADS_Walk_Limp_FP) == 0x000090, "Member 'UReadyOrNotWeaponAnimData::ADS_Walk_Limp_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_AFG_FP) == 0x000098, "Member 'UReadyOrNotWeaponAnimData::IdlePose_AFG_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_VFG_FP) == 0x0000A0, "Member 'UReadyOrNotWeaponAnimData::IdlePose_VFG_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_HSTOP_FP) == 0x0000A8, "Member 'UReadyOrNotWeaponAnimData::IdlePose_HSTOP_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_Low_TP) == 0x0000B0, "Member 'UReadyOrNotWeaponAnimData::IdlePose_Low_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_Up_TP) == 0x0000B8, "Member 'UReadyOrNotWeaponAnimData::IdlePose_Up_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_Shld_TP) == 0x0000C0, "Member 'UReadyOrNotWeaponAnimData::IdlePose_Shld_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_Sights_TP) == 0x0000C8, "Member 'UReadyOrNotWeaponAnimData::IdlePose_Sights_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_Ret_TP) == 0x0000D0, "Member 'UReadyOrNotWeaponAnimData::IdlePose_Ret_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_Ovr_TP) == 0x0000D8, "Member 'UReadyOrNotWeaponAnimData::IdlePose_Ovr_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_IdlePose_Low_TP) == 0x0000E0, "Member 'UReadyOrNotWeaponAnimData::Crouch_IdlePose_Low_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_IdlePose_Up_TP) == 0x0000E8, "Member 'UReadyOrNotWeaponAnimData::Crouch_IdlePose_Up_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_IdlePose_Shld_TP) == 0x0000F0, "Member 'UReadyOrNotWeaponAnimData::Crouch_IdlePose_Shld_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_IdlePose_Sights_TP) == 0x0000F8, "Member 'UReadyOrNotWeaponAnimData::Crouch_IdlePose_Sights_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_IdlePose_Ret_TP) == 0x000100, "Member 'UReadyOrNotWeaponAnimData::Crouch_IdlePose_Ret_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_IdlePose_Ovr_TP) == 0x000108, "Member 'UReadyOrNotWeaponAnimData::Crouch_IdlePose_Ovr_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload) == 0x000110, "Member 'UReadyOrNotWeaponAnimData::Reload' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReloadEmpty) == 0x000130, "Member 'UReadyOrNotWeaponAnimData::ReloadEmpty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Reload) == 0x000150, "Member 'UReadyOrNotWeaponAnimData::Crouch_Reload' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_ReloadEmpty) == 0x000170, "Member 'UReadyOrNotWeaponAnimData::Crouch_ReloadEmpty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Tactical_Reload) == 0x000190, "Member 'UReadyOrNotWeaponAnimData::Tactical_Reload' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Tactical_ReloadEmpty) == 0x0001B0, "Member 'UReadyOrNotWeaponAnimData::Tactical_ReloadEmpty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ShellRack_Reload) == 0x0001D0, "Member 'UReadyOrNotWeaponAnimData::ShellRack_Reload' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ShellRack_ReloadEmpty) == 0x0001E0, "Member 'UReadyOrNotWeaponAnimData::ShellRack_ReloadEmpty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ShellRack_ReloadRack) == 0x0001F0, "Member 'UReadyOrNotWeaponAnimData::ShellRack_ReloadRack' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Tactical_Crouch_Reload) == 0x000200, "Member 'UReadyOrNotWeaponAnimData::Tactical_Crouch_Reload' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Tactical_Crouch_ReloadEmpty) == 0x000220, "Member 'UReadyOrNotWeaponAnimData::Tactical_Crouch_ReloadEmpty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, MeleeHit) == 0x000240, "Member 'UReadyOrNotWeaponAnimData::MeleeHit' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, MeleeMiss) == 0x000260, "Member 'UReadyOrNotWeaponAnimData::MeleeMiss' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireSelect_Auto) == 0x000280, "Member 'UReadyOrNotWeaponAnimData::FireSelect_Auto' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireSelect_Burst) == 0x0002A0, "Member 'UReadyOrNotWeaponAnimData::FireSelect_Burst' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireSelect_Semi) == 0x0002C0, "Member 'UReadyOrNotWeaponAnimData::FireSelect_Semi' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireSelect_Safe) == 0x0002E0, "Member 'UReadyOrNotWeaponAnimData::FireSelect_Safe' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireSelect_Auto) == 0x000300, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireSelect_Auto' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireSelect_Burst) == 0x000320, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireSelect_Burst' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireSelect_Semi) == 0x000340, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireSelect_Semi' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireSelect_Safe) == 0x000360, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireSelect_Safe' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_Start) == 0x000380, "Member 'UReadyOrNotWeaponAnimData::Reload_Start' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_Loop) == 0x0003A0, "Member 'UReadyOrNotWeaponAnimData::Reload_Loop' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_End) == 0x0003C0, "Member 'UReadyOrNotWeaponAnimData::Reload_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_Start_Empty) == 0x0003E0, "Member 'UReadyOrNotWeaponAnimData::Reload_Start_Empty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_Loop_Empty) == 0x000400, "Member 'UReadyOrNotWeaponAnimData::Reload_Loop_Empty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_End_Empty) == 0x000420, "Member 'UReadyOrNotWeaponAnimData::Reload_End_Empty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Reload_Start) == 0x000440, "Member 'UReadyOrNotWeaponAnimData::Crouch_Reload_Start' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Reload_Loop) == 0x000460, "Member 'UReadyOrNotWeaponAnimData::Crouch_Reload_Loop' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Reload_End) == 0x000480, "Member 'UReadyOrNotWeaponAnimData::Crouch_Reload_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Reload_Start_Empty) == 0x0004A0, "Member 'UReadyOrNotWeaponAnimData::Crouch_Reload_Start_Empty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Reload_Loop_Empty) == 0x0004C0, "Member 'UReadyOrNotWeaponAnimData::Crouch_Reload_Loop_Empty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Reload_End_Empty) == 0x0004E0, "Member 'UReadyOrNotWeaponAnimData::Crouch_Reload_End_Empty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, MagazineCheck) == 0x000500, "Member 'UReadyOrNotWeaponAnimData::MagazineCheck' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_MagazineCheck) == 0x000520, "Member 'UReadyOrNotWeaponAnimData::Crouch_MagazineCheck' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, MagazineCheckSights) == 0x000540, "Member 'UReadyOrNotWeaponAnimData::MagazineCheckSights' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_MagazineCheckSights) == 0x000560, "Member 'UReadyOrNotWeaponAnimData::Crouch_MagazineCheckSights' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireSingle) == 0x000580, "Member 'UReadyOrNotWeaponAnimData::FireSingle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireSingleSights) == 0x000590, "Member 'UReadyOrNotWeaponAnimData::FireSingleSights' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireSingleLast) == 0x0005A0, "Member 'UReadyOrNotWeaponAnimData::FireSingleLast' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireSingleSightsLast) == 0x0005C0, "Member 'UReadyOrNotWeaponAnimData::FireSingleSightsLast' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, DryFire) == 0x0005E0, "Member 'UReadyOrNotWeaponAnimData::DryFire' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireSingle) == 0x000600, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireSingle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireSingleSights) == 0x000610, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireSingleSights' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireSingleLast) == 0x000620, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireSingleLast' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireSingleSightsLast) == 0x000640, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireSingleSightsLast' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Dryfire) == 0x000660, "Member 'UReadyOrNotWeaponAnimData::Crouch_Dryfire' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireLoop) == 0x000680, "Member 'UReadyOrNotWeaponAnimData::FireLoop' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireLoopEnd) == 0x0006A0, "Member 'UReadyOrNotWeaponAnimData::FireLoopEnd' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireLoopSights) == 0x0006C0, "Member 'UReadyOrNotWeaponAnimData::FireLoopSights' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireLoopSightsEnd) == 0x0006E0, "Member 'UReadyOrNotWeaponAnimData::FireLoopSightsEnd' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireLoop) == 0x000700, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireLoop' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireLoopEnd) == 0x000720, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireLoopEnd' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireLoopSights) == 0x000740, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireLoopSights' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireLoopSightsEnd) == 0x000760, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireLoopSightsEnd' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Draw) == 0x000780, "Member 'UReadyOrNotWeaponAnimData::Draw' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, DrawFirst) == 0x0007A0, "Member 'UReadyOrNotWeaponAnimData::DrawFirst' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Draw) == 0x0007C0, "Member 'UReadyOrNotWeaponAnimData::Crouch_Draw' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_DrawFirst) == 0x0007E0, "Member 'UReadyOrNotWeaponAnimData::Crouch_DrawFirst' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Holster) == 0x000800, "Member 'UReadyOrNotWeaponAnimData::Holster' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Holster) == 0x000820, "Member 'UReadyOrNotWeaponAnimData::Crouch_Holster' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, PullPin) == 0x000840, "Member 'UReadyOrNotWeaponAnimData::PullPin' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Throw) == 0x000860, "Member 'UReadyOrNotWeaponAnimData::Throw' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, PullPinUnderarm) == 0x000880, "Member 'UReadyOrNotWeaponAnimData::PullPinUnderarm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ThrowUnderarm) == 0x0008A0, "Member 'UReadyOrNotWeaponAnimData::ThrowUnderarm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_PullPin) == 0x0008C0, "Member 'UReadyOrNotWeaponAnimData::Crouch_PullPin' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Throw) == 0x0008E0, "Member 'UReadyOrNotWeaponAnimData::Crouch_Throw' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_PullPinUnderarm) == 0x000900, "Member 'UReadyOrNotWeaponAnimData::Crouch_PullPinUnderarm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_ThrowUnderarm) == 0x000920, "Member 'UReadyOrNotWeaponAnimData::Crouch_ThrowUnderarm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, QuickThrow_PinPull) == 0x000940, "Member 'UReadyOrNotWeaponAnimData::QuickThrow_PinPull' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Quickthrow_Throw) == 0x000960, "Member 'UReadyOrNotWeaponAnimData::Quickthrow_Throw' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_QuickThrow_PinPull) == 0x000980, "Member 'UReadyOrNotWeaponAnimData::Crouch_QuickThrow_PinPull' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_QuickThrow_Throw) == 0x0009A0, "Member 'UReadyOrNotWeaponAnimData::Crouch_QuickThrow_Throw' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, QuickThrow_Fast) == 0x0009C0, "Member 'UReadyOrNotWeaponAnimData::QuickThrow_Fast' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_QuickThrow_Fast) == 0x0009E0, "Member 'UReadyOrNotWeaponAnimData::Crouch_QuickThrow_Fast' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Multitool_Use) == 0x000A00, "Member 'UReadyOrNotWeaponAnimData::Multitool_Use' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Multitool_Use_End) == 0x000A20, "Member 'UReadyOrNotWeaponAnimData::Multitool_Use_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Multitool_Cutters_To_Lockpick) == 0x000A40, "Member 'UReadyOrNotWeaponAnimData::Multitool_Cutters_To_Lockpick' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Multitool_Cutters_To_Knife) == 0x000A60, "Member 'UReadyOrNotWeaponAnimData::Multitool_Cutters_To_Knife' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Multitool_Lockpick_To_Cutters) == 0x000A80, "Member 'UReadyOrNotWeaponAnimData::Multitool_Lockpick_To_Cutters' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Multitool_Lockpick_To_Knife) == 0x000AA0, "Member 'UReadyOrNotWeaponAnimData::Multitool_Lockpick_To_Knife' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Multitool_Knife_To_Lockpick) == 0x000AC0, "Member 'UReadyOrNotWeaponAnimData::Multitool_Knife_To_Lockpick' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Multitool_Knife_To_Cutters) == 0x000AE0, "Member 'UReadyOrNotWeaponAnimData::Multitool_Knife_To_Cutters' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Optiwand_Start_Screening) == 0x000B00, "Member 'UReadyOrNotWeaponAnimData::Optiwand_Start_Screening' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Optiwand_End_Screening) == 0x000B20, "Member 'UReadyOrNotWeaponAnimData::Optiwand_End_Screening' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Charge_Valid_Plant_Start) == 0x000B40, "Member 'UReadyOrNotWeaponAnimData::Charge_Valid_Plant_Start' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Charge_Valid_Plant_End) == 0x000B60, "Member 'UReadyOrNotWeaponAnimData::Charge_Valid_Plant_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, PlantCharge) == 0x000B80, "Member 'UReadyOrNotWeaponAnimData::PlantCharge' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, DetonateCharge) == 0x000BA0, "Member 'UReadyOrNotWeaponAnimData::DetonateCharge' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, EnableNVG) == 0x000BC0, "Member 'UReadyOrNotWeaponAnimData::EnableNVG' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, DisableNVG) == 0x000BE0, "Member 'UReadyOrNotWeaponAnimData::DisableNVG' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ShieldDownToUp) == 0x000C00, "Member 'UReadyOrNotWeaponAnimData::ShieldDownToUp' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ShieldUpToDown) == 0x000C20, "Member 'UReadyOrNotWeaponAnimData::ShieldUpToDown' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_ShieldDownToUp) == 0x000C40, "Member 'UReadyOrNotWeaponAnimData::Crouch_ShieldDownToUp' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_ShieldUpToDown) == 0x000C60, "Member 'UReadyOrNotWeaponAnimData::Crouch_ShieldUpToDown' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ShieldHit) == 0x000C80, "Member 'UReadyOrNotWeaponAnimData::ShieldHit' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, TabletDownToUp) == 0x000CA0, "Member 'UReadyOrNotWeaponAnimData::TabletDownToUp' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, TabletUpToDown) == 0x000CC0, "Member 'UReadyOrNotWeaponAnimData::TabletUpToDown' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, TabletSwitchCameraDown) == 0x000CE0, "Member 'UReadyOrNotWeaponAnimData::TabletSwitchCameraDown' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, TabletSwitchCameraUp) == 0x000D00, "Member 'UReadyOrNotWeaponAnimData::TabletSwitchCameraUp' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, EvidencePickup) == 0x000D20, "Member 'UReadyOrNotWeaponAnimData::EvidencePickup' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Yell) == 0x000D40, "Member 'UReadyOrNotWeaponAnimData::Yell' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, RadioSelect) == 0x000D60, "Member 'UReadyOrNotWeaponAnimData::RadioSelect' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, bRadioUsesNotifies) == 0x000D80, "Member 'UReadyOrNotWeaponAnimData::bRadioUsesNotifies' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, DoorPush) == 0x000D88, "Member 'UReadyOrNotWeaponAnimData::DoorPush' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ButtonPush) == 0x000DA8, "Member 'UReadyOrNotWeaponAnimData::ButtonPush' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, WeaponClearing) == 0x000DC8, "Member 'UReadyOrNotWeaponAnimData::WeaponClearing' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToSting) == 0x000DE8, "Member 'UReadyOrNotWeaponAnimData::ReactToSting' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToFlash) == 0x000E08, "Member 'UReadyOrNotWeaponAnimData::ReactToFlash' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToTaser) == 0x000E28, "Member 'UReadyOrNotWeaponAnimData::ReactToTaser' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToGas) == 0x000E48, "Member 'UReadyOrNotWeaponAnimData::ReactToGas' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToPepperSpray) == 0x000E68, "Member 'UReadyOrNotWeaponAnimData::ReactToPepperSpray' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToSting_End) == 0x000E88, "Member 'UReadyOrNotWeaponAnimData::ReactToSting_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToFlash_End) == 0x000EA8, "Member 'UReadyOrNotWeaponAnimData::ReactToFlash_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToTaser_End) == 0x000EC8, "Member 'UReadyOrNotWeaponAnimData::ReactToTaser_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToGas_End) == 0x000EE8, "Member 'UReadyOrNotWeaponAnimData::ReactToGas_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToPepperSpray_End) == 0x000F08, "Member 'UReadyOrNotWeaponAnimData::ReactToPepperSpray_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_Level_01) == 0x000F28, "Member 'UReadyOrNotWeaponAnimData::Reload_Level_01' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_Level_02) == 0x000F48, "Member 'UReadyOrNotWeaponAnimData::Reload_Level_02' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_Level_03) == 0x000F68, "Member 'UReadyOrNotWeaponAnimData::Reload_Level_03' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Recoil_Level_01) == 0x000F88, "Member 'UReadyOrNotWeaponAnimData::Recoil_Level_01' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Recoil_Level_02) == 0x000FA8, "Member 'UReadyOrNotWeaponAnimData::Recoil_Level_02' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Recoil_Level_03) == 0x000FC8, "Member 'UReadyOrNotWeaponAnimData::Recoil_Level_03' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Grip_VFG_Body_FP_Fire) == 0x000FE8, "Member 'UReadyOrNotWeaponAnimData::Grip_VFG_Body_FP_Fire' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Grip_VFG_Body_FP_Fire_Last) == 0x000FF0, "Member 'UReadyOrNotWeaponAnimData::Grip_VFG_Body_FP_Fire_Last' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Grip_VFG_Body_FP_Fire_Aim) == 0x000FF8, "Member 'UReadyOrNotWeaponAnimData::Grip_VFG_Body_FP_Fire_Aim' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Grip_VFG_Body_FP_Fire_Aim_Last) == 0x001000, "Member 'UReadyOrNotWeaponAnimData::Grip_VFG_Body_FP_Fire_Aim_Last' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Grip_AFG_Body_FP_Fire) == 0x001008, "Member 'UReadyOrNotWeaponAnimData::Grip_AFG_Body_FP_Fire' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Grip_AFG_Body_FP_Fire_Last) == 0x001010, "Member 'UReadyOrNotWeaponAnimData::Grip_AFG_Body_FP_Fire_Last' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Grip_AFG_Body_FP_Fire_Aim) == 0x001018, "Member 'UReadyOrNotWeaponAnimData::Grip_AFG_Body_FP_Fire_Aim' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Grip_AFG_Body_FP_Fire_Aim_Last) == 0x001020, "Member 'UReadyOrNotWeaponAnimData::Grip_AFG_Body_FP_Fire_Aim_Last' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_FP_Ads) == 0x001028, "Member 'UReadyOrNotWeaponAnimData::Reload_FP_Ads' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReloadEmpty_FP_Ads) == 0x001030, "Member 'UReadyOrNotWeaponAnimData::ReloadEmpty_FP_Ads' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Tactical_Reload_FP_Ads) == 0x001038, "Member 'UReadyOrNotWeaponAnimData::Tactical_Reload_FP_Ads' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Tactical_ReloadEmpty_FP_Ads) == 0x001040, "Member 'UReadyOrNotWeaponAnimData::Tactical_ReloadEmpty_FP_Ads' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, bEmptyReload) == 0x001048, "Member 'UReadyOrNotWeaponAnimData::bEmptyReload' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, bHasRetentionAdditives) == 0x001049, "Member 'UReadyOrNotWeaponAnimData::bHasRetentionAdditives' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, bHasLoweredAdditives) == 0x00104A, "Member 'UReadyOrNotWeaponAnimData::bHasLoweredAdditives' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, bHasSightAdditives) == 0x00104B, "Member 'UReadyOrNotWeaponAnimData::bHasSightAdditives' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, bOverrideFireAnimForGrip) == 0x00104C, "Member 'UReadyOrNotWeaponAnimData::bOverrideFireAnimForGrip' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_AFG_TP) == 0x001050, "Member 'UReadyOrNotWeaponAnimData::IdlePose_AFG_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_VFG_TP) == 0x001058, "Member 'UReadyOrNotWeaponAnimData::IdlePose_VFG_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_HSTOP_TP) == 0x001060, "Member 'UReadyOrNotWeaponAnimData::IdlePose_HSTOP_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_AI_Calm) == 0x001068, "Member 'UReadyOrNotWeaponAnimData::IdlePose_AI_Calm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_AI_Aiming) == 0x001070, "Member 'UReadyOrNotWeaponAnimData::IdlePose_AI_Aiming' has a wrong offset!");

// Class ReadyOrNot.ReceiveAISenseUpdates
// 0x0000 (0x0028 - 0x0028)
class IReceiveAISenseUpdates final  : public IInterface
{
public:
	void OnAIDamageSense(class ACyberneticController* InSenseController, const struct FAIStimulus& Stimulus, class AActor** OutOverrideSensedActor);
	void OnAIHearingSense(class ACyberneticController* InSenseController, const struct FAIStimulus& Stimulus, class AActor** OutOverrideSensedActor);
	void OnAIPerceptionSense(class ACyberneticController* InSenseController, const struct FAIStimulus& Stimulus, class AActor** OutOverrideSensedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReceiveAISenseUpdates">();
	}
	static class IReceiveAISenseUpdates* GetDefaultObj()
	{
		return GetDefaultObjImpl<IReceiveAISenseUpdates>();
	}
};
static_assert(alignof(IReceiveAISenseUpdates) == 0x000008, "Wrong alignment on IReceiveAISenseUpdates");
static_assert(sizeof(IReceiveAISenseUpdates) == 0x000028, "Wrong size on IReceiveAISenseUpdates");

// Class ReadyOrNot.ReloadSafelyActivity
// 0x0010 (0x01B8 - 0x01A8)
class UReloadSafelyActivity final  : public UBaseActivity
{
public:
	class UAnimMontage*                           ReloadMontage;                                     // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_289B[0x8];                                     // 0x01B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReloadFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReloadSafelyActivity">();
	}
	static class UReloadSafelyActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReloadSafelyActivity>();
	}
};
static_assert(alignof(UReloadSafelyActivity) == 0x000008, "Wrong alignment on UReloadSafelyActivity");
static_assert(sizeof(UReloadSafelyActivity) == 0x0001B8, "Wrong size on UReloadSafelyActivity");
static_assert(offsetof(UReloadSafelyActivity, ReloadMontage) == 0x0001A8, "Member 'UReloadSafelyActivity::ReloadMontage' has a wrong offset!");

// Class ReadyOrNot.ReplayControls
// 0x0000 (0x0260 - 0x0260)
class UReplayControls : public UUserWidget
{
public:
	void CustomTick();
	void NextActor();
	void PauseReplay();
	void PreviousActor();
	void SetMinimumReplayBarTime(float Percent);
	void SkipReplayBackward();
	void SkipReplayForward();
	void ToggleHUD();
	void UpdateMountedSocketSelections();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplayControls">();
	}
	static class UReplayControls* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReplayControls>();
	}
};
static_assert(alignof(UReplayControls) == 0x000008, "Wrong alignment on UReplayControls");
static_assert(sizeof(UReplayControls) == 0x000260, "Wrong size on UReplayControls");

// Class ReadyOrNot.Reportable
// 0x0000 (0x0028 - 0x0028)
class IReportable final  : public IInterface
{
public:
	bool CanReportNow();
	class FString GetSpeechTypeForReport();
	void ReportToTOC(class AReadyOrNotCharacter* Reporter, bool bPlayAnimation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Reportable">();
	}
	static class IReportable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IReportable>();
	}
};
static_assert(alignof(IReportable) == 0x000008, "Wrong alignment on IReportable");
static_assert(sizeof(IReportable) == 0x000028, "Wrong size on IReportable");

// Class ReadyOrNot.ReportReportableByTag
// 0x0010 (0x02B8 - 0x02A8)
class AReportReportableByTag final  : public AObjective
{
public:
	uint32                                        NumReportsToComplete;                              // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        CurrentReportCount;                                // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ReportTag;                                         // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool HasReportedReportableByTag(class FName& Tag);
	void OnReportableReported(class AReportableActor* Reportable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReportReportableByTag">();
	}
	static class AReportReportableByTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReportReportableByTag>();
	}
};
static_assert(alignof(AReportReportableByTag) == 0x000008, "Wrong alignment on AReportReportableByTag");
static_assert(sizeof(AReportReportableByTag) == 0x0002B8, "Wrong size on AReportReportableByTag");
static_assert(offsetof(AReportReportableByTag, NumReportsToComplete) == 0x0002A8, "Member 'AReportReportableByTag::NumReportsToComplete' has a wrong offset!");
static_assert(offsetof(AReportReportableByTag, CurrentReportCount) == 0x0002AC, "Member 'AReportReportableByTag::CurrentReportCount' has a wrong offset!");
static_assert(offsetof(AReportReportableByTag, ReportTag) == 0x0002B0, "Member 'AReportReportableByTag::ReportTag' has a wrong offset!");

// Class ReadyOrNot.ReportTargetActivity
// 0x0010 (0x01B8 - 0x01A8)
class UReportTargetActivity final  : public UBaseActivity
{
public:
	TScriptInterface<class IReportable>           ReportTarget;                                      // 0x01A8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReportTargetActivity">();
	}
	static class UReportTargetActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReportTargetActivity>();
	}
};
static_assert(alignof(UReportTargetActivity) == 0x000008, "Wrong alignment on UReportTargetActivity");
static_assert(sizeof(UReportTargetActivity) == 0x0001B8, "Wrong size on UReportTargetActivity");
static_assert(offsetof(UReportTargetActivity, ReportTarget) == 0x0001A8, "Member 'UReportTargetActivity::ReportTarget' has a wrong offset!");

// Class ReadyOrNot.RepositionCombatMove
// 0x0008 (0x01E0 - 0x01D8)
class URepositionCombatMove final  : public UBaseCombatMoveActivity
{
public:
	class ADoor*                                  TheDoor;                                           // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RepositionCombatMove">();
	}
	static class URepositionCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<URepositionCombatMove>();
	}
};
static_assert(alignof(URepositionCombatMove) == 0x000008, "Wrong alignment on URepositionCombatMove");
static_assert(sizeof(URepositionCombatMove) == 0x0001E0, "Wrong size on URepositionCombatMove");
static_assert(offsetof(URepositionCombatMove, TheDoor) == 0x0001D8, "Member 'URepositionCombatMove::TheDoor' has a wrong offset!");

// Class ReadyOrNot.RescueCivilianByTag
// 0x0028 (0x02D0 - 0x02A8)
class ARescueCivilianByTag final  : public AObjective
{
public:
	uint8                                         Pad_289E[0x10];                                    // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CivilianTag;                                       // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   Civilian;                                          // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowIncapacitation;                              // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289F[0x7];                                     // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasNeutralizedCivilianByTag(bool* bArrested);
	void OnAISpawned();
	void OnCivilianKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RescueCivilianByTag">();
	}
	static class ARescueCivilianByTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARescueCivilianByTag>();
	}
};
static_assert(alignof(ARescueCivilianByTag) == 0x000008, "Wrong alignment on ARescueCivilianByTag");
static_assert(sizeof(ARescueCivilianByTag) == 0x0002D0, "Wrong size on ARescueCivilianByTag");
static_assert(offsetof(ARescueCivilianByTag, CivilianTag) == 0x0002B8, "Member 'ARescueCivilianByTag::CivilianTag' has a wrong offset!");
static_assert(offsetof(ARescueCivilianByTag, Civilian) == 0x0002C0, "Member 'ARescueCivilianByTag::Civilian' has a wrong offset!");
static_assert(offsetof(ARescueCivilianByTag, bAllowIncapacitation) == 0x0002C8, "Member 'ARescueCivilianByTag::bAllowIncapacitation' has a wrong offset!");

// Class ReadyOrNot.RespondToPlayerGaze
// 0x0000 (0x0028 - 0x0028)
class IRespondToPlayerGaze final  : public IInterface
{
public:
	void OnPlayerGazeEnded(class APlayerCharacter* Gazer);
	void OnPlayerGazeStarted(class APlayerCharacter* Gazer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RespondToPlayerGaze">();
	}
	static class IRespondToPlayerGaze* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRespondToPlayerGaze>();
	}
};
static_assert(alignof(IRespondToPlayerGaze) == 0x000008, "Wrong alignment on IRespondToPlayerGaze");
static_assert(sizeof(IRespondToPlayerGaze) == 0x000028, "Wrong size on IRespondToPlayerGaze");

// Class ReadyOrNot.RoNAnimInstance_HumanBase
// 0x14B0 (0x1770 - 0x02C0)
class URoNAnimInstance_HumanBase : public UAnimInstance
{
public:
	class URoNMoveStyleComponent*                 MoveStyleComponent;                                // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A0[0xC];                                     // 0x02C0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsStrafing;                                       // 0x02CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A1[0x3];                                     // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRoNStyleSlotData                      Slot0;                                             // 0x02D0(0x0250)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FRoNStyleSlotData                      Slot1;                                             // 0x0520(0x0250)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FRoNStyleSlotData                      Slot2;                                             // 0x0770(0x0250)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FRoNStyleSlotData                      Slot3;                                             // 0x09C0(0x0250)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FRoNStyleSlotData                      Slot4;                                             // 0x0C10(0x0250)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FRoNStyleSlotData                      Slot5;                                             // 0x0E60(0x0250)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FRoNStyleSlotData                      Slot6;                                             // 0x10B0(0x0250)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FRoNStyleIdleData                      IdleData_Default;                                  // 0x1300(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRoNStyleTurnData                      TurnData_Default;                                  // 0x1310(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRoNGaitTransitionData                 TransitionData_Default;                            // 0x1358(0x0120)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRoNGaitLocomotionData                 LocomotionData_Default;                            // 0x1478(0x00C0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StrafeBS_Default;                                  // 0x1538(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            NonStrafeBS_Default;                               // 0x1540(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlotBlendTime;                                     // 0x1548(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultSlotBlendTime;                              // 0x154C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetAlpha;                                    // 0x1550(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeBlendTime;                                   // 0x1554(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeWarpingAlpha;                                 // 0x1558(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoveStyleSlotBActive;                           // 0x155C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A2[0x3];                                     // 0x155D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIdx;                                           // 0x1560(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HeadLookRotation;                                  // 0x1564(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A3[0x10];                                    // 0x1570(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lean;                                              // 0x1580(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanClamped;                                       // 0x1584(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanFactor;                                        // 0x1588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanInterpSpeed;                                   // 0x158C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustedPlayrate;                                  // 0x1590(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedScaling;                                      // 0x1594(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayrateClampMax;                                  // 0x1598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentIdleIndex;                                  // 0x159C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStrafeDirection                              CurrentStrafeDirection;                            // 0x15A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A4[0x7];                                     // 0x15A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StrafeDirectionAngle;                              // 0x15A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AimOffsetInterpolated;                             // 0x15AC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInRagdoll;                                        // 0x15B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecoveringFromRagdoll;                            // 0x15B5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x15B6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayingDeathAnim;                               // 0x15B7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWorldBuildingAnimState                WorldBuildingAnimState;                            // 0x15B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCarryArrestedAnimState                CarryArrestAnimState;                              // 0x15C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FTakeHostageAnimState                  TakeHostageAnimState;                              // 0x15D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	EAnimWeaponType                               CurWeaponType;                                     // 0x15E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A5[0x7];                                     // 0x15E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          IncapacitationLoopAnim;                            // 0x15F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsArrested;                                       // 0x15F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsArrestedAsRagdoll;                              // 0x15F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingArrested;                                  // 0x15FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingArrestedAsRagdoll;                         // 0x15FB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSurrendered;                                      // 0x15FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCarried;                                        // 0x15FD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGetUpPlaying;                                   // 0x15FE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A6[0x1];                                     // 0x15FF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIncapacitated;                                    // 0x1600(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableIKProcess;                                  // 0x1601(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFemale;                                         // 0x1602(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUnarmed;                                        // 0x1603(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSWAT;                                           // 0x1604(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCrouching;                                      // 0x1605(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsArrestedAndDead;                                // 0x1606(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A7[0x1];                                     // 0x1607(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoverAnimStateMachineData             CoverAnimStateMachineData;                         // 0x1608(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FHidingAnimStateMachineData            HidingAnimStateMachineData;                        // 0x1620(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FHoleTraversalAnimStateMachineData     HoleTraversalAnimStateMachineData;                 // 0x1630(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LeftArmIKAlpha;                                    // 0x1640(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightArmIKAlpha;                                   // 0x1644(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmsOnlySlotAlpha;                                 // 0x1648(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftArmOnlySlotAlpha;                              // 0x164C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandAdditiveLockOverride;                          // 0x1650(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponDown;                                       // 0x1654(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPistolAndWeaponDown;                            // 0x1655(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPistol;                                         // 0x1656(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A8[0x9];                                     // 0x1657(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Calm_Override_Pose;                                // 0x1660(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Aiming_Override_Pose;                              // 0x1668(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Default_Calm_Override_Pose;                        // 0x1670(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Default_Aiming_Override_Pose;                      // 0x1678(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReloading;                                      // 0x1680(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A9[0x3];                                     // 0x1681(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FinalAimOffsetAlpha;                               // 0x1684(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnyMontageIsActive;                               // 0x1688(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFullBodyMontagePlaying;                           // 0x1689(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpperBodyMontagePlaying;                          // 0x168A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInteractionMontagePlaying;                        // 0x168B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFullOrInteractionMontagePlaying;                  // 0x168C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemOverrideRule                             CurOverrideRule;                                   // 0x168D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoweredSet;                                     // 0x168E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowTurnInPlace;                                 // 0x168F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceSpeedMultiplier;                        // 0x1690(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawOffsetLimit;                                    // 0x1694(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimTurnInPlaceAnimSet                TurnInPlaceAnimSet;                                // 0x1698(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FAnimTurnInPlaceState                  TurnInPlaceState;                                  // 0x16B0(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bExitTurnRecoveryIfMoving;                         // 0x1708(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28AA[0x3];                                     // 0x1709(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateData                   TurnAnimStateData;                                 // 0x170C(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsTurnInPlaceStateRelevant;                       // 0x1728(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28AB[0x3];                                     // 0x1729(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VelocityInterpTime;                                // 0x172C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocitySmoothed;                                  // 0x1730(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableAdditiveOverrides;                         // 0x173C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28AC[0x3];                                     // 0x173D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         AdditiveDisableTagList;                            // 0x1740(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Move_x;                                            // 0x1750(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Move_y;                                            // 0x1754(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHostageTaker;                                   // 0x1758(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHostage;                                        // 0x1759(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHostageOrHostageTaker;                          // 0x175A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28AD[0x1];                                     // 0x175B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveStyleBlendCoolDown;                            // 0x175C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28AE[0x4];                                     // 0x1760(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMoveStyleChanging;                                // 0x1764(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28AF[0xB];                                     // 0x1765(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMoveStyleDataFromComp(class URoNMoveStyleComponent* MoveStyleComp);
	void UpdateGaitDataFromComp(class URoNMoveStyleComponent* MoveStyleComp);
	void UpdateMoveStyleDataFromComp(class URoNMoveStyleComponent* MoveStyleComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoNAnimInstance_HumanBase">();
	}
	static class URoNAnimInstance_HumanBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoNAnimInstance_HumanBase>();
	}
};
static_assert(alignof(URoNAnimInstance_HumanBase) == 0x000010, "Wrong alignment on URoNAnimInstance_HumanBase");
static_assert(sizeof(URoNAnimInstance_HumanBase) == 0x001770, "Wrong size on URoNAnimInstance_HumanBase");
static_assert(offsetof(URoNAnimInstance_HumanBase, MoveStyleComponent) == 0x0002B8, "Member 'URoNAnimInstance_HumanBase::MoveStyleComponent' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsStrafing) == 0x0002CC, "Member 'URoNAnimInstance_HumanBase::bIsStrafing' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Slot0) == 0x0002D0, "Member 'URoNAnimInstance_HumanBase::Slot0' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Slot1) == 0x000520, "Member 'URoNAnimInstance_HumanBase::Slot1' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Slot2) == 0x000770, "Member 'URoNAnimInstance_HumanBase::Slot2' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Slot3) == 0x0009C0, "Member 'URoNAnimInstance_HumanBase::Slot3' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Slot4) == 0x000C10, "Member 'URoNAnimInstance_HumanBase::Slot4' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Slot5) == 0x000E60, "Member 'URoNAnimInstance_HumanBase::Slot5' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Slot6) == 0x0010B0, "Member 'URoNAnimInstance_HumanBase::Slot6' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, IdleData_Default) == 0x001300, "Member 'URoNAnimInstance_HumanBase::IdleData_Default' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, TurnData_Default) == 0x001310, "Member 'URoNAnimInstance_HumanBase::TurnData_Default' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, TransitionData_Default) == 0x001358, "Member 'URoNAnimInstance_HumanBase::TransitionData_Default' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, LocomotionData_Default) == 0x001478, "Member 'URoNAnimInstance_HumanBase::LocomotionData_Default' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, StrafeBS_Default) == 0x001538, "Member 'URoNAnimInstance_HumanBase::StrafeBS_Default' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, NonStrafeBS_Default) == 0x001540, "Member 'URoNAnimInstance_HumanBase::NonStrafeBS_Default' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, SlotBlendTime) == 0x001548, "Member 'URoNAnimInstance_HumanBase::SlotBlendTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, DefaultSlotBlendTime) == 0x00154C, "Member 'URoNAnimInstance_HumanBase::DefaultSlotBlendTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, AimOffsetAlpha) == 0x001550, "Member 'URoNAnimInstance_HumanBase::AimOffsetAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, StrafeBlendTime) == 0x001554, "Member 'URoNAnimInstance_HumanBase::StrafeBlendTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, SlopeWarpingAlpha) == 0x001558, "Member 'URoNAnimInstance_HumanBase::SlopeWarpingAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsMoveStyleSlotBActive) == 0x00155C, "Member 'URoNAnimInstance_HumanBase::bIsMoveStyleSlotBActive' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, SlotIdx) == 0x001560, "Member 'URoNAnimInstance_HumanBase::SlotIdx' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, HeadLookRotation) == 0x001564, "Member 'URoNAnimInstance_HumanBase::HeadLookRotation' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Lean) == 0x001580, "Member 'URoNAnimInstance_HumanBase::Lean' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, LeanClamped) == 0x001584, "Member 'URoNAnimInstance_HumanBase::LeanClamped' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, LeanFactor) == 0x001588, "Member 'URoNAnimInstance_HumanBase::LeanFactor' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, LeanInterpSpeed) == 0x00158C, "Member 'URoNAnimInstance_HumanBase::LeanInterpSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, AdjustedPlayrate) == 0x001590, "Member 'URoNAnimInstance_HumanBase::AdjustedPlayrate' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, SpeedScaling) == 0x001594, "Member 'URoNAnimInstance_HumanBase::SpeedScaling' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, PlayrateClampMax) == 0x001598, "Member 'URoNAnimInstance_HumanBase::PlayrateClampMax' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, CurrentIdleIndex) == 0x00159C, "Member 'URoNAnimInstance_HumanBase::CurrentIdleIndex' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, CurrentStrafeDirection) == 0x0015A0, "Member 'URoNAnimInstance_HumanBase::CurrentStrafeDirection' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, StrafeDirectionAngle) == 0x0015A8, "Member 'URoNAnimInstance_HumanBase::StrafeDirectionAngle' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, AimOffsetInterpolated) == 0x0015AC, "Member 'URoNAnimInstance_HumanBase::AimOffsetInterpolated' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bInRagdoll) == 0x0015B4, "Member 'URoNAnimInstance_HumanBase::bInRagdoll' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bRecoveringFromRagdoll) == 0x0015B5, "Member 'URoNAnimInstance_HumanBase::bRecoveringFromRagdoll' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsDead) == 0x0015B6, "Member 'URoNAnimInstance_HumanBase::bIsDead' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsPlayingDeathAnim) == 0x0015B7, "Member 'URoNAnimInstance_HumanBase::bIsPlayingDeathAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, WorldBuildingAnimState) == 0x0015B8, "Member 'URoNAnimInstance_HumanBase::WorldBuildingAnimState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, CarryArrestAnimState) == 0x0015C8, "Member 'URoNAnimInstance_HumanBase::CarryArrestAnimState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, TakeHostageAnimState) == 0x0015D0, "Member 'URoNAnimInstance_HumanBase::TakeHostageAnimState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, CurWeaponType) == 0x0015E8, "Member 'URoNAnimInstance_HumanBase::CurWeaponType' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, IncapacitationLoopAnim) == 0x0015F0, "Member 'URoNAnimInstance_HumanBase::IncapacitationLoopAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsArrested) == 0x0015F8, "Member 'URoNAnimInstance_HumanBase::bIsArrested' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsArrestedAsRagdoll) == 0x0015F9, "Member 'URoNAnimInstance_HumanBase::bIsArrestedAsRagdoll' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsBeingArrested) == 0x0015FA, "Member 'URoNAnimInstance_HumanBase::bIsBeingArrested' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsBeingArrestedAsRagdoll) == 0x0015FB, "Member 'URoNAnimInstance_HumanBase::bIsBeingArrestedAsRagdoll' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bSurrendered) == 0x0015FC, "Member 'URoNAnimInstance_HumanBase::bSurrendered' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsCarried) == 0x0015FD, "Member 'URoNAnimInstance_HumanBase::bIsCarried' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsGetUpPlaying) == 0x0015FE, "Member 'URoNAnimInstance_HumanBase::bIsGetUpPlaying' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIncapacitated) == 0x001600, "Member 'URoNAnimInstance_HumanBase::bIncapacitated' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bEnableIKProcess) == 0x001601, "Member 'URoNAnimInstance_HumanBase::bEnableIKProcess' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsFemale) == 0x001602, "Member 'URoNAnimInstance_HumanBase::bIsFemale' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsUnarmed) == 0x001603, "Member 'URoNAnimInstance_HumanBase::bIsUnarmed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsSWAT) == 0x001604, "Member 'URoNAnimInstance_HumanBase::bIsSWAT' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsCrouching) == 0x001605, "Member 'URoNAnimInstance_HumanBase::bIsCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsArrestedAndDead) == 0x001606, "Member 'URoNAnimInstance_HumanBase::bIsArrestedAndDead' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, CoverAnimStateMachineData) == 0x001608, "Member 'URoNAnimInstance_HumanBase::CoverAnimStateMachineData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, HidingAnimStateMachineData) == 0x001620, "Member 'URoNAnimInstance_HumanBase::HidingAnimStateMachineData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, HoleTraversalAnimStateMachineData) == 0x001630, "Member 'URoNAnimInstance_HumanBase::HoleTraversalAnimStateMachineData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, LeftArmIKAlpha) == 0x001640, "Member 'URoNAnimInstance_HumanBase::LeftArmIKAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, RightArmIKAlpha) == 0x001644, "Member 'URoNAnimInstance_HumanBase::RightArmIKAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, ArmsOnlySlotAlpha) == 0x001648, "Member 'URoNAnimInstance_HumanBase::ArmsOnlySlotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, LeftArmOnlySlotAlpha) == 0x00164C, "Member 'URoNAnimInstance_HumanBase::LeftArmOnlySlotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, HandAdditiveLockOverride) == 0x001650, "Member 'URoNAnimInstance_HumanBase::HandAdditiveLockOverride' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bWeaponDown) == 0x001654, "Member 'URoNAnimInstance_HumanBase::bWeaponDown' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsPistolAndWeaponDown) == 0x001655, "Member 'URoNAnimInstance_HumanBase::bIsPistolAndWeaponDown' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsPistol) == 0x001656, "Member 'URoNAnimInstance_HumanBase::bIsPistol' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Calm_Override_Pose) == 0x001660, "Member 'URoNAnimInstance_HumanBase::Calm_Override_Pose' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Aiming_Override_Pose) == 0x001668, "Member 'URoNAnimInstance_HumanBase::Aiming_Override_Pose' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Default_Calm_Override_Pose) == 0x001670, "Member 'URoNAnimInstance_HumanBase::Default_Calm_Override_Pose' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Default_Aiming_Override_Pose) == 0x001678, "Member 'URoNAnimInstance_HumanBase::Default_Aiming_Override_Pose' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsReloading) == 0x001680, "Member 'URoNAnimInstance_HumanBase::bIsReloading' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, FinalAimOffsetAlpha) == 0x001684, "Member 'URoNAnimInstance_HumanBase::FinalAimOffsetAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bAnyMontageIsActive) == 0x001688, "Member 'URoNAnimInstance_HumanBase::bAnyMontageIsActive' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bFullBodyMontagePlaying) == 0x001689, "Member 'URoNAnimInstance_HumanBase::bFullBodyMontagePlaying' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bUpperBodyMontagePlaying) == 0x00168A, "Member 'URoNAnimInstance_HumanBase::bUpperBodyMontagePlaying' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bInteractionMontagePlaying) == 0x00168B, "Member 'URoNAnimInstance_HumanBase::bInteractionMontagePlaying' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bFullOrInteractionMontagePlaying) == 0x00168C, "Member 'URoNAnimInstance_HumanBase::bFullOrInteractionMontagePlaying' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, CurOverrideRule) == 0x00168D, "Member 'URoNAnimInstance_HumanBase::CurOverrideRule' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsLoweredSet) == 0x00168E, "Member 'URoNAnimInstance_HumanBase::bIsLoweredSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bAllowTurnInPlace) == 0x00168F, "Member 'URoNAnimInstance_HumanBase::bAllowTurnInPlace' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, TurnInPlaceSpeedMultiplier) == 0x001690, "Member 'URoNAnimInstance_HumanBase::TurnInPlaceSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, YawOffsetLimit) == 0x001694, "Member 'URoNAnimInstance_HumanBase::YawOffsetLimit' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, TurnInPlaceAnimSet) == 0x001698, "Member 'URoNAnimInstance_HumanBase::TurnInPlaceAnimSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, TurnInPlaceState) == 0x0016B0, "Member 'URoNAnimInstance_HumanBase::TurnInPlaceState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bExitTurnRecoveryIfMoving) == 0x001708, "Member 'URoNAnimInstance_HumanBase::bExitTurnRecoveryIfMoving' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, TurnAnimStateData) == 0x00170C, "Member 'URoNAnimInstance_HumanBase::TurnAnimStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsTurnInPlaceStateRelevant) == 0x001728, "Member 'URoNAnimInstance_HumanBase::bIsTurnInPlaceStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, VelocityInterpTime) == 0x00172C, "Member 'URoNAnimInstance_HumanBase::VelocityInterpTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, VelocitySmoothed) == 0x001730, "Member 'URoNAnimInstance_HumanBase::VelocitySmoothed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bDisableAdditiveOverrides) == 0x00173C, "Member 'URoNAnimInstance_HumanBase::bDisableAdditiveOverrides' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, AdditiveDisableTagList) == 0x001740, "Member 'URoNAnimInstance_HumanBase::AdditiveDisableTagList' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Move_x) == 0x001750, "Member 'URoNAnimInstance_HumanBase::Move_x' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Move_y) == 0x001754, "Member 'URoNAnimInstance_HumanBase::Move_y' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsHostageTaker) == 0x001758, "Member 'URoNAnimInstance_HumanBase::bIsHostageTaker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsHostage) == 0x001759, "Member 'URoNAnimInstance_HumanBase::bIsHostage' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsHostageOrHostageTaker) == 0x00175A, "Member 'URoNAnimInstance_HumanBase::bIsHostageOrHostageTaker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, MoveStyleBlendCoolDown) == 0x00175C, "Member 'URoNAnimInstance_HumanBase::MoveStyleBlendCoolDown' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bMoveStyleChanging) == 0x001764, "Member 'URoNAnimInstance_HumanBase::bMoveStyleChanging' has a wrong offset!");

// Class ReadyOrNot.RoNAnimInstance_PlayerTP
// 0x0BB0 (0x1010 - 0x0460)
class URoNAnimInstance_PlayerTP final  : public UReadyOrNotAnimInstance
{
public:
	struct FReadyOrNotAnimInstanceProxyTP         Proxy;                                             // 0x0460(0x0770)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class UReadyOrNotWeaponAnimData*              LastAnimWeaponData;                                // 0x0BD0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotWeaponAnimData*              EditorWeaponAnimData;                              // 0x0BD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowTurnInPlace;                                 // 0x0BE0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTurnInPlaceStateRelevant;                       // 0x0BE1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B0[0x2];                                     // 0x0BE2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YawOffsetLimit;                                    // 0x0BE4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceSpeedMultiplier;                        // 0x0BE8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B1[0x4];                                     // 0x0BEC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimTurnInPlaceAnimSet                TurnInPlaceAnimSet;                                // 0x0BF0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAnimTurnInPlaceState                  TurnInPlaceState;                                  // 0x0C08(0x0058)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimTurnInPlaceAnimSet                StandRifAnimSet;                                   // 0x0C60(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAnimTurnInPlaceAnimSet                CrouchRifAnimSet;                                  // 0x0C78(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bWeaponDown;                                       // 0x0C90(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAiming;                                         // 0x0C91(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShieldEquipped;                                 // 0x0C92(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B2[0x1];                                     // 0x0C93(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimingAlpha;                                       // 0x0C94(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeanLeft;                                         // 0x0C98(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeanRight;                                        // 0x0C99(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B3[0x2];                                     // 0x0C9A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QuickLeanLeftAmount;                               // 0x0C9C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanRightAmount;                              // 0x0CA0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanLeftAlpha;                                // 0x0CA4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanRightAlpha;                               // 0x0CA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanIntensity;                                // 0x0CAC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanInterpSpeed;                              // 0x0CB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKValue;                                       // 0x0CB4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKAlpha;                                       // 0x0CB8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRagdoll;                                          // 0x0CBC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayingDeathAnim;                               // 0x0CBD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArrested;                                         // 0x0CBE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x0CBF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeathAnimEnd;                                     // 0x0CC0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStunned;                                          // 0x0CC1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTased;                                            // 0x0CC2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnLadder;                                         // 0x0CC3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LadderUpDownMovement;                              // 0x0CC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAngleY;                                        // 0x0CC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAngleZ;                                        // 0x0CCC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverLeft;                                        // 0x0CD0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverRight;                                       // 0x0CD1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverMiddle;                                      // 0x0CD2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverLeftLow;                                     // 0x0CD3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverRightLow;                                    // 0x0CD4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverPeek;                                        // 0x0CD5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B4[0x2];                                     // 0x0CD6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimOffsetAlpha;                                    // 0x0CD8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AimOffsets;                                        // 0x0CDC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumpStartTrigger;                                 // 0x0CE4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B5[0x3];                                     // 0x0CE5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmoothMappedLeanToAnimStandLeft;                   // 0x0CE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothMappedLeanToAnimStandRight;                  // 0x0CEC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothMappedLeanToAnimCrouchLeft;                  // 0x0CF0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothMappedLeanToAnimCrouchRight;                 // 0x0CF4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_tp_rifle_stand_sprint_f;                     // 0x0CF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B6[0x4];                                     // 0x0CFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Low_TP;                           // 0x0D00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Up_TP;                            // 0x0D08(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Shld_TP;                          // 0x0D10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Sights_TP;                        // 0x0D18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Ret_TP;                           // 0x0D20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Ovr_TP;                           // 0x0D28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Low_TP;                                  // 0x0D30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Up_TP;                                   // 0x0D38(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Shld_TP;                                 // 0x0D40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Sights_TP;                               // 0x0D48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Ret_TP;                                  // 0x0D50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Ovr_TP;                                  // 0x0D58(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_VFG_TP;                                  // 0x0D60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_AFG_TP;                                  // 0x0D68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_HSTOP_TP;                                // 0x0D70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaningLeftNotCrouching;                          // 0x0D78(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotLeaningLeftOrCrouching;                        // 0x0D79(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotLeaningLeftOrNotCrouching;                     // 0x0D7A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaningRightNotCrouching;                         // 0x0D7B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotLeaningRightOrCrouching;                       // 0x0D7C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotLeaningRightOrNotCrouching;                    // 0x0D7D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouchingAndMoving;                               // 0x0D7E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotCrouchingAndMoving;                            // 0x0D7F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAimingAndNotDeployable;                           // 0x0D80(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B7[0x3];                                     // 0x0D81(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkSpeedForward;                                  // 0x0D84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedLeft;                                     // 0x0D88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedRight;                                    // 0x0D8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedBackward;                                 // 0x0D90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWalkSpeedForward;                            // 0x0D94(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWalkSpeedLeft;                               // 0x0D98(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWalkSpeedRight;                              // 0x0D9C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWalkSpeedBackward;                           // 0x0DA0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedForward;                                   // 0x0DA4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedLeft;                                      // 0x0DA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedRight;                                     // 0x0DAC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedBackward;                                  // 0x0DB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLessThanPointOneSecondOnRelevantAnim;             // 0x0DB4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInCombatOrAlerted;                              // 0x0DB5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoving;                                           // 0x0DB6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAlerted;                                        // 0x0DB7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlertAlpha;                                        // 0x0DB8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInCombat;                                       // 0x0DBC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSurrendering;                                   // 0x0DBD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSprayed;                                          // 0x0DBE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStung;                                            // 0x0DBF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPseudoSpeedType                              CurPseudoSpeed;                                    // 0x0DC0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFemale;                                           // 0x0DC1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChild;                                            // 0x0DC2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasInjury;                                        // 0x0DC3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSpeedFwdPlayrateSync;                          // 0x0DC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSpeedSidePlayrateSync;                         // 0x0DC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSpeedPlayrateSync;                             // 0x0DCC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetentionAlpha;                                    // 0x0DD0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoweredAlpha;                                      // 0x0DD4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B8[0x8];                                     // 0x0DD8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SightAlpha;                                        // 0x0DE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoweredCooldownTime;                               // 0x0DE4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLoweredUp;                                       // 0x0DE8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B9[0x13];                                    // 0x0DE9(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArmsOnlySlotAlpha;                                 // 0x0DFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftArmOnlySlotAlpha;                              // 0x0E00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityInterpTime;                                // 0x0E04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocitySmoothed;                                  // 0x0E08(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedScaling;                                      // 0x0E14(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayrateClampMax;                                  // 0x0E18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimCharacterMovementSnapshot         CharMovementSnapshot;                              // 0x0E1C(0x0094)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PostPivotTriggerThreshold;                         // 0x0EB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCardinalDirectionSnapshot             PivotingCardinalDirSnapShot;                       // 0x0EB4(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28BA[0xC];                                     // 0x0ECC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       CharacterRef;                                      // 0x0ED8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   CharacterAiRef;                                    // 0x0EE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDistanceMatching;                              // 0x0EE8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistanceMatchingType                         DistanceMatchingCurrentState;                      // 0x0EE9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28BB[0x2];                                     // 0x0EEA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionResult                      StartMarker;                                       // 0x0EEC(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      StopMarker;                                        // 0x0F0C(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      PivotMarker;                                       // 0x0F2C(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      PostPivotMarker;                                   // 0x0F4C(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      TakeOffMarker;                                     // 0x0F6C(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      ApexMarker;                                        // 0x0F8C(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      LandingMarker;                                     // 0x0FAC(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	EMoveDirectionExt                             CurrentPivotDirectionExt;                          // 0x0FCC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPivotDirectionBroken;                             // 0x0FCD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPivotInCurDirection;                           // 0x0FCE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSMPrePivotRuleset;                                // 0x0FCF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartDirectionBroken;                             // 0x0FD0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28BC[0x3];                                     // 0x0FD1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReplicatedMaxSpeed;                                // 0x0FD4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSMStartRuleset;                                   // 0x0FD8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSMStopRuleset;                                    // 0x0FD9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28BD[0x2];                                     // 0x0FDA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PelvisDefaultWorldPos;                             // 0x0FDC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CrouchedPelvisDefaultWorldPos;                     // 0x0FE8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CrouchedPelvisMovingWorldPos;                      // 0x0FF4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CrouchedPelvisCurrentWorldPos;                     // 0x1000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28BE[0x4];                                     // 0x100C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAnimSequenceBase* GetPlayerAnimation_TP(EBaseAnimType_TP AnimName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoNAnimInstance_PlayerTP">();
	}
	static class URoNAnimInstance_PlayerTP* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoNAnimInstance_PlayerTP>();
	}
};
static_assert(alignof(URoNAnimInstance_PlayerTP) == 0x000010, "Wrong alignment on URoNAnimInstance_PlayerTP");
static_assert(sizeof(URoNAnimInstance_PlayerTP) == 0x001010, "Wrong size on URoNAnimInstance_PlayerTP");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Proxy) == 0x000460, "Member 'URoNAnimInstance_PlayerTP::Proxy' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, LastAnimWeaponData) == 0x000BD0, "Member 'URoNAnimInstance_PlayerTP::LastAnimWeaponData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, EditorWeaponAnimData) == 0x000BD8, "Member 'URoNAnimInstance_PlayerTP::EditorWeaponAnimData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bAllowTurnInPlace) == 0x000BE0, "Member 'URoNAnimInstance_PlayerTP::bAllowTurnInPlace' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsTurnInPlaceStateRelevant) == 0x000BE1, "Member 'URoNAnimInstance_PlayerTP::bIsTurnInPlaceStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, YawOffsetLimit) == 0x000BE4, "Member 'URoNAnimInstance_PlayerTP::YawOffsetLimit' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, TurnInPlaceSpeedMultiplier) == 0x000BE8, "Member 'URoNAnimInstance_PlayerTP::TurnInPlaceSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, TurnInPlaceAnimSet) == 0x000BF0, "Member 'URoNAnimInstance_PlayerTP::TurnInPlaceAnimSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, TurnInPlaceState) == 0x000C08, "Member 'URoNAnimInstance_PlayerTP::TurnInPlaceState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, StandRifAnimSet) == 0x000C60, "Member 'URoNAnimInstance_PlayerTP::StandRifAnimSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CrouchRifAnimSet) == 0x000C78, "Member 'URoNAnimInstance_PlayerTP::CrouchRifAnimSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bWeaponDown) == 0x000C90, "Member 'URoNAnimInstance_PlayerTP::bWeaponDown' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsAiming) == 0x000C91, "Member 'URoNAnimInstance_PlayerTP::bIsAiming' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsShieldEquipped) == 0x000C92, "Member 'URoNAnimInstance_PlayerTP::bIsShieldEquipped' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, AimingAlpha) == 0x000C94, "Member 'URoNAnimInstance_PlayerTP::AimingAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bLeanLeft) == 0x000C98, "Member 'URoNAnimInstance_PlayerTP::bLeanLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bLeanRight) == 0x000C99, "Member 'URoNAnimInstance_PlayerTP::bLeanRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, QuickLeanLeftAmount) == 0x000C9C, "Member 'URoNAnimInstance_PlayerTP::QuickLeanLeftAmount' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, QuickLeanRightAmount) == 0x000CA0, "Member 'URoNAnimInstance_PlayerTP::QuickLeanRightAmount' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, QuickLeanLeftAlpha) == 0x000CA4, "Member 'URoNAnimInstance_PlayerTP::QuickLeanLeftAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, QuickLeanRightAlpha) == 0x000CA8, "Member 'URoNAnimInstance_PlayerTP::QuickLeanRightAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, QuickLeanIntensity) == 0x000CAC, "Member 'URoNAnimInstance_PlayerTP::QuickLeanIntensity' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, QuickLeanInterpSpeed) == 0x000CB0, "Member 'URoNAnimInstance_PlayerTP::QuickLeanInterpSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, FootIKValue) == 0x000CB4, "Member 'URoNAnimInstance_PlayerTP::FootIKValue' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, FootIKAlpha) == 0x000CB8, "Member 'URoNAnimInstance_PlayerTP::FootIKAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bRagdoll) == 0x000CBC, "Member 'URoNAnimInstance_PlayerTP::bRagdoll' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsPlayingDeathAnim) == 0x000CBD, "Member 'URoNAnimInstance_PlayerTP::bIsPlayingDeathAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bArrested) == 0x000CBE, "Member 'URoNAnimInstance_PlayerTP::bArrested' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsDead) == 0x000CBF, "Member 'URoNAnimInstance_PlayerTP::bIsDead' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bDeathAnimEnd) == 0x000CC0, "Member 'URoNAnimInstance_PlayerTP::bDeathAnimEnd' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bStunned) == 0x000CC1, "Member 'URoNAnimInstance_PlayerTP::bStunned' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bTased) == 0x000CC2, "Member 'URoNAnimInstance_PlayerTP::bTased' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bOnLadder) == 0x000CC3, "Member 'URoNAnimInstance_PlayerTP::bOnLadder' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, LadderUpDownMovement) == 0x000CC4, "Member 'URoNAnimInstance_PlayerTP::LadderUpDownMovement' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, LeanAngleY) == 0x000CC8, "Member 'URoNAnimInstance_PlayerTP::LeanAngleY' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, LeanAngleZ) == 0x000CCC, "Member 'URoNAnimInstance_PlayerTP::LeanAngleZ' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bCoverLeft) == 0x000CD0, "Member 'URoNAnimInstance_PlayerTP::bCoverLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bCoverRight) == 0x000CD1, "Member 'URoNAnimInstance_PlayerTP::bCoverRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bCoverMiddle) == 0x000CD2, "Member 'URoNAnimInstance_PlayerTP::bCoverMiddle' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bCoverLeftLow) == 0x000CD3, "Member 'URoNAnimInstance_PlayerTP::bCoverLeftLow' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bCoverRightLow) == 0x000CD4, "Member 'URoNAnimInstance_PlayerTP::bCoverRightLow' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bCoverPeek) == 0x000CD5, "Member 'URoNAnimInstance_PlayerTP::bCoverPeek' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, AimOffsetAlpha) == 0x000CD8, "Member 'URoNAnimInstance_PlayerTP::AimOffsetAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, AimOffsets) == 0x000CDC, "Member 'URoNAnimInstance_PlayerTP::AimOffsets' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bJumpStartTrigger) == 0x000CE4, "Member 'URoNAnimInstance_PlayerTP::bJumpStartTrigger' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, SmoothMappedLeanToAnimStandLeft) == 0x000CE8, "Member 'URoNAnimInstance_PlayerTP::SmoothMappedLeanToAnimStandLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, SmoothMappedLeanToAnimStandRight) == 0x000CEC, "Member 'URoNAnimInstance_PlayerTP::SmoothMappedLeanToAnimStandRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, SmoothMappedLeanToAnimCrouchLeft) == 0x000CF0, "Member 'URoNAnimInstance_PlayerTP::SmoothMappedLeanToAnimCrouchLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, SmoothMappedLeanToAnimCrouchRight) == 0x000CF4, "Member 'URoNAnimInstance_PlayerTP::SmoothMappedLeanToAnimCrouchRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Speed_tp_rifle_stand_sprint_f) == 0x000CF8, "Member 'URoNAnimInstance_PlayerTP::Speed_tp_rifle_stand_sprint_f' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Crouch_Idle_Pose_Low_TP) == 0x000D00, "Member 'URoNAnimInstance_PlayerTP::Crouch_Idle_Pose_Low_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Crouch_Idle_Pose_Up_TP) == 0x000D08, "Member 'URoNAnimInstance_PlayerTP::Crouch_Idle_Pose_Up_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Crouch_Idle_Pose_Shld_TP) == 0x000D10, "Member 'URoNAnimInstance_PlayerTP::Crouch_Idle_Pose_Shld_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Crouch_Idle_Pose_Sights_TP) == 0x000D18, "Member 'URoNAnimInstance_PlayerTP::Crouch_Idle_Pose_Sights_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Crouch_Idle_Pose_Ret_TP) == 0x000D20, "Member 'URoNAnimInstance_PlayerTP::Crouch_Idle_Pose_Ret_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Crouch_Idle_Pose_Ovr_TP) == 0x000D28, "Member 'URoNAnimInstance_PlayerTP::Crouch_Idle_Pose_Ovr_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_Low_TP) == 0x000D30, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_Low_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_Up_TP) == 0x000D38, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_Up_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_Shld_TP) == 0x000D40, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_Shld_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_Sights_TP) == 0x000D48, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_Sights_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_Ret_TP) == 0x000D50, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_Ret_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_Ovr_TP) == 0x000D58, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_Ovr_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_VFG_TP) == 0x000D60, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_VFG_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_AFG_TP) == 0x000D68, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_AFG_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_HSTOP_TP) == 0x000D70, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_HSTOP_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bLeaningLeftNotCrouching) == 0x000D78, "Member 'URoNAnimInstance_PlayerTP::bLeaningLeftNotCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bNotLeaningLeftOrCrouching) == 0x000D79, "Member 'URoNAnimInstance_PlayerTP::bNotLeaningLeftOrCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bNotLeaningLeftOrNotCrouching) == 0x000D7A, "Member 'URoNAnimInstance_PlayerTP::bNotLeaningLeftOrNotCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bLeaningRightNotCrouching) == 0x000D7B, "Member 'URoNAnimInstance_PlayerTP::bLeaningRightNotCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bNotLeaningRightOrCrouching) == 0x000D7C, "Member 'URoNAnimInstance_PlayerTP::bNotLeaningRightOrCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bNotLeaningRightOrNotCrouching) == 0x000D7D, "Member 'URoNAnimInstance_PlayerTP::bNotLeaningRightOrNotCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bCrouchingAndMoving) == 0x000D7E, "Member 'URoNAnimInstance_PlayerTP::bCrouchingAndMoving' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bNotCrouchingAndMoving) == 0x000D7F, "Member 'URoNAnimInstance_PlayerTP::bNotCrouchingAndMoving' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bAimingAndNotDeployable) == 0x000D80, "Member 'URoNAnimInstance_PlayerTP::bAimingAndNotDeployable' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, WalkSpeedForward) == 0x000D84, "Member 'URoNAnimInstance_PlayerTP::WalkSpeedForward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, WalkSpeedLeft) == 0x000D88, "Member 'URoNAnimInstance_PlayerTP::WalkSpeedLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, WalkSpeedRight) == 0x000D8C, "Member 'URoNAnimInstance_PlayerTP::WalkSpeedRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, WalkSpeedBackward) == 0x000D90, "Member 'URoNAnimInstance_PlayerTP::WalkSpeedBackward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CrouchWalkSpeedForward) == 0x000D94, "Member 'URoNAnimInstance_PlayerTP::CrouchWalkSpeedForward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CrouchWalkSpeedLeft) == 0x000D98, "Member 'URoNAnimInstance_PlayerTP::CrouchWalkSpeedLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CrouchWalkSpeedRight) == 0x000D9C, "Member 'URoNAnimInstance_PlayerTP::CrouchWalkSpeedRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CrouchWalkSpeedBackward) == 0x000DA0, "Member 'URoNAnimInstance_PlayerTP::CrouchWalkSpeedBackward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, RunSpeedForward) == 0x000DA4, "Member 'URoNAnimInstance_PlayerTP::RunSpeedForward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, RunSpeedLeft) == 0x000DA8, "Member 'URoNAnimInstance_PlayerTP::RunSpeedLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, RunSpeedRight) == 0x000DAC, "Member 'URoNAnimInstance_PlayerTP::RunSpeedRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, RunSpeedBackward) == 0x000DB0, "Member 'URoNAnimInstance_PlayerTP::RunSpeedBackward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bLessThanPointOneSecondOnRelevantAnim) == 0x000DB4, "Member 'URoNAnimInstance_PlayerTP::bLessThanPointOneSecondOnRelevantAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsInCombatOrAlerted) == 0x000DB5, "Member 'URoNAnimInstance_PlayerTP::bIsInCombatOrAlerted' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bMoving) == 0x000DB6, "Member 'URoNAnimInstance_PlayerTP::bMoving' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsAlerted) == 0x000DB7, "Member 'URoNAnimInstance_PlayerTP::bIsAlerted' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, AlertAlpha) == 0x000DB8, "Member 'URoNAnimInstance_PlayerTP::AlertAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsInCombat) == 0x000DBC, "Member 'URoNAnimInstance_PlayerTP::bIsInCombat' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsSurrendering) == 0x000DBD, "Member 'URoNAnimInstance_PlayerTP::bIsSurrendering' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bSprayed) == 0x000DBE, "Member 'URoNAnimInstance_PlayerTP::bSprayed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bStung) == 0x000DBF, "Member 'URoNAnimInstance_PlayerTP::bStung' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CurPseudoSpeed) == 0x000DC0, "Member 'URoNAnimInstance_PlayerTP::CurPseudoSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bFemale) == 0x000DC1, "Member 'URoNAnimInstance_PlayerTP::bFemale' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bChild) == 0x000DC2, "Member 'URoNAnimInstance_PlayerTP::bChild' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bHasInjury) == 0x000DC3, "Member 'URoNAnimInstance_PlayerTP::bHasInjury' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, AnimSpeedFwdPlayrateSync) == 0x000DC4, "Member 'URoNAnimInstance_PlayerTP::AnimSpeedFwdPlayrateSync' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, AnimSpeedSidePlayrateSync) == 0x000DC8, "Member 'URoNAnimInstance_PlayerTP::AnimSpeedSidePlayrateSync' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, AnimSpeedPlayrateSync) == 0x000DCC, "Member 'URoNAnimInstance_PlayerTP::AnimSpeedPlayrateSync' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, RetentionAlpha) == 0x000DD0, "Member 'URoNAnimInstance_PlayerTP::RetentionAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, LoweredAlpha) == 0x000DD4, "Member 'URoNAnimInstance_PlayerTP::LoweredAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, SightAlpha) == 0x000DE0, "Member 'URoNAnimInstance_PlayerTP::SightAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, LoweredCooldownTime) == 0x000DE4, "Member 'URoNAnimInstance_PlayerTP::LoweredCooldownTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, IsLoweredUp) == 0x000DE8, "Member 'URoNAnimInstance_PlayerTP::IsLoweredUp' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, ArmsOnlySlotAlpha) == 0x000DFC, "Member 'URoNAnimInstance_PlayerTP::ArmsOnlySlotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, LeftArmOnlySlotAlpha) == 0x000E00, "Member 'URoNAnimInstance_PlayerTP::LeftArmOnlySlotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, VelocityInterpTime) == 0x000E04, "Member 'URoNAnimInstance_PlayerTP::VelocityInterpTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, VelocitySmoothed) == 0x000E08, "Member 'URoNAnimInstance_PlayerTP::VelocitySmoothed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, SpeedScaling) == 0x000E14, "Member 'URoNAnimInstance_PlayerTP::SpeedScaling' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, PlayrateClampMax) == 0x000E18, "Member 'URoNAnimInstance_PlayerTP::PlayrateClampMax' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CharMovementSnapshot) == 0x000E1C, "Member 'URoNAnimInstance_PlayerTP::CharMovementSnapshot' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, PostPivotTriggerThreshold) == 0x000EB0, "Member 'URoNAnimInstance_PlayerTP::PostPivotTriggerThreshold' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, PivotingCardinalDirSnapShot) == 0x000EB4, "Member 'URoNAnimInstance_PlayerTP::PivotingCardinalDirSnapShot' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CharacterRef) == 0x000ED8, "Member 'URoNAnimInstance_PlayerTP::CharacterRef' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CharacterAiRef) == 0x000EE0, "Member 'URoNAnimInstance_PlayerTP::CharacterAiRef' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bUseDistanceMatching) == 0x000EE8, "Member 'URoNAnimInstance_PlayerTP::bUseDistanceMatching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, DistanceMatchingCurrentState) == 0x000EE9, "Member 'URoNAnimInstance_PlayerTP::DistanceMatchingCurrentState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, StartMarker) == 0x000EEC, "Member 'URoNAnimInstance_PlayerTP::StartMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, StopMarker) == 0x000F0C, "Member 'URoNAnimInstance_PlayerTP::StopMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, PivotMarker) == 0x000F2C, "Member 'URoNAnimInstance_PlayerTP::PivotMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, PostPivotMarker) == 0x000F4C, "Member 'URoNAnimInstance_PlayerTP::PostPivotMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, TakeOffMarker) == 0x000F6C, "Member 'URoNAnimInstance_PlayerTP::TakeOffMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, ApexMarker) == 0x000F8C, "Member 'URoNAnimInstance_PlayerTP::ApexMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, LandingMarker) == 0x000FAC, "Member 'URoNAnimInstance_PlayerTP::LandingMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CurrentPivotDirectionExt) == 0x000FCC, "Member 'URoNAnimInstance_PlayerTP::CurrentPivotDirectionExt' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bPivotDirectionBroken) == 0x000FCD, "Member 'URoNAnimInstance_PlayerTP::bPivotDirectionBroken' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bCanPivotInCurDirection) == 0x000FCE, "Member 'URoNAnimInstance_PlayerTP::bCanPivotInCurDirection' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bSMPrePivotRuleset) == 0x000FCF, "Member 'URoNAnimInstance_PlayerTP::bSMPrePivotRuleset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bStartDirectionBroken) == 0x000FD0, "Member 'URoNAnimInstance_PlayerTP::bStartDirectionBroken' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, ReplicatedMaxSpeed) == 0x000FD4, "Member 'URoNAnimInstance_PlayerTP::ReplicatedMaxSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bSMStartRuleset) == 0x000FD8, "Member 'URoNAnimInstance_PlayerTP::bSMStartRuleset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bSMStopRuleset) == 0x000FD9, "Member 'URoNAnimInstance_PlayerTP::bSMStopRuleset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, PelvisDefaultWorldPos) == 0x000FDC, "Member 'URoNAnimInstance_PlayerTP::PelvisDefaultWorldPos' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CrouchedPelvisDefaultWorldPos) == 0x000FE8, "Member 'URoNAnimInstance_PlayerTP::CrouchedPelvisDefaultWorldPos' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CrouchedPelvisMovingWorldPos) == 0x000FF4, "Member 'URoNAnimInstance_PlayerTP::CrouchedPelvisMovingWorldPos' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CrouchedPelvisCurrentWorldPos) == 0x001000, "Member 'URoNAnimInstance_PlayerTP::CrouchedPelvisCurrentWorldPos' has a wrong offset!");

// Class ReadyOrNot.RoNAnimInstance_PlayerTP_V2
// 0x0790 (0x0BF0 - 0x0460)
class URoNAnimInstance_PlayerTP_V2 : public UReadyOrNotAnimInstance
{
public:
	class UReadyOrNotWeaponAnimData*              LastAnimWeaponData;                                // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotWeaponAnimData*              EditorWeaponAnimData;                              // 0x0468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowTurnInPlace;                                 // 0x0470(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C0[0x3];                                     // 0x0471(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YawOffsetLimit;                                    // 0x0474(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceSpeedMultiplier;                        // 0x0478(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C1[0x4];                                     // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimTurnInPlaceAnimSet                TurnInPlaceAnimSet;                                // 0x0480(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAnimTurnInPlaceState                  TurnInPlaceState;                                  // 0x0498(0x0058)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimTurnInPlaceAnimSet                StandRifAnimSet;                                   // 0x04F0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAnimTurnInPlaceAnimSet                CrouchRifAnimSet;                                  // 0x0508(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsAIControlled;                                   // 0x0520(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponDown;                                       // 0x0521(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAiming;                                         // 0x0522(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShieldEquipped;                                 // 0x0523(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimingAlpha;                                       // 0x0524(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeanLeft;                                         // 0x0528(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeanRight;                                        // 0x0529(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C2[0x2];                                     // 0x052A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QuickLeanLeftAmount;                               // 0x052C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanRightAmount;                              // 0x0530(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanLeftAlpha;                                // 0x0534(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanRightAlpha;                               // 0x0538(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanIntensity;                                // 0x053C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanInterpSpeed;                              // 0x0540(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKValue;                                       // 0x0544(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKAlpha;                                       // 0x0548(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRagdoll;                                          // 0x054C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayingDeathAnim;                               // 0x054D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArrested;                                         // 0x054E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x054F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeathAnimEnd;                                     // 0x0550(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStunned;                                          // 0x0551(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTased;                                            // 0x0552(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnLadder;                                         // 0x0553(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LadderUpDownMovement;                              // 0x0554(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAngleY;                                        // 0x0558(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAngleZ;                                        // 0x055C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverLeft;                                        // 0x0560(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverRight;                                       // 0x0561(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverMiddle;                                      // 0x0562(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverLeftLow;                                     // 0x0563(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverRightLow;                                    // 0x0564(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverPeek;                                        // 0x0565(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C3[0x2];                                     // 0x0566(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimOffsetAlpha;                                    // 0x0568(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AimOffsets;                                        // 0x056C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumpStartTrigger;                                 // 0x0574(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C4[0x3];                                     // 0x0575(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmoothMappedLeanToAnimStandLeft;                   // 0x0578(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothMappedLeanToAnimStandRight;                  // 0x057C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothMappedLeanToAnimCrouchLeft;                  // 0x0580(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothMappedLeanToAnimCrouchRight;                 // 0x0584(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_tp_rifle_stand_sprint_f;                     // 0x0588(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C5[0x4];                                     // 0x058C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Low_TP;                           // 0x0590(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Up_TP;                            // 0x0598(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Shld_TP;                          // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Sights_TP;                        // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Ret_TP;                           // 0x05B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Ovr_TP;                           // 0x05B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Low_TP;                                  // 0x05C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Up_TP;                                   // 0x05C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Shld_TP;                                 // 0x05D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Sights_TP;                               // 0x05D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Ret_TP;                                  // 0x05E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Ovr_TP;                                  // 0x05E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_VFG_TP;                                  // 0x05F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_AFG_TP;                                  // 0x05F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_HSTOP_TP;                                // 0x0600(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaningLeftNotCrouching;                          // 0x0608(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotLeaningLeftOrCrouching;                        // 0x0609(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotLeaningLeftOrNotCrouching;                     // 0x060A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaningRightNotCrouching;                         // 0x060B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotLeaningRightOrCrouching;                       // 0x060C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotLeaningRightOrNotCrouching;                    // 0x060D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouchingAndMoving;                               // 0x060E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotCrouchingAndMoving;                            // 0x060F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAimingAndNotDeployable;                           // 0x0610(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C6[0x3];                                     // 0x0611(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkSpeedForward;                                  // 0x0614(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedLeft;                                     // 0x0618(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedRight;                                    // 0x061C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedBackward;                                 // 0x0620(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWalkSpeedForward;                            // 0x0624(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWalkSpeedLeft;                               // 0x0628(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWalkSpeedRight;                              // 0x062C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWalkSpeedBackward;                           // 0x0630(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedForward;                                   // 0x0634(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedLeft;                                      // 0x0638(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedRight;                                     // 0x063C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedBackward;                                  // 0x0640(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLessThanPointOneSecondOnRelevantAnim;             // 0x0644(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInCombatOrAlerted;                              // 0x0645(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoving;                                           // 0x0646(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAlerted;                                        // 0x0647(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlertAlpha;                                        // 0x0648(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInCombat;                                       // 0x064C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSurrendering;                                   // 0x064D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSprayed;                                          // 0x064E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStung;                                            // 0x064F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPseudoSpeedType                              CurPseudoSpeed;                                    // 0x0650(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFemale;                                           // 0x0651(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChild;                                            // 0x0652(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasInjury;                                        // 0x0653(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSpeedFwdPlayrateSync;                          // 0x0654(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSpeedSidePlayrateSync;                         // 0x0658(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSpeedPlayrateSync;                             // 0x065C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetentionAlpha;                                    // 0x0660(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoweredAlpha;                                      // 0x0664(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C7[0x8];                                     // 0x0668(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SightAlpha;                                        // 0x0670(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoweredCooldownTime;                               // 0x0674(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLoweredUp;                                       // 0x0678(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C8[0x13];                                    // 0x0679(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArmsOnlySlotAlpha;                                 // 0x068C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftArmOnlySlotAlpha;                              // 0x0690(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityInterpTime;                                // 0x0694(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocitySmoothed;                                  // 0x0698(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimCharacterMovementSnapshot         CharMovementSnapshot;                              // 0x06A4(0x0094)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PostPivotTriggerThreshold;                         // 0x0738(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCardinalDirectionSnapshot             PivotingCardinalDirSnapShot;                       // 0x073C(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C9[0xC];                                     // 0x0754(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   BaseCharacterRef;                                  // 0x0760(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       CharacterRef;                                      // 0x0768(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   CharacterAiRef;                                    // 0x0770(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDistanceMatching;                              // 0x0778(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistanceMatchingType                         DistanceMatchingCurrentState;                      // 0x0779(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28CA[0x2];                                     // 0x077A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionResult                      StartMarker;                                       // 0x077C(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      StopMarker;                                        // 0x079C(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      PivotMarker;                                       // 0x07BC(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      PostPivotMarker;                                   // 0x07DC(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      TakeOffMarker;                                     // 0x07FC(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      ApexMarker;                                        // 0x081C(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      LandingMarker;                                     // 0x083C(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	EMoveDirectionExt                             CurrentPivotDirectionExt;                          // 0x085C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPivotDirectionBroken;                             // 0x085D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPivotInCurDirection;                           // 0x085E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSMPrePivotRuleset;                                // 0x085F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartDirectionBroken;                             // 0x0860(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28CB[0x3];                                     // 0x0861(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReplicatedMaxSpeed;                                // 0x0864(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSMStartRuleset;                                   // 0x0868(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSMStopRuleset;                                    // 0x0869(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDistanceMatchToTarget;                            // 0x086A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28CC[0x1];                                     // 0x086B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DistanceCurveName;                                 // 0x086C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PelvisDefaultWorldPos;                             // 0x0874(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CrouchedPelvisDefaultWorldPos;                     // 0x0880(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CrouchedPelvisMovingWorldPos;                      // 0x088C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CrouchedPelvisCurrentWorldPos;                     // 0x0898(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   IdleStateData;                                     // 0x08A4(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   StartStateData;                                    // 0x08C0(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   MoveStateData;                                     // 0x08DC(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   StopStateData;                                     // 0x08F8(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   PrePivotStateData;                                 // 0x0914(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   PostPivotStateData;                                // 0x0930(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   TurnInPlaceStateData;                              // 0x094C(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   LocalTurnInPlaceStateData;                         // 0x0968(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28CD[0x4A];                                    // 0x0984(0x004A)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bStartToCycleRuleSet;                              // 0x09CE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerPivotARuleSet;                             // 0x09CF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerPivotBRuleSet;                             // 0x09D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrePivotToPostPivotRuleSet;                       // 0x09D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPostPivotToPrePivotRuleSet;                       // 0x09D2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPivotToCycleRuleSet;                              // 0x09D3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopToIdleRuleSet;                                // 0x09D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterPrePivotRuleSet;                          // 0x09D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28CE[0x2];                                     // 0x09D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  StandFastStartAnimations;                          // 0x09D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  StandFastStopAnimations;                           // 0x09E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  StandFastPivotAnimations;                          // 0x09F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  StandSlowStartAnimations;                          // 0x0A08(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  StandSlowStopAnimations;                           // 0x0A18(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  StandSlowPivotAnimations;                          // 0x0A28(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  CrouchFastStartAnimations;                         // 0x0A38(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  CrouchFastStopAnimations;                          // 0x0A48(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  CrouchFastPivotAnimations;                         // 0x0A58(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  CrouchSlowStartAnimations;                         // 0x0A68(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  CrouchSlowStopAnimations;                          // 0x0A78(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  CrouchSlowPivotAnimations;                         // 0x0A88(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ActiveStopAnim;                                    // 0x0A98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveStopAnimTime;                                // 0x0AA0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28CF[0x4];                                     // 0x0AA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ActiveStartAnim;                                   // 0x0AA8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveStartAnimTime;                               // 0x0AB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D0[0x4];                                     // 0x0AB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ActivePrePivotAnim;                                // 0x0AB8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivePrePivotAnimTime;                            // 0x0AC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D1[0x4];                                     // 0x0AC4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ActivePostPivotAnim;                               // 0x0AC8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivePostPivotAnimTime;                           // 0x0AD0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIdleStateRelevant;                              // 0x0AD4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStartStateRelevant;                             // 0x0AD5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStopStateRelevant;                              // 0x0AD6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPrePivotStateRelevant;                          // 0x0AD7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPostPivotStateRelevant;                         // 0x0AD8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoveStateRelevant;                              // 0x0AD9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTurnInPlaceStateRelevant;                       // 0x0ADA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStartStateFullWeight;                           // 0x0ADB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPrePivotStateFullWeight;                        // 0x0ADC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPostPivotStateFullWeight;                       // 0x0ADD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D2[0x2];                                     // 0x0ADE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeInStartState;                                  // 0x0AE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeInPostPivotState;                              // 0x0AE4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReadDisableSpeedCurve;                            // 0x0AE8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D3[0x3];                                     // 0x0AE9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisableSpeedWarping;                               // 0x0AEC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedScaling;                                      // 0x0AF0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayrateClampMax;                                  // 0x0AF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PlayRateClamp;                                     // 0x0AF8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PlayRateClampCycle;                                // 0x0B00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PlayRateClampStartsPivots;                         // 0x0B08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrideWarpingBlendInStartOffset;                   // 0x0B10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrideWarpingBlendInDurationScaled;                // 0x0B14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrideWarpingStartAlpha;                           // 0x0B18(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrideWarpingPivotAlpha;                           // 0x0B1C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionBlendTime;                                // 0x0B20(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D4[0x4];                                     // 0x0B24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseSnapshot                          DeathPose;                                         // 0x0B28(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	float                                         SlopeWarpingAlpha;                                 // 0x0B60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsItemOrPistolMotionBlock;                        // 0x0B64(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRifleMotionBlock;                               // 0x0B65(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCrouchingWithShield;                            // 0x0B66(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D5[0x1];                                     // 0x0B67(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrouchHighPoseAdditiveAlpha;                       // 0x0B68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandHighPoseAdditiveAlpha;                        // 0x0B6C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandIKAlpha_ItemBased;                         // 0x0B70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ZHeightLeanAdjustment;                             // 0x0B74(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsCrouchingWithShield_AsFloat;                     // 0x0B80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandAdditiveLockOverride;                          // 0x0B84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandAdditiveOvrBlend;                          // 0x0B88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandTempFinIK;                                 // 0x0B8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastWalkSwitchRule;                               // 0x0B90(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouchFastWalkSwitchRule;                         // 0x0B91(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartWalkSwitchTransitionRule;                    // 0x0B92(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D6[0x1];                                     // 0x0B93(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultCrouchSpeed;                                // 0x0B94(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultStandSpeed;                                 // 0x0B98(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWalkSwitchTransitionRule;                     // 0x0B9C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPivotWalkSwitchTransitionRule;                    // 0x0B9D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasUnderbarrelAttachment;                         // 0x0B9E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponUnderbarrelAnimationType               UnderbarrelType;                                   // 0x0B9F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandGripAlpha;                                 // 0x0BA0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperbodySlotNoWeight;                             // 0x0BA4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFastWalking;                                    // 0x0BA8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFastStop;                                       // 0x0BA9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFastStart;                                      // 0x0BAA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFastPivot;                                      // 0x0BAB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocallyFirstPerson;                             // 0x0BAC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPFStartPhase;                                     // 0x0BAD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPFStoppingPhase;                                  // 0x0BAE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPFHasReachedStoppingPhase;                        // 0x0BAF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PFStartDistanceThreshold;                          // 0x0BB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PFStopDistanceThreshold;                           // 0x0BB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PFLastStopLocation;                                // 0x0BB8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PFCurrentStopLocation;                             // 0x0BC4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PFStopDistance;                                    // 0x0BD0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PFCurrentAcceptanceRadius;                         // 0x0BD4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPFPathTooShort;                                   // 0x0BD8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPFPathIsValid;                                    // 0x0BD9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPFRequestedNewPath;                               // 0x0BDA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D7[0x15];                                    // 0x0BDB(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAnimSequenceBase* GetPlayerAnimation_TP(EBaseAnimType_TP AnimName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoNAnimInstance_PlayerTP_V2">();
	}
	static class URoNAnimInstance_PlayerTP_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoNAnimInstance_PlayerTP_V2>();
	}
};
static_assert(alignof(URoNAnimInstance_PlayerTP_V2) == 0x000010, "Wrong alignment on URoNAnimInstance_PlayerTP_V2");
static_assert(sizeof(URoNAnimInstance_PlayerTP_V2) == 0x000BF0, "Wrong size on URoNAnimInstance_PlayerTP_V2");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LastAnimWeaponData) == 0x000460, "Member 'URoNAnimInstance_PlayerTP_V2::LastAnimWeaponData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, EditorWeaponAnimData) == 0x000468, "Member 'URoNAnimInstance_PlayerTP_V2::EditorWeaponAnimData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bAllowTurnInPlace) == 0x000470, "Member 'URoNAnimInstance_PlayerTP_V2::bAllowTurnInPlace' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, YawOffsetLimit) == 0x000474, "Member 'URoNAnimInstance_PlayerTP_V2::YawOffsetLimit' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, TurnInPlaceSpeedMultiplier) == 0x000478, "Member 'URoNAnimInstance_PlayerTP_V2::TurnInPlaceSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, TurnInPlaceAnimSet) == 0x000480, "Member 'URoNAnimInstance_PlayerTP_V2::TurnInPlaceAnimSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, TurnInPlaceState) == 0x000498, "Member 'URoNAnimInstance_PlayerTP_V2::TurnInPlaceState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StandRifAnimSet) == 0x0004F0, "Member 'URoNAnimInstance_PlayerTP_V2::StandRifAnimSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchRifAnimSet) == 0x000508, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchRifAnimSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsAIControlled) == 0x000520, "Member 'URoNAnimInstance_PlayerTP_V2::bIsAIControlled' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bWeaponDown) == 0x000521, "Member 'URoNAnimInstance_PlayerTP_V2::bWeaponDown' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsAiming) == 0x000522, "Member 'URoNAnimInstance_PlayerTP_V2::bIsAiming' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsShieldEquipped) == 0x000523, "Member 'URoNAnimInstance_PlayerTP_V2::bIsShieldEquipped' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, AimingAlpha) == 0x000524, "Member 'URoNAnimInstance_PlayerTP_V2::AimingAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bLeanLeft) == 0x000528, "Member 'URoNAnimInstance_PlayerTP_V2::bLeanLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bLeanRight) == 0x000529, "Member 'URoNAnimInstance_PlayerTP_V2::bLeanRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, QuickLeanLeftAmount) == 0x00052C, "Member 'URoNAnimInstance_PlayerTP_V2::QuickLeanLeftAmount' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, QuickLeanRightAmount) == 0x000530, "Member 'URoNAnimInstance_PlayerTP_V2::QuickLeanRightAmount' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, QuickLeanLeftAlpha) == 0x000534, "Member 'URoNAnimInstance_PlayerTP_V2::QuickLeanLeftAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, QuickLeanRightAlpha) == 0x000538, "Member 'URoNAnimInstance_PlayerTP_V2::QuickLeanRightAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, QuickLeanIntensity) == 0x00053C, "Member 'URoNAnimInstance_PlayerTP_V2::QuickLeanIntensity' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, QuickLeanInterpSpeed) == 0x000540, "Member 'URoNAnimInstance_PlayerTP_V2::QuickLeanInterpSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, FootIKValue) == 0x000544, "Member 'URoNAnimInstance_PlayerTP_V2::FootIKValue' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, FootIKAlpha) == 0x000548, "Member 'URoNAnimInstance_PlayerTP_V2::FootIKAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bRagdoll) == 0x00054C, "Member 'URoNAnimInstance_PlayerTP_V2::bRagdoll' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsPlayingDeathAnim) == 0x00054D, "Member 'URoNAnimInstance_PlayerTP_V2::bIsPlayingDeathAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bArrested) == 0x00054E, "Member 'URoNAnimInstance_PlayerTP_V2::bArrested' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsDead) == 0x00054F, "Member 'URoNAnimInstance_PlayerTP_V2::bIsDead' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bDeathAnimEnd) == 0x000550, "Member 'URoNAnimInstance_PlayerTP_V2::bDeathAnimEnd' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bStunned) == 0x000551, "Member 'URoNAnimInstance_PlayerTP_V2::bStunned' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bTased) == 0x000552, "Member 'URoNAnimInstance_PlayerTP_V2::bTased' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bOnLadder) == 0x000553, "Member 'URoNAnimInstance_PlayerTP_V2::bOnLadder' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LadderUpDownMovement) == 0x000554, "Member 'URoNAnimInstance_PlayerTP_V2::LadderUpDownMovement' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LeanAngleY) == 0x000558, "Member 'URoNAnimInstance_PlayerTP_V2::LeanAngleY' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LeanAngleZ) == 0x00055C, "Member 'URoNAnimInstance_PlayerTP_V2::LeanAngleZ' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCoverLeft) == 0x000560, "Member 'URoNAnimInstance_PlayerTP_V2::bCoverLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCoverRight) == 0x000561, "Member 'URoNAnimInstance_PlayerTP_V2::bCoverRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCoverMiddle) == 0x000562, "Member 'URoNAnimInstance_PlayerTP_V2::bCoverMiddle' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCoverLeftLow) == 0x000563, "Member 'URoNAnimInstance_PlayerTP_V2::bCoverLeftLow' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCoverRightLow) == 0x000564, "Member 'URoNAnimInstance_PlayerTP_V2::bCoverRightLow' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCoverPeek) == 0x000565, "Member 'URoNAnimInstance_PlayerTP_V2::bCoverPeek' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, AimOffsetAlpha) == 0x000568, "Member 'URoNAnimInstance_PlayerTP_V2::AimOffsetAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, AimOffsets) == 0x00056C, "Member 'URoNAnimInstance_PlayerTP_V2::AimOffsets' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bJumpStartTrigger) == 0x000574, "Member 'URoNAnimInstance_PlayerTP_V2::bJumpStartTrigger' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, SmoothMappedLeanToAnimStandLeft) == 0x000578, "Member 'URoNAnimInstance_PlayerTP_V2::SmoothMappedLeanToAnimStandLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, SmoothMappedLeanToAnimStandRight) == 0x00057C, "Member 'URoNAnimInstance_PlayerTP_V2::SmoothMappedLeanToAnimStandRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, SmoothMappedLeanToAnimCrouchLeft) == 0x000580, "Member 'URoNAnimInstance_PlayerTP_V2::SmoothMappedLeanToAnimCrouchLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, SmoothMappedLeanToAnimCrouchRight) == 0x000584, "Member 'URoNAnimInstance_PlayerTP_V2::SmoothMappedLeanToAnimCrouchRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Speed_tp_rifle_stand_sprint_f) == 0x000588, "Member 'URoNAnimInstance_PlayerTP_V2::Speed_tp_rifle_stand_sprint_f' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Crouch_Idle_Pose_Low_TP) == 0x000590, "Member 'URoNAnimInstance_PlayerTP_V2::Crouch_Idle_Pose_Low_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Crouch_Idle_Pose_Up_TP) == 0x000598, "Member 'URoNAnimInstance_PlayerTP_V2::Crouch_Idle_Pose_Up_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Crouch_Idle_Pose_Shld_TP) == 0x0005A0, "Member 'URoNAnimInstance_PlayerTP_V2::Crouch_Idle_Pose_Shld_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Crouch_Idle_Pose_Sights_TP) == 0x0005A8, "Member 'URoNAnimInstance_PlayerTP_V2::Crouch_Idle_Pose_Sights_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Crouch_Idle_Pose_Ret_TP) == 0x0005B0, "Member 'URoNAnimInstance_PlayerTP_V2::Crouch_Idle_Pose_Ret_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Crouch_Idle_Pose_Ovr_TP) == 0x0005B8, "Member 'URoNAnimInstance_PlayerTP_V2::Crouch_Idle_Pose_Ovr_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_Low_TP) == 0x0005C0, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_Low_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_Up_TP) == 0x0005C8, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_Up_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_Shld_TP) == 0x0005D0, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_Shld_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_Sights_TP) == 0x0005D8, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_Sights_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_Ret_TP) == 0x0005E0, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_Ret_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_Ovr_TP) == 0x0005E8, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_Ovr_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_VFG_TP) == 0x0005F0, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_VFG_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_AFG_TP) == 0x0005F8, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_AFG_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_HSTOP_TP) == 0x000600, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_HSTOP_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bLeaningLeftNotCrouching) == 0x000608, "Member 'URoNAnimInstance_PlayerTP_V2::bLeaningLeftNotCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bNotLeaningLeftOrCrouching) == 0x000609, "Member 'URoNAnimInstance_PlayerTP_V2::bNotLeaningLeftOrCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bNotLeaningLeftOrNotCrouching) == 0x00060A, "Member 'URoNAnimInstance_PlayerTP_V2::bNotLeaningLeftOrNotCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bLeaningRightNotCrouching) == 0x00060B, "Member 'URoNAnimInstance_PlayerTP_V2::bLeaningRightNotCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bNotLeaningRightOrCrouching) == 0x00060C, "Member 'URoNAnimInstance_PlayerTP_V2::bNotLeaningRightOrCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bNotLeaningRightOrNotCrouching) == 0x00060D, "Member 'URoNAnimInstance_PlayerTP_V2::bNotLeaningRightOrNotCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCrouchingAndMoving) == 0x00060E, "Member 'URoNAnimInstance_PlayerTP_V2::bCrouchingAndMoving' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bNotCrouchingAndMoving) == 0x00060F, "Member 'URoNAnimInstance_PlayerTP_V2::bNotCrouchingAndMoving' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bAimingAndNotDeployable) == 0x000610, "Member 'URoNAnimInstance_PlayerTP_V2::bAimingAndNotDeployable' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, WalkSpeedForward) == 0x000614, "Member 'URoNAnimInstance_PlayerTP_V2::WalkSpeedForward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, WalkSpeedLeft) == 0x000618, "Member 'URoNAnimInstance_PlayerTP_V2::WalkSpeedLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, WalkSpeedRight) == 0x00061C, "Member 'URoNAnimInstance_PlayerTP_V2::WalkSpeedRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, WalkSpeedBackward) == 0x000620, "Member 'URoNAnimInstance_PlayerTP_V2::WalkSpeedBackward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchWalkSpeedForward) == 0x000624, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchWalkSpeedForward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchWalkSpeedLeft) == 0x000628, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchWalkSpeedLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchWalkSpeedRight) == 0x00062C, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchWalkSpeedRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchWalkSpeedBackward) == 0x000630, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchWalkSpeedBackward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, RunSpeedForward) == 0x000634, "Member 'URoNAnimInstance_PlayerTP_V2::RunSpeedForward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, RunSpeedLeft) == 0x000638, "Member 'URoNAnimInstance_PlayerTP_V2::RunSpeedLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, RunSpeedRight) == 0x00063C, "Member 'URoNAnimInstance_PlayerTP_V2::RunSpeedRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, RunSpeedBackward) == 0x000640, "Member 'URoNAnimInstance_PlayerTP_V2::RunSpeedBackward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bLessThanPointOneSecondOnRelevantAnim) == 0x000644, "Member 'URoNAnimInstance_PlayerTP_V2::bLessThanPointOneSecondOnRelevantAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsInCombatOrAlerted) == 0x000645, "Member 'URoNAnimInstance_PlayerTP_V2::bIsInCombatOrAlerted' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bMoving) == 0x000646, "Member 'URoNAnimInstance_PlayerTP_V2::bMoving' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsAlerted) == 0x000647, "Member 'URoNAnimInstance_PlayerTP_V2::bIsAlerted' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, AlertAlpha) == 0x000648, "Member 'URoNAnimInstance_PlayerTP_V2::AlertAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsInCombat) == 0x00064C, "Member 'URoNAnimInstance_PlayerTP_V2::bIsInCombat' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsSurrendering) == 0x00064D, "Member 'URoNAnimInstance_PlayerTP_V2::bIsSurrendering' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bSprayed) == 0x00064E, "Member 'URoNAnimInstance_PlayerTP_V2::bSprayed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bStung) == 0x00064F, "Member 'URoNAnimInstance_PlayerTP_V2::bStung' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CurPseudoSpeed) == 0x000650, "Member 'URoNAnimInstance_PlayerTP_V2::CurPseudoSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bFemale) == 0x000651, "Member 'URoNAnimInstance_PlayerTP_V2::bFemale' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bChild) == 0x000652, "Member 'URoNAnimInstance_PlayerTP_V2::bChild' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bHasInjury) == 0x000653, "Member 'URoNAnimInstance_PlayerTP_V2::bHasInjury' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, AnimSpeedFwdPlayrateSync) == 0x000654, "Member 'URoNAnimInstance_PlayerTP_V2::AnimSpeedFwdPlayrateSync' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, AnimSpeedSidePlayrateSync) == 0x000658, "Member 'URoNAnimInstance_PlayerTP_V2::AnimSpeedSidePlayrateSync' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, AnimSpeedPlayrateSync) == 0x00065C, "Member 'URoNAnimInstance_PlayerTP_V2::AnimSpeedPlayrateSync' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, RetentionAlpha) == 0x000660, "Member 'URoNAnimInstance_PlayerTP_V2::RetentionAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LoweredAlpha) == 0x000664, "Member 'URoNAnimInstance_PlayerTP_V2::LoweredAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, SightAlpha) == 0x000670, "Member 'URoNAnimInstance_PlayerTP_V2::SightAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LoweredCooldownTime) == 0x000674, "Member 'URoNAnimInstance_PlayerTP_V2::LoweredCooldownTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, IsLoweredUp) == 0x000678, "Member 'URoNAnimInstance_PlayerTP_V2::IsLoweredUp' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ArmsOnlySlotAlpha) == 0x00068C, "Member 'URoNAnimInstance_PlayerTP_V2::ArmsOnlySlotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LeftArmOnlySlotAlpha) == 0x000690, "Member 'URoNAnimInstance_PlayerTP_V2::LeftArmOnlySlotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, VelocityInterpTime) == 0x000694, "Member 'URoNAnimInstance_PlayerTP_V2::VelocityInterpTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, VelocitySmoothed) == 0x000698, "Member 'URoNAnimInstance_PlayerTP_V2::VelocitySmoothed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CharMovementSnapshot) == 0x0006A4, "Member 'URoNAnimInstance_PlayerTP_V2::CharMovementSnapshot' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PostPivotTriggerThreshold) == 0x000738, "Member 'URoNAnimInstance_PlayerTP_V2::PostPivotTriggerThreshold' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PivotingCardinalDirSnapShot) == 0x00073C, "Member 'URoNAnimInstance_PlayerTP_V2::PivotingCardinalDirSnapShot' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, BaseCharacterRef) == 0x000760, "Member 'URoNAnimInstance_PlayerTP_V2::BaseCharacterRef' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CharacterRef) == 0x000768, "Member 'URoNAnimInstance_PlayerTP_V2::CharacterRef' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CharacterAiRef) == 0x000770, "Member 'URoNAnimInstance_PlayerTP_V2::CharacterAiRef' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bUseDistanceMatching) == 0x000778, "Member 'URoNAnimInstance_PlayerTP_V2::bUseDistanceMatching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, DistanceMatchingCurrentState) == 0x000779, "Member 'URoNAnimInstance_PlayerTP_V2::DistanceMatchingCurrentState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StartMarker) == 0x00077C, "Member 'URoNAnimInstance_PlayerTP_V2::StartMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StopMarker) == 0x00079C, "Member 'URoNAnimInstance_PlayerTP_V2::StopMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PivotMarker) == 0x0007BC, "Member 'URoNAnimInstance_PlayerTP_V2::PivotMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PostPivotMarker) == 0x0007DC, "Member 'URoNAnimInstance_PlayerTP_V2::PostPivotMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, TakeOffMarker) == 0x0007FC, "Member 'URoNAnimInstance_PlayerTP_V2::TakeOffMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ApexMarker) == 0x00081C, "Member 'URoNAnimInstance_PlayerTP_V2::ApexMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LandingMarker) == 0x00083C, "Member 'URoNAnimInstance_PlayerTP_V2::LandingMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CurrentPivotDirectionExt) == 0x00085C, "Member 'URoNAnimInstance_PlayerTP_V2::CurrentPivotDirectionExt' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPivotDirectionBroken) == 0x00085D, "Member 'URoNAnimInstance_PlayerTP_V2::bPivotDirectionBroken' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCanPivotInCurDirection) == 0x00085E, "Member 'URoNAnimInstance_PlayerTP_V2::bCanPivotInCurDirection' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bSMPrePivotRuleset) == 0x00085F, "Member 'URoNAnimInstance_PlayerTP_V2::bSMPrePivotRuleset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bStartDirectionBroken) == 0x000860, "Member 'URoNAnimInstance_PlayerTP_V2::bStartDirectionBroken' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ReplicatedMaxSpeed) == 0x000864, "Member 'URoNAnimInstance_PlayerTP_V2::ReplicatedMaxSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bSMStartRuleset) == 0x000868, "Member 'URoNAnimInstance_PlayerTP_V2::bSMStartRuleset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bSMStopRuleset) == 0x000869, "Member 'URoNAnimInstance_PlayerTP_V2::bSMStopRuleset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bDistanceMatchToTarget) == 0x00086A, "Member 'URoNAnimInstance_PlayerTP_V2::bDistanceMatchToTarget' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, DistanceCurveName) == 0x00086C, "Member 'URoNAnimInstance_PlayerTP_V2::DistanceCurveName' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PelvisDefaultWorldPos) == 0x000874, "Member 'URoNAnimInstance_PlayerTP_V2::PelvisDefaultWorldPos' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchedPelvisDefaultWorldPos) == 0x000880, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchedPelvisDefaultWorldPos' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchedPelvisMovingWorldPos) == 0x00088C, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchedPelvisMovingWorldPos' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchedPelvisCurrentWorldPos) == 0x000898, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchedPelvisCurrentWorldPos' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, IdleStateData) == 0x0008A4, "Member 'URoNAnimInstance_PlayerTP_V2::IdleStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StartStateData) == 0x0008C0, "Member 'URoNAnimInstance_PlayerTP_V2::StartStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, MoveStateData) == 0x0008DC, "Member 'URoNAnimInstance_PlayerTP_V2::MoveStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StopStateData) == 0x0008F8, "Member 'URoNAnimInstance_PlayerTP_V2::StopStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PrePivotStateData) == 0x000914, "Member 'URoNAnimInstance_PlayerTP_V2::PrePivotStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PostPivotStateData) == 0x000930, "Member 'URoNAnimInstance_PlayerTP_V2::PostPivotStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, TurnInPlaceStateData) == 0x00094C, "Member 'URoNAnimInstance_PlayerTP_V2::TurnInPlaceStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LocalTurnInPlaceStateData) == 0x000968, "Member 'URoNAnimInstance_PlayerTP_V2::LocalTurnInPlaceStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bStartToCycleRuleSet) == 0x0009CE, "Member 'URoNAnimInstance_PlayerTP_V2::bStartToCycleRuleSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bTriggerPivotARuleSet) == 0x0009CF, "Member 'URoNAnimInstance_PlayerTP_V2::bTriggerPivotARuleSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bTriggerPivotBRuleSet) == 0x0009D0, "Member 'URoNAnimInstance_PlayerTP_V2::bTriggerPivotBRuleSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPrePivotToPostPivotRuleSet) == 0x0009D1, "Member 'URoNAnimInstance_PlayerTP_V2::bPrePivotToPostPivotRuleSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPostPivotToPrePivotRuleSet) == 0x0009D2, "Member 'URoNAnimInstance_PlayerTP_V2::bPostPivotToPrePivotRuleSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPivotToCycleRuleSet) == 0x0009D3, "Member 'URoNAnimInstance_PlayerTP_V2::bPivotToCycleRuleSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bStopToIdleRuleSet) == 0x0009D4, "Member 'URoNAnimInstance_PlayerTP_V2::bStopToIdleRuleSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCanEnterPrePivotRuleSet) == 0x0009D5, "Member 'URoNAnimInstance_PlayerTP_V2::bCanEnterPrePivotRuleSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StandFastStartAnimations) == 0x0009D8, "Member 'URoNAnimInstance_PlayerTP_V2::StandFastStartAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StandFastStopAnimations) == 0x0009E8, "Member 'URoNAnimInstance_PlayerTP_V2::StandFastStopAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StandFastPivotAnimations) == 0x0009F8, "Member 'URoNAnimInstance_PlayerTP_V2::StandFastPivotAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StandSlowStartAnimations) == 0x000A08, "Member 'URoNAnimInstance_PlayerTP_V2::StandSlowStartAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StandSlowStopAnimations) == 0x000A18, "Member 'URoNAnimInstance_PlayerTP_V2::StandSlowStopAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StandSlowPivotAnimations) == 0x000A28, "Member 'URoNAnimInstance_PlayerTP_V2::StandSlowPivotAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchFastStartAnimations) == 0x000A38, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchFastStartAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchFastStopAnimations) == 0x000A48, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchFastStopAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchFastPivotAnimations) == 0x000A58, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchFastPivotAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchSlowStartAnimations) == 0x000A68, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchSlowStartAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchSlowStopAnimations) == 0x000A78, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchSlowStopAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchSlowPivotAnimations) == 0x000A88, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchSlowPivotAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ActiveStopAnim) == 0x000A98, "Member 'URoNAnimInstance_PlayerTP_V2::ActiveStopAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ActiveStopAnimTime) == 0x000AA0, "Member 'URoNAnimInstance_PlayerTP_V2::ActiveStopAnimTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ActiveStartAnim) == 0x000AA8, "Member 'URoNAnimInstance_PlayerTP_V2::ActiveStartAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ActiveStartAnimTime) == 0x000AB0, "Member 'URoNAnimInstance_PlayerTP_V2::ActiveStartAnimTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ActivePrePivotAnim) == 0x000AB8, "Member 'URoNAnimInstance_PlayerTP_V2::ActivePrePivotAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ActivePrePivotAnimTime) == 0x000AC0, "Member 'URoNAnimInstance_PlayerTP_V2::ActivePrePivotAnimTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ActivePostPivotAnim) == 0x000AC8, "Member 'URoNAnimInstance_PlayerTP_V2::ActivePostPivotAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ActivePostPivotAnimTime) == 0x000AD0, "Member 'URoNAnimInstance_PlayerTP_V2::ActivePostPivotAnimTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsIdleStateRelevant) == 0x000AD4, "Member 'URoNAnimInstance_PlayerTP_V2::bIsIdleStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsStartStateRelevant) == 0x000AD5, "Member 'URoNAnimInstance_PlayerTP_V2::bIsStartStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsStopStateRelevant) == 0x000AD6, "Member 'URoNAnimInstance_PlayerTP_V2::bIsStopStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsPrePivotStateRelevant) == 0x000AD7, "Member 'URoNAnimInstance_PlayerTP_V2::bIsPrePivotStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsPostPivotStateRelevant) == 0x000AD8, "Member 'URoNAnimInstance_PlayerTP_V2::bIsPostPivotStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsMoveStateRelevant) == 0x000AD9, "Member 'URoNAnimInstance_PlayerTP_V2::bIsMoveStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsTurnInPlaceStateRelevant) == 0x000ADA, "Member 'URoNAnimInstance_PlayerTP_V2::bIsTurnInPlaceStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsStartStateFullWeight) == 0x000ADB, "Member 'URoNAnimInstance_PlayerTP_V2::bIsStartStateFullWeight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsPrePivotStateFullWeight) == 0x000ADC, "Member 'URoNAnimInstance_PlayerTP_V2::bIsPrePivotStateFullWeight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsPostPivotStateFullWeight) == 0x000ADD, "Member 'URoNAnimInstance_PlayerTP_V2::bIsPostPivotStateFullWeight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, TimeInStartState) == 0x000AE0, "Member 'URoNAnimInstance_PlayerTP_V2::TimeInStartState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, TimeInPostPivotState) == 0x000AE4, "Member 'URoNAnimInstance_PlayerTP_V2::TimeInPostPivotState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bReadDisableSpeedCurve) == 0x000AE8, "Member 'URoNAnimInstance_PlayerTP_V2::bReadDisableSpeedCurve' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, DisableSpeedWarping) == 0x000AEC, "Member 'URoNAnimInstance_PlayerTP_V2::DisableSpeedWarping' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, SpeedScaling) == 0x000AF0, "Member 'URoNAnimInstance_PlayerTP_V2::SpeedScaling' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PlayrateClampMax) == 0x000AF4, "Member 'URoNAnimInstance_PlayerTP_V2::PlayrateClampMax' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PlayRateClamp) == 0x000AF8, "Member 'URoNAnimInstance_PlayerTP_V2::PlayRateClamp' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PlayRateClampCycle) == 0x000B00, "Member 'URoNAnimInstance_PlayerTP_V2::PlayRateClampCycle' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PlayRateClampStartsPivots) == 0x000B08, "Member 'URoNAnimInstance_PlayerTP_V2::PlayRateClampStartsPivots' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StrideWarpingBlendInStartOffset) == 0x000B10, "Member 'URoNAnimInstance_PlayerTP_V2::StrideWarpingBlendInStartOffset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StrideWarpingBlendInDurationScaled) == 0x000B14, "Member 'URoNAnimInstance_PlayerTP_V2::StrideWarpingBlendInDurationScaled' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StrideWarpingStartAlpha) == 0x000B18, "Member 'URoNAnimInstance_PlayerTP_V2::StrideWarpingStartAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StrideWarpingPivotAlpha) == 0x000B1C, "Member 'URoNAnimInstance_PlayerTP_V2::StrideWarpingPivotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, DirectionBlendTime) == 0x000B20, "Member 'URoNAnimInstance_PlayerTP_V2::DirectionBlendTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, DeathPose) == 0x000B28, "Member 'URoNAnimInstance_PlayerTP_V2::DeathPose' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, SlopeWarpingAlpha) == 0x000B60, "Member 'URoNAnimInstance_PlayerTP_V2::SlopeWarpingAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsItemOrPistolMotionBlock) == 0x000B64, "Member 'URoNAnimInstance_PlayerTP_V2::bIsItemOrPistolMotionBlock' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsRifleMotionBlock) == 0x000B65, "Member 'URoNAnimInstance_PlayerTP_V2::bIsRifleMotionBlock' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsCrouchingWithShield) == 0x000B66, "Member 'URoNAnimInstance_PlayerTP_V2::bIsCrouchingWithShield' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchHighPoseAdditiveAlpha) == 0x000B68, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchHighPoseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StandHighPoseAdditiveAlpha) == 0x000B6C, "Member 'URoNAnimInstance_PlayerTP_V2::StandHighPoseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LeftHandIKAlpha_ItemBased) == 0x000B70, "Member 'URoNAnimInstance_PlayerTP_V2::LeftHandIKAlpha_ItemBased' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ZHeightLeanAdjustment) == 0x000B74, "Member 'URoNAnimInstance_PlayerTP_V2::ZHeightLeanAdjustment' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, IsCrouchingWithShield_AsFloat) == 0x000B80, "Member 'URoNAnimInstance_PlayerTP_V2::IsCrouchingWithShield_AsFloat' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, HandAdditiveLockOverride) == 0x000B84, "Member 'URoNAnimInstance_PlayerTP_V2::HandAdditiveLockOverride' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LeftHandAdditiveOvrBlend) == 0x000B88, "Member 'URoNAnimInstance_PlayerTP_V2::LeftHandAdditiveOvrBlend' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LeftHandTempFinIK) == 0x000B8C, "Member 'URoNAnimInstance_PlayerTP_V2::LeftHandTempFinIK' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bFastWalkSwitchRule) == 0x000B90, "Member 'URoNAnimInstance_PlayerTP_V2::bFastWalkSwitchRule' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCrouchFastWalkSwitchRule) == 0x000B91, "Member 'URoNAnimInstance_PlayerTP_V2::bCrouchFastWalkSwitchRule' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bStartWalkSwitchTransitionRule) == 0x000B92, "Member 'URoNAnimInstance_PlayerTP_V2::bStartWalkSwitchTransitionRule' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, DefaultCrouchSpeed) == 0x000B94, "Member 'URoNAnimInstance_PlayerTP_V2::DefaultCrouchSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, DefaultStandSpeed) == 0x000B98, "Member 'URoNAnimInstance_PlayerTP_V2::DefaultStandSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bStopWalkSwitchTransitionRule) == 0x000B9C, "Member 'URoNAnimInstance_PlayerTP_V2::bStopWalkSwitchTransitionRule' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPivotWalkSwitchTransitionRule) == 0x000B9D, "Member 'URoNAnimInstance_PlayerTP_V2::bPivotWalkSwitchTransitionRule' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bHasUnderbarrelAttachment) == 0x000B9E, "Member 'URoNAnimInstance_PlayerTP_V2::bHasUnderbarrelAttachment' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, UnderbarrelType) == 0x000B9F, "Member 'URoNAnimInstance_PlayerTP_V2::UnderbarrelType' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LeftHandGripAlpha) == 0x000BA0, "Member 'URoNAnimInstance_PlayerTP_V2::LeftHandGripAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, UpperbodySlotNoWeight) == 0x000BA4, "Member 'URoNAnimInstance_PlayerTP_V2::UpperbodySlotNoWeight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsFastWalking) == 0x000BA8, "Member 'URoNAnimInstance_PlayerTP_V2::bIsFastWalking' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsFastStop) == 0x000BA9, "Member 'URoNAnimInstance_PlayerTP_V2::bIsFastStop' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsFastStart) == 0x000BAA, "Member 'URoNAnimInstance_PlayerTP_V2::bIsFastStart' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsFastPivot) == 0x000BAB, "Member 'URoNAnimInstance_PlayerTP_V2::bIsFastPivot' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsLocallyFirstPerson) == 0x000BAC, "Member 'URoNAnimInstance_PlayerTP_V2::bIsLocallyFirstPerson' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPFStartPhase) == 0x000BAD, "Member 'URoNAnimInstance_PlayerTP_V2::bPFStartPhase' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPFStoppingPhase) == 0x000BAE, "Member 'URoNAnimInstance_PlayerTP_V2::bPFStoppingPhase' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPFHasReachedStoppingPhase) == 0x000BAF, "Member 'URoNAnimInstance_PlayerTP_V2::bPFHasReachedStoppingPhase' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PFStartDistanceThreshold) == 0x000BB0, "Member 'URoNAnimInstance_PlayerTP_V2::PFStartDistanceThreshold' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PFStopDistanceThreshold) == 0x000BB4, "Member 'URoNAnimInstance_PlayerTP_V2::PFStopDistanceThreshold' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PFLastStopLocation) == 0x000BB8, "Member 'URoNAnimInstance_PlayerTP_V2::PFLastStopLocation' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PFCurrentStopLocation) == 0x000BC4, "Member 'URoNAnimInstance_PlayerTP_V2::PFCurrentStopLocation' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PFStopDistance) == 0x000BD0, "Member 'URoNAnimInstance_PlayerTP_V2::PFStopDistance' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PFCurrentAcceptanceRadius) == 0x000BD4, "Member 'URoNAnimInstance_PlayerTP_V2::PFCurrentAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPFPathTooShort) == 0x000BD8, "Member 'URoNAnimInstance_PlayerTP_V2::bPFPathTooShort' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPFPathIsValid) == 0x000BD9, "Member 'URoNAnimInstance_PlayerTP_V2::bPFPathIsValid' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPFRequestedNewPath) == 0x000BDA, "Member 'URoNAnimInstance_PlayerTP_V2::bPFRequestedNewPath' has a wrong offset!");

// Class ReadyOrNot.RoNMoveStyleComponent
// 0x00F8 (0x01A8 - 0x00B0)
class URoNMoveStyleComponent final  : public UActorComponent
{
public:
	class UDataTable*                             MoveStyleDatabase;                                 // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultMoveStyleName;                              // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaulGaitName;                                    // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MoveStyleCharacterName;                            // 0x00C8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PreviousMoveStyleName;                             // 0x00D0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsOverriding;                                     // 0x00D8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D9[0x7];                                     // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRoNMovementStyle                      ActiveMoveStyle;                                   // 0x00E0(0x0088)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FName                                   Rep_MoveStyleName;                                 // 0x0168(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveGaitIndex;                                   // 0x0170(0x0004)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActiveGaitName;                                    // 0x0174(0x0008)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GaitTimeOut;                                       // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PendingGaitName;                                   // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStrafing;                                       // 0x0188(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28DA[0x1F];                                    // 0x0189(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearOverrideMoveStyle();
	void OnRep_IsStrafing();
	void OnRep_MoveStyle();
	void SetCharacterAcceleration(float Acceleration);
	void SetCharacterAccelerationMultiplier(float Multiplier);
	void SetCharacterSpeed(float Speed);
	void SetCharacterSpeedMultiplier(float Multiplier);
	bool SetMovementGaitByName(class FName Param_Name, bool bForce);
	void SetMovementStyleByName(class FName Param_Name);
	void SetOverrideMoveStyleByName(class FName Param_Name);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoNMoveStyleComponent">();
	}
	static class URoNMoveStyleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoNMoveStyleComponent>();
	}
};
static_assert(alignof(URoNMoveStyleComponent) == 0x000008, "Wrong alignment on URoNMoveStyleComponent");
static_assert(sizeof(URoNMoveStyleComponent) == 0x0001A8, "Wrong size on URoNMoveStyleComponent");
static_assert(offsetof(URoNMoveStyleComponent, MoveStyleDatabase) == 0x0000B0, "Member 'URoNMoveStyleComponent::MoveStyleDatabase' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, DefaultMoveStyleName) == 0x0000B8, "Member 'URoNMoveStyleComponent::DefaultMoveStyleName' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, DefaulGaitName) == 0x0000C0, "Member 'URoNMoveStyleComponent::DefaulGaitName' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, MoveStyleCharacterName) == 0x0000C8, "Member 'URoNMoveStyleComponent::MoveStyleCharacterName' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, PreviousMoveStyleName) == 0x0000D0, "Member 'URoNMoveStyleComponent::PreviousMoveStyleName' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, bIsOverriding) == 0x0000D8, "Member 'URoNMoveStyleComponent::bIsOverriding' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, ActiveMoveStyle) == 0x0000E0, "Member 'URoNMoveStyleComponent::ActiveMoveStyle' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, Rep_MoveStyleName) == 0x000168, "Member 'URoNMoveStyleComponent::Rep_MoveStyleName' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, ActiveGaitIndex) == 0x000170, "Member 'URoNMoveStyleComponent::ActiveGaitIndex' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, ActiveGaitName) == 0x000174, "Member 'URoNMoveStyleComponent::ActiveGaitName' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, GaitTimeOut) == 0x00017C, "Member 'URoNMoveStyleComponent::GaitTimeOut' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, PendingGaitName) == 0x000180, "Member 'URoNMoveStyleComponent::PendingGaitName' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, bIsStrafing) == 0x000188, "Member 'URoNMoveStyleComponent::bIsStrafing' has a wrong offset!");

// Class ReadyOrNot.DoorSound
// 0x0050 (0x0080 - 0x0030)
class UDoorSound final  : public UDataAsset
{
public:
	class UFMODEvent*                             DoorClosed;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DoorOpened;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DoorStartManipulation;                             // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DoorStopManipulation;                              // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BrokenByC2;                                        // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BrokenByRam;                                       // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BrokenByShotgun;                                   // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             KickedDown;                                        // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             KickedDownFailed;                                  // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             KickedDownBreak;                                   // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorSound">();
	}
	static class UDoorSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoorSound>();
	}
};
static_assert(alignof(UDoorSound) == 0x000008, "Wrong alignment on UDoorSound");
static_assert(sizeof(UDoorSound) == 0x000080, "Wrong size on UDoorSound");
static_assert(offsetof(UDoorSound, DoorClosed) == 0x000030, "Member 'UDoorSound::DoorClosed' has a wrong offset!");
static_assert(offsetof(UDoorSound, DoorOpened) == 0x000038, "Member 'UDoorSound::DoorOpened' has a wrong offset!");
static_assert(offsetof(UDoorSound, DoorStartManipulation) == 0x000040, "Member 'UDoorSound::DoorStartManipulation' has a wrong offset!");
static_assert(offsetof(UDoorSound, DoorStopManipulation) == 0x000048, "Member 'UDoorSound::DoorStopManipulation' has a wrong offset!");
static_assert(offsetof(UDoorSound, BrokenByC2) == 0x000050, "Member 'UDoorSound::BrokenByC2' has a wrong offset!");
static_assert(offsetof(UDoorSound, BrokenByRam) == 0x000058, "Member 'UDoorSound::BrokenByRam' has a wrong offset!");
static_assert(offsetof(UDoorSound, BrokenByShotgun) == 0x000060, "Member 'UDoorSound::BrokenByShotgun' has a wrong offset!");
static_assert(offsetof(UDoorSound, KickedDown) == 0x000068, "Member 'UDoorSound::KickedDown' has a wrong offset!");
static_assert(offsetof(UDoorSound, KickedDownFailed) == 0x000070, "Member 'UDoorSound::KickedDownFailed' has a wrong offset!");
static_assert(offsetof(UDoorSound, KickedDownBreak) == 0x000078, "Member 'UDoorSound::KickedDownBreak' has a wrong offset!");

// Class ReadyOrNot.RoNWeaponAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class URoNWeaponAnimInstance : public UAnimInstance
{
public:
	float                                         AmmoRemaining;                                     // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OptiwandBoneModify;                                // 0x02BC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28DC[0x4];                                     // 0x02C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsEquipped;                                       // 0x02CC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28DD[0x3];                                     // 0x02CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDisassembleMagazineEjected();
	void OnSpeedReloadMagazineEjected();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoNWeaponAnimInstance">();
	}
	static class URoNWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoNWeaponAnimInstance>();
	}
};
static_assert(alignof(URoNWeaponAnimInstance) == 0x000010, "Wrong alignment on URoNWeaponAnimInstance");
static_assert(sizeof(URoNWeaponAnimInstance) == 0x0002D0, "Wrong size on URoNWeaponAnimInstance");
static_assert(offsetof(URoNWeaponAnimInstance, AmmoRemaining) == 0x0002B8, "Member 'URoNWeaponAnimInstance::AmmoRemaining' has a wrong offset!");
static_assert(offsetof(URoNWeaponAnimInstance, OptiwandBoneModify) == 0x0002BC, "Member 'URoNWeaponAnimInstance::OptiwandBoneModify' has a wrong offset!");
static_assert(offsetof(URoNWeaponAnimInstance, bIsEquipped) == 0x0002CC, "Member 'URoNWeaponAnimInstance::bIsEquipped' has a wrong offset!");

// Class ReadyOrNot.RoomVisualizer
// 0x0048 (0x0268 - 0x0220)
class ARoomVisualizer final  : public AActor
{
public:
	class USceneComponent*                        DefaultScene;                                      // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OwningRoom;                                        // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          Doors;                                             // 0x0230(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TArray<class AThreatAwarenessActor*>          Threats;                                           // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TArray<class ARoomVisualizer*>                ConnectingRooms;                                   // 0x0250(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	ERoomSize                                     Size;                                              // 0x0260(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28DE[0x7];                                     // 0x0261(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomVisualizer">();
	}
	static class ARoomVisualizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARoomVisualizer>();
	}
};
static_assert(alignof(ARoomVisualizer) == 0x000008, "Wrong alignment on ARoomVisualizer");
static_assert(sizeof(ARoomVisualizer) == 0x000268, "Wrong size on ARoomVisualizer");
static_assert(offsetof(ARoomVisualizer, DefaultScene) == 0x000220, "Member 'ARoomVisualizer::DefaultScene' has a wrong offset!");
static_assert(offsetof(ARoomVisualizer, OwningRoom) == 0x000228, "Member 'ARoomVisualizer::OwningRoom' has a wrong offset!");
static_assert(offsetof(ARoomVisualizer, Doors) == 0x000230, "Member 'ARoomVisualizer::Doors' has a wrong offset!");
static_assert(offsetof(ARoomVisualizer, Threats) == 0x000240, "Member 'ARoomVisualizer::Threats' has a wrong offset!");
static_assert(offsetof(ARoomVisualizer, ConnectingRooms) == 0x000250, "Member 'ARoomVisualizer::ConnectingRooms' has a wrong offset!");
static_assert(offsetof(ARoomVisualizer, Size) == 0x000260, "Member 'ARoomVisualizer::Size' has a wrong offset!");

// Class ReadyOrNot.RosterTrait
// 0x00D0 (0x0100 - 0x0030)
class URosterTrait final  : public UDataAsset
{
public:
	class FText                                   Name_RosterTrait;                                  // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Format;                                            // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     TraitCurve;                                        // 0x0078(0x0088)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterTrait">();
	}
	static class URosterTrait* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterTrait>();
	}
};
static_assert(alignof(URosterTrait) == 0x000008, "Wrong alignment on URosterTrait");
static_assert(sizeof(URosterTrait) == 0x000100, "Wrong size on URosterTrait");
static_assert(offsetof(URosterTrait, Name_RosterTrait) == 0x000030, "Member 'URosterTrait::Name_RosterTrait' has a wrong offset!");
static_assert(offsetof(URosterTrait, Description) == 0x000048, "Member 'URosterTrait::Description' has a wrong offset!");
static_assert(offsetof(URosterTrait, Format) == 0x000060, "Member 'URosterTrait::Format' has a wrong offset!");
static_assert(offsetof(URosterTrait, TraitCurve) == 0x000078, "Member 'URosterTrait::TraitCurve' has a wrong offset!");

// Class ReadyOrNot.RosterStoryline
// 0x0070 (0x00A0 - 0x0030)
class URosterStoryline final  : public UDataAsset
{
public:
	TArray<class FText>                           DeathEvents;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           UnfitForDutyEvents;                                // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           ReturnFromIncapacitationEvents;                    // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           ReturnFromTherapyEvents;                           // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           StressQuitEvents;                                  // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           TherapistEvents;                                   // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           TherapistAssessmentEvents;                         // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterStoryline">();
	}
	static class URosterStoryline* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterStoryline>();
	}
};
static_assert(alignof(URosterStoryline) == 0x000008, "Wrong alignment on URosterStoryline");
static_assert(sizeof(URosterStoryline) == 0x0000A0, "Wrong size on URosterStoryline");
static_assert(offsetof(URosterStoryline, DeathEvents) == 0x000030, "Member 'URosterStoryline::DeathEvents' has a wrong offset!");
static_assert(offsetof(URosterStoryline, UnfitForDutyEvents) == 0x000040, "Member 'URosterStoryline::UnfitForDutyEvents' has a wrong offset!");
static_assert(offsetof(URosterStoryline, ReturnFromIncapacitationEvents) == 0x000050, "Member 'URosterStoryline::ReturnFromIncapacitationEvents' has a wrong offset!");
static_assert(offsetof(URosterStoryline, ReturnFromTherapyEvents) == 0x000060, "Member 'URosterStoryline::ReturnFromTherapyEvents' has a wrong offset!");
static_assert(offsetof(URosterStoryline, StressQuitEvents) == 0x000070, "Member 'URosterStoryline::StressQuitEvents' has a wrong offset!");
static_assert(offsetof(URosterStoryline, TherapistEvents) == 0x000080, "Member 'URosterStoryline::TherapistEvents' has a wrong offset!");
static_assert(offsetof(URosterStoryline, TherapistAssessmentEvents) == 0x000090, "Member 'URosterStoryline::TherapistAssessmentEvents' has a wrong offset!");

// Class ReadyOrNot.RosterEventData
// 0x0020 (0x0050 - 0x0030)
class URosterEventData final  : public UDataAsset
{
public:
	TArray<class URosterStoryline*>               Storylines;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTherapistReminderEvent>        TherapistReminderEvents;                           // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterEventData">();
	}
	static class URosterEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterEventData>();
	}
};
static_assert(alignof(URosterEventData) == 0x000008, "Wrong alignment on URosterEventData");
static_assert(sizeof(URosterEventData) == 0x000050, "Wrong size on URosterEventData");
static_assert(offsetof(URosterEventData, Storylines) == 0x000030, "Member 'URosterEventData::Storylines' has a wrong offset!");
static_assert(offsetof(URosterEventData, TherapistReminderEvents) == 0x000040, "Member 'URosterEventData::TherapistReminderEvents' has a wrong offset!");

// Class ReadyOrNot.RosterCharacter
// 0x00B8 (0x00E0 - 0x0028)
class URosterCharacter final  : public UObject
{
public:
	ERosterCharacterState                         State;                                             // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERosterSquadPosition                          Position;                                          // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERosterRemovalReason                          RemovalReason;                                     // 0x002A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28DF[0x1];                                     // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MissionsPlayed;                                    // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressLevel;                                       // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MissionsUntilReturn;                               // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERosterCharacterState                         PreviousState;                                     // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E0[0x2];                                     // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreviousStressLevel;                               // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTherapistIntervened;                              // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E1[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URosterTrait*                           Trait;                                             // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraitUnlocked;                                    // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJustUnlockedTrait;                                // 0x0051(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E2[0x6];                                     // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MostRecentEventText;                               // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class URosterCharacterArchetype*              Archetype;                                         // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationCharacter*                Character;                                         // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationVoice*                    Voice;                                             // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   FirstName;                                         // 0x0088(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LastName;                                          // 0x00A0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         SerialNumber;                                      // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YearsInSWAT;                                       // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x00C0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class URosterStoryline*                       Storyline;                                         // 0x00D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterCharacter">();
	}
	static class URosterCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterCharacter>();
	}
};
static_assert(alignof(URosterCharacter) == 0x000008, "Wrong alignment on URosterCharacter");
static_assert(sizeof(URosterCharacter) == 0x0000E0, "Wrong size on URosterCharacter");
static_assert(offsetof(URosterCharacter, State) == 0x000028, "Member 'URosterCharacter::State' has a wrong offset!");
static_assert(offsetof(URosterCharacter, Position) == 0x000029, "Member 'URosterCharacter::Position' has a wrong offset!");
static_assert(offsetof(URosterCharacter, RemovalReason) == 0x00002A, "Member 'URosterCharacter::RemovalReason' has a wrong offset!");
static_assert(offsetof(URosterCharacter, MissionsPlayed) == 0x00002C, "Member 'URosterCharacter::MissionsPlayed' has a wrong offset!");
static_assert(offsetof(URosterCharacter, StressLevel) == 0x000030, "Member 'URosterCharacter::StressLevel' has a wrong offset!");
static_assert(offsetof(URosterCharacter, MissionsUntilReturn) == 0x000034, "Member 'URosterCharacter::MissionsUntilReturn' has a wrong offset!");
static_assert(offsetof(URosterCharacter, bIsNew) == 0x000038, "Member 'URosterCharacter::bIsNew' has a wrong offset!");
static_assert(offsetof(URosterCharacter, PreviousState) == 0x000039, "Member 'URosterCharacter::PreviousState' has a wrong offset!");
static_assert(offsetof(URosterCharacter, PreviousStressLevel) == 0x00003C, "Member 'URosterCharacter::PreviousStressLevel' has a wrong offset!");
static_assert(offsetof(URosterCharacter, bTherapistIntervened) == 0x000040, "Member 'URosterCharacter::bTherapistIntervened' has a wrong offset!");
static_assert(offsetof(URosterCharacter, Trait) == 0x000048, "Member 'URosterCharacter::Trait' has a wrong offset!");
static_assert(offsetof(URosterCharacter, bTraitUnlocked) == 0x000050, "Member 'URosterCharacter::bTraitUnlocked' has a wrong offset!");
static_assert(offsetof(URosterCharacter, bJustUnlockedTrait) == 0x000051, "Member 'URosterCharacter::bJustUnlockedTrait' has a wrong offset!");
static_assert(offsetof(URosterCharacter, MostRecentEventText) == 0x000058, "Member 'URosterCharacter::MostRecentEventText' has a wrong offset!");
static_assert(offsetof(URosterCharacter, Archetype) == 0x000070, "Member 'URosterCharacter::Archetype' has a wrong offset!");
static_assert(offsetof(URosterCharacter, Character) == 0x000078, "Member 'URosterCharacter::Character' has a wrong offset!");
static_assert(offsetof(URosterCharacter, Voice) == 0x000080, "Member 'URosterCharacter::Voice' has a wrong offset!");
static_assert(offsetof(URosterCharacter, FirstName) == 0x000088, "Member 'URosterCharacter::FirstName' has a wrong offset!");
static_assert(offsetof(URosterCharacter, LastName) == 0x0000A0, "Member 'URosterCharacter::LastName' has a wrong offset!");
static_assert(offsetof(URosterCharacter, SerialNumber) == 0x0000B8, "Member 'URosterCharacter::SerialNumber' has a wrong offset!");
static_assert(offsetof(URosterCharacter, YearsInSWAT) == 0x0000BC, "Member 'URosterCharacter::YearsInSWAT' has a wrong offset!");
static_assert(offsetof(URosterCharacter, Description) == 0x0000C0, "Member 'URosterCharacter::Description' has a wrong offset!");
static_assert(offsetof(URosterCharacter, Storyline) == 0x0000D8, "Member 'URosterCharacter::Storyline' has a wrong offset!");

// Class ReadyOrNot.RosterManagerSettings
// 0x00C0 (0x00F8 - 0x0038)
class URosterManagerSettings final  : public UDeveloperSettings
{
public:
	int32                                         RosterSize;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRecruitableCharacters;                          // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 AdditionalRosterSlots;                             // 0x0040(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         MaximumStartingStress;                             // 0x0050(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E3[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRosterTraitEntry>              AvailableTraits;                                   // 0x0058(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         MissionsUntilTraitUnlockable;                      // 0x0068(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E4[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class URosterEventData>        EventData;                                         // 0x0070(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathChance;                                       // 0x0098(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIncapacitationTime;                             // 0x009C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStressWhenIncapacitated;                        // 0x00A0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxOfficersFiredAtOnce;                            // 0x00A4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressGainForOfficerFired;                         // 0x00A8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStressForOfficerFired;                          // 0x00AC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressGainForOfficerKilled;                        // 0x00B0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressGainForPlayerKilled;                         // 0x00B4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressGainForExfil;                                // 0x00B8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressGainForActiveShooterExfil;                   // 0x00BC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressGainForOfficerNotExfil;                      // 0x00C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressGainForFriendlyKilledByPlayer;               // 0x00C4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressGainForFriendlyKilledByPlayerBase;           // 0x00C8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBaseStressGainForKill;                          // 0x00CC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBaseStressGainForKill;                          // 0x00D0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressMultiplierForKillInstigator;                 // 0x00D4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressMultiplierForCivilianKill;                   // 0x00D8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressLossForCivilianArrest;                       // 0x00DC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressLossForSuspectArrest;                        // 0x00E0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PassiveStressLoss;                                 // 0x00E4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCharactersInTherapy;                            // 0x00E8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumStressForTherapy;                           // 0x00EC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TherapistTimeScale;                                // 0x00F0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E5[0x4];                                     // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterManagerSettings">();
	}
	static class URosterManagerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterManagerSettings>();
	}
};
static_assert(alignof(URosterManagerSettings) == 0x000008, "Wrong alignment on URosterManagerSettings");
static_assert(sizeof(URosterManagerSettings) == 0x0000F8, "Wrong size on URosterManagerSettings");
static_assert(offsetof(URosterManagerSettings, RosterSize) == 0x000038, "Member 'URosterManagerSettings::RosterSize' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, NumRecruitableCharacters) == 0x00003C, "Member 'URosterManagerSettings::NumRecruitableCharacters' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, AdditionalRosterSlots) == 0x000040, "Member 'URosterManagerSettings::AdditionalRosterSlots' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MaximumStartingStress) == 0x000050, "Member 'URosterManagerSettings::MaximumStartingStress' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, AvailableTraits) == 0x000058, "Member 'URosterManagerSettings::AvailableTraits' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MissionsUntilTraitUnlockable) == 0x000068, "Member 'URosterManagerSettings::MissionsUntilTraitUnlockable' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, EventData) == 0x000070, "Member 'URosterManagerSettings::EventData' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, DeathChance) == 0x000098, "Member 'URosterManagerSettings::DeathChance' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MaxIncapacitationTime) == 0x00009C, "Member 'URosterManagerSettings::MaxIncapacitationTime' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MaxStressWhenIncapacitated) == 0x0000A0, "Member 'URosterManagerSettings::MaxStressWhenIncapacitated' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MaxOfficersFiredAtOnce) == 0x0000A4, "Member 'URosterManagerSettings::MaxOfficersFiredAtOnce' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressGainForOfficerFired) == 0x0000A8, "Member 'URosterManagerSettings::StressGainForOfficerFired' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MaxStressForOfficerFired) == 0x0000AC, "Member 'URosterManagerSettings::MaxStressForOfficerFired' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressGainForOfficerKilled) == 0x0000B0, "Member 'URosterManagerSettings::StressGainForOfficerKilled' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressGainForPlayerKilled) == 0x0000B4, "Member 'URosterManagerSettings::StressGainForPlayerKilled' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressGainForExfil) == 0x0000B8, "Member 'URosterManagerSettings::StressGainForExfil' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressGainForActiveShooterExfil) == 0x0000BC, "Member 'URosterManagerSettings::StressGainForActiveShooterExfil' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressGainForOfficerNotExfil) == 0x0000C0, "Member 'URosterManagerSettings::StressGainForOfficerNotExfil' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressGainForFriendlyKilledByPlayer) == 0x0000C4, "Member 'URosterManagerSettings::StressGainForFriendlyKilledByPlayer' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressGainForFriendlyKilledByPlayerBase) == 0x0000C8, "Member 'URosterManagerSettings::StressGainForFriendlyKilledByPlayerBase' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MinBaseStressGainForKill) == 0x0000CC, "Member 'URosterManagerSettings::MinBaseStressGainForKill' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MaxBaseStressGainForKill) == 0x0000D0, "Member 'URosterManagerSettings::MaxBaseStressGainForKill' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressMultiplierForKillInstigator) == 0x0000D4, "Member 'URosterManagerSettings::StressMultiplierForKillInstigator' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressMultiplierForCivilianKill) == 0x0000D8, "Member 'URosterManagerSettings::StressMultiplierForCivilianKill' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressLossForCivilianArrest) == 0x0000DC, "Member 'URosterManagerSettings::StressLossForCivilianArrest' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressLossForSuspectArrest) == 0x0000E0, "Member 'URosterManagerSettings::StressLossForSuspectArrest' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, PassiveStressLoss) == 0x0000E4, "Member 'URosterManagerSettings::PassiveStressLoss' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MaxCharactersInTherapy) == 0x0000E8, "Member 'URosterManagerSettings::MaxCharactersInTherapy' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MinimumStressForTherapy) == 0x0000EC, "Member 'URosterManagerSettings::MinimumStressForTherapy' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, TherapistTimeScale) == 0x0000F0, "Member 'URosterManagerSettings::TherapistTimeScale' has a wrong offset!");

// Class ReadyOrNot.RosterManager
// 0x0170 (0x0198 - 0x0028)
class URosterManager final  : public UObject
{
public:
	class URosterManagerSettings*                 Settings;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommanderProfile*                      CommanderProfile;                                  // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class URosterCharacter*>               Characters;                                        // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class URosterCharacter*>               PreviousCharacters;                                // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class URosterCharacter*>               RecruitableCharacters;                             // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<ERosterSquadPosition, class URosterCharacter*> SquadCharacters;                                   // 0x0068(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class URosterCharacterArchetype*>      PossibleCharacters;                                // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FName, class URosterTrait*>        PossibleTraits;                                    // 0x00C8(0x0050)(NativeAccessSpecifierPrivate)
	class URosterEventData*                       EventData;                                         // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URosterCharacterArchetype*              LastArchetype;                                     // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28E6[0x70];                                    // 0x0128(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterManager">();
	}
	static class URosterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterManager>();
	}
};
static_assert(alignof(URosterManager) == 0x000008, "Wrong alignment on URosterManager");
static_assert(sizeof(URosterManager) == 0x000198, "Wrong size on URosterManager");
static_assert(offsetof(URosterManager, Settings) == 0x000028, "Member 'URosterManager::Settings' has a wrong offset!");
static_assert(offsetof(URosterManager, CommanderProfile) == 0x000030, "Member 'URosterManager::CommanderProfile' has a wrong offset!");
static_assert(offsetof(URosterManager, Characters) == 0x000038, "Member 'URosterManager::Characters' has a wrong offset!");
static_assert(offsetof(URosterManager, PreviousCharacters) == 0x000048, "Member 'URosterManager::PreviousCharacters' has a wrong offset!");
static_assert(offsetof(URosterManager, RecruitableCharacters) == 0x000058, "Member 'URosterManager::RecruitableCharacters' has a wrong offset!");
static_assert(offsetof(URosterManager, SquadCharacters) == 0x000068, "Member 'URosterManager::SquadCharacters' has a wrong offset!");
static_assert(offsetof(URosterManager, PossibleCharacters) == 0x0000B8, "Member 'URosterManager::PossibleCharacters' has a wrong offset!");
static_assert(offsetof(URosterManager, PossibleTraits) == 0x0000C8, "Member 'URosterManager::PossibleTraits' has a wrong offset!");
static_assert(offsetof(URosterManager, EventData) == 0x000118, "Member 'URosterManager::EventData' has a wrong offset!");
static_assert(offsetof(URosterManager, LastArchetype) == 0x000120, "Member 'URosterManager::LastArchetype' has a wrong offset!");

// Class ReadyOrNot.RosterReviewWidget
// 0x0008 (0x0328 - 0x0320)
class URosterReviewWidget : public UCommonActivatableWidget
{
public:
	class URosterManager*                         RosterManager;                                     // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddIncapacitatedCharacters(TArray<class URosterCharacter*>& Characters);
	void AddRemovedCharacters(TArray<class URosterCharacter*>& Characters);
	void AddReturningCharacters(TArray<class URosterCharacter*>& Characters);
	void AddSquadCharacters(TMap<ERosterSquadPosition, class URosterCharacter*>& Characters);
	TArray<class URosterCharacter*> GetAllCharacters();
	class FText GetTherapistReminderPrompt();
	void OpenRoster();

	TArray<class URosterCharacter*> GetCharactersSortedByReviewScore() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterReviewWidget">();
	}
	static class URosterReviewWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterReviewWidget>();
	}
};
static_assert(alignof(URosterReviewWidget) == 0x000008, "Wrong alignment on URosterReviewWidget");
static_assert(sizeof(URosterReviewWidget) == 0x000328, "Wrong size on URosterReviewWidget");
static_assert(offsetof(URosterReviewWidget, RosterManager) == 0x000320, "Member 'URosterReviewWidget::RosterManager' has a wrong offset!");

// Class ReadyOrNot.RosterScenarioSpawner
// 0x0030 (0x0250 - 0x0220)
class ARosterScenarioSpawner final  : public AInfo
{
public:
	TArray<struct FObjectiveSpawn>                Objectives;                                        // 0x0220(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          UsedTrapDoors;                                     // 0x0230(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E7[0x10];                                    // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterScenarioSpawner">();
	}
	static class ARosterScenarioSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARosterScenarioSpawner>();
	}
};
static_assert(alignof(ARosterScenarioSpawner) == 0x000008, "Wrong alignment on ARosterScenarioSpawner");
static_assert(sizeof(ARosterScenarioSpawner) == 0x000250, "Wrong size on ARosterScenarioSpawner");
static_assert(offsetof(ARosterScenarioSpawner, Objectives) == 0x000220, "Member 'ARosterScenarioSpawner::Objectives' has a wrong offset!");
static_assert(offsetof(ARosterScenarioSpawner, UsedTrapDoors) == 0x000230, "Member 'ARosterScenarioSpawner::UsedTrapDoors' has a wrong offset!");

// Class ReadyOrNot.RosterSelectionWidget
// 0x0010 (0x0330 - 0x0320)
class URosterSelectionWidget : public UCommonActivatableWidget
{
public:
	class UCommanderProfile*                      CommanderProfile;                                  // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URosterManager*                         RosterManager;                                     // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CanFireCharacter(class URosterCharacter* Character);
	bool CanUseTherapist(class URosterCharacter* Character);
	void FireCharacter(class URosterCharacter* Character);
	TArray<class URosterCharacter*> GetAllCharacters();
	struct FRosterLoadout GetCharacterLoadout(class URosterCharacter* Character);
	int32 GetMaxCharactersInTherapy();
	int32 GetNumCharactersInTherapy();
	TArray<class URosterCharacter*> GetRecruitableCharacters();
	TMap<ERosterSquadPosition, class URosterCharacter*> GetSquadCharacters();
	void InitializeRoster();
	void OnCharactersUpdated();
	void RecruitCharacter(class URosterCharacter* Character);
	void RefreshRoster();
	void RefreshRosterEvent();
	void SendCharacterToTherapist(class URosterCharacter* Character);
	void SetSquadCharacter(class URosterCharacter* Character, ERosterSquadPosition Position);

	TArray<struct FRosterActiveTraitInfo> GetActiveTraits() const;
	int32 GetCurrentRosterSize() const;
	int32 GetMaximumRosterSize() const;
	TArray<int32> GetUnlockableSlotMissionsRemaining() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterSelectionWidget">();
	}
	static class URosterSelectionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterSelectionWidget>();
	}
};
static_assert(alignof(URosterSelectionWidget) == 0x000008, "Wrong alignment on URosterSelectionWidget");
static_assert(sizeof(URosterSelectionWidget) == 0x000330, "Wrong size on URosterSelectionWidget");
static_assert(offsetof(URosterSelectionWidget, CommanderProfile) == 0x000320, "Member 'URosterSelectionWidget::CommanderProfile' has a wrong offset!");
static_assert(offsetof(URosterSelectionWidget, RosterManager) == 0x000328, "Member 'URosterSelectionWidget::RosterManager' has a wrong offset!");

// Class ReadyOrNot.RoundEndWidget_PVP
// 0x0008 (0x0280 - 0x0278)
class URoundEndWidget_PVP : public UBaseWidget
{
public:
	class UWidgetAnimation*                       Anim_FadeIn;                                       // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnGameModeRoundEnded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoundEndWidget_PVP">();
	}
	static class URoundEndWidget_PVP* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoundEndWidget_PVP>();
	}
};
static_assert(alignof(URoundEndWidget_PVP) == 0x000008, "Wrong alignment on URoundEndWidget_PVP");
static_assert(sizeof(URoundEndWidget_PVP) == 0x000280, "Wrong size on URoundEndWidget_PVP");
static_assert(offsetof(URoundEndWidget_PVP, Anim_FadeIn) == 0x000278, "Member 'URoundEndWidget_PVP::Anim_FadeIn' has a wrong offset!");

// Class ReadyOrNot.SafeZoneVolume
// 0x0038 (0x0290 - 0x0258)
class ASafeZoneVolume final  : public AVolume
{
public:
	TArray<class ASafeZoneVolume*>                NextSafeZones;                                     // 0x0258(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AAISpawn*>                       AIBlacklist;                                       // 0x0268(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AAISpawn*>                       AIWhitelist;                                       // 0x0278(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsFirstSafeZone;                                  // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28EB[0x7];                                     // 0x0289(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SafeZoneVolume">();
	}
	static class ASafeZoneVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASafeZoneVolume>();
	}
};
static_assert(alignof(ASafeZoneVolume) == 0x000008, "Wrong alignment on ASafeZoneVolume");
static_assert(sizeof(ASafeZoneVolume) == 0x000290, "Wrong size on ASafeZoneVolume");
static_assert(offsetof(ASafeZoneVolume, NextSafeZones) == 0x000258, "Member 'ASafeZoneVolume::NextSafeZones' has a wrong offset!");
static_assert(offsetof(ASafeZoneVolume, AIBlacklist) == 0x000268, "Member 'ASafeZoneVolume::AIBlacklist' has a wrong offset!");
static_assert(offsetof(ASafeZoneVolume, AIWhitelist) == 0x000278, "Member 'ASafeZoneVolume::AIWhitelist' has a wrong offset!");
static_assert(offsetof(ASafeZoneVolume, bIsFirstSafeZone) == 0x000288, "Member 'ASafeZoneVolume::bIsFirstSafeZone' has a wrong offset!");

// Class ReadyOrNot.ScopedWeaponAttachment
// 0x05F0 (0x15F0 - 0x1000)
class UScopedWeaponAttachment : public UWeaponAttachment
{
public:
	TArray<struct FScopeModifications>            ScopeMods;                                         // 0x0FF8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ZoomFOVAddition;                                   // 0x1008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomInSpeed;                                       // 0x100C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutSpeed;                                      // 0x1010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsCowitness;                                // 0x1014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScopeEffect;                                   // 0x1015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28EC[0x2];                                     // 0x1016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              ScopeReticle;                                      // 0x1018(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePipRendering;                                  // 0x1040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESceneCaptureSource                           CaptureSource;                                     // 0x1041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverridePostProcessSettings;                      // 0x1042(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedInventoryUpdate;                              // 0x1043(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28ED[0xC];                                     // 0x1044(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   OverridePostProcessSettings;                       // 0x1050(0x0560)(Edit, NativeAccessSpecifierPublic)
	int32                                         PipMaterialIdx;                                    // 0x15B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PipFOV;                                            // 0x15B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerCameraFOVMultiplier;                         // 0x15B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28EE[0x4];                                     // 0x15BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               PipRenderDynamicMaterial;                          // 0x15C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneCaptureComponent2D*               PipSceneCapture;                                   // 0x15C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 PipRenderTarget;                                   // 0x15D0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PipResolution;                                     // 0x15D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28EF[0x10];                                    // 0x15E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetMeshspaceOffsetDistance(class ABaseWeapon* Weapon);
	float GetMeshspaceOffsetHorizontal(class ABaseWeapon* Weapon);
	float GetMeshspaceOffsetVertical(class ABaseWeapon* Weapon);
	struct FScopeModifications GetScopeMods(class ABaseWeapon* Weapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScopedWeaponAttachment">();
	}
	static class UScopedWeaponAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScopedWeaponAttachment>();
	}
};
static_assert(alignof(UScopedWeaponAttachment) == 0x000010, "Wrong alignment on UScopedWeaponAttachment");
static_assert(sizeof(UScopedWeaponAttachment) == 0x0015F0, "Wrong size on UScopedWeaponAttachment");
static_assert(offsetof(UScopedWeaponAttachment, ScopeMods) == 0x000FF8, "Member 'UScopedWeaponAttachment::ScopeMods' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, ZoomFOVAddition) == 0x001008, "Member 'UScopedWeaponAttachment::ZoomFOVAddition' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, ZoomInSpeed) == 0x00100C, "Member 'UScopedWeaponAttachment::ZoomInSpeed' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, ZoomOutSpeed) == 0x001010, "Member 'UScopedWeaponAttachment::ZoomOutSpeed' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, bSupportsCowitness) == 0x001014, "Member 'UScopedWeaponAttachment::bSupportsCowitness' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, bUseScopeEffect) == 0x001015, "Member 'UScopedWeaponAttachment::bUseScopeEffect' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, ScopeReticle) == 0x001018, "Member 'UScopedWeaponAttachment::ScopeReticle' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, bUsePipRendering) == 0x001040, "Member 'UScopedWeaponAttachment::bUsePipRendering' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, CaptureSource) == 0x001041, "Member 'UScopedWeaponAttachment::CaptureSource' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, bOverridePostProcessSettings) == 0x001042, "Member 'UScopedWeaponAttachment::bOverridePostProcessSettings' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, bNeedInventoryUpdate) == 0x001043, "Member 'UScopedWeaponAttachment::bNeedInventoryUpdate' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, OverridePostProcessSettings) == 0x001050, "Member 'UScopedWeaponAttachment::OverridePostProcessSettings' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, PipMaterialIdx) == 0x0015B0, "Member 'UScopedWeaponAttachment::PipMaterialIdx' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, PipFOV) == 0x0015B4, "Member 'UScopedWeaponAttachment::PipFOV' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, PlayerCameraFOVMultiplier) == 0x0015B8, "Member 'UScopedWeaponAttachment::PlayerCameraFOVMultiplier' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, PipRenderDynamicMaterial) == 0x0015C0, "Member 'UScopedWeaponAttachment::PipRenderDynamicMaterial' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, PipSceneCapture) == 0x0015C8, "Member 'UScopedWeaponAttachment::PipSceneCapture' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, PipRenderTarget) == 0x0015D0, "Member 'UScopedWeaponAttachment::PipRenderTarget' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, PipResolution) == 0x0015D8, "Member 'UScopedWeaponAttachment::PipResolution' has a wrong offset!");

// Class ReadyOrNot.ScoringInterface
// 0x0000 (0x0028 - 0x0028)
class IScoringInterface final  : public IInterface
{
public:
	class UScoringComponent* GetScoringComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScoringInterface">();
	}
	static class IScoringInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IScoringInterface>();
	}
};
static_assert(alignof(IScoringInterface) == 0x000008, "Wrong alignment on IScoringInterface");
static_assert(sizeof(IScoringInterface) == 0x000028, "Wrong size on IScoringInterface");

// Class ReadyOrNot.ScoringManager
// 0x0050 (0x0270 - 0x0220)
class AScoringManager final  : public AInfo
{
public:
	uint8                                         Pad_28F3[0x18];                                    // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalScorePool;                                    // 0x0238(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28F4[0xC];                                     // 0x023C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FScoreGroup>                    ObjectiveScoreGroups;                              // 0x0248(0x0010)(Net, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FScorePenaltyData>              PenaltyScoreGroups;                                // 0x0258(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_28F5[0x4];                                     // 0x0268(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsOfficialScoring;                                // 0x026C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28F6[0x3];                                     // 0x026D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString CalculateGradeLetterFromPercentage(float ScorePercentage);
	static class AScoringManager* Get();
	static void GetCivilianCount(int32* OutReported, int32* OutInjured, int32* OutKilled, int32* OutArrested, int32* OutTotal);
	static void GetEvidenceCount(int32* EvidenceCollected, int32* TotalEvidence);
	static void GetObjectiveCompletionStatus(int32* ObjectivesComplete, int32* ObjectivesFailed, int32* TotalObjectives);
	static void GetReportCount(int32* ReportedCount, int32* TotalReports);
	static void GetScoreCountFromGroup(class FName& InGroupName, int32* OutScoresGiven, int32* OutTotalScores, bool bRequiredOnly);
	static void GetSuspectCount(int32* OutReported, int32* OutArrested, int32* OutKilled, int32* OutTotal);
	static void HasClearedMission(bool* bHasClearedMission, bool* bSoftClearedMission, bool* bMissionFailed);
	static bool IsOfficialScoring();

	class FString CalculateGradeLetterFromPlayerScore();
	void ChangeScoreGroup(class UScoringComponent* InScoringComponent, class FName NewGroupName);
	void DisplayBonuses(class UScoringComponent* InScoringComponent, bool bCondensed, class FText& ScoreTextOverride);
	void DisplayBonusesAndPenalties(class UScoringComponent* InScoringComponent, bool bCondensed, class FText& ScoreTextOverride);
	void DisplayPenalties(class UScoringComponent* InScoringComponent, bool bCondensed, class FText& ScoreTextOverride);
	void GetTotalScore(int32* TotalScore, bool bIncludePrimaryScores);
	void GetTotalScorePool(int32* MaxScore);
	void GiveAllScores(class UScoringComponent* InScoringComponent, bool bOnlyEnabledScore, bool bDisplayScoreOnHUD, class FText& ScoreText, float DisplayOnHUDDelay, int32 CustomScoreOnHUD);
	void GiveCustomPenalty(class FText& PenaltyGroupName, int32 PenaltyScore, bool bDisplayScoreOnHUD, float DisplayOnHUDDelay);
	void GiveFakeScore(class UScoringComponent* InScoringComponent, class FText& ScoreName, bool bDisplayScoreOnHUD, class FText& ScoreText, float DisplayOnHUDDelay, int32 CustomScoreOnHUD);
	void GivePenalty(class UScoringComponent* InScoringComponent, class FText& PenaltyGroupName, bool bDisplayScoreOnHUD, class FText& ScoreText, float DisplayOnHUDDelay, int32 CustomScoreOnHUD);
	void GiveScore(class UScoringComponent* InScoringComponent, class FText& ScoreName, bool bDisplayScoreOnHUD, class FText& ScoreText, float DisplayOnHUDDelay, int32 CustomScoreOnHUD);
	void GiveScores(class UScoringComponent* InScoringComponent, TArray<class FText>& ScoreNames, bool bDisplayScoreOnHUD, class FText& ScoreText, float DisplayOnHUDDelay, int32 CustomScoreOnHUD);
	void Multicast_DisplayScore(class FText& ScoreText, int32 Score, bool bGive);
	void RevokeAllPenalties(class UScoringComponent* InScoringComponent);
	void RevokePenalty(class UScoringComponent* InScoringComponent, class FText& PenaltyGroupName);
	void TakeAllScores(class UScoringComponent* InScoringComponent, class FText& TakeReason, bool bDisplayScoreOnHUD, bool bDisableScores);
	void TakeAllScoresExcept(class UScoringComponent* InScoringComponent, TArray<class FText>& ScoreNames, class FText& TakeReason, bool bDisplayScoreOnHUD, bool bDisableScores);
	void TakeScore(class UScoringComponent* InScoringComponent, class FText& ScoreName, class FText& TakeReason, bool bDisplayScoreOnHUD, bool bDisableScore);
	void TakeScores(class UScoringComponent* InScoringComponent, TArray<class FText>& ScoreNames, class FText& TakeReason, bool bDisplayScoreOnHUD, bool bDisableScores);

	bool AllRequiredScoresGiven(TArray<struct FScoreBonus>& InScoreBonusArray) const;
	bool AllScoresGiven(TArray<struct FScoreBonus>& InScoreBonusArray) const;
	bool AnyScoresGiven(TArray<struct FScoreBonus>& InScoreBonusArray) const;
	class FString CalculateGradeLetterFromScore(int32 Score) const;
	float GetCurrentScoreAsPercentage() const;
	int32 GetGivenScoreCountFromArray(TArray<struct FScoreData>& InScoreDataArray, bool bIncludeHiddenScores) const;
	int32 GetGivenScoreCountFromGroup(TArray<struct FScoreGroup>& InScoreGroupArray) const;
	int32 GetNonGivenScoreCountFromArray(TArray<struct FScoreData>& InScoreDataArray, bool bOnlyEnabled) const;
	int32 GetNonGivenScoreCountFromGroup(TArray<struct FScoreGroup>& InScoreGroupArray) const;
	TArray<struct FScorePenaltyData> GetPenaltyScoreGroups() const;
	TArray<struct FScoreGroup> GetScoreGroups() const;
	int32 GetTotalActorsTrackingScore() const;
	int32 GetTotalGivenScoresFromArray(TArray<struct FScoreData>& InScoreDataArray, bool bIncludeHiddenScores) const;
	int32 GetTotalNonGivenScoresFromArray(TArray<struct FScoreData>& InScoreDataArray) const;
	int32 GetTotalScoreCountFromArray(TArray<struct FScoreData>& InScoreDataArray, bool bIncludeHiddenScores) const;
	int32 GetTotalScoreFromArray(TArray<struct FScoreData>& InScoreDataArray) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScoringManager">();
	}
	static class AScoringManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScoringManager>();
	}
};
static_assert(alignof(AScoringManager) == 0x000008, "Wrong alignment on AScoringManager");
static_assert(sizeof(AScoringManager) == 0x000270, "Wrong size on AScoringManager");
static_assert(offsetof(AScoringManager, TotalScorePool) == 0x000238, "Member 'AScoringManager::TotalScorePool' has a wrong offset!");
static_assert(offsetof(AScoringManager, ObjectiveScoreGroups) == 0x000248, "Member 'AScoringManager::ObjectiveScoreGroups' has a wrong offset!");
static_assert(offsetof(AScoringManager, PenaltyScoreGroups) == 0x000258, "Member 'AScoringManager::PenaltyScoreGroups' has a wrong offset!");
static_assert(offsetof(AScoringManager, bIsOfficialScoring) == 0x00026C, "Member 'AScoringManager::bIsOfficialScoring' has a wrong offset!");

// Class ReadyOrNot.ScreenspaceMarkerWidget
// 0x0000 (0x0288 - 0x0288)
class UScreenspaceMarkerWidget final  : public UCommonUserWidget
{
public:
	void HideWidget();
	void ShowWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenspaceMarkerWidget">();
	}
	static class UScreenspaceMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenspaceMarkerWidget>();
	}
};
static_assert(alignof(UScreenspaceMarkerWidget) == 0x000008, "Wrong alignment on UScreenspaceMarkerWidget");
static_assert(sizeof(UScreenspaceMarkerWidget) == 0x000288, "Wrong size on UScreenspaceMarkerWidget");

// Class ReadyOrNot.ScriptedLevelEvents
// 0x0000 (0x0028 - 0x0028)
class UScriptedLevelEvents final  : public UBlueprintFunctionLibrary
{
public:
	static class ACyberneticCharacter* GetCyberneticsCharacterByTag(class FName Tag);
	static class ACyberneticController* GetCyberneticsControllerByTag(class FName Tag);
	static void GiveWorldBuildingActivityByTag(class ACyberneticController* Controller, class FName Tag, float TimeDoingActivity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptedLevelEvents">();
	}
	static class UScriptedLevelEvents* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptedLevelEvents>();
	}
};
static_assert(alignof(UScriptedLevelEvents) == 0x000008, "Wrong alignment on UScriptedLevelEvents");
static_assert(sizeof(UScriptedLevelEvents) == 0x000028, "Wrong size on UScriptedLevelEvents");

// Class ReadyOrNot.SearchAndDestroyGM
// 0x0010 (0x07E0 - 0x07D0)
class ASearchAndDestroyGM final  : public AReadyOrNotGameMode_PVP
{
public:
	bool                                          bBombPlanted;                                      // 0x07D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2916[0x3];                                     // 0x07D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumRedSpawned;                                     // 0x07D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBlueSpawned;                                    // 0x07D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2917[0x4];                                     // 0x07DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetNumberOfActivePlayersOnTeam(ETeamType Team);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchAndDestroyGM">();
	}
	static class ASearchAndDestroyGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASearchAndDestroyGM>();
	}
};
static_assert(alignof(ASearchAndDestroyGM) == 0x000010, "Wrong alignment on ASearchAndDestroyGM");
static_assert(sizeof(ASearchAndDestroyGM) == 0x0007E0, "Wrong size on ASearchAndDestroyGM");
static_assert(offsetof(ASearchAndDestroyGM, bBombPlanted) == 0x0007D0, "Member 'ASearchAndDestroyGM::bBombPlanted' has a wrong offset!");
static_assert(offsetof(ASearchAndDestroyGM, NumRedSpawned) == 0x0007D4, "Member 'ASearchAndDestroyGM::NumRedSpawned' has a wrong offset!");
static_assert(offsetof(ASearchAndDestroyGM, NumBlueSpawned) == 0x0007D8, "Member 'ASearchAndDestroyGM::NumBlueSpawned' has a wrong offset!");

// Class ReadyOrNot.SearchLandmarkActivity
// 0x0020 (0x01C8 - 0x01A8)
class USearchLandmarkActivity final  : public UBaseActivity
{
public:
	class ACoverLandmark*                         CoverLandmark;                                     // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2919[0x18];                                    // 0x01B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterCompleteStage();
	void EnterMoveToStage();
	void EnterSearchStage();
	void Notify_SearchLandmark();
	void TickSearchStage(float DeltaTime, float Uptime);

	bool CanAbortSearch() const;
	bool CanSearchNow() const;
	bool IsSearchFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchLandmarkActivity">();
	}
	static class USearchLandmarkActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchLandmarkActivity>();
	}
};
static_assert(alignof(USearchLandmarkActivity) == 0x000008, "Wrong alignment on USearchLandmarkActivity");
static_assert(sizeof(USearchLandmarkActivity) == 0x0001C8, "Wrong size on USearchLandmarkActivity");
static_assert(offsetof(USearchLandmarkActivity, CoverLandmark) == 0x0001A8, "Member 'USearchLandmarkActivity::CoverLandmark' has a wrong offset!");

// Class ReadyOrNot.Securable
// 0x0000 (0x0028 - 0x0028)
class ISecurable final  : public IInterface
{
public:
	void Secure(class AReadyOrNotCharacter* Instigator);

	bool CanBeSecured() const;
	bool CanBeSecuredByTrailers() const;
	struct FVector GetLocation() const;
	bool IsSecured() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Securable">();
	}
	static class ISecurable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISecurable>();
	}
};
static_assert(alignof(ISecurable) == 0x000008, "Wrong alignment on ISecurable");
static_assert(sizeof(ISecurable) == 0x000028, "Wrong size on ISecurable");

// Class ReadyOrNot.SettingsMenuGamepad
// 0x00F0 (0x0410 - 0x0320)
class USettingsMenuGamepad : public UMenuWidget
{
public:
	TArray<struct FKeyBinding>                    CharacterControls;                                 // 0x0320(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKeyBinding>                    DroneControls;                                     // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKeyBinding>                    SharedControls;                                    // 0x0340(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class UControlsBind*, struct FAxisMappingStruct> AxesControlBinds;                                  // 0x0350(0x0050)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class UControlsBind*, struct FActionMappingStruct> ActionsControlBinds;                               // 0x03A0(0x0050)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FKeyBinding>                    UnbindableControls;                                // 0x03F0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UIllegalUnbindModal*                    IllegalKeyConflictDetectedPopUp;                   // 0x0400(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCommonActivatableWidgetStack*          WidgetStack;                                       // 0x0408(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void EndButtonsDisabledForBinding();
	void SelectNewTab(const TArray<class UCommonButtonBase*>& TabButtonsArray, int32 WidgetIndex, bool GoingToPreviousWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsMenuGamepad">();
	}
	static class USettingsMenuGamepad* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingsMenuGamepad>();
	}
};
static_assert(alignof(USettingsMenuGamepad) == 0x000008, "Wrong alignment on USettingsMenuGamepad");
static_assert(sizeof(USettingsMenuGamepad) == 0x000410, "Wrong size on USettingsMenuGamepad");
static_assert(offsetof(USettingsMenuGamepad, CharacterControls) == 0x000320, "Member 'USettingsMenuGamepad::CharacterControls' has a wrong offset!");
static_assert(offsetof(USettingsMenuGamepad, DroneControls) == 0x000330, "Member 'USettingsMenuGamepad::DroneControls' has a wrong offset!");
static_assert(offsetof(USettingsMenuGamepad, SharedControls) == 0x000340, "Member 'USettingsMenuGamepad::SharedControls' has a wrong offset!");
static_assert(offsetof(USettingsMenuGamepad, AxesControlBinds) == 0x000350, "Member 'USettingsMenuGamepad::AxesControlBinds' has a wrong offset!");
static_assert(offsetof(USettingsMenuGamepad, ActionsControlBinds) == 0x0003A0, "Member 'USettingsMenuGamepad::ActionsControlBinds' has a wrong offset!");
static_assert(offsetof(USettingsMenuGamepad, UnbindableControls) == 0x0003F0, "Member 'USettingsMenuGamepad::UnbindableControls' has a wrong offset!");
static_assert(offsetof(USettingsMenuGamepad, IllegalKeyConflictDetectedPopUp) == 0x000400, "Member 'USettingsMenuGamepad::IllegalKeyConflictDetectedPopUp' has a wrong offset!");
static_assert(offsetof(USettingsMenuGamepad, WidgetStack) == 0x000408, "Member 'USettingsMenuGamepad::WidgetStack' has a wrong offset!");

// Class ReadyOrNot.ShotDetectionVolume
// 0x0008 (0x0228 - 0x0220)
class AShotDetectionVolume final  : public AActor
{
public:
	class UBoxComponent*                          Bounds;                                            // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnShotFired(class ABaseWeapon* FiringWeapon, class APlayerCharacter* FiringPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShotDetectionVolume">();
	}
	static class AShotDetectionVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShotDetectionVolume>();
	}
};
static_assert(alignof(AShotDetectionVolume) == 0x000008, "Wrong alignment on AShotDetectionVolume");
static_assert(sizeof(AShotDetectionVolume) == 0x000228, "Wrong size on AShotDetectionVolume");
static_assert(offsetof(AShotDetectionVolume, Bounds) == 0x000220, "Member 'AShotDetectionVolume::Bounds' has a wrong offset!");

// Class ReadyOrNot.SlowDownVolume
// 0x0008 (0x0230 - 0x0228)
class ASlowDownVolume final  : public ATriggerBox
{
public:
	float                                         SlowDownMultiplier;                                // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_291B[0x4];                                     // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapBeginComponent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapEndComponent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlowDownVolume">();
	}
	static class ASlowDownVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASlowDownVolume>();
	}
};
static_assert(alignof(ASlowDownVolume) == 0x000008, "Wrong alignment on ASlowDownVolume");
static_assert(sizeof(ASlowDownVolume) == 0x000230, "Wrong size on ASlowDownVolume");
static_assert(offsetof(ASlowDownVolume, SlowDownMultiplier) == 0x000228, "Member 'ASlowDownVolume::SlowDownMultiplier' has a wrong offset!");

// Class ReadyOrNot.SniperCharacter
// 0x0040 (0x2560 - 0x2520)
class ASniperCharacter final  : public APlayerCharacter
{
public:
	int32                                         Designation;                                       // 0x2518(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bADSLocked;                                        // 0x251C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291E[0x3];                                     // 0x251D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ExitControlHandle;                                 // 0x2520(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UScopedWeaponAttachment>    PrimaryScopeAttachment;                            // 0x2528(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          PrimaryMuzzleAttachment;                           // 0x2530(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          PrimaryUnderbarrelAttachment;                      // 0x2538(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UScopedWeaponAttachment>    SecondaryScopeAttachment;                          // 0x2540(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          SecondaryMuzzleAttachment;                         // 0x2548(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          SecondaryUnderbarrelAttachment;                    // 0x2550(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291F[0x8];                                     // 0x2558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExitControl();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SniperCharacter">();
	}
	static class ASniperCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASniperCharacter>();
	}
};
static_assert(alignof(ASniperCharacter) == 0x000010, "Wrong alignment on ASniperCharacter");
static_assert(sizeof(ASniperCharacter) == 0x002560, "Wrong size on ASniperCharacter");
static_assert(offsetof(ASniperCharacter, Designation) == 0x002518, "Member 'ASniperCharacter::Designation' has a wrong offset!");
static_assert(offsetof(ASniperCharacter, bADSLocked) == 0x00251C, "Member 'ASniperCharacter::bADSLocked' has a wrong offset!");
static_assert(offsetof(ASniperCharacter, ExitControlHandle) == 0x002520, "Member 'ASniperCharacter::ExitControlHandle' has a wrong offset!");
static_assert(offsetof(ASniperCharacter, PrimaryScopeAttachment) == 0x002528, "Member 'ASniperCharacter::PrimaryScopeAttachment' has a wrong offset!");
static_assert(offsetof(ASniperCharacter, PrimaryMuzzleAttachment) == 0x002530, "Member 'ASniperCharacter::PrimaryMuzzleAttachment' has a wrong offset!");
static_assert(offsetof(ASniperCharacter, PrimaryUnderbarrelAttachment) == 0x002538, "Member 'ASniperCharacter::PrimaryUnderbarrelAttachment' has a wrong offset!");
static_assert(offsetof(ASniperCharacter, SecondaryScopeAttachment) == 0x002540, "Member 'ASniperCharacter::SecondaryScopeAttachment' has a wrong offset!");
static_assert(offsetof(ASniperCharacter, SecondaryMuzzleAttachment) == 0x002548, "Member 'ASniperCharacter::SecondaryMuzzleAttachment' has a wrong offset!");
static_assert(offsetof(ASniperCharacter, SecondaryUnderbarrelAttachment) == 0x002550, "Member 'ASniperCharacter::SecondaryUnderbarrelAttachment' has a wrong offset!");

// Class ReadyOrNot.SniperSpawn
// 0x0048 (0x0268 - 0x0220)
class ASniperSpawn final  : public AActor
{
public:
	class FName                                   SpawnLabel;                                        // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovementLocked;                                   // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartInADS;                                       // 0x0229(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockADS;                                          // 0x022A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2920[0x5];                                     // 0x022B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ASniperCharacter>           SniperClass;                                       // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASniperCharacter>           SpotterClass;                                      // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASniperCharacter>           MarksmanClass;                                     // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        SpawnDirection;                                    // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        RootSceneComponent;                                // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSniperSpawned;                                 // 0x0258(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2921[0x7];                                     // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ASniperCharacter*                       SpawnedSniper;                                     // 0x0260(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SpawnMarksmanHere(int32 Designation);
	void SpawnPersonnelOfClass(TSubclassOf<class ASniperCharacter> CharacterClass, int32 Designation);
	void SpawnSniperHere(int32 Designation);
	void SpawnSpotterHere(int32 Designation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SniperSpawn">();
	}
	static class ASniperSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASniperSpawn>();
	}
};
static_assert(alignof(ASniperSpawn) == 0x000008, "Wrong alignment on ASniperSpawn");
static_assert(sizeof(ASniperSpawn) == 0x000268, "Wrong size on ASniperSpawn");
static_assert(offsetof(ASniperSpawn, SpawnLabel) == 0x000220, "Member 'ASniperSpawn::SpawnLabel' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, bMovementLocked) == 0x000228, "Member 'ASniperSpawn::bMovementLocked' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, bStartInADS) == 0x000229, "Member 'ASniperSpawn::bStartInADS' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, bLockADS) == 0x00022A, "Member 'ASniperSpawn::bLockADS' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, SniperClass) == 0x000230, "Member 'ASniperSpawn::SniperClass' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, SpotterClass) == 0x000238, "Member 'ASniperSpawn::SpotterClass' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, MarksmanClass) == 0x000240, "Member 'ASniperSpawn::MarksmanClass' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, SpawnDirection) == 0x000248, "Member 'ASniperSpawn::SpawnDirection' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, RootSceneComponent) == 0x000250, "Member 'ASniperSpawn::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, bHasSniperSpawned) == 0x000258, "Member 'ASniperSpawn::bHasSniperSpawned' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, SpawnedSniper) == 0x000260, "Member 'ASniperSpawn::SpawnedSniper' has a wrong offset!");

// Class ReadyOrNot.SoftCoverCombatMove
// 0x0008 (0x01E0 - 0x01D8)
class USoftCoverCombatMove final  : public UBaseCombatMoveActivity
{
public:
	uint8                                         Pad_2923[0x8];                                     // 0x01D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoftCoverCombatMove">();
	}
	static class USoftCoverCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoftCoverCombatMove>();
	}
};
static_assert(alignof(USoftCoverCombatMove) == 0x000008, "Wrong alignment on USoftCoverCombatMove");
static_assert(sizeof(USoftCoverCombatMove) == 0x0001E0, "Wrong size on USoftCoverCombatMove");

// Class ReadyOrNot.SoundManager
// 0x0080 (0x00C0 - 0x0040)
class USoundManager final  : public UTickableWorldSubsystem
{
public:
	bool                                          bForceLegacySound;                                 // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasFinishedSetup;                                 // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2924[0x6];                                     // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APortalVolume*>                  PortalVolumes;                                     // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ARoomVolume*>                    RoomVolumes;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USoundSource*>                   ActiveSoundSources;                                // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USoundSource*>                   InactiveSoundSources;                              // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UBVHNode*                               RootBVHNode;                                       // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2925[0x30];                                    // 0x0090(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USoundManager* Get(class UWorld* World);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundManager">();
	}
	static class USoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundManager>();
	}
};
static_assert(alignof(USoundManager) == 0x000008, "Wrong alignment on USoundManager");
static_assert(sizeof(USoundManager) == 0x0000C0, "Wrong size on USoundManager");
static_assert(offsetof(USoundManager, bForceLegacySound) == 0x000040, "Member 'USoundManager::bForceLegacySound' has a wrong offset!");
static_assert(offsetof(USoundManager, bHasFinishedSetup) == 0x000041, "Member 'USoundManager::bHasFinishedSetup' has a wrong offset!");
static_assert(offsetof(USoundManager, PortalVolumes) == 0x000048, "Member 'USoundManager::PortalVolumes' has a wrong offset!");
static_assert(offsetof(USoundManager, RoomVolumes) == 0x000058, "Member 'USoundManager::RoomVolumes' has a wrong offset!");
static_assert(offsetof(USoundManager, ActiveSoundSources) == 0x000068, "Member 'USoundManager::ActiveSoundSources' has a wrong offset!");
static_assert(offsetof(USoundManager, InactiveSoundSources) == 0x000078, "Member 'USoundManager::InactiveSoundSources' has a wrong offset!");
static_assert(offsetof(USoundManager, RootBVHNode) == 0x000088, "Member 'USoundManager::RootBVHNode' has a wrong offset!");

// Class ReadyOrNot.BVHNode
// 0x0048 (0x0070 - 0x0028)
class UBVHNode final  : public UObject
{
public:
	uint8                                         Pad_2926[0x20];                                    // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBVHNode*>                       Children;                                          // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ARoomVolume*>                    Rooms;                                             // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BVHNode">();
	}
	static class UBVHNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBVHNode>();
	}
};
static_assert(alignof(UBVHNode) == 0x000008, "Wrong alignment on UBVHNode");
static_assert(sizeof(UBVHNode) == 0x000070, "Wrong size on UBVHNode");
static_assert(offsetof(UBVHNode, Children) == 0x000048, "Member 'UBVHNode::Children' has a wrong offset!");
static_assert(offsetof(UBVHNode, Rooms) == 0x000058, "Member 'UBVHNode::Rooms' has a wrong offset!");
static_assert(offsetof(UBVHNode, World) == 0x000068, "Member 'UBVHNode::World' has a wrong offset!");

// Class ReadyOrNot.SoundNodeVolume
// 0x0008 (0x0050 - 0x0048)
class USoundNodeVolume final  : public USoundNodeAssetReferencer
{
public:
	float                                         VolumeAdjust;                                      // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2927[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeVolume">();
	}
	static class USoundNodeVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeVolume>();
	}
};
static_assert(alignof(USoundNodeVolume) == 0x000008, "Wrong alignment on USoundNodeVolume");
static_assert(sizeof(USoundNodeVolume) == 0x000050, "Wrong size on USoundNodeVolume");
static_assert(offsetof(USoundNodeVolume, VolumeAdjust) == 0x000048, "Member 'USoundNodeVolume::VolumeAdjust' has a wrong offset!");

// Class ReadyOrNot.SoundPropagator
// 0x0078 (0x0298 - 0x0220)
class ASoundPropagator final  : public AActor
{
public:
	TMap<class APropagationPoint*, float>         PropagationPoints;                                 // 0x0220(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         bStopPropagationIfClosestToSound : 1;              // 0x0270(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2928[0x3];                                     // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathTracerRefreshRate;                             // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavCheckRefreshRate;                               // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableDebugSpheres : 1;                           // 0x027C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableDebugPathPoints : 1;                        // 0x027C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2929[0x3];                                     // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          PropagationSwitchEnter;                            // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          PropagationSwitchExit;                             // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPropagationEnterOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void OnPropagationExitOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundPropagator">();
	}
	static class ASoundPropagator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASoundPropagator>();
	}
};
static_assert(alignof(ASoundPropagator) == 0x000008, "Wrong alignment on ASoundPropagator");
static_assert(sizeof(ASoundPropagator) == 0x000298, "Wrong size on ASoundPropagator");
static_assert(offsetof(ASoundPropagator, PropagationPoints) == 0x000220, "Member 'ASoundPropagator::PropagationPoints' has a wrong offset!");
static_assert(offsetof(ASoundPropagator, PathTracerRefreshRate) == 0x000274, "Member 'ASoundPropagator::PathTracerRefreshRate' has a wrong offset!");
static_assert(offsetof(ASoundPropagator, NavCheckRefreshRate) == 0x000278, "Member 'ASoundPropagator::NavCheckRefreshRate' has a wrong offset!");
static_assert(offsetof(ASoundPropagator, SceneComponent) == 0x000280, "Member 'ASoundPropagator::SceneComponent' has a wrong offset!");
static_assert(offsetof(ASoundPropagator, PropagationSwitchEnter) == 0x000288, "Member 'ASoundPropagator::PropagationSwitchEnter' has a wrong offset!");
static_assert(offsetof(ASoundPropagator, PropagationSwitchExit) == 0x000290, "Member 'ASoundPropagator::PropagationSwitchExit' has a wrong offset!");

// Class ReadyOrNot.SpawnGenerator
// 0x0058 (0x0278 - 0x0220)
class ASpawnGenerator final  : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBillboardComponent*                    BillboardComponent;                                // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeamType                                     SpawnTeam;                                         // 0x0230(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_292C[0x1];                                     // 0x0231(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        Rows;                                              // 0x0232(0x0002)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint16                                        Columns;                                           // 0x0234(0x0002)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_292D[0x2];                                     // 0x0236(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RowSpacing;                                        // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ColumnSpacing;                                     // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bShowNodes : 1;                                    // 0x0240(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_292E[0x17];                                    // 0x0241(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerStart*>                   PlayerStarts;                                      // 0x0258(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_292F[0x10];                                    // 0x0268(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RefreshSpawns();
	void SelectAll();
	void UpdatePlayerStartTags();

	const TArray<class APlayerStart*> GetAllPlayerStarts() const;
	TArray<struct FVector> GetNodes() const;
	ETeamType GetSpawnTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnGenerator">();
	}
	static class ASpawnGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawnGenerator>();
	}
};
static_assert(alignof(ASpawnGenerator) == 0x000008, "Wrong alignment on ASpawnGenerator");
static_assert(sizeof(ASpawnGenerator) == 0x000278, "Wrong size on ASpawnGenerator");
static_assert(offsetof(ASpawnGenerator, SceneComponent) == 0x000220, "Member 'ASpawnGenerator::SceneComponent' has a wrong offset!");
static_assert(offsetof(ASpawnGenerator, BillboardComponent) == 0x000228, "Member 'ASpawnGenerator::BillboardComponent' has a wrong offset!");
static_assert(offsetof(ASpawnGenerator, SpawnTeam) == 0x000230, "Member 'ASpawnGenerator::SpawnTeam' has a wrong offset!");
static_assert(offsetof(ASpawnGenerator, Rows) == 0x000232, "Member 'ASpawnGenerator::Rows' has a wrong offset!");
static_assert(offsetof(ASpawnGenerator, Columns) == 0x000234, "Member 'ASpawnGenerator::Columns' has a wrong offset!");
static_assert(offsetof(ASpawnGenerator, RowSpacing) == 0x000238, "Member 'ASpawnGenerator::RowSpacing' has a wrong offset!");
static_assert(offsetof(ASpawnGenerator, ColumnSpacing) == 0x00023C, "Member 'ASpawnGenerator::ColumnSpacing' has a wrong offset!");
static_assert(offsetof(ASpawnGenerator, PlayerStarts) == 0x000258, "Member 'ASpawnGenerator::PlayerStarts' has a wrong offset!");

// Class ReadyOrNot.SpawnStaticMeshAnimNotifyState
// 0x0038 (0x0068 - 0x0030)
class USpawnStaticMeshAnimNotifyState final  : public UAnimNotifyState
{
public:
	class UStaticMesh*                            StaticMeshToSpawn;                                 // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneToSpawnOn;                                     // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2930[0x10];                                    // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCastShadow;                                       // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyOwnerSee;                                     // 0x0051(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOwnerNoSee;                                       // 0x0052(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyAtEnd;                                     // 0x0053(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulatePhysicsAtEnd;                             // 0x0054(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2931[0x3];                                     // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ForceVector;                                       // 0x0058(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2932[0x4];                                     // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnStaticMeshAnimNotifyState">();
	}
	static class USpawnStaticMeshAnimNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnStaticMeshAnimNotifyState>();
	}
};
static_assert(alignof(USpawnStaticMeshAnimNotifyState) == 0x000008, "Wrong alignment on USpawnStaticMeshAnimNotifyState");
static_assert(sizeof(USpawnStaticMeshAnimNotifyState) == 0x000068, "Wrong size on USpawnStaticMeshAnimNotifyState");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, StaticMeshToSpawn) == 0x000030, "Member 'USpawnStaticMeshAnimNotifyState::StaticMeshToSpawn' has a wrong offset!");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, BoneToSpawnOn) == 0x000038, "Member 'USpawnStaticMeshAnimNotifyState::BoneToSpawnOn' has a wrong offset!");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, bCastShadow) == 0x000050, "Member 'USpawnStaticMeshAnimNotifyState::bCastShadow' has a wrong offset!");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, bOnlyOwnerSee) == 0x000051, "Member 'USpawnStaticMeshAnimNotifyState::bOnlyOwnerSee' has a wrong offset!");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, bOwnerNoSee) == 0x000052, "Member 'USpawnStaticMeshAnimNotifyState::bOwnerNoSee' has a wrong offset!");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, bDestroyAtEnd) == 0x000053, "Member 'USpawnStaticMeshAnimNotifyState::bDestroyAtEnd' has a wrong offset!");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, bSimulatePhysicsAtEnd) == 0x000054, "Member 'USpawnStaticMeshAnimNotifyState::bSimulatePhysicsAtEnd' has a wrong offset!");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, ForceVector) == 0x000058, "Member 'USpawnStaticMeshAnimNotifyState::ForceVector' has a wrong offset!");

// Class ReadyOrNot.SpectatePawn
// 0x0068 (0x0310 - 0x02A8)
class ASpectatePawn : public ASpectatorPawn
{
public:
	class UCameraComponent*                       PawnCamera;                                        // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeadSpectatePawn;                                 // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2933[0x1];                                     // 0x02B1(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBlendWithViewTarget;                              // 0x02B2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPendingCenterprint;                               // 0x02B3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PendingCenterprintDuration;                        // 0x02B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PendingCenterprintType;                            // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       PendingCenterprintOther;                           // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              HeadcamMaterial;                                   // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               HeadcamMaterialInstance;                           // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                SpectateWidget;                                    // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpectatorCharacterHUD*                 SpectatorHUD;                                      // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldShowViewTargetHUD;                          // 0x02E8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2934[0x7];                                     // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentViewTarget;                                 // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideWidgets;                                      // 0x02F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2935[0x7];                                     // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       Killer;                                            // 0x0300(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       KilledCharacter;                                   // 0x0308(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CenterPrint(class FName Type, float Duration, class APlayerCharacter* Other);
	void CleanUpOldPlayer();
	void EscapeMenu();
	void OnChatPressed();
	void OnTeamChatPressed();
	void SetSpectatorCharacterWidget(class USpectatorCharacterHUD* NewHud);
	void SetViewTarget(class AReadyOrNotCharacter* InCharacter);
	void SpectateNextPlayer();
	void SpectatePreviousPlayer();

	ETeamType GetTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatePawn">();
	}
	static class ASpectatePawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpectatePawn>();
	}
};
static_assert(alignof(ASpectatePawn) == 0x000008, "Wrong alignment on ASpectatePawn");
static_assert(sizeof(ASpectatePawn) == 0x000310, "Wrong size on ASpectatePawn");
static_assert(offsetof(ASpectatePawn, PawnCamera) == 0x0002A8, "Member 'ASpectatePawn::PawnCamera' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, bDeadSpectatePawn) == 0x0002B0, "Member 'ASpectatePawn::bDeadSpectatePawn' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, bBlendWithViewTarget) == 0x0002B2, "Member 'ASpectatePawn::bBlendWithViewTarget' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, bPendingCenterprint) == 0x0002B3, "Member 'ASpectatePawn::bPendingCenterprint' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, PendingCenterprintDuration) == 0x0002B4, "Member 'ASpectatePawn::PendingCenterprintDuration' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, PendingCenterprintType) == 0x0002B8, "Member 'ASpectatePawn::PendingCenterprintType' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, PendingCenterprintOther) == 0x0002C0, "Member 'ASpectatePawn::PendingCenterprintOther' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, HeadcamMaterial) == 0x0002C8, "Member 'ASpectatePawn::HeadcamMaterial' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, HeadcamMaterialInstance) == 0x0002D0, "Member 'ASpectatePawn::HeadcamMaterialInstance' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, SpectateWidget) == 0x0002D8, "Member 'ASpectatePawn::SpectateWidget' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, SpectatorHUD) == 0x0002E0, "Member 'ASpectatePawn::SpectatorHUD' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, bShouldShowViewTargetHUD) == 0x0002E8, "Member 'ASpectatePawn::bShouldShowViewTargetHUD' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, CurrentViewTarget) == 0x0002F0, "Member 'ASpectatePawn::CurrentViewTarget' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, bHideWidgets) == 0x0002F8, "Member 'ASpectatePawn::bHideWidgets' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, Killer) == 0x000300, "Member 'ASpectatePawn::Killer' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, KilledCharacter) == 0x000308, "Member 'ASpectatePawn::KilledCharacter' has a wrong offset!");

// Class ReadyOrNot.StackUpActor
// 0x0028 (0x0248 - 0x0220)
class AStackUpActor final  : public AActor
{
public:
	class USceneComponent*                        DefaultScene;                                      // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Depth;                                             // 0x0228(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2937[0x7];                                     // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            OccupiedBy;                                        // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESquadPosition                                StackUpPosition;                                   // 0x0238(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2938[0x7];                                     // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  LinkedDoor;                                        // 0x0240(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StackUpActor">();
	}
	static class AStackUpActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStackUpActor>();
	}
};
static_assert(alignof(AStackUpActor) == 0x000008, "Wrong alignment on AStackUpActor");
static_assert(sizeof(AStackUpActor) == 0x000248, "Wrong size on AStackUpActor");
static_assert(offsetof(AStackUpActor, DefaultScene) == 0x000220, "Member 'AStackUpActor::DefaultScene' has a wrong offset!");
static_assert(offsetof(AStackUpActor, Depth) == 0x000228, "Member 'AStackUpActor::Depth' has a wrong offset!");
static_assert(offsetof(AStackUpActor, OccupiedBy) == 0x000230, "Member 'AStackUpActor::OccupiedBy' has a wrong offset!");
static_assert(offsetof(AStackUpActor, StackUpPosition) == 0x000238, "Member 'AStackUpActor::StackUpPosition' has a wrong offset!");
static_assert(offsetof(AStackUpActor, LinkedDoor) == 0x000240, "Member 'AStackUpActor::LinkedDoor' has a wrong offset!");

// Class ReadyOrNot.StationSubLevelController
// 0x0020 (0x0240 - 0x0220)
class AStationSubLevelController final  : public AActor
{
public:
	class FName                                   LevelToLoad;                                       // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   EnableAfterCompleting;                             // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DisableAfterCompleting;                            // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMultiplayerOnly;                                // 0x0238(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2939[0x7];                                     // 0x0239(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FString> GetCampaignLevelOptions() const;
	TArray<class FString> GetStreamingLevelOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StationSubLevelController">();
	}
	static class AStationSubLevelController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStationSubLevelController>();
	}
};
static_assert(alignof(AStationSubLevelController) == 0x000008, "Wrong alignment on AStationSubLevelController");
static_assert(sizeof(AStationSubLevelController) == 0x000240, "Wrong size on AStationSubLevelController");
static_assert(offsetof(AStationSubLevelController, LevelToLoad) == 0x000220, "Member 'AStationSubLevelController::LevelToLoad' has a wrong offset!");
static_assert(offsetof(AStationSubLevelController, EnableAfterCompleting) == 0x000228, "Member 'AStationSubLevelController::EnableAfterCompleting' has a wrong offset!");
static_assert(offsetof(AStationSubLevelController, DisableAfterCompleting) == 0x000230, "Member 'AStationSubLevelController::DisableAfterCompleting' has a wrong offset!");
static_assert(offsetof(AStationSubLevelController, bIsMultiplayerOnly) == 0x000238, "Member 'AStationSubLevelController::bIsMultiplayerOnly' has a wrong offset!");

// Class ReadyOrNot.StrideWarpingLibrary
// 0x0000 (0x0028 - 0x0028)
class UStrideWarpingLibrary final  : public UBlueprintFunctionLibrary
{
public:
	static void UpdateStrideWarping(float DeltaTime, struct FVector& Velocity, float& VelocityInterpTime, float& CurrentAnimationSpeed, float& PlayrateMaxAdjustment, float& StrideScaling, float& PlayRate, struct FVector& VelocitySmoothed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StrideWarpingLibrary">();
	}
	static class UStrideWarpingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStrideWarpingLibrary>();
	}
};
static_assert(alignof(UStrideWarpingLibrary) == 0x000008, "Wrong alignment on UStrideWarpingLibrary");
static_assert(sizeof(UStrideWarpingLibrary) == 0x000028, "Wrong size on UStrideWarpingLibrary");

// Class ReadyOrNot.SubtitlesSettings
// 0x00B0 (0x00E8 - 0x0038)
class USubtitlesSettings final  : public UDeveloperSettings
{
public:
	class FString                                 FallbackLocale;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FText>              AvailableLocales;                                  // 0x0048(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    VoiceLineCooldowns;                                // 0x0098(0x0050)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitlesSettings">();
	}
	static class USubtitlesSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitlesSettings>();
	}
};
static_assert(alignof(USubtitlesSettings) == 0x000008, "Wrong alignment on USubtitlesSettings");
static_assert(sizeof(USubtitlesSettings) == 0x0000E8, "Wrong size on USubtitlesSettings");
static_assert(offsetof(USubtitlesSettings, FallbackLocale) == 0x000038, "Member 'USubtitlesSettings::FallbackLocale' has a wrong offset!");
static_assert(offsetof(USubtitlesSettings, AvailableLocales) == 0x000048, "Member 'USubtitlesSettings::AvailableLocales' has a wrong offset!");
static_assert(offsetof(USubtitlesSettings, VoiceLineCooldowns) == 0x000098, "Member 'USubtitlesSettings::VoiceLineCooldowns' has a wrong offset!");

// Class ReadyOrNot.SubtitleBlock
// 0x0010 (0x0270 - 0x0260)
class USubtitleBlock : public UUserWidget
{
public:
	float                                         CurrentTime;                                       // 0x0260(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalTime;                                         // 0x0264(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBoxSlot*                       VerticalBoxSlot;                                   // 0x0268(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetBackgroundColor(const struct FLinearColor& Color);
	void SetText(class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitleBlock">();
	}
	static class USubtitleBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitleBlock>();
	}
};
static_assert(alignof(USubtitleBlock) == 0x000008, "Wrong alignment on USubtitleBlock");
static_assert(sizeof(USubtitleBlock) == 0x000270, "Wrong size on USubtitleBlock");
static_assert(offsetof(USubtitleBlock, CurrentTime) == 0x000260, "Member 'USubtitleBlock::CurrentTime' has a wrong offset!");
static_assert(offsetof(USubtitleBlock, TotalTime) == 0x000264, "Member 'USubtitleBlock::TotalTime' has a wrong offset!");
static_assert(offsetof(USubtitleBlock, VerticalBoxSlot) == 0x000268, "Member 'USubtitleBlock::VerticalBoxSlot' has a wrong offset!");

// Class ReadyOrNot.SuppressionCombatMove
// 0x0018 (0x01F0 - 0x01D8)
class USuppressionCombatMove final  : public UBaseCombatMoveActivity
{
public:
	uint8                                         Pad_293A[0x18];                                    // 0x01D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuppressionCombatMove">();
	}
	static class USuppressionCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<USuppressionCombatMove>();
	}
};
static_assert(alignof(USuppressionCombatMove) == 0x000008, "Wrong alignment on USuppressionCombatMove");
static_assert(sizeof(USuppressionCombatMove) == 0x0001F0, "Wrong size on USuppressionCombatMove");

// Class ReadyOrNot.SuspectCombatActivity
// 0x0020 (0x0440 - 0x0420)
class USuspectCombatActivity final  : public UBaseCombatActivity
{
public:
	uint8                                         Pad_293B[0x20];                                    // 0x0420(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuspectCombatActivity">();
	}
	static class USuspectCombatActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<USuspectCombatActivity>();
	}
};
static_assert(alignof(USuspectCombatActivity) == 0x000008, "Wrong alignment on USuspectCombatActivity");
static_assert(sizeof(USuspectCombatActivity) == 0x000440, "Wrong size on USuspectCombatActivity");

// Class ReadyOrNot.SuspectsAndCivilianManager
// 0x0090 (0x00D0 - 0x0040)
class USuspectsAndCivilianManager final  : public UTickableWorldSubsystem
{
public:
	TArray<class ATrapActor*>                     InvestigatedTrap;                                  // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class ACyberneticCharacter*>           Suspects;                                          // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ACyberneticCharacter*>           Civilians;                                         // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastInvestigation;                        // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_293C[0xC];                                     // 0x0074(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, float>                    SpeechCooldownMap;                                 // 0x0080(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void Server_PlaySharedBarkOrStartConversation(const class FString& SpeechRow, class ACyberneticCharacter* Speaker, float Cooldown);

	TArray<class ACyberneticCharacter*> GetAllSuspectsAndCivilians() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuspectsAndCivilianManager">();
	}
	static class USuspectsAndCivilianManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USuspectsAndCivilianManager>();
	}
};
static_assert(alignof(USuspectsAndCivilianManager) == 0x000008, "Wrong alignment on USuspectsAndCivilianManager");
static_assert(sizeof(USuspectsAndCivilianManager) == 0x0000D0, "Wrong size on USuspectsAndCivilianManager");
static_assert(offsetof(USuspectsAndCivilianManager, InvestigatedTrap) == 0x000040, "Member 'USuspectsAndCivilianManager::InvestigatedTrap' has a wrong offset!");
static_assert(offsetof(USuspectsAndCivilianManager, Suspects) == 0x000050, "Member 'USuspectsAndCivilianManager::Suspects' has a wrong offset!");
static_assert(offsetof(USuspectsAndCivilianManager, Civilians) == 0x000060, "Member 'USuspectsAndCivilianManager::Civilians' has a wrong offset!");
static_assert(offsetof(USuspectsAndCivilianManager, TimeSinceLastInvestigation) == 0x000070, "Member 'USuspectsAndCivilianManager::TimeSinceLastInvestigation' has a wrong offset!");
static_assert(offsetof(USuspectsAndCivilianManager, SpeechCooldownMap) == 0x000080, "Member 'USuspectsAndCivilianManager::SpeechCooldownMap' has a wrong offset!");

// Class ReadyOrNot.SWATArmour
// 0x0040 (0x0A80 - 0x0A40)
class ASWATArmour : public ABaseArmour
{
public:
	EArmourCoverage                               MaxArmourCoverage;                                 // 0x0A40(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_293E[0x7];                                     // 0x0A41(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmourMaterial*                        CarrierMaterial;                                   // 0x0A48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalSlots;                                        // 0x0A50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultPrimaryAmmoSlots;                           // 0x0A54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultSecondaryAmmoSlots;                         // 0x0A58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultGrenadeSlots;                               // 0x0A5C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultTacticalDeviceSlots;                        // 0x0A60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArmourCoverage                               ArmourCoverage;                                    // 0x0A64(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_293F[0x3];                                     // 0x0A65(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmourMaterial*                        ArmourMaterial;                                    // 0x0A68(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<float>                                 Durabilities;                                      // 0x0A70(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SWATArmour">();
	}
	static class ASWATArmour* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASWATArmour>();
	}
};
static_assert(alignof(ASWATArmour) == 0x000010, "Wrong alignment on ASWATArmour");
static_assert(sizeof(ASWATArmour) == 0x000A80, "Wrong size on ASWATArmour");
static_assert(offsetof(ASWATArmour, MaxArmourCoverage) == 0x000A40, "Member 'ASWATArmour::MaxArmourCoverage' has a wrong offset!");
static_assert(offsetof(ASWATArmour, CarrierMaterial) == 0x000A48, "Member 'ASWATArmour::CarrierMaterial' has a wrong offset!");
static_assert(offsetof(ASWATArmour, TotalSlots) == 0x000A50, "Member 'ASWATArmour::TotalSlots' has a wrong offset!");
static_assert(offsetof(ASWATArmour, DefaultPrimaryAmmoSlots) == 0x000A54, "Member 'ASWATArmour::DefaultPrimaryAmmoSlots' has a wrong offset!");
static_assert(offsetof(ASWATArmour, DefaultSecondaryAmmoSlots) == 0x000A58, "Member 'ASWATArmour::DefaultSecondaryAmmoSlots' has a wrong offset!");
static_assert(offsetof(ASWATArmour, DefaultGrenadeSlots) == 0x000A5C, "Member 'ASWATArmour::DefaultGrenadeSlots' has a wrong offset!");
static_assert(offsetof(ASWATArmour, DefaultTacticalDeviceSlots) == 0x000A60, "Member 'ASWATArmour::DefaultTacticalDeviceSlots' has a wrong offset!");
static_assert(offsetof(ASWATArmour, ArmourCoverage) == 0x000A64, "Member 'ASWATArmour::ArmourCoverage' has a wrong offset!");
static_assert(offsetof(ASWATArmour, ArmourMaterial) == 0x000A68, "Member 'ASWATArmour::ArmourMaterial' has a wrong offset!");
static_assert(offsetof(ASWATArmour, Durabilities) == 0x000A70, "Member 'ASWATArmour::Durabilities' has a wrong offset!");

// Class ReadyOrNot.SwatAutomationManager
// 0x0030 (0x0250 - 0x0220)
class ASwatAutomationManager final  : public AInfo
{
public:
	uint8                                         Pad_2940[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADoor*>                          Doors;                                             // 0x0228(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          BreachedDoors;                                     // 0x0238(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class ADoor*                                  CurrentDoor;                                       // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwatAutomationManager">();
	}
	static class ASwatAutomationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASwatAutomationManager>();
	}
};
static_assert(alignof(ASwatAutomationManager) == 0x000008, "Wrong alignment on ASwatAutomationManager");
static_assert(sizeof(ASwatAutomationManager) == 0x000250, "Wrong size on ASwatAutomationManager");
static_assert(offsetof(ASwatAutomationManager, Doors) == 0x000228, "Member 'ASwatAutomationManager::Doors' has a wrong offset!");
static_assert(offsetof(ASwatAutomationManager, BreachedDoors) == 0x000238, "Member 'ASwatAutomationManager::BreachedDoors' has a wrong offset!");
static_assert(offsetof(ASwatAutomationManager, CurrentDoor) == 0x000248, "Member 'ASwatAutomationManager::CurrentDoor' has a wrong offset!");

// Class ReadyOrNot.SwatCommandEntryWidget
// 0x00C8 (0x0328 - 0x0260)
class USwatCommandEntryWidget : public UUserWidget
{
public:
	struct FSwatCommand                           SwatCommand;                                       // 0x0260(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	ETeamType                                     ActiveTeamType;                                    // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2941[0x3];                                     // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           RedTeamColor;                                      // 0x02C4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BlueTeamColor;                                     // 0x02D4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           GoldTeamColor;                                     // 0x02E4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLast;                                             // 0x02F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBack;                                             // 0x02F5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExtended;                                         // 0x02F6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2942[0x1];                                     // 0x02F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextWidget*                            CommandText;                                       // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            KeybindText;                                       // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                EntryBorder;                                       // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ExtendedImage;                                     // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BackIcon;                                          // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Flash;                                             // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwatCommandEntryWidget">();
	}
	static class USwatCommandEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwatCommandEntryWidget>();
	}
};
static_assert(alignof(USwatCommandEntryWidget) == 0x000008, "Wrong alignment on USwatCommandEntryWidget");
static_assert(sizeof(USwatCommandEntryWidget) == 0x000328, "Wrong size on USwatCommandEntryWidget");
static_assert(offsetof(USwatCommandEntryWidget, SwatCommand) == 0x000260, "Member 'USwatCommandEntryWidget::SwatCommand' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, ActiveTeamType) == 0x0002C0, "Member 'USwatCommandEntryWidget::ActiveTeamType' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, RedTeamColor) == 0x0002C4, "Member 'USwatCommandEntryWidget::RedTeamColor' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, BlueTeamColor) == 0x0002D4, "Member 'USwatCommandEntryWidget::BlueTeamColor' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, GoldTeamColor) == 0x0002E4, "Member 'USwatCommandEntryWidget::GoldTeamColor' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, bLast) == 0x0002F4, "Member 'USwatCommandEntryWidget::bLast' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, bBack) == 0x0002F5, "Member 'USwatCommandEntryWidget::bBack' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, bExtended) == 0x0002F6, "Member 'USwatCommandEntryWidget::bExtended' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, CommandText) == 0x0002F8, "Member 'USwatCommandEntryWidget::CommandText' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, KeybindText) == 0x000300, "Member 'USwatCommandEntryWidget::KeybindText' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, EntryBorder) == 0x000308, "Member 'USwatCommandEntryWidget::EntryBorder' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, ExtendedImage) == 0x000310, "Member 'USwatCommandEntryWidget::ExtendedImage' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, BackIcon) == 0x000318, "Member 'USwatCommandEntryWidget::BackIcon' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, Flash) == 0x000320, "Member 'USwatCommandEntryWidget::Flash' has a wrong offset!");

// Class ReadyOrNot.SwatCommandStatusWidget
// 0x0120 (0x0380 - 0x0260)
class USwatCommandStatusWidget : public UUserWidget
{
public:
	bool                                          bIsLead;                                           // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESquadPosition                                SquadPosition;                                     // 0x0261(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerHealthStatus                           PlayerHealthStatus;                                // 0x0262(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2943[0x1];                                     // 0x0263(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinHeight;                                         // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2944[0x4];                                     // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHorizontalBox*                         CurrentCommand_Box;                                // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           CommandStatus_Box;                                 // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            CurrentCommand_Text;                               // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            CurrentCommand_Pulse_Text;                         // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            CurrentCommand_Status_Text;                        // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               SizeBox;                                           // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           SwatInfo_Box;                                      // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SwatStats_Box;                                     // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            SwatName_Text;                                     // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               TeamIndicator_Box;                                 // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TeamIndicator_Image;                               // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               HealthStatus_SizeBox;                              // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            PlayerHealth_Text;                                 // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         IssueCommand_Hotkey_RichText;                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IssueCommand_Hotkey_Icon;                          // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_CommandCompleted;                             // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_CommandIssued;                                // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_CommandCompletedWhileAnotherQueued;           // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsProgress;                                       // 0x0300(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2945[0x3];                                     // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           RedTeamColor;                                      // 0x0304(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BlueTeamColor;                                     // 0x0314(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ElementTeamColor;                                  // 0x0324(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NormalColor;                                       // 0x0334(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           InjuredColor;                                      // 0x0344(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DeadColor;                                         // 0x0354(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2946[0x1C];                                    // 0x0364(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwatCommandStatusWidget">();
	}
	static class USwatCommandStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwatCommandStatusWidget>();
	}
};
static_assert(alignof(USwatCommandStatusWidget) == 0x000008, "Wrong alignment on USwatCommandStatusWidget");
static_assert(sizeof(USwatCommandStatusWidget) == 0x000380, "Wrong size on USwatCommandStatusWidget");
static_assert(offsetof(USwatCommandStatusWidget, bIsLead) == 0x000260, "Member 'USwatCommandStatusWidget::bIsLead' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, SquadPosition) == 0x000261, "Member 'USwatCommandStatusWidget::SquadPosition' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, PlayerHealthStatus) == 0x000262, "Member 'USwatCommandStatusWidget::PlayerHealthStatus' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, MinHeight) == 0x000264, "Member 'USwatCommandStatusWidget::MinHeight' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, MaxHeight) == 0x000268, "Member 'USwatCommandStatusWidget::MaxHeight' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, CurrentCommand_Box) == 0x000270, "Member 'USwatCommandStatusWidget::CurrentCommand_Box' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, CommandStatus_Box) == 0x000278, "Member 'USwatCommandStatusWidget::CommandStatus_Box' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, CurrentCommand_Text) == 0x000280, "Member 'USwatCommandStatusWidget::CurrentCommand_Text' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, CurrentCommand_Pulse_Text) == 0x000288, "Member 'USwatCommandStatusWidget::CurrentCommand_Pulse_Text' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, CurrentCommand_Status_Text) == 0x000290, "Member 'USwatCommandStatusWidget::CurrentCommand_Status_Text' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, SizeBox) == 0x000298, "Member 'USwatCommandStatusWidget::SizeBox' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, SwatInfo_Box) == 0x0002A0, "Member 'USwatCommandStatusWidget::SwatInfo_Box' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, SwatStats_Box) == 0x0002A8, "Member 'USwatCommandStatusWidget::SwatStats_Box' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, SwatName_Text) == 0x0002B0, "Member 'USwatCommandStatusWidget::SwatName_Text' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, TeamIndicator_Box) == 0x0002B8, "Member 'USwatCommandStatusWidget::TeamIndicator_Box' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, TeamIndicator_Image) == 0x0002C0, "Member 'USwatCommandStatusWidget::TeamIndicator_Image' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, HealthStatus_SizeBox) == 0x0002C8, "Member 'USwatCommandStatusWidget::HealthStatus_SizeBox' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, PlayerHealth_Text) == 0x0002D0, "Member 'USwatCommandStatusWidget::PlayerHealth_Text' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, IssueCommand_Hotkey_RichText) == 0x0002D8, "Member 'USwatCommandStatusWidget::IssueCommand_Hotkey_RichText' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, IssueCommand_Hotkey_Icon) == 0x0002E0, "Member 'USwatCommandStatusWidget::IssueCommand_Hotkey_Icon' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, Anim_CommandCompleted) == 0x0002E8, "Member 'USwatCommandStatusWidget::Anim_CommandCompleted' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, Anim_CommandIssued) == 0x0002F0, "Member 'USwatCommandStatusWidget::Anim_CommandIssued' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, Anim_CommandCompletedWhileAnotherQueued) == 0x0002F8, "Member 'USwatCommandStatusWidget::Anim_CommandCompletedWhileAnotherQueued' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, bIsProgress) == 0x000300, "Member 'USwatCommandStatusWidget::bIsProgress' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, RedTeamColor) == 0x000304, "Member 'USwatCommandStatusWidget::RedTeamColor' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, BlueTeamColor) == 0x000314, "Member 'USwatCommandStatusWidget::BlueTeamColor' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, ElementTeamColor) == 0x000324, "Member 'USwatCommandStatusWidget::ElementTeamColor' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, NormalColor) == 0x000334, "Member 'USwatCommandStatusWidget::NormalColor' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, InjuredColor) == 0x000344, "Member 'USwatCommandStatusWidget::InjuredColor' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, DeadColor) == 0x000354, "Member 'USwatCommandStatusWidget::DeadColor' has a wrong offset!");

// Class ReadyOrNot.SwatCommandWidget
// 0x0410 (0x0670 - 0x0260)
class USwatCommandWidget : public UUserWidget
{
public:
	uint8                                         Pad_2947[0x10];                                    // 0x0260(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DirectoryStringOverride;                           // 0x0270(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DirectoryString;                                   // 0x0280(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 LastActorBeforeGoingIntoSubPage;                   // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2948[0x4];                                     // 0x0298(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastSubCommandPageIndex;                           // 0x029C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSwatCommand>                   ParentCommands;                                    // 0x02A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSwatCommand>                   ActiveCommandPage;                                 // 0x02B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSwatCommand>                   PreviousActiveCommandPage;                         // 0x02C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FKey>                           CommandCombo;                                      // 0x02D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	ETeamType                                     ActiveTeamType;                                    // 0x02E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeamType                                     PreviousActiveTeamType;                            // 0x02E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeamType                                     OverrideActiveTeamType;                            // 0x02E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bOverrideActiveTeamType : 1;                       // 0x02E3(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	ETeamType                                     ExecutionTeamType;                                 // 0x02E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESwatCommand                                  DefaultDoorOpenCommand;                            // 0x02E5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESwatCommand                                  DefaultDoorUnknownCommand;                         // 0x02E6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESwatCommand                                  DefaultCheckDoorCommand;                           // 0x02E7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESwatCommand                                  DefaultDoorLockedCommand;                          // 0x02E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESwatCommand                                  DefaultDoorUnlockedCommand;                        // 0x02E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2949[0x8E];                                    // 0x02EA(0x008E)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LastContextActor;                                  // 0x0378(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             ContextualData;                                    // 0x0380(0x0088)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_294A[0x88];                                    // 0x0408(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             LastExecutedCommandContextualData;                 // 0x0490(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UFMODEvent*                             OpenMenuEvent;                                     // 0x0518(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             OpenSubCommandMenuEvent;                           // 0x0520(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             ExecuteCommandEvent;                               // 0x0528(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABaseGrenade>               Flashbang;                                         // 0x0530(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABaseGrenade>               Stinger;                                           // 0x0538(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABaseGrenade>               CSGas;                                             // 0x0540(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHoldingQueueCommandKey : 1;                       // 0x0548(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_294B[0x7];                                     // 0x0549(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USizeBox*                               SizeBox;                                           // 0x0550(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_Commands;                                       // 0x0558(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_Queue;                                          // 0x0560(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_SwatCommand;                                    // 0x0568(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_1;                                // 0x0570(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_2;                                // 0x0578(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_3;                                // 0x0580(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_4;                                // 0x0588(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_5;                                // 0x0590(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_6;                                // 0x0598(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_7;                                // 0x05A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_8;                                // 0x05A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_9;                                // 0x05B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_10;                               // 0x05B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandIssued;                                 // 0x05C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                Back;                                              // 0x05C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            Txt_QueueBinding;                                  // 0x05D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            Txt_QueueStatus;                                   // 0x05D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            CommandDirectoryText;                              // 0x05E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DivTop;                                            // 0x05E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DivBottom;                                         // 0x05F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           RedTeamColor;                                      // 0x05F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BlueTeamColor;                                     // 0x0608(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           GoldTeamColor;                                     // 0x0618(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294C[0x48];                                    // 0x0628(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoCommand(const struct FSwatCommand& Command, bool bFromQueue, ETeamType ActiveTeamOverride, const struct FHitResult& ContextualDataOverride, bool bOverrideContextualData);
	bool GetSubCommands(const struct FSwatCommand& Command, TArray<struct FSwatCommand>* OutSubCommands);
	void InitEntryWidget(class USwatCommandEntryWidget* Entry, struct FSwatCommand& InSwatCommand, ETeamType Team, bool bLast);
	void OnClose();
	void OnCommandIssued(int32 Param_Index, struct FSwatCommand& Command, bool bFromDefault);
	void OnInputKey();
	void OnOpen();
	void OnPageViewUpdateBP();
	void OnPostUpdateSwatCommands__DelegateSignature(class USwatCommandWidget* Widget, TArray<struct FSwatCommand>* SwatCommands);
	void OnSwatCommandIssued__DelegateSignature(ESwatCommand SwatCommand, ETeamType TeamType, class AActor* ContextActor);
	void OnSwatCommandQueued__DelegateSignature(const struct FQueuedSwatCommand& QueuedSwatCommand, ETeamType TeamType);
	void OnSwatElementChanged__DelegateSignature(ETeamType TeamType);

	struct FKey ConvertIntToInputKey(int32 Int) const;
	ETeamType GetActiveTeam() const;
	struct FKey GetCommandInput(class FName InName) const;
	struct FKey GetInputBack() const;
	struct FKey GetInputEight() const;
	struct FKey GetInputFive() const;
	struct FKey GetInputFour() const;
	struct FKey GetInputNine() const;
	struct FKey GetInputOne() const;
	struct FKey GetInputSeven() const;
	struct FKey GetInputSix() const;
	struct FKey GetInputThree() const;
	struct FKey GetInputTwo() const;
	bool HasQueuedCommandForActiveTeam() const;
	bool HasQueuedCommandForTeam(ETeamType TeamType) const;
	class USwatCommandEntryWidget* IndexToEntryWidget(uint8 Param_Index) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwatCommandWidget">();
	}
	static class USwatCommandWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwatCommandWidget>();
	}
};
static_assert(alignof(USwatCommandWidget) == 0x000008, "Wrong alignment on USwatCommandWidget");
static_assert(sizeof(USwatCommandWidget) == 0x000670, "Wrong size on USwatCommandWidget");
static_assert(offsetof(USwatCommandWidget, DirectoryStringOverride) == 0x000270, "Member 'USwatCommandWidget::DirectoryStringOverride' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, DirectoryString) == 0x000280, "Member 'USwatCommandWidget::DirectoryString' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, LastActorBeforeGoingIntoSubPage) == 0x000290, "Member 'USwatCommandWidget::LastActorBeforeGoingIntoSubPage' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, LastSubCommandPageIndex) == 0x00029C, "Member 'USwatCommandWidget::LastSubCommandPageIndex' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, ParentCommands) == 0x0002A0, "Member 'USwatCommandWidget::ParentCommands' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, ActiveCommandPage) == 0x0002B0, "Member 'USwatCommandWidget::ActiveCommandPage' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, PreviousActiveCommandPage) == 0x0002C0, "Member 'USwatCommandWidget::PreviousActiveCommandPage' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, CommandCombo) == 0x0002D0, "Member 'USwatCommandWidget::CommandCombo' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, ActiveTeamType) == 0x0002E0, "Member 'USwatCommandWidget::ActiveTeamType' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, PreviousActiveTeamType) == 0x0002E1, "Member 'USwatCommandWidget::PreviousActiveTeamType' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, OverrideActiveTeamType) == 0x0002E2, "Member 'USwatCommandWidget::OverrideActiveTeamType' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, ExecutionTeamType) == 0x0002E4, "Member 'USwatCommandWidget::ExecutionTeamType' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, DefaultDoorOpenCommand) == 0x0002E5, "Member 'USwatCommandWidget::DefaultDoorOpenCommand' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, DefaultDoorUnknownCommand) == 0x0002E6, "Member 'USwatCommandWidget::DefaultDoorUnknownCommand' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, DefaultCheckDoorCommand) == 0x0002E7, "Member 'USwatCommandWidget::DefaultCheckDoorCommand' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, DefaultDoorLockedCommand) == 0x0002E8, "Member 'USwatCommandWidget::DefaultDoorLockedCommand' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, DefaultDoorUnlockedCommand) == 0x0002E9, "Member 'USwatCommandWidget::DefaultDoorUnlockedCommand' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, LastContextActor) == 0x000378, "Member 'USwatCommandWidget::LastContextActor' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, ContextualData) == 0x000380, "Member 'USwatCommandWidget::ContextualData' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, LastExecutedCommandContextualData) == 0x000490, "Member 'USwatCommandWidget::LastExecutedCommandContextualData' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, OpenMenuEvent) == 0x000518, "Member 'USwatCommandWidget::OpenMenuEvent' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, OpenSubCommandMenuEvent) == 0x000520, "Member 'USwatCommandWidget::OpenSubCommandMenuEvent' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, ExecuteCommandEvent) == 0x000528, "Member 'USwatCommandWidget::ExecuteCommandEvent' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, Flashbang) == 0x000530, "Member 'USwatCommandWidget::Flashbang' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, Stinger) == 0x000538, "Member 'USwatCommandWidget::Stinger' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, CSGas) == 0x000540, "Member 'USwatCommandWidget::CSGas' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SizeBox) == 0x000550, "Member 'USwatCommandWidget::SizeBox' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, VB_Commands) == 0x000558, "Member 'USwatCommandWidget::VB_Commands' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, VB_Queue) == 0x000560, "Member 'USwatCommandWidget::VB_Queue' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, VB_SwatCommand) == 0x000568, "Member 'USwatCommandWidget::VB_SwatCommand' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_1) == 0x000570, "Member 'USwatCommandWidget::SwatCommandEntry_1' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_2) == 0x000578, "Member 'USwatCommandWidget::SwatCommandEntry_2' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_3) == 0x000580, "Member 'USwatCommandWidget::SwatCommandEntry_3' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_4) == 0x000588, "Member 'USwatCommandWidget::SwatCommandEntry_4' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_5) == 0x000590, "Member 'USwatCommandWidget::SwatCommandEntry_5' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_6) == 0x000598, "Member 'USwatCommandWidget::SwatCommandEntry_6' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_7) == 0x0005A0, "Member 'USwatCommandWidget::SwatCommandEntry_7' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_8) == 0x0005A8, "Member 'USwatCommandWidget::SwatCommandEntry_8' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_9) == 0x0005B0, "Member 'USwatCommandWidget::SwatCommandEntry_9' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_10) == 0x0005B8, "Member 'USwatCommandWidget::SwatCommandEntry_10' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandIssued) == 0x0005C0, "Member 'USwatCommandWidget::SwatCommandIssued' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, Back) == 0x0005C8, "Member 'USwatCommandWidget::Back' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, Txt_QueueBinding) == 0x0005D0, "Member 'USwatCommandWidget::Txt_QueueBinding' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, Txt_QueueStatus) == 0x0005D8, "Member 'USwatCommandWidget::Txt_QueueStatus' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, CommandDirectoryText) == 0x0005E0, "Member 'USwatCommandWidget::CommandDirectoryText' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, DivTop) == 0x0005E8, "Member 'USwatCommandWidget::DivTop' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, DivBottom) == 0x0005F0, "Member 'USwatCommandWidget::DivBottom' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, RedTeamColor) == 0x0005F8, "Member 'USwatCommandWidget::RedTeamColor' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, BlueTeamColor) == 0x000608, "Member 'USwatCommandWidget::BlueTeamColor' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, GoldTeamColor) == 0x000618, "Member 'USwatCommandWidget::GoldTeamColor' has a wrong offset!");

// Class ReadyOrNot.SWATManager
// 0x0AE0 (0x0B20 - 0x0040)
class USWATManager final  : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_2957[0x88];                                    // 0x0040(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASWATCharacter*>                 SwatAI;                                            // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ATrailerSWATCharacter*>          SwatTrailers;                                      // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class ASWATCharacter*                         ClosestFallInSwat;                                 // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class ASWATCharacter*, float>            FallInSwat_PathFound;                              // 0x00F0(0x0050)(NativeAccessSpecifierPublic)
	TArray<class ASWATCharacter*>                 FallInSwat;                                        // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ASWATCharacter*>                 FallInSwat_FileA;                                  // 0x0150(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ASWATCharacter*>                 FallInSwat_FileB;                                  // 0x0160(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ASWATCharacter*>                 FallInSwat_Diamond;                                // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ETeamType, struct FClearQueueInfo>       ClearingQueue;                                     // 0x0180(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FIntVector, class ASWATCharacter*> OccupiedLookAtPoints;                              // 0x01D0(0x0050)(NativeAccessSpecifierPublic)
	TMap<class AActor*, class FString>            CallOutQueue;                                      // 0x0220(0x0050)(NativeAccessSpecifierPublic)
	TArray<class AActor*>                         CallOutHistory;                                    // 0x0270(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class AActor*, class ASWATCharacter*>    ReportQueue;                                       // 0x0280(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_2958[0x7E8];                                   // 0x02D0(0x07E8)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   SquadLeader;                                       // 0x0AB8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ETeamType, struct FQueuedSwatCommand>    QueuedSwatCommandMap;                              // 0x0AC0(0x0050)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ESwatCommand                                  CurrentDefaultCommand;                             // 0x0B10(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     ActiveCommandTeam;                                 // 0x0B11(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2959[0xE];                                     // 0x0B12(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class ASWATCharacter*> GetSWATSortedByDistanceToLocation(const struct FVector& Location, ETeamType FilterTeam, class ADoor* StackUpDoor, bool bAscendingOrder);
	TArray<class ASWATCharacter*> GetSWATSortedByDistanceToLocationV2(const struct FVector& Location, const TArray<class ASWATCharacter*>& ExcludedSwat, ETeamType FilterTeam, bool bAscendingOrder);
	void GiveBreachAndClearCommand(class ADoor* Door, EDoorBreachType DoorBreachType, ETeamType TeamType, const struct FVector& CommandLocation, TSubclassOf<class ABaseItem> DoorBreachItemClass, TSubclassOf<class ABaseItem> DoorUseItemClass, bool bWithLeader, bool bWithLeaderItem, bool bAutoClear, bool bLastAutoClear, EStackUpStyle CustomStackUpStyle);
	void GiveCheckForContactsCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation, const struct FVector& CommandNormal);
	void GiveCheckForTrapsCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation, const struct FVector& CommandNormal);
	void GiveCloseDoorCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation);
	void GiveCollectEvidenceCommand(class AActor* Target, ETeamType TeamType);
	void GiveCoverAreaCommand(ETeamType TeamType, const struct FVector& CommandLocation);
	void GiveDeployGrenadeAtLocation(ETeamType TeamType, const struct FVector& CommandLocation, TSubclassOf<class ABaseGrenade> Grenade);
	void GiveDeployNonLethalItemAtTargetCommand(class AReadyOrNotCharacter* Target, ETeamType TeamType, EItemCategory Item);
	void GiveDeployShield(ETeamType TeamType);
	void GiveDisarmStandaloneTrapCommand(class AActor* Target, ETeamType TeamType);
	void GiveDisarmTrapOnDoorCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation);
	void GiveDropChemlightAtLocation(ETeamType TeamType, const struct FVector& CommandLocation);
	void GiveFallInCommand(ETeamType TeamType, EFallInPattern FallInPattern);
	void GiveHoldCommand(ETeamType TeamType);
	void GiveMoveCommand(ETeamType TeamType, const struct FVector& CommandLocation);
	void GiveOpenDoorCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation);
	void GivePickLockCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation);
	void GiveRemoveWedgeCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation, const struct FVector& CommandNormal);
	void GiveReportTargetCommand(class AActor* Target, ETeamType TeamType);
	void GiveRestrainCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation);
	void GiveScanDoorCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation, EDoorScanMethod ScanMethod);
	void GiveSearchAndSecureCommand(ETeamType TeamType, const struct FVector& CommandLocation, bool bOnlyCurrentRoom);
	void GiveSearchAndSecureCommand_Individual(class AActor* Target, const struct FVector& CommandLocation, bool bOnlyCurrentRoom);
	void GiveStackUpCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation, const struct FVector& CommandNormal, bool bCheckDoor, EStackUpStyle StackUpStyle);
	void GiveWedgeDoorCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation, const struct FVector& CommandNormal);
	void OnActivityStarted(class UBaseActivity* Activity, class ACyberneticController* OwningController);
	void OnLeaderToggledNightvision(class AReadyOrNotCharacter* Character, bool bOn);
	void OnSwatFinishedClearing(class UTeamBreachAndClearActivity* BreachAndClearActivity, bool bAuto);
	void OnSwatFinishedRoomSearch(class USearchAndSecureActivity* SearchAndSecureActivity, class ADoor* BreachedDoor);
	void OnTrailerSearchComplete(class UBaseActivity* Activity, class ACyberneticController* Controller);
	void PlaySwatCommandVoiceLine(const class FString& VoiceLine, const class FString& OverrideSpearkerName, bool bTeamPrefix);
	void RemoveHoldCommand(ETeamType TeamType);

	bool CanGiveActivityToSWAT(class ASWATCharacter* Swat, ETeamType Team) const;
	struct FVector GetAverageSwatLocation() const;
	ESwatCommand GetQueuedSwatCommandForSquadPosition(ESquadPosition SquadPosition) const;
	class AReadyOrNotCharacter* GetSquadLeader() const;
	class ASWATCharacter* GetSwatCharacterAtSquadPosition(ESquadPosition InSquadPosition) const;
	uint8 GetSWATCount() const;
	TArray<class ASWATCharacter*> GetSwatTeam() const;
	bool IsCharacterKnownEnemy(class AReadyOrNotCharacter* InCharacter) const;
	bool IsSWATTeamDead(ETeamType Team) const;
	bool IsSWATTeamHoldingPosition(ETeamType Team) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SWATManager">();
	}
	static class USWATManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USWATManager>();
	}
};
static_assert(alignof(USWATManager) == 0x000008, "Wrong alignment on USWATManager");
static_assert(sizeof(USWATManager) == 0x000B20, "Wrong size on USWATManager");
static_assert(offsetof(USWATManager, SwatAI) == 0x0000C8, "Member 'USWATManager::SwatAI' has a wrong offset!");
static_assert(offsetof(USWATManager, SwatTrailers) == 0x0000D8, "Member 'USWATManager::SwatTrailers' has a wrong offset!");
static_assert(offsetof(USWATManager, ClosestFallInSwat) == 0x0000E8, "Member 'USWATManager::ClosestFallInSwat' has a wrong offset!");
static_assert(offsetof(USWATManager, FallInSwat_PathFound) == 0x0000F0, "Member 'USWATManager::FallInSwat_PathFound' has a wrong offset!");
static_assert(offsetof(USWATManager, FallInSwat) == 0x000140, "Member 'USWATManager::FallInSwat' has a wrong offset!");
static_assert(offsetof(USWATManager, FallInSwat_FileA) == 0x000150, "Member 'USWATManager::FallInSwat_FileA' has a wrong offset!");
static_assert(offsetof(USWATManager, FallInSwat_FileB) == 0x000160, "Member 'USWATManager::FallInSwat_FileB' has a wrong offset!");
static_assert(offsetof(USWATManager, FallInSwat_Diamond) == 0x000170, "Member 'USWATManager::FallInSwat_Diamond' has a wrong offset!");
static_assert(offsetof(USWATManager, ClearingQueue) == 0x000180, "Member 'USWATManager::ClearingQueue' has a wrong offset!");
static_assert(offsetof(USWATManager, OccupiedLookAtPoints) == 0x0001D0, "Member 'USWATManager::OccupiedLookAtPoints' has a wrong offset!");
static_assert(offsetof(USWATManager, CallOutQueue) == 0x000220, "Member 'USWATManager::CallOutQueue' has a wrong offset!");
static_assert(offsetof(USWATManager, CallOutHistory) == 0x000270, "Member 'USWATManager::CallOutHistory' has a wrong offset!");
static_assert(offsetof(USWATManager, ReportQueue) == 0x000280, "Member 'USWATManager::ReportQueue' has a wrong offset!");
static_assert(offsetof(USWATManager, SquadLeader) == 0x000AB8, "Member 'USWATManager::SquadLeader' has a wrong offset!");
static_assert(offsetof(USWATManager, QueuedSwatCommandMap) == 0x000AC0, "Member 'USWATManager::QueuedSwatCommandMap' has a wrong offset!");
static_assert(offsetof(USWATManager, CurrentDefaultCommand) == 0x000B10, "Member 'USWATManager::CurrentDefaultCommand' has a wrong offset!");
static_assert(offsetof(USWATManager, ActiveCommandTeam) == 0x000B11, "Member 'USWATManager::ActiveCommandTeam' has a wrong offset!");

// Class ReadyOrNot.SwatTeamStatusWidget
// 0x00A8 (0x0308 - 0x0260)
class USwatTeamStatusWidget : public UUserWidget
{
public:
	class UVerticalBox*                           SWAT_Status_Container;                             // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandStatusWidget*               SWAT_Alpha_Status;                                 // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandStatusWidget*               SWAT_Beta_Status;                                  // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandStatusWidget*               SWAT_Charlie_Status;                               // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandStatusWidget*               SWAT_Delta_Status;                                 // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandStatusWidget*               SWAT_Lead_Status;                                  // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseActivity*                          AlphaActivity;                                     // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseActivity*                          BetaActivity;                                      // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseActivity*                          CharlieActivity;                                   // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseActivity*                          DeltaActivity;                                     // 0x02A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseActivity*                          LeadActivity;                                      // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ESquadPosition, class ASWATCharacter*>   InitialSquadMap;                                   // 0x02B8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnDefaultCommandIssued(class APlayerCharacter* Issuer, ESwatCommand CommandIssued);
	void UpdateStatus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwatTeamStatusWidget">();
	}
	static class USwatTeamStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwatTeamStatusWidget>();
	}
};
static_assert(alignof(USwatTeamStatusWidget) == 0x000008, "Wrong alignment on USwatTeamStatusWidget");
static_assert(sizeof(USwatTeamStatusWidget) == 0x000308, "Wrong size on USwatTeamStatusWidget");
static_assert(offsetof(USwatTeamStatusWidget, SWAT_Status_Container) == 0x000260, "Member 'USwatTeamStatusWidget::SWAT_Status_Container' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, SWAT_Alpha_Status) == 0x000268, "Member 'USwatTeamStatusWidget::SWAT_Alpha_Status' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, SWAT_Beta_Status) == 0x000270, "Member 'USwatTeamStatusWidget::SWAT_Beta_Status' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, SWAT_Charlie_Status) == 0x000278, "Member 'USwatTeamStatusWidget::SWAT_Charlie_Status' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, SWAT_Delta_Status) == 0x000280, "Member 'USwatTeamStatusWidget::SWAT_Delta_Status' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, SWAT_Lead_Status) == 0x000288, "Member 'USwatTeamStatusWidget::SWAT_Lead_Status' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, AlphaActivity) == 0x000290, "Member 'USwatTeamStatusWidget::AlphaActivity' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, BetaActivity) == 0x000298, "Member 'USwatTeamStatusWidget::BetaActivity' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, CharlieActivity) == 0x0002A0, "Member 'USwatTeamStatusWidget::CharlieActivity' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, DeltaActivity) == 0x0002A8, "Member 'USwatTeamStatusWidget::DeltaActivity' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, LeadActivity) == 0x0002B0, "Member 'USwatTeamStatusWidget::LeadActivity' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, InitialSquadMap) == 0x0002B8, "Member 'USwatTeamStatusWidget::InitialSquadMap' has a wrong offset!");

// Class ReadyOrNot.Tablet
// 0x0050 (0x0A20 - 0x09D0)
class ATablet : public ABaseItem
{
public:
	uint8                                         Pad_2983[0x10];                                    // 0x09D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetComponent*                       WidgetComponent;                                   // 0x09E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTabletAwake;                                    // 0x09E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2984[0x3];                                     // 0x09E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FocusedCameraRotation;                             // 0x09EC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               FocusedItemRotation;                               // 0x09F8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FocusedMinimumHorizontalFov;                       // 0x0A04(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusedTargetVerticalFov;                          // 0x0A08(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TabletFocusInterpSpeed;                            // 0x0A0C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2985[0x10];                                    // 0x0A10(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMissionSelected();
	void PlayNotificationEvent();
	void PlaySoundEvent(class UFMODEvent* Event);
	void PlayVibrationEvent();
	void SleepScreen();
	void WakeScreen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tablet">();
	}
	static class ATablet* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATablet>();
	}
};
static_assert(alignof(ATablet) == 0x000010, "Wrong alignment on ATablet");
static_assert(sizeof(ATablet) == 0x000A20, "Wrong size on ATablet");
static_assert(offsetof(ATablet, WidgetComponent) == 0x0009E0, "Member 'ATablet::WidgetComponent' has a wrong offset!");
static_assert(offsetof(ATablet, bIsTabletAwake) == 0x0009E8, "Member 'ATablet::bIsTabletAwake' has a wrong offset!");
static_assert(offsetof(ATablet, FocusedCameraRotation) == 0x0009EC, "Member 'ATablet::FocusedCameraRotation' has a wrong offset!");
static_assert(offsetof(ATablet, FocusedItemRotation) == 0x0009F8, "Member 'ATablet::FocusedItemRotation' has a wrong offset!");
static_assert(offsetof(ATablet, FocusedMinimumHorizontalFov) == 0x000A04, "Member 'ATablet::FocusedMinimumHorizontalFov' has a wrong offset!");
static_assert(offsetof(ATablet, FocusedTargetVerticalFov) == 0x000A08, "Member 'ATablet::FocusedTargetVerticalFov' has a wrong offset!");
static_assert(offsetof(ATablet, TabletFocusInterpSpeed) == 0x000A0C, "Member 'ATablet::TabletFocusInterpSpeed' has a wrong offset!");

// Class ReadyOrNot.TableTennisPlayer
// 0x0010 (0x0230 - 0x0220)
class ATableTennisPlayer final  : public AActor
{
public:
	class ATableTennisMachine*                    TargetGame;                                        // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2986[0x8];                                     // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_SetPosition(float NewPosition);
	void Server_StopPlaying();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TableTennisPlayer">();
	}
	static class ATableTennisPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATableTennisPlayer>();
	}
};
static_assert(alignof(ATableTennisPlayer) == 0x000008, "Wrong alignment on ATableTennisPlayer");
static_assert(sizeof(ATableTennisPlayer) == 0x000230, "Wrong size on ATableTennisPlayer");
static_assert(offsetof(ATableTennisPlayer, TargetGame) == 0x000220, "Member 'ATableTennisPlayer::TargetGame' has a wrong offset!");

// Class ReadyOrNot.TableTennisMachine
// 0x00B0 (0x02D0 - 0x0220)
class ATableTennisMachine final  : public AActor
{
public:
	uint8                                         Pad_2987[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GameRenderDistance;                                // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxScore;                                          // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTableTennisGame                       Game;                                              // 0x0230(0x0034)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2988[0x4];                                     // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ATableTennisPlayer*                     LeftPlayer;                                        // 0x0268(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATableTennisPlayer*                     RightPlayer;                                       // 0x0270(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 GameRenderTarget;                                  // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHasInsertedCoin : 1;                              // 0x0280(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2989[0x7];                                     // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 LeftPlayerInteractable;                            // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 RightPlayerInteractable;                           // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InsertCoinInteractable;                            // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             NumberTexture;                                     // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BackgroundTexture;                                 // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StartTexture;                                      // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ReadyTexture;                                      // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             InsertCoinTexture;                                 // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             GameOverTexture;                                   // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCoinInserted();
	void OnLeftPaddleHit();
	void OnRightPaddleHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TableTennisMachine">();
	}
	static class ATableTennisMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATableTennisMachine>();
	}
};
static_assert(alignof(ATableTennisMachine) == 0x000008, "Wrong alignment on ATableTennisMachine");
static_assert(sizeof(ATableTennisMachine) == 0x0002D0, "Wrong size on ATableTennisMachine");
static_assert(offsetof(ATableTennisMachine, GameRenderDistance) == 0x000228, "Member 'ATableTennisMachine::GameRenderDistance' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, MaxScore) == 0x00022C, "Member 'ATableTennisMachine::MaxScore' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, Game) == 0x000230, "Member 'ATableTennisMachine::Game' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, LeftPlayer) == 0x000268, "Member 'ATableTennisMachine::LeftPlayer' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, RightPlayer) == 0x000270, "Member 'ATableTennisMachine::RightPlayer' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, GameRenderTarget) == 0x000278, "Member 'ATableTennisMachine::GameRenderTarget' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, LeftPlayerInteractable) == 0x000288, "Member 'ATableTennisMachine::LeftPlayerInteractable' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, RightPlayerInteractable) == 0x000290, "Member 'ATableTennisMachine::RightPlayerInteractable' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, InsertCoinInteractable) == 0x000298, "Member 'ATableTennisMachine::InsertCoinInteractable' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, NumberTexture) == 0x0002A0, "Member 'ATableTennisMachine::NumberTexture' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, BackgroundTexture) == 0x0002A8, "Member 'ATableTennisMachine::BackgroundTexture' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, StartTexture) == 0x0002B0, "Member 'ATableTennisMachine::StartTexture' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, ReadyTexture) == 0x0002B8, "Member 'ATableTennisMachine::ReadyTexture' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, InsertCoinTexture) == 0x0002C0, "Member 'ATableTennisMachine::InsertCoinTexture' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, GameOverTexture) == 0x0002C8, "Member 'ATableTennisMachine::GameOverTexture' has a wrong offset!");

// Class ReadyOrNot.TabletWidget
// 0x0010 (0x0340 - 0x0330)
class UTabletWidget : public UMissionPlanWidget
{
public:
	class UTeamViewWidget*                        TeamView;                                          // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        ScreenSwitcher;                                    // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	int32 GetActiveButton(int32 CurrentIndex, int32 NavigationDirection, const TArray<bool>& buttonVisibilities);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabletWidget">();
	}
	static class UTabletWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabletWidget>();
	}
};
static_assert(alignof(UTabletWidget) == 0x000008, "Wrong alignment on UTabletWidget");
static_assert(sizeof(UTabletWidget) == 0x000340, "Wrong size on UTabletWidget");
static_assert(offsetof(UTabletWidget, TeamView) == 0x000330, "Member 'UTabletWidget::TeamView' has a wrong offset!");
static_assert(offsetof(UTabletWidget, ScreenSwitcher) == 0x000338, "Member 'UTabletWidget::ScreenSwitcher' has a wrong offset!");

// Class ReadyOrNot.TacticalSlot_V2
// 0x0000 (0x0288 - 0x0288)
class UTacticalSlot_V2 final  : public UCommonUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TacticalSlot_V2">();
	}
	static class UTacticalSlot_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTacticalSlot_V2>();
	}
};
static_assert(alignof(UTacticalSlot_V2) == 0x000008, "Wrong alignment on UTacticalSlot_V2");
static_assert(sizeof(UTacticalSlot_V2) == 0x000288, "Wrong size on UTacticalSlot_V2");

// Class ReadyOrNot.TakeCoverActivity
// 0x01D8 (0x0380 - 0x01A8)
class UTakeCoverActivity final  : public UBaseActivity
{
public:
	uint8                                         Pad_298B[0x10];                                    // 0x01A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxCoverFireCount;                                 // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverFireTimeCooldown;                             // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverFireCooldown;                                 // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_298C[0xC];                                     // 0x01C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoverInstigatorStimulus               InstigatorStimulus;                                // 0x01D0(0x0050)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_298D[0xA0];                                    // 0x0220(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  Door;                                              // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           LastExitMontagePlayed;                             // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           EntryMontage;                                      // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298E[0xA8];                                    // 0x02D8(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterCompleteAbruptState();
	void EnterCompleteState();
	void EnterCoverFireState();
	void EnterCoverState();
	void EnterMoveToCoverState();
	void ExitCoverFireState();
	void ExitCoverState();
	void OnEnemyWeaponFire(class AReadyOrNotCharacter* Character, class ABaseMagazineWeapon* Weapon, const struct FVector& FireDirection);
	void OnEnteredCover__DelegateSignature();
	void OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void TickCoverFireState(float DeltaTime, float Uptime);
	void TickCoverState(float DeltaTime, float Uptime);
	void TickMoveToCoverState(float DeltaTime, float Uptime);

	bool CanAbruptCompleteCover() const;
	bool CanCompleteCover() const;
	bool CanCover() const;
	bool CanFireFromCover() const;
	bool CanStopCoverFire() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TakeCoverActivity">();
	}
	static class UTakeCoverActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTakeCoverActivity>();
	}
};
static_assert(alignof(UTakeCoverActivity) == 0x000010, "Wrong alignment on UTakeCoverActivity");
static_assert(sizeof(UTakeCoverActivity) == 0x000380, "Wrong size on UTakeCoverActivity");
static_assert(offsetof(UTakeCoverActivity, MaxCoverFireCount) == 0x0001B8, "Member 'UTakeCoverActivity::MaxCoverFireCount' has a wrong offset!");
static_assert(offsetof(UTakeCoverActivity, CoverFireTimeCooldown) == 0x0001BC, "Member 'UTakeCoverActivity::CoverFireTimeCooldown' has a wrong offset!");
static_assert(offsetof(UTakeCoverActivity, CoverFireCooldown) == 0x0001C0, "Member 'UTakeCoverActivity::CoverFireCooldown' has a wrong offset!");
static_assert(offsetof(UTakeCoverActivity, InstigatorStimulus) == 0x0001D0, "Member 'UTakeCoverActivity::InstigatorStimulus' has a wrong offset!");
static_assert(offsetof(UTakeCoverActivity, Door) == 0x0002C0, "Member 'UTakeCoverActivity::Door' has a wrong offset!");
static_assert(offsetof(UTakeCoverActivity, LastExitMontagePlayed) == 0x0002C8, "Member 'UTakeCoverActivity::LastExitMontagePlayed' has a wrong offset!");
static_assert(offsetof(UTakeCoverActivity, EntryMontage) == 0x0002D0, "Member 'UTakeCoverActivity::EntryMontage' has a wrong offset!");

// Class ReadyOrNot.TakeCoverAtLandmarkActivity
// 0x0068 (0x0210 - 0x01A8)
class UTakeCoverAtLandmarkActivity final  : public UBaseActivity
{
public:
	class ACoverLandmark*                         CoverLandmark;                                     // 0x01A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACoverLandmarkProxy*                    ChosenEntryProxy;                                  // 0x01B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACoverLandmarkProxy*                    ChosenExitProxy;                                   // 0x01B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchRadius;                                      // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2991[0x1C];                                    // 0x01C4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           EntryAnim;                                         // 0x01E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ExitAnim;                                          // 0x01E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           LoopEntryAnim;                                     // 0x01F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           LoopExitAnim;                                      // 0x01F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AStaticMeshActor*>               IgnoredMeshActors;                                 // 0x0200(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void Enter_AbruptExit_State();
	void Enter_EnterLandmark_State();
	void Enter_ExitLandmark_State();
	void Enter_Wait_State();
	void EnterMoveToLandmarkState();
	void OnEnemyWeaponFire(class AReadyOrNotCharacter* Character, class ABaseMagazineWeapon* Weapon, const struct FVector& FireDirection);
	void OnHeardYell(class AReadyOrNotCharacter* Shouter, bool bLOS);
	void OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void Tick_AbruptExit_State(float DeltaTime, float Uptime);
	void Tick_EnterLandmark_State(float DeltaTime, float Uptime);
	void Tick_ExitLandmark_State(float DeltaTime, float Uptime);
	void Tick_Wait_State(float DeltaTime, float Uptime);
	void TickMoveToLandmarkState(float DeltaTime, float Uptime);

	bool CanAbruptlyExit() const;
	bool CanEnterLandmark() const;
	bool CanExitLandmark() const;
	bool ShouldWait() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TakeCoverAtLandmarkActivity">();
	}
	static class UTakeCoverAtLandmarkActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTakeCoverAtLandmarkActivity>();
	}
};
static_assert(alignof(UTakeCoverAtLandmarkActivity) == 0x000008, "Wrong alignment on UTakeCoverAtLandmarkActivity");
static_assert(sizeof(UTakeCoverAtLandmarkActivity) == 0x000210, "Wrong size on UTakeCoverAtLandmarkActivity");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, CoverLandmark) == 0x0001A8, "Member 'UTakeCoverAtLandmarkActivity::CoverLandmark' has a wrong offset!");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, ChosenEntryProxy) == 0x0001B0, "Member 'UTakeCoverAtLandmarkActivity::ChosenEntryProxy' has a wrong offset!");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, ChosenExitProxy) == 0x0001B8, "Member 'UTakeCoverAtLandmarkActivity::ChosenExitProxy' has a wrong offset!");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, SearchRadius) == 0x0001C0, "Member 'UTakeCoverAtLandmarkActivity::SearchRadius' has a wrong offset!");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, EntryAnim) == 0x0001E0, "Member 'UTakeCoverAtLandmarkActivity::EntryAnim' has a wrong offset!");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, ExitAnim) == 0x0001E8, "Member 'UTakeCoverAtLandmarkActivity::ExitAnim' has a wrong offset!");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, LoopEntryAnim) == 0x0001F0, "Member 'UTakeCoverAtLandmarkActivity::LoopEntryAnim' has a wrong offset!");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, LoopExitAnim) == 0x0001F8, "Member 'UTakeCoverAtLandmarkActivity::LoopExitAnim' has a wrong offset!");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, IgnoredMeshActors) == 0x000200, "Member 'UTakeCoverAtLandmarkActivity::IgnoredMeshActors' has a wrong offset!");

// Class ReadyOrNot.TakeHostageActivity
// 0x0098 (0x0240 - 0x01A8)
class UTakeHostageActivity final  : public UBaseActivity
{
public:
	class ACyberneticCharacter*                   Hostage;                                           // 0x01A8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToSurrenderHostage;                            // 0x01B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2995[0x4];                                     // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   LastEnemySensed;                                   // 0x01B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UInteractionsData*>   HostageInteractions;                               // 0x01C0(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2996[0x30];                                    // 0x0210(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndTakingState();
	void EnterBeginHostageTakeState();
	void EnterEndHostageTakeState();
	void EnterMoveToState();
	void EnterTakingState();
	void EnterTurnState();
	void OnHeardYell(class AReadyOrNotCharacter* Shouter, bool bLOS);
	void OnHostageKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnHostageTakeEndComplete_Driver(class AActor* Actor);
	void OnHostageTakeEndComplete_Slave(class AActor* Actor);
	void OnHostageTakeKillComplete_Driver(class AActor* Actor);
	void OnHostageTakeKillComplete_Slave(class AActor* Actor);
	void OnHostageTakeStartComplete_Driver(class AActor* Actor);
	void OnHostageTakeStartComplete_Slave(class AActor* Actor);
	void OnHostageTakeTurnComplete_Driver(class AActor* Actor);
	void OnHostageTakeTurnComplete_Slave(class AActor* Actor);
	void OnSensedCharacter(class AReadyOrNotCharacter* SensedCharacter);
	void OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void TickBeginHostageTakeState(float DeltaTime, float Uptime);
	void TickEndHostageTakeState(float DeltaTime, float Uptime);
	void TickMoveToState(float DeltaTime, float Uptime);
	void TickTakingState(float DeltaTime, float Uptime);
	void TickTurnState(float DeltaTime, float Uptime);

	bool CanEndHostageTake() const;
	bool CanIdle() const;
	bool CanStartHostageTake() const;
	bool ShouldTurn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TakeHostageActivity">();
	}
	static class UTakeHostageActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTakeHostageActivity>();
	}
};
static_assert(alignof(UTakeHostageActivity) == 0x000008, "Wrong alignment on UTakeHostageActivity");
static_assert(sizeof(UTakeHostageActivity) == 0x000240, "Wrong size on UTakeHostageActivity");
static_assert(offsetof(UTakeHostageActivity, Hostage) == 0x0001A8, "Member 'UTakeHostageActivity::Hostage' has a wrong offset!");
static_assert(offsetof(UTakeHostageActivity, TimeToSurrenderHostage) == 0x0001B0, "Member 'UTakeHostageActivity::TimeToSurrenderHostage' has a wrong offset!");
static_assert(offsetof(UTakeHostageActivity, LastEnemySensed) == 0x0001B8, "Member 'UTakeHostageActivity::LastEnemySensed' has a wrong offset!");
static_assert(offsetof(UTakeHostageActivity, HostageInteractions) == 0x0001C0, "Member 'UTakeHostageActivity::HostageInteractions' has a wrong offset!");

// Class ReadyOrNot.TargetingComponent
// 0x0500 (0x05B0 - 0x00B0)
class UTargetingComponent final  : public UActorComponent
{
public:
	struct FVector                                ThreatTrackingIgnoredDirection;                    // 0x00B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2999[0x4];                                     // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADoor*>                          AllowedTrackingDoors;                              // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageFocalAnim;                                  // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MontageFocalPoint;                                 // 0x00D8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CustomFocusLocation;                               // 0x00E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CustomFocusActor;                                  // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AInterestOverrideZone*                  CurrentInterestZone;                               // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HeadTrackingLocation;                              // 0x0100(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Threat;                                            // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tension;                                           // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299A[0x4];                                     // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AThreatAwarenessActor*                  ThreatLookPoint;                                   // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299B[0x8];                                     // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExposedToNoise                        LastHeardAggressiveNoise;                          // 0x0128(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FExposedToNoise>     HeardNoises;                                       // 0x0158(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	struct FExposedToNoise                        LastHeardNoiseStimulus;                            // 0x01A8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_299C[0x18];                                    // 0x01D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AReadyOrNotCharacter*, float>      CharactersSeen;                                    // 0x01F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	ETargetingCompTracking                        TrackingType;                                      // 0x0240(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299D[0x7];                                     // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotCharacter*>           KnownFriendlies;                                   // 0x0248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           KnownNeutrals;                                     // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           KnownEnemies;                                      // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	struct FVector                                LastKnownTargetPosition;                           // 0x0278(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastKnownTargetPositionInLOS;                      // 0x0284(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastSeenKnownTargetFrom;                           // 0x0290(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299E[0xC];                                     // 0x029C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceLastSeenTarget;                           // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastSeenEnemy;                            // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastSeenNeutral;                          // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastSeenFriendly;                         // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviousTimeNotSeenTarget;                         // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviousTimeNotSeenEnemy;                          // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviousTimeNotSeenFriendly;                       // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviousTimeNotSeenNeutral;                        // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeTrackingTarget;                                // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeTrackingEnemy;                                 // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeTrackingNeutral;                               // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeTrackingFriendly;                              // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastFriendlyDeath;                        // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastFriendlyTookDamage;                   // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastFriendlyStunned;                      // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastEnemyDeath;                           // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastEnemyTookDamage;                      // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastEnemyStunned;                         // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EngagementTimeUntilReachedLastBoneZone;            // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BoneRetargetingRate;                               // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastBoneRetarget;                         // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastKnownTrackingTime;                             // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AReadyOrNotCharacter*>           AITrackingMe;                                      // 0x0300(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         bHasLOSToTarget : 1;                               // 0x0310(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanSeeTarget : 1;                                 // 0x0310(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasLOSToLastTarget : 1;                           // 0x0310(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanSeeLastTarget : 1;                             // 0x0310(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasLOSToLastKnownTargetPosition : 1;              // 0x0310(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         CurrentBoneTargetZoneIndex;                        // 0x0311(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         PreviousBoneTargetZoneIndex;                       // 0x0312(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299F[0x1];                                     // 0x0313(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetedBone;                                      // 0x0314(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29A0[0x4];                                     // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BonesToTarget;                                     // 0x0320(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_29A1[0x10];                                    // 0x0330(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseGrenade*                           SmokeGrenadeBetweenTarget;                         // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExposureFromEnemy;                                 // 0x0348(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnemyExposureFromUs;                               // 0x034C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RequiredTimeTrackingTarget;                        // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeTrackingHead;                                  // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   TrackedTarget;                                     // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   LastTrackedTarget;                                 // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   LastKnownEnemy;                                    // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastMoveVectorFocalPoint;                          // 0x0370(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29A2[0x4];                                     // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  LastTrackedDoor;                                   // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastHeardNoiseStimulus;                   // 0x0388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LatestNoiseLocation;                               // 0x038C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AThreatAwarenessActor*                  LastThreatAwarenessActor;                          // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSearchingPathAwareness;                           // 0x03A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29A3[0x3];                                     // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceGotLastThreatAwarenessActor;              // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeUntilFinishedCheckingThreat;                   // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntVector                             LastLookAtPoint;                                   // 0x03AC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EPathedAwareness, struct FPathAwarenessInfo> LatestPathedAwareness;                             // 0x03B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<EPathedAwareness, struct FVector>        LastSearchedPathedAwareness;                       // 0x0408(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<EPathedAwareness, float>                 PathAwarenessSearchTimeout;                        // 0x0458(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<uint32, EPathedAwareness>                PathedAwarenessQueryType;                          // 0x04A8(0x0050)(Edit, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class AReadyOrNotCharacter*>           AllKnownCharacters;                                // 0x04F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_29A4[0x8];                                     // 0x0508(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AThreatAwarenessActor*                  NearestThreat;                                     // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AThreatAwarenessActor*                  NearestExtremeThreat;                              // 0x0518(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29A5[0x90];                                    // 0x0520(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCharacterToSeenMap(class AReadyOrNotCharacter* InCharacter);
	void AddKnownEnemy(class AReadyOrNotCharacter* Enemy, bool bForce);
	void AddKnownFriendly(class AReadyOrNotCharacter* Friendly);
	void AddKnownNeutral(class AReadyOrNotCharacter* Neutral);
	struct FExposedToNoise GetLastNoiseByTag(class FName Tag);
	TArray<class FName> GetLastNoisesTags();
	int32 GetVisibleKnownFriendlies();
	bool IsLookingAtFocalPoint(float Tolerance);
	bool IsTrackedByKnownFriendly(class AReadyOrNotCharacter* Target);
	void OnTrackedTargetExitedSurrender(class ACyberneticCharacter* Character, ESurrenderExitType ExitType);
	void OnTrackedTargetIncapacitated(class AReadyOrNotCharacter* IncapacitatedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnTrackedTargetKilled(class AReadyOrNotCharacter* Instigator, class AReadyOrNotCharacter* KilledCharacter);
	void OnTrackedTargetStartedReloading(class APlayerCharacter* Character);
	void SetLastTrackedTarget(class AReadyOrNotCharacter* Target);

	bool AnyAITrackingMe() const;
	bool CanActorBeSeen(class AActor* InActor) const;
	bool CanCharacterBeSeen(class AReadyOrNotCharacter* InCharacter) const;
	bool CanSeeLastTrackedTarget() const;
	bool CanSeeTrackedTarget() const;
	int32 GetKnownFriendlyCount() const;
	struct FVector GetLastHeardAggressiveNoiseLocation() const;
	struct FVector GetLastHeardNoiseLocation() const;
	class AReadyOrNotCharacter* GetLastKnownEnemy() const;
	struct FVector GetLastKnownEnemyPosition() const;
	float GetLastKnownTrackingTimeConfig() const;
	struct FVector GetLastSeenKnownEnemyFrom() const;
	class AReadyOrNotCharacter* GetLastTrackedTarget() const;
	class AThreatAwarenessActor* GetNearestExtremeThreat() const;
	class AThreatAwarenessActor* GetNearestThreat() const;
	float GetRequiredTrackingTime() const;
	class FName GetTargetedBone() const;
	float GetTimeSinceLastSeenEnemy() const;
	float GetTimeSinceLastSeenFriendly() const;
	float GetTimeSinceLastSeenNeutral() const;
	float GetTimeTrackingHead() const;
	float GetTimeTrackingTarget() const;
	class AReadyOrNotCharacter* GetTrackedTarget() const;
	ETargetingCompTracking GetTrackingType() const;
	bool HasLineOfSightToLastKnownTargetPosition() const;
	bool HasLineOfSightToLastTrackedTarget() const;
	bool HasLineOfSightToTrackedTarget() const;
	bool HasSeenCharacterFor(class AReadyOrNotCharacter* InCharacter, float Seconds) const;
	bool IsTrackedInKnownEnemies(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool IsTrackedInKnownFriendlies(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool IsTrackedInKnownNeutrals(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool IsTrackingMontagePosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetingComponent">();
	}
	static class UTargetingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetingComponent>();
	}
};
static_assert(alignof(UTargetingComponent) == 0x000008, "Wrong alignment on UTargetingComponent");
static_assert(sizeof(UTargetingComponent) == 0x0005B0, "Wrong size on UTargetingComponent");
static_assert(offsetof(UTargetingComponent, ThreatTrackingIgnoredDirection) == 0x0000B0, "Member 'UTargetingComponent::ThreatTrackingIgnoredDirection' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, AllowedTrackingDoors) == 0x0000C0, "Member 'UTargetingComponent::AllowedTrackingDoors' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, MontageFocalAnim) == 0x0000D0, "Member 'UTargetingComponent::MontageFocalAnim' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, MontageFocalPoint) == 0x0000D8, "Member 'UTargetingComponent::MontageFocalPoint' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, CustomFocusLocation) == 0x0000E4, "Member 'UTargetingComponent::CustomFocusLocation' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, CustomFocusActor) == 0x0000F0, "Member 'UTargetingComponent::CustomFocusActor' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, CurrentInterestZone) == 0x0000F8, "Member 'UTargetingComponent::CurrentInterestZone' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, HeadTrackingLocation) == 0x000100, "Member 'UTargetingComponent::HeadTrackingLocation' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, Threat) == 0x00010C, "Member 'UTargetingComponent::Threat' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, Tension) == 0x000110, "Member 'UTargetingComponent::Tension' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, ThreatLookPoint) == 0x000118, "Member 'UTargetingComponent::ThreatLookPoint' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastHeardAggressiveNoise) == 0x000128, "Member 'UTargetingComponent::LastHeardAggressiveNoise' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, HeardNoises) == 0x000158, "Member 'UTargetingComponent::HeardNoises' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastHeardNoiseStimulus) == 0x0001A8, "Member 'UTargetingComponent::LastHeardNoiseStimulus' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, CharactersSeen) == 0x0001F0, "Member 'UTargetingComponent::CharactersSeen' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TrackingType) == 0x000240, "Member 'UTargetingComponent::TrackingType' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, KnownFriendlies) == 0x000248, "Member 'UTargetingComponent::KnownFriendlies' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, KnownNeutrals) == 0x000258, "Member 'UTargetingComponent::KnownNeutrals' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, KnownEnemies) == 0x000268, "Member 'UTargetingComponent::KnownEnemies' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastKnownTargetPosition) == 0x000278, "Member 'UTargetingComponent::LastKnownTargetPosition' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastKnownTargetPositionInLOS) == 0x000284, "Member 'UTargetingComponent::LastKnownTargetPositionInLOS' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastSeenKnownTargetFrom) == 0x000290, "Member 'UTargetingComponent::LastSeenKnownTargetFrom' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastSeenTarget) == 0x0002A8, "Member 'UTargetingComponent::TimeSinceLastSeenTarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastSeenEnemy) == 0x0002AC, "Member 'UTargetingComponent::TimeSinceLastSeenEnemy' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastSeenNeutral) == 0x0002B0, "Member 'UTargetingComponent::TimeSinceLastSeenNeutral' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastSeenFriendly) == 0x0002B4, "Member 'UTargetingComponent::TimeSinceLastSeenFriendly' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, PreviousTimeNotSeenTarget) == 0x0002B8, "Member 'UTargetingComponent::PreviousTimeNotSeenTarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, PreviousTimeNotSeenEnemy) == 0x0002BC, "Member 'UTargetingComponent::PreviousTimeNotSeenEnemy' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, PreviousTimeNotSeenFriendly) == 0x0002C0, "Member 'UTargetingComponent::PreviousTimeNotSeenFriendly' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, PreviousTimeNotSeenNeutral) == 0x0002C4, "Member 'UTargetingComponent::PreviousTimeNotSeenNeutral' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeTrackingTarget) == 0x0002C8, "Member 'UTargetingComponent::TimeTrackingTarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeTrackingEnemy) == 0x0002CC, "Member 'UTargetingComponent::TimeTrackingEnemy' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeTrackingNeutral) == 0x0002D0, "Member 'UTargetingComponent::TimeTrackingNeutral' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeTrackingFriendly) == 0x0002D4, "Member 'UTargetingComponent::TimeTrackingFriendly' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastFriendlyDeath) == 0x0002D8, "Member 'UTargetingComponent::TimeSinceLastFriendlyDeath' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastFriendlyTookDamage) == 0x0002DC, "Member 'UTargetingComponent::TimeSinceLastFriendlyTookDamage' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastFriendlyStunned) == 0x0002E0, "Member 'UTargetingComponent::TimeSinceLastFriendlyStunned' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastEnemyDeath) == 0x0002E4, "Member 'UTargetingComponent::TimeSinceLastEnemyDeath' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastEnemyTookDamage) == 0x0002E8, "Member 'UTargetingComponent::TimeSinceLastEnemyTookDamage' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastEnemyStunned) == 0x0002EC, "Member 'UTargetingComponent::TimeSinceLastEnemyStunned' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, EngagementTimeUntilReachedLastBoneZone) == 0x0002F0, "Member 'UTargetingComponent::EngagementTimeUntilReachedLastBoneZone' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, BoneRetargetingRate) == 0x0002F4, "Member 'UTargetingComponent::BoneRetargetingRate' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastBoneRetarget) == 0x0002F8, "Member 'UTargetingComponent::TimeSinceLastBoneRetarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastKnownTrackingTime) == 0x0002FC, "Member 'UTargetingComponent::LastKnownTrackingTime' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, AITrackingMe) == 0x000300, "Member 'UTargetingComponent::AITrackingMe' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, CurrentBoneTargetZoneIndex) == 0x000311, "Member 'UTargetingComponent::CurrentBoneTargetZoneIndex' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, PreviousBoneTargetZoneIndex) == 0x000312, "Member 'UTargetingComponent::PreviousBoneTargetZoneIndex' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TargetedBone) == 0x000314, "Member 'UTargetingComponent::TargetedBone' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, BonesToTarget) == 0x000320, "Member 'UTargetingComponent::BonesToTarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, SmokeGrenadeBetweenTarget) == 0x000340, "Member 'UTargetingComponent::SmokeGrenadeBetweenTarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, ExposureFromEnemy) == 0x000348, "Member 'UTargetingComponent::ExposureFromEnemy' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, EnemyExposureFromUs) == 0x00034C, "Member 'UTargetingComponent::EnemyExposureFromUs' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, RequiredTimeTrackingTarget) == 0x000350, "Member 'UTargetingComponent::RequiredTimeTrackingTarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeTrackingHead) == 0x000354, "Member 'UTargetingComponent::TimeTrackingHead' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TrackedTarget) == 0x000358, "Member 'UTargetingComponent::TrackedTarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastTrackedTarget) == 0x000360, "Member 'UTargetingComponent::LastTrackedTarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastKnownEnemy) == 0x000368, "Member 'UTargetingComponent::LastKnownEnemy' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastMoveVectorFocalPoint) == 0x000370, "Member 'UTargetingComponent::LastMoveVectorFocalPoint' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastTrackedDoor) == 0x000380, "Member 'UTargetingComponent::LastTrackedDoor' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastHeardNoiseStimulus) == 0x000388, "Member 'UTargetingComponent::TimeSinceLastHeardNoiseStimulus' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LatestNoiseLocation) == 0x00038C, "Member 'UTargetingComponent::LatestNoiseLocation' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastThreatAwarenessActor) == 0x000398, "Member 'UTargetingComponent::LastThreatAwarenessActor' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, bSearchingPathAwareness) == 0x0003A0, "Member 'UTargetingComponent::bSearchingPathAwareness' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceGotLastThreatAwarenessActor) == 0x0003A4, "Member 'UTargetingComponent::TimeSinceGotLastThreatAwarenessActor' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeUntilFinishedCheckingThreat) == 0x0003A8, "Member 'UTargetingComponent::TimeUntilFinishedCheckingThreat' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastLookAtPoint) == 0x0003AC, "Member 'UTargetingComponent::LastLookAtPoint' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LatestPathedAwareness) == 0x0003B8, "Member 'UTargetingComponent::LatestPathedAwareness' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastSearchedPathedAwareness) == 0x000408, "Member 'UTargetingComponent::LastSearchedPathedAwareness' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, PathAwarenessSearchTimeout) == 0x000458, "Member 'UTargetingComponent::PathAwarenessSearchTimeout' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, PathedAwarenessQueryType) == 0x0004A8, "Member 'UTargetingComponent::PathedAwarenessQueryType' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, AllKnownCharacters) == 0x0004F8, "Member 'UTargetingComponent::AllKnownCharacters' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, NearestThreat) == 0x000510, "Member 'UTargetingComponent::NearestThreat' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, NearestExtremeThreat) == 0x000518, "Member 'UTargetingComponent::NearestExtremeThreat' has a wrong offset!");

// Class ReadyOrNot.TargetNextCivilianActivity
// 0x0018 (0x01C0 - 0x01A8)
class UTargetNextCivilianActivity final  : public UBaseActivity
{
public:
	class ACyberneticCharacter*                   TargetingCivilian;                                 // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29B0[0x10];                                    // 0x01B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetNextCivilianActivity">();
	}
	static class UTargetNextCivilianActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetNextCivilianActivity>();
	}
};
static_assert(alignof(UTargetNextCivilianActivity) == 0x000008, "Wrong alignment on UTargetNextCivilianActivity");
static_assert(sizeof(UTargetNextCivilianActivity) == 0x0001C0, "Wrong size on UTargetNextCivilianActivity");
static_assert(offsetof(UTargetNextCivilianActivity, TargetingCivilian) == 0x0001A8, "Member 'UTargetNextCivilianActivity::TargetingCivilian' has a wrong offset!");

// Class ReadyOrNot.Taser
// 0x0290 (0x16C0 - 0x1430)
class ATaser : public ABaseMagazineWeapon
{
public:
	class UMaterialInstanceDynamic*               TaserLightDynamicMaterial;                         // 0x1430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             ProjectileHitResult;                               // 0x1438(0x0088)(Net, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         CartridgesPerSlot;                                 // 0x14C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartingCartridges;                                // 0x14C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SweepForReactionVolumeSize;                        // 0x14C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CartridgeWeight;                                   // 0x14CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFiredCartridge;                                   // 0x14D0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetachedProbes;                                   // 0x14D1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29B1[0x2];                                     // 0x14D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlinkTime;                                         // 0x14D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlinkState;                                       // 0x14D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29B2[0x3];                                     // 0x14D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxBatteryLevel;                                   // 0x14DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCableLength;                                    // 0x14E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCableLength;                                    // 0x14E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CableGainRate;                                     // 0x14E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProbeMaxDistance;                                  // 0x14EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DetachSoundEffect;                                 // 0x14F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DetachSoundEffectFMOD;                             // 0x14F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PingStunDuration;                                  // 0x1500(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StunDurationRemaining;                             // 0x1504(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartedStun;                                      // 0x1508(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29B3[0x7];                                     // 0x1509(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             CrackleSoundEffect;                                // 0x1510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             CrackleSoundEffectFMOD;                            // 0x1518(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             TaserHitEffectFMOD;                                // 0x1520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABulletProjectile*                      LeftProjectile;                                    // 0x1528(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABulletProjectile*                      RightProjectile;                                   // 0x1530(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29B4[0x8];                                     // 0x1538(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        TaserImpactParticle_Start;                         // 0x1540(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               TaserImpactParticleComp_Start;                     // 0x1548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        TaserImpactParticle_Loop;                          // 0x1550(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               TaserImpactParticleComp_LoopLeft;                  // 0x1558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               TaserImpactParticleComp_LoopRight;                 // 0x1560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29B5[0x8C];                                    // 0x1568(0x008C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorBlowOutForce;                                  // 0x15F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LeftCableAttachActor;                              // 0x15F8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 RightCableAttachActor;                             // 0x1600(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TaserFireLoop1P;                                   // 0x1608(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TaserFireLoop3P;                                   // 0x1610(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        TaserFireLoopCameraShake;                          // 0x1618(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29B6[0x8];                                     // 0x1620(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCableComponent*                        TopCable;                                          // 0x1628(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCableComponent*                        BottomCable;                                       // 0x1630(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 LeftDoor;                                          // 0x1638(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 RightDoor;                                         // 0x1640(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        CrackleSoundGenerator;                             // 0x1648(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    CrackleSoundGeneratorFMOD;                         // 0x1650(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ULaserAttachment>           LaserAttachmentClass;                              // 0x1658(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29B7[0x60];                                    // 0x1660(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DetachProbes();
	void HandleMeleeDeffered(const struct FHitResult& Hit);
	void Multicast_DestroyProjectiles();
	void Multicast_HideCables();
	void Multicast_PlayDetachEffect();
	void Multicast_PlayFireEffects(bool bDryFire);
	void Multicast_PlayTaserHitEffect(const struct FHitResult& Hit);
	void Multicast_ResetCableAttachments();
	void Multicast_ResetDoors();
	void Multicast_StartCrackleSoundEffect();
	void Multicast_StopCrackleSoundEffect();
	void OnRep_ProjectileReplicated();
	void Server_DeliverStunToAttachedTarget();
	void Server_DetachProbes();
	void Server_SetHoldingTaser(bool bNewHold);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Taser">();
	}
	static class ATaser* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATaser>();
	}
};
static_assert(alignof(ATaser) == 0x000010, "Wrong alignment on ATaser");
static_assert(sizeof(ATaser) == 0x0016C0, "Wrong size on ATaser");
static_assert(offsetof(ATaser, TaserLightDynamicMaterial) == 0x001430, "Member 'ATaser::TaserLightDynamicMaterial' has a wrong offset!");
static_assert(offsetof(ATaser, ProjectileHitResult) == 0x001438, "Member 'ATaser::ProjectileHitResult' has a wrong offset!");
static_assert(offsetof(ATaser, CartridgesPerSlot) == 0x0014C0, "Member 'ATaser::CartridgesPerSlot' has a wrong offset!");
static_assert(offsetof(ATaser, StartingCartridges) == 0x0014C4, "Member 'ATaser::StartingCartridges' has a wrong offset!");
static_assert(offsetof(ATaser, SweepForReactionVolumeSize) == 0x0014C8, "Member 'ATaser::SweepForReactionVolumeSize' has a wrong offset!");
static_assert(offsetof(ATaser, CartridgeWeight) == 0x0014CC, "Member 'ATaser::CartridgeWeight' has a wrong offset!");
static_assert(offsetof(ATaser, bFiredCartridge) == 0x0014D0, "Member 'ATaser::bFiredCartridge' has a wrong offset!");
static_assert(offsetof(ATaser, bDetachedProbes) == 0x0014D1, "Member 'ATaser::bDetachedProbes' has a wrong offset!");
static_assert(offsetof(ATaser, BlinkTime) == 0x0014D4, "Member 'ATaser::BlinkTime' has a wrong offset!");
static_assert(offsetof(ATaser, bBlinkState) == 0x0014D8, "Member 'ATaser::bBlinkState' has a wrong offset!");
static_assert(offsetof(ATaser, MaxBatteryLevel) == 0x0014DC, "Member 'ATaser::MaxBatteryLevel' has a wrong offset!");
static_assert(offsetof(ATaser, MinCableLength) == 0x0014E0, "Member 'ATaser::MinCableLength' has a wrong offset!");
static_assert(offsetof(ATaser, MaxCableLength) == 0x0014E4, "Member 'ATaser::MaxCableLength' has a wrong offset!");
static_assert(offsetof(ATaser, CableGainRate) == 0x0014E8, "Member 'ATaser::CableGainRate' has a wrong offset!");
static_assert(offsetof(ATaser, ProbeMaxDistance) == 0x0014EC, "Member 'ATaser::ProbeMaxDistance' has a wrong offset!");
static_assert(offsetof(ATaser, DetachSoundEffect) == 0x0014F0, "Member 'ATaser::DetachSoundEffect' has a wrong offset!");
static_assert(offsetof(ATaser, DetachSoundEffectFMOD) == 0x0014F8, "Member 'ATaser::DetachSoundEffectFMOD' has a wrong offset!");
static_assert(offsetof(ATaser, PingStunDuration) == 0x001500, "Member 'ATaser::PingStunDuration' has a wrong offset!");
static_assert(offsetof(ATaser, StunDurationRemaining) == 0x001504, "Member 'ATaser::StunDurationRemaining' has a wrong offset!");
static_assert(offsetof(ATaser, bStartedStun) == 0x001508, "Member 'ATaser::bStartedStun' has a wrong offset!");
static_assert(offsetof(ATaser, CrackleSoundEffect) == 0x001510, "Member 'ATaser::CrackleSoundEffect' has a wrong offset!");
static_assert(offsetof(ATaser, CrackleSoundEffectFMOD) == 0x001518, "Member 'ATaser::CrackleSoundEffectFMOD' has a wrong offset!");
static_assert(offsetof(ATaser, TaserHitEffectFMOD) == 0x001520, "Member 'ATaser::TaserHitEffectFMOD' has a wrong offset!");
static_assert(offsetof(ATaser, LeftProjectile) == 0x001528, "Member 'ATaser::LeftProjectile' has a wrong offset!");
static_assert(offsetof(ATaser, RightProjectile) == 0x001530, "Member 'ATaser::RightProjectile' has a wrong offset!");
static_assert(offsetof(ATaser, TaserImpactParticle_Start) == 0x001540, "Member 'ATaser::TaserImpactParticle_Start' has a wrong offset!");
static_assert(offsetof(ATaser, TaserImpactParticleComp_Start) == 0x001548, "Member 'ATaser::TaserImpactParticleComp_Start' has a wrong offset!");
static_assert(offsetof(ATaser, TaserImpactParticle_Loop) == 0x001550, "Member 'ATaser::TaserImpactParticle_Loop' has a wrong offset!");
static_assert(offsetof(ATaser, TaserImpactParticleComp_LoopLeft) == 0x001558, "Member 'ATaser::TaserImpactParticleComp_LoopLeft' has a wrong offset!");
static_assert(offsetof(ATaser, TaserImpactParticleComp_LoopRight) == 0x001560, "Member 'ATaser::TaserImpactParticleComp_LoopRight' has a wrong offset!");
static_assert(offsetof(ATaser, DoorBlowOutForce) == 0x0015F4, "Member 'ATaser::DoorBlowOutForce' has a wrong offset!");
static_assert(offsetof(ATaser, LeftCableAttachActor) == 0x0015F8, "Member 'ATaser::LeftCableAttachActor' has a wrong offset!");
static_assert(offsetof(ATaser, RightCableAttachActor) == 0x001600, "Member 'ATaser::RightCableAttachActor' has a wrong offset!");
static_assert(offsetof(ATaser, TaserFireLoop1P) == 0x001608, "Member 'ATaser::TaserFireLoop1P' has a wrong offset!");
static_assert(offsetof(ATaser, TaserFireLoop3P) == 0x001610, "Member 'ATaser::TaserFireLoop3P' has a wrong offset!");
static_assert(offsetof(ATaser, TaserFireLoopCameraShake) == 0x001618, "Member 'ATaser::TaserFireLoopCameraShake' has a wrong offset!");
static_assert(offsetof(ATaser, TopCable) == 0x001628, "Member 'ATaser::TopCable' has a wrong offset!");
static_assert(offsetof(ATaser, BottomCable) == 0x001630, "Member 'ATaser::BottomCable' has a wrong offset!");
static_assert(offsetof(ATaser, LeftDoor) == 0x001638, "Member 'ATaser::LeftDoor' has a wrong offset!");
static_assert(offsetof(ATaser, RightDoor) == 0x001640, "Member 'ATaser::RightDoor' has a wrong offset!");
static_assert(offsetof(ATaser, CrackleSoundGenerator) == 0x001648, "Member 'ATaser::CrackleSoundGenerator' has a wrong offset!");
static_assert(offsetof(ATaser, CrackleSoundGeneratorFMOD) == 0x001650, "Member 'ATaser::CrackleSoundGeneratorFMOD' has a wrong offset!");
static_assert(offsetof(ATaser, LaserAttachmentClass) == 0x001658, "Member 'ATaser::LaserAttachmentClass' has a wrong offset!");

// Class ReadyOrNot.TaserReactionVolume
// 0x0008 (0x0228 - 0x0220)
class ATaserReactionVolume final  : public AActor
{
public:
	class UBoxComponent*                          Bounds;                                            // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnTaserStunDelivered(class AReadyOrNotCharacter* Character, class ATaser* Taser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TaserReactionVolume">();
	}
	static class ATaserReactionVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATaserReactionVolume>();
	}
};
static_assert(alignof(ATaserReactionVolume) == 0x000008, "Wrong alignment on ATaserReactionVolume");
static_assert(sizeof(ATaserReactionVolume) == 0x000228, "Wrong size on ATaserReactionVolume");
static_assert(offsetof(ATaserReactionVolume, Bounds) == 0x000220, "Member 'ATaserReactionVolume::Bounds' has a wrong offset!");

// Class ReadyOrNot.TeamBreachAndClearActivity
// 0x00C8 (0x02C0 - 0x01F8)
class UTeamBreachAndClearActivity final  : public UTeamStackUpActivity
{
public:
	FMulticastInlineDelegateProperty_             OnCleared;                                         // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_29B8[0x30];                                    // 0x0208(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class ACyberneticCharacter*                   AIBlockingClearingPath;                            // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACyberneticCharacter*                   ClearingLeader;                                    // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AThreatAwarenessActor*                  NearestThreat;                                     // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29B9[0x70];                                    // 0x0250(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreachAndClearComplete__DelegateSignature(class UTeamBreachAndClearActivity* Activity, bool bAuto);
	void EnterBreachStage();
	void EnterClearedStage();
	void EnterClearStage();
	void EnterScanStage();
	void OnDoorBreachActivityFinished(class UBaseActivity* InActivity, class ACyberneticController* InController);
	void OnDoorBreacherBreaching();
	void OnDoorBreacherReady();
	void OnDoorBreachFinished(class UBaseActivity* InActivity, class ACyberneticController* InController);
	void OnDoorScanFinished(class UBaseActivity* Activity, class ACyberneticController* Controller);
	void OnLeaderGrenadeDetonated(class ABaseGrenade* InGrenade);
	void OnLeaderGrenadeProjectileDetonated(class AGrenadeProjectile* InGrenadeProjectile);
	void OnLeaderItemPrimaryUse(class AReadyOrNotCharacter* ItemOwner, class ABaseItem* Item);
	void PerformBreachStage(float DeltaTime, float Uptime);
	void PerformClearStage(float DeltaTime, float Uptime);
	void PerformScanStage(float DeltaTime, float Uptime);

	bool CanPerformBreach() const;
	bool CanPerformClear() const;
	bool IsFinishedClearing() const;
	bool IsScanFinished() const;
	bool ShouldScan() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamBreachAndClearActivity">();
	}
	static class UTeamBreachAndClearActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamBreachAndClearActivity>();
	}
};
static_assert(alignof(UTeamBreachAndClearActivity) == 0x000008, "Wrong alignment on UTeamBreachAndClearActivity");
static_assert(sizeof(UTeamBreachAndClearActivity) == 0x0002C0, "Wrong size on UTeamBreachAndClearActivity");
static_assert(offsetof(UTeamBreachAndClearActivity, OnCleared) == 0x0001F8, "Member 'UTeamBreachAndClearActivity::OnCleared' has a wrong offset!");
static_assert(offsetof(UTeamBreachAndClearActivity, AIBlockingClearingPath) == 0x000238, "Member 'UTeamBreachAndClearActivity::AIBlockingClearingPath' has a wrong offset!");
static_assert(offsetof(UTeamBreachAndClearActivity, ClearingLeader) == 0x000240, "Member 'UTeamBreachAndClearActivity::ClearingLeader' has a wrong offset!");
static_assert(offsetof(UTeamBreachAndClearActivity, NearestThreat) == 0x000248, "Member 'UTeamBreachAndClearActivity::NearestThreat' has a wrong offset!");

// Class ReadyOrNot.TeamCoverAreaActivity
// 0x0000 (0x01B8 - 0x01B8)
class UTeamCoverAreaActivity final  : public UTeamBaseActivity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamCoverAreaActivity">();
	}
	static class UTeamCoverAreaActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamCoverAreaActivity>();
	}
};
static_assert(alignof(UTeamCoverAreaActivity) == 0x000008, "Wrong alignment on UTeamCoverAreaActivity");
static_assert(sizeof(UTeamCoverAreaActivity) == 0x0001B8, "Wrong size on UTeamCoverAreaActivity");

// Class ReadyOrNot.TeamFallinActivity
// 0x0010 (0x01C8 - 0x01B8)
class UTeamFallinActivity final  : public UTeamBaseActivity
{
public:
	class ASWATCharacter*                         MyLeader;                                          // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29BB[0x8];                                     // 0x01C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamFallinActivity">();
	}
	static class UTeamFallinActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamFallinActivity>();
	}
};
static_assert(alignof(UTeamFallinActivity) == 0x000008, "Wrong alignment on UTeamFallinActivity");
static_assert(sizeof(UTeamFallinActivity) == 0x0001C8, "Wrong size on UTeamFallinActivity");
static_assert(offsetof(UTeamFallinActivity, MyLeader) == 0x0001B8, "Member 'UTeamFallinActivity::MyLeader' has a wrong offset!");

// Class ReadyOrNot.TeamPaperdollWidget
// 0x0008 (0x0268 - 0x0260)
class UTeamPaperdollWidget final  : public UUserWidget
{
public:
	class UImage*                                 Paperdoll_Image;                                   // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeWidget(ETeamType InTeam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamPaperdollWidget">();
	}
	static class UTeamPaperdollWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamPaperdollWidget>();
	}
};
static_assert(alignof(UTeamPaperdollWidget) == 0x000008, "Wrong alignment on UTeamPaperdollWidget");
static_assert(sizeof(UTeamPaperdollWidget) == 0x000268, "Wrong size on UTeamPaperdollWidget");
static_assert(offsetof(UTeamPaperdollWidget, Paperdoll_Image) == 0x000260, "Member 'UTeamPaperdollWidget::Paperdoll_Image' has a wrong offset!");

// Class ReadyOrNot.TeamProgressScoreWidget
// 0x0028 (0x02A0 - 0x0278)
class UTeamProgressScoreWidget final  : public UBaseWidget
{
public:
	ETeamType                                     Team;                                              // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29BC[0x7];                                     // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UProgressBar*                           ProgressBar_LeftAligned;                           // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Score_Text_LeftAligned;                            // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_RightAligned;                          // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Score_Text_RightAligned;                           // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamProgressScoreWidget">();
	}
	static class UTeamProgressScoreWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamProgressScoreWidget>();
	}
};
static_assert(alignof(UTeamProgressScoreWidget) == 0x000008, "Wrong alignment on UTeamProgressScoreWidget");
static_assert(sizeof(UTeamProgressScoreWidget) == 0x0002A0, "Wrong size on UTeamProgressScoreWidget");
static_assert(offsetof(UTeamProgressScoreWidget, Team) == 0x000278, "Member 'UTeamProgressScoreWidget::Team' has a wrong offset!");
static_assert(offsetof(UTeamProgressScoreWidget, ProgressBar_LeftAligned) == 0x000280, "Member 'UTeamProgressScoreWidget::ProgressBar_LeftAligned' has a wrong offset!");
static_assert(offsetof(UTeamProgressScoreWidget, Score_Text_LeftAligned) == 0x000288, "Member 'UTeamProgressScoreWidget::Score_Text_LeftAligned' has a wrong offset!");
static_assert(offsetof(UTeamProgressScoreWidget, ProgressBar_RightAligned) == 0x000290, "Member 'UTeamProgressScoreWidget::ProgressBar_RightAligned' has a wrong offset!");
static_assert(offsetof(UTeamProgressScoreWidget, Score_Text_RightAligned) == 0x000298, "Member 'UTeamProgressScoreWidget::Score_Text_RightAligned' has a wrong offset!");

// Class ReadyOrNot.TeamStatusWidget
// 0x0170 (0x03E8 - 0x0278)
class UTeamStatusWidget final  : public UBaseWidget
{
public:
	class UImage*                                 TeamEmblem_Image_LeftAligned;                      // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         Teammates_Container_LeftAligned;                   // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TeamEmblem_Image_RightAligned;                     // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         Teammates_Container_RightAligned;                  // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          Alignment;                                         // 0x0298(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29BD[0x7];                                     // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            TeamEmblemBrush;                                   // 0x02A0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	ETeamType                                     Team;                                              // 0x0328(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29BE[0x7];                                     // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTeamPaperdollWidget>       PaperdollWidgetClass;                              // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   EmptyTeamText;                                     // 0x0338(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	struct FSlateColor                            EmptyTeamTextColor;                                // 0x0350(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         EmptyTeamTextFont;                                 // 0x0378(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTeamPaperdollWidget*>           TeamPaperdolls;                                    // 0x03D0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             EmptyTeam_Text;                                    // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeTeam();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamStatusWidget">();
	}
	static class UTeamStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamStatusWidget>();
	}
};
static_assert(alignof(UTeamStatusWidget) == 0x000008, "Wrong alignment on UTeamStatusWidget");
static_assert(sizeof(UTeamStatusWidget) == 0x0003E8, "Wrong size on UTeamStatusWidget");
static_assert(offsetof(UTeamStatusWidget, TeamEmblem_Image_LeftAligned) == 0x000278, "Member 'UTeamStatusWidget::TeamEmblem_Image_LeftAligned' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, Teammates_Container_LeftAligned) == 0x000280, "Member 'UTeamStatusWidget::Teammates_Container_LeftAligned' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, TeamEmblem_Image_RightAligned) == 0x000288, "Member 'UTeamStatusWidget::TeamEmblem_Image_RightAligned' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, Teammates_Container_RightAligned) == 0x000290, "Member 'UTeamStatusWidget::Teammates_Container_RightAligned' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, Alignment) == 0x000298, "Member 'UTeamStatusWidget::Alignment' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, TeamEmblemBrush) == 0x0002A0, "Member 'UTeamStatusWidget::TeamEmblemBrush' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, Team) == 0x000328, "Member 'UTeamStatusWidget::Team' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, PaperdollWidgetClass) == 0x000330, "Member 'UTeamStatusWidget::PaperdollWidgetClass' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, EmptyTeamText) == 0x000338, "Member 'UTeamStatusWidget::EmptyTeamText' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, EmptyTeamTextColor) == 0x000350, "Member 'UTeamStatusWidget::EmptyTeamTextColor' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, EmptyTeamTextFont) == 0x000378, "Member 'UTeamStatusWidget::EmptyTeamTextFont' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, TeamPaperdolls) == 0x0003D0, "Member 'UTeamStatusWidget::TeamPaperdolls' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, EmptyTeam_Text) == 0x0003E0, "Member 'UTeamStatusWidget::EmptyTeam_Text' has a wrong offset!");

// Class ReadyOrNot.TeamViewWidget
// 0x00E0 (0x0340 - 0x0260)
class UTeamViewWidget : public UUserWidget
{
public:
	class UInvalidationBox*                       InvalidationBox;                                   // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PlayerViewImage;                                   // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerNameText;                                    // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerHealthStatusText;                            // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PlayerTeamIndicatorImage;                          // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SwitchViewText;                                    // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CloseViewText;                                     // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentViewIndexText;                              // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ETeamType, struct FSlateColor>           TeamColorMap;                                      // 0x02A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<EPlayerHealthStatus, struct FSlateColor> HealthStatusColorMap;                              // 0x02F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void Tick_TeamViewOn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamViewWidget">();
	}
	static class UTeamViewWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamViewWidget>();
	}
};
static_assert(alignof(UTeamViewWidget) == 0x000008, "Wrong alignment on UTeamViewWidget");
static_assert(sizeof(UTeamViewWidget) == 0x000340, "Wrong size on UTeamViewWidget");
static_assert(offsetof(UTeamViewWidget, InvalidationBox) == 0x000260, "Member 'UTeamViewWidget::InvalidationBox' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, PlayerViewImage) == 0x000268, "Member 'UTeamViewWidget::PlayerViewImage' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, PlayerNameText) == 0x000270, "Member 'UTeamViewWidget::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, PlayerHealthStatusText) == 0x000278, "Member 'UTeamViewWidget::PlayerHealthStatusText' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, PlayerTeamIndicatorImage) == 0x000280, "Member 'UTeamViewWidget::PlayerTeamIndicatorImage' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, SwitchViewText) == 0x000288, "Member 'UTeamViewWidget::SwitchViewText' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, CloseViewText) == 0x000290, "Member 'UTeamViewWidget::CloseViewText' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, CurrentViewIndexText) == 0x000298, "Member 'UTeamViewWidget::CurrentViewIndexText' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, TeamColorMap) == 0x0002A0, "Member 'UTeamViewWidget::TeamColorMap' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, HealthStatusColorMap) == 0x0002F0, "Member 'UTeamViewWidget::HealthStatusColorMap' has a wrong offset!");

// Class ReadyOrNot.TelescopicLadder
// 0x01F0 (0x0BC0 - 0x09D0)
class ATelescopicLadder : public ABaseDeployableGear
{
public:
	class USceneComponent*                        LadderVerticalIconPoint;                           // 0x09D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        LadderHorizontalIconPoint;                         // 0x09D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        LadderBottomMountPoint;                            // 0x09E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        LadderTopMountPoint;                               // 0x09E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ALadderSnapZone>            LadderSnapZoneBP;                                  // 0x09F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreezeFrame;                                      // 0x09F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29BF[0x3];                                     // 0x09F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRollDegreesBeforeUnwalkable;                    // 0x09FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C0[0xA0];                                    // 0x0A00(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             FreezeTransform;                                   // 0x0AA0(0x0030)(Net, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C1[0x2C];                                    // 0x0AD0(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowGhostLadder;                                  // 0x0AFC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCollapsedLadder;                              // 0x0AFD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C2[0x2];                                     // 0x0AFE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          CollapsedLadderAnim;                               // 0x0B00(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C3[0x8];                                     // 0x0B08(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LastTransform;                                     // 0x0B10(0x0030)(Net, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class ASkeletalMeshActor*                     GhostLadderActor;                                  // 0x0B40(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              GhostLadderMaterial;                               // 0x0B48(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          DroppedPhysics;                                    // 0x0B50(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          PlacedPhysics;                                     // 0x0B58(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             PlacementSoundEvent;                               // 0x0B60(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             PickupSoundEvent;                                  // 0x0B68(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             CollideSoundEvent;                                 // 0x0B70(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeployed;                                         // 0x0B78(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeployedHorizontal;                               // 0x0B79(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMounted;                                          // 0x0B7A(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C4[0x1];                                     // 0x0B7B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RetractedRungCount;                                // 0x0B7C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALadderSnapZone*                        CurrentSnapZone;                                   // 0x0B80(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWallFound;                                        // 0x0B88(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C5[0x37];                                    // 0x0B89(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_DeployLadderAtZone(class ALadderSnapZone* NewSnapZone);
	void Multicast_PlaceLadder();
	void OnRep_CurrentSnapZone();
	void OnRep_Deployed();
	void Server_DeployLadderAtZone(class ALadderSnapZone* NewSnapZone);
	void Server_PlaceLadder();
	void Server_RemoveLadder();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TelescopicLadder">();
	}
	static class ATelescopicLadder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATelescopicLadder>();
	}
};
static_assert(alignof(ATelescopicLadder) == 0x000010, "Wrong alignment on ATelescopicLadder");
static_assert(sizeof(ATelescopicLadder) == 0x000BC0, "Wrong size on ATelescopicLadder");
static_assert(offsetof(ATelescopicLadder, LadderVerticalIconPoint) == 0x0009D0, "Member 'ATelescopicLadder::LadderVerticalIconPoint' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, LadderHorizontalIconPoint) == 0x0009D8, "Member 'ATelescopicLadder::LadderHorizontalIconPoint' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, LadderBottomMountPoint) == 0x0009E0, "Member 'ATelescopicLadder::LadderBottomMountPoint' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, LadderTopMountPoint) == 0x0009E8, "Member 'ATelescopicLadder::LadderTopMountPoint' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, LadderSnapZoneBP) == 0x0009F0, "Member 'ATelescopicLadder::LadderSnapZoneBP' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, bFreezeFrame) == 0x0009F8, "Member 'ATelescopicLadder::bFreezeFrame' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, MaxRollDegreesBeforeUnwalkable) == 0x0009FC, "Member 'ATelescopicLadder::MaxRollDegreesBeforeUnwalkable' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, FreezeTransform) == 0x000AA0, "Member 'ATelescopicLadder::FreezeTransform' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, bShowGhostLadder) == 0x000AFC, "Member 'ATelescopicLadder::bShowGhostLadder' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, bShowCollapsedLadder) == 0x000AFD, "Member 'ATelescopicLadder::bShowCollapsedLadder' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, CollapsedLadderAnim) == 0x000B00, "Member 'ATelescopicLadder::CollapsedLadderAnim' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, LastTransform) == 0x000B10, "Member 'ATelescopicLadder::LastTransform' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, GhostLadderActor) == 0x000B40, "Member 'ATelescopicLadder::GhostLadderActor' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, GhostLadderMaterial) == 0x000B48, "Member 'ATelescopicLadder::GhostLadderMaterial' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, DroppedPhysics) == 0x000B50, "Member 'ATelescopicLadder::DroppedPhysics' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, PlacedPhysics) == 0x000B58, "Member 'ATelescopicLadder::PlacedPhysics' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, PlacementSoundEvent) == 0x000B60, "Member 'ATelescopicLadder::PlacementSoundEvent' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, PickupSoundEvent) == 0x000B68, "Member 'ATelescopicLadder::PickupSoundEvent' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, CollideSoundEvent) == 0x000B70, "Member 'ATelescopicLadder::CollideSoundEvent' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, bDeployed) == 0x000B78, "Member 'ATelescopicLadder::bDeployed' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, bDeployedHorizontal) == 0x000B79, "Member 'ATelescopicLadder::bDeployedHorizontal' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, bMounted) == 0x000B7A, "Member 'ATelescopicLadder::bMounted' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, RetractedRungCount) == 0x000B7C, "Member 'ATelescopicLadder::RetractedRungCount' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, CurrentSnapZone) == 0x000B80, "Member 'ATelescopicLadder::CurrentSnapZone' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, bWallFound) == 0x000B88, "Member 'ATelescopicLadder::bWallFound' has a wrong offset!");

// Class ReadyOrNot.TextWidget
// 0x0078 (0x02D8 - 0x0260)
class UTextWidget : public UUserWidget
{
public:
	class UCommonTextBlock*                       Txt_Text;                                          // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   CurrentText;                                       // 0x0268(0x0018)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         CurrentFont;                                       // 0x0280(0x0058)(BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextWidget">();
	}
	static class UTextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextWidget>();
	}
};
static_assert(alignof(UTextWidget) == 0x000008, "Wrong alignment on UTextWidget");
static_assert(sizeof(UTextWidget) == 0x0002D8, "Wrong size on UTextWidget");
static_assert(offsetof(UTextWidget, Txt_Text) == 0x000260, "Member 'UTextWidget::Txt_Text' has a wrong offset!");
static_assert(offsetof(UTextWidget, CurrentText) == 0x000268, "Member 'UTextWidget::CurrentText' has a wrong offset!");
static_assert(offsetof(UTextWidget, CurrentFont) == 0x000280, "Member 'UTextWidget::CurrentFont' has a wrong offset!");

// Class ReadyOrNot.TherapistWidget
// 0x0010 (0x0330 - 0x0320)
class UTherapistWidget : public UCommonActivatableWidget
{
public:
	TArray<class URosterCharacter*>               CharactersInTherapy;                               // 0x0320(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void CloseTherapistWidget();
	TArray<class URosterCharacter*> GetCharactersInTherapy();
	class FText GetTherapistText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TherapistWidget">();
	}
	static class UTherapistWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTherapistWidget>();
	}
};
static_assert(alignof(UTherapistWidget) == 0x000008, "Wrong alignment on UTherapistWidget");
static_assert(sizeof(UTherapistWidget) == 0x000330, "Wrong size on UTherapistWidget");
static_assert(offsetof(UTherapistWidget, CharactersInTherapy) == 0x000320, "Member 'UTherapistWidget::CharactersInTherapy' has a wrong offset!");

// Class ReadyOrNot.ThreatAwarenessActor
// 0x0068 (0x0288 - 0x0220)
class AThreatAwarenessActor final  : public AActor
{
public:
	class USceneComponent*                        DefaultScene;                                      // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EThreatLevel                                  ThreatLevel;                                       // 0x0228(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C6[0x7];                                     // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FExitData>                      Exits;                                             // 0x0230(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          UniqueExits;                                       // 0x0240(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class FName                                   OwningRoom;                                        // 0x0250(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADoor*                                  DoorThreat;                                        // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFrontDoorThreat;                                  // 0x0260(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOutside;                                        // 0x0261(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C7[0x6];                                     // 0x0262(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AThreatAwarenessActor*>          PathableThreatAwarenessActors;                     // 0x0268(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLookAtPoint>                   SwatLookAtPoints;                                  // 0x0278(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)

public:
	void GenerateLookAtPoints();
	void RemoveAnyVisibleExits();

	class ADoor* GetAttachedDoor() const;
	bool GetRandomExitDoor(class ADoor** Door) const;
	EThreatLevel GetThreatLevel() const;
	bool GetUniqueExtis(TArray<class ADoor*>* OutDoors) const;
	bool HasExit() const;
	bool HasSpecificExitDoor(class ADoor* Door) const;
	bool IsDoorThreat() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThreatAwarenessActor">();
	}
	static class AThreatAwarenessActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThreatAwarenessActor>();
	}
};
static_assert(alignof(AThreatAwarenessActor) == 0x000008, "Wrong alignment on AThreatAwarenessActor");
static_assert(sizeof(AThreatAwarenessActor) == 0x000288, "Wrong size on AThreatAwarenessActor");
static_assert(offsetof(AThreatAwarenessActor, DefaultScene) == 0x000220, "Member 'AThreatAwarenessActor::DefaultScene' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, ThreatLevel) == 0x000228, "Member 'AThreatAwarenessActor::ThreatLevel' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, Exits) == 0x000230, "Member 'AThreatAwarenessActor::Exits' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, UniqueExits) == 0x000240, "Member 'AThreatAwarenessActor::UniqueExits' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, OwningRoom) == 0x000250, "Member 'AThreatAwarenessActor::OwningRoom' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, DoorThreat) == 0x000258, "Member 'AThreatAwarenessActor::DoorThreat' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, bFrontDoorThreat) == 0x000260, "Member 'AThreatAwarenessActor::bFrontDoorThreat' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, bIsOutside) == 0x000261, "Member 'AThreatAwarenessActor::bIsOutside' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, PathableThreatAwarenessActors) == 0x000268, "Member 'AThreatAwarenessActor::PathableThreatAwarenessActors' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, SwatLookAtPoints) == 0x000278, "Member 'AThreatAwarenessActor::SwatLookAtPoints' has a wrong offset!");

// Class ReadyOrNot.ThreatAwarenessSubsystem
// 0x0058 (0x0088 - 0x0030)
class UThreatAwarenessSubsystem final  : public UWorldSubsystem
{
public:
	uint8                                         Pad_29CB[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AThreatAwarenessActor*>          AllThreatActors;                                   // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bDrawThreatAwarenessOctree : 1;                    // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawThreatPoints : 1;                             // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawThreatRoomNames : 1;                          // 0x0048(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29CC[0x3F];                                    // 0x0049(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AThreatAwarenessActor* GetFurthestHighestThreat(TArray<class AThreatAwarenessActor*>& InThreats, const struct FVector& Location, float MinDistance);
	static class AThreatAwarenessActor* GetNearestHighestThreat(TArray<class AThreatAwarenessActor*>& InThreats, const struct FVector& Location);
	static TArray<class AThreatAwarenessActor*> GetThreatsFromLocationBeyondRadius(TArray<class AThreatAwarenessActor*>& InThreats, const struct FVector& Location, float MinDistance);

	void GetThreatsForLocation(TArray<class AThreatAwarenessActor*>* OutThreats, const struct FVector& Location, float MinDistance, bool bRequireLOS, class FName RoomName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThreatAwarenessSubsystem">();
	}
	static class UThreatAwarenessSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThreatAwarenessSubsystem>();
	}
};
static_assert(alignof(UThreatAwarenessSubsystem) == 0x000008, "Wrong alignment on UThreatAwarenessSubsystem");
static_assert(sizeof(UThreatAwarenessSubsystem) == 0x000088, "Wrong size on UThreatAwarenessSubsystem");
static_assert(offsetof(UThreatAwarenessSubsystem, AllThreatActors) == 0x000038, "Member 'UThreatAwarenessSubsystem::AllThreatActors' has a wrong offset!");

// Class ReadyOrNot.ThrownEvidenceActor
// 0x0038 (0x0258 - 0x0220)
class AThrownEvidenceActor final  : public AActor
{
public:
	uint8                                         Pad_29D0[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          BoxComponent;                                      // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              OwningItem;                                        // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Rep_Location;                                      // 0x0238(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rep_Rotation;                                      // 0x0244(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_29D1[0x8];                                     // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBoxHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrownEvidenceActor">();
	}
	static class AThrownEvidenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThrownEvidenceActor>();
	}
};
static_assert(alignof(AThrownEvidenceActor) == 0x000008, "Wrong alignment on AThrownEvidenceActor");
static_assert(sizeof(AThrownEvidenceActor) == 0x000258, "Wrong size on AThrownEvidenceActor");
static_assert(offsetof(AThrownEvidenceActor, BoxComponent) == 0x000228, "Member 'AThrownEvidenceActor::BoxComponent' has a wrong offset!");
static_assert(offsetof(AThrownEvidenceActor, OwningItem) == 0x000230, "Member 'AThrownEvidenceActor::OwningItem' has a wrong offset!");
static_assert(offsetof(AThrownEvidenceActor, Rep_Location) == 0x000238, "Member 'AThrownEvidenceActor::Rep_Location' has a wrong offset!");
static_assert(offsetof(AThrownEvidenceActor, Rep_Rotation) == 0x000244, "Member 'AThrownEvidenceActor::Rep_Rotation' has a wrong offset!");

// Class ReadyOrNot.TOCManager
// 0x0048 (0x0268 - 0x0220)
class ATOCManager final  : public AActor
{
public:
	uint8                                         Pad_29D3[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundSource*                           VoiceSoundSource;                                  // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             TocEvent;                                          // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTOCData                               CurrentTOCData;                                    // 0x0240(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTOCData>                       QueuedTOCData;                                     // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class ATOCManager* Get();

	void IterateTOCQueue();
	void Multicast_PlayTOCSound2D(const class FString& Filename);
	void StartTOCResponse(const class FString& Line, bool bIsNetworked, ETOCPriority Priority);
	void StopTOCAudio(bool bClearQueue);

	bool IsTOCSpeaking() const;
	bool IsTOCSpeakingLine(const class FString& Line) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TOCManager">();
	}
	static class ATOCManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATOCManager>();
	}
};
static_assert(alignof(ATOCManager) == 0x000008, "Wrong alignment on ATOCManager");
static_assert(sizeof(ATOCManager) == 0x000268, "Wrong size on ATOCManager");
static_assert(offsetof(ATOCManager, SceneComponent) == 0x000228, "Member 'ATOCManager::SceneComponent' has a wrong offset!");
static_assert(offsetof(ATOCManager, VoiceSoundSource) == 0x000230, "Member 'ATOCManager::VoiceSoundSource' has a wrong offset!");
static_assert(offsetof(ATOCManager, TocEvent) == 0x000238, "Member 'ATOCManager::TocEvent' has a wrong offset!");
static_assert(offsetof(ATOCManager, CurrentTOCData) == 0x000240, "Member 'ATOCManager::CurrentTOCData' has a wrong offset!");
static_assert(offsetof(ATOCManager, QueuedTOCData) == 0x000258, "Member 'ATOCManager::QueuedTOCData' has a wrong offset!");

// Class ReadyOrNot.ToggleDoorActivity
// 0x0008 (0x0200 - 0x01F8)
class UToggleDoorActivity final  : public UDoorInteractionActivity
{
public:
	uint8                                         Pad_29D6[0x8];                                     // 0x01F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToggleDoorActivity">();
	}
	static class UToggleDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UToggleDoorActivity>();
	}
};
static_assert(alignof(UToggleDoorActivity) == 0x000008, "Wrong alignment on UToggleDoorActivity");
static_assert(sizeof(UToggleDoorActivity) == 0x000200, "Wrong size on UToggleDoorActivity");

// Class ReadyOrNot.TrailerSearchAndSecureActivity
// 0x0038 (0x01E0 - 0x01A8)
class UTrailerSearchAndSecureActivity final  : public UBaseActivity
{
public:
	TArray<class AActor*>                         AllSecurables;                                     // 0x01A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_29D7[0x20];                                    // 0x01B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ClosestSecurable;                                  // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrailerSearchAndSecureActivity">();
	}
	static class UTrailerSearchAndSecureActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrailerSearchAndSecureActivity>();
	}
};
static_assert(alignof(UTrailerSearchAndSecureActivity) == 0x000008, "Wrong alignment on UTrailerSearchAndSecureActivity");
static_assert(sizeof(UTrailerSearchAndSecureActivity) == 0x0001E0, "Wrong size on UTrailerSearchAndSecureActivity");
static_assert(offsetof(UTrailerSearchAndSecureActivity, AllSecurables) == 0x0001A8, "Member 'UTrailerSearchAndSecureActivity::AllSecurables' has a wrong offset!");
static_assert(offsetof(UTrailerSearchAndSecureActivity, ClosestSecurable) == 0x0001D8, "Member 'UTrailerSearchAndSecureActivity::ClosestSecurable' has a wrong offset!");

// Class ReadyOrNot.TrailerSWATCharacter
// 0x0000 (0x1FE0 - 0x1FE0)
class ATrailerSWATCharacter final  : public ASWATCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrailerSWATCharacter">();
	}
	static class ATrailerSWATCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrailerSWATCharacter>();
	}
};
static_assert(alignof(ATrailerSWATCharacter) == 0x000010, "Wrong alignment on ATrailerSWATCharacter");
static_assert(sizeof(ATrailerSWATCharacter) == 0x001FE0, "Wrong size on ATrailerSWATCharacter");

// Class ReadyOrNot.TrainingGS
// 0x0008 (0x07E8 - 0x07E0)
class ATrainingGS final  : public AReadyOrNotGameState
{
public:
	uint8                                         Pad_29D8[0x8];                                     // 0x07E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainingGS">();
	}
	static class ATrainingGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrainingGS>();
	}
};
static_assert(alignof(ATrainingGS) == 0x000008, "Wrong alignment on ATrainingGS");
static_assert(sizeof(ATrainingGS) == 0x0007E8, "Wrong size on ATrainingGS");

// Class ReadyOrNot.TrainingTarget
// 0x0038 (0x0258 - 0x0220)
class ATrainingTarget final  : public AActor
{
public:
	class UStaticMeshComponent*                   TargetMesh;                                        // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          SuccessBox;                                        // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          FailureBox;                                        // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnSuccessfulShot;                                  // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGrenadeHit;                                      // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnPointDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& ShotFromDirection, class UDamageType* DamageType, class AActor* DamageCauser);
	void OnRadialDamage(class AActor* DamagedActor, float Damage, class UDamageType* DamageType, const struct FVector& Origin, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainingTarget">();
	}
	static class ATrainingTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrainingTarget>();
	}
};
static_assert(alignof(ATrainingTarget) == 0x000008, "Wrong alignment on ATrainingTarget");
static_assert(sizeof(ATrainingTarget) == 0x000258, "Wrong size on ATrainingTarget");
static_assert(offsetof(ATrainingTarget, TargetMesh) == 0x000220, "Member 'ATrainingTarget::TargetMesh' has a wrong offset!");
static_assert(offsetof(ATrainingTarget, SuccessBox) == 0x000228, "Member 'ATrainingTarget::SuccessBox' has a wrong offset!");
static_assert(offsetof(ATrainingTarget, FailureBox) == 0x000230, "Member 'ATrainingTarget::FailureBox' has a wrong offset!");
static_assert(offsetof(ATrainingTarget, OnSuccessfulShot) == 0x000238, "Member 'ATrainingTarget::OnSuccessfulShot' has a wrong offset!");
static_assert(offsetof(ATrainingTarget, OnGrenadeHit) == 0x000248, "Member 'ATrainingTarget::OnGrenadeHit' has a wrong offset!");

// Class ReadyOrNot.TrapActor
// 0x00C0 (0x02E0 - 0x0220)
class ATrapActor : public AActor
{
public:
	uint8                                         Pad_29DE[0x28];                                    // 0x0220(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   TrapMeshComponent;                                 // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    TrapActivateAudioComponent;                        // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 InteractableComponent;                             // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScoringComponent*                      ScoringComponent;                                  // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineComponent;                                   // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCableComponent*                        CutCableComponent1;                                // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCableComponent*                        CutCableComponent2;                                // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          TripWireTriggerComponent;                          // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIPerceptionStimuliSourceComponent*    PerceptionStimuliComp;                             // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        TrapRoot;                                          // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AttachedActor;                                     // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TrapName;                                          // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrapType                                     TrapType;                                          // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrapState                                    TrapStatus;                                        // 0x02B1(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseMultitoolWhenActivated;                     // 0x02B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitializeTrapOnBeginPlay;                        // 0x02B3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29DF[0x4];                                     // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            CableMesh;                                         // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     CableMaterial;                                     // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TrapTriggered;                                     // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_29E0[0x8];                                     // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_OnTrapDisarmed();
	void Multicast_OnTrapTriggered(class AReadyOrNotCharacter* TriggeredBy);
	void OnTrapDisarmed(class AReadyOrNotCharacter* DisarmedBy);
	void OnTrapTriggered(class AReadyOrNotCharacter* TriggeredBy);
	void Server_OnTrapDisarmed();
	void Server_OnTrapTriggered(class AReadyOrNotCharacter* TriggeredBy);
	void TrapDeInit();
	void TrapInit();
	void TrapTriggeredDelegate__DelegateSignature(class ATrapActor* Trap, class AReadyOrNotCharacter* TriggeredBy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrapActor">();
	}
	static class ATrapActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrapActor>();
	}
};
static_assert(alignof(ATrapActor) == 0x000008, "Wrong alignment on ATrapActor");
static_assert(sizeof(ATrapActor) == 0x0002E0, "Wrong size on ATrapActor");
static_assert(offsetof(ATrapActor, TrapMeshComponent) == 0x000248, "Member 'ATrapActor::TrapMeshComponent' has a wrong offset!");
static_assert(offsetof(ATrapActor, TrapActivateAudioComponent) == 0x000250, "Member 'ATrapActor::TrapActivateAudioComponent' has a wrong offset!");
static_assert(offsetof(ATrapActor, InteractableComponent) == 0x000258, "Member 'ATrapActor::InteractableComponent' has a wrong offset!");
static_assert(offsetof(ATrapActor, ScoringComponent) == 0x000260, "Member 'ATrapActor::ScoringComponent' has a wrong offset!");
static_assert(offsetof(ATrapActor, SplineComponent) == 0x000268, "Member 'ATrapActor::SplineComponent' has a wrong offset!");
static_assert(offsetof(ATrapActor, CutCableComponent1) == 0x000270, "Member 'ATrapActor::CutCableComponent1' has a wrong offset!");
static_assert(offsetof(ATrapActor, CutCableComponent2) == 0x000278, "Member 'ATrapActor::CutCableComponent2' has a wrong offset!");
static_assert(offsetof(ATrapActor, TripWireTriggerComponent) == 0x000280, "Member 'ATrapActor::TripWireTriggerComponent' has a wrong offset!");
static_assert(offsetof(ATrapActor, PerceptionStimuliComp) == 0x000288, "Member 'ATrapActor::PerceptionStimuliComp' has a wrong offset!");
static_assert(offsetof(ATrapActor, TrapRoot) == 0x000290, "Member 'ATrapActor::TrapRoot' has a wrong offset!");
static_assert(offsetof(ATrapActor, AttachedActor) == 0x000298, "Member 'ATrapActor::AttachedActor' has a wrong offset!");
static_assert(offsetof(ATrapActor, TrapName) == 0x0002A0, "Member 'ATrapActor::TrapName' has a wrong offset!");
static_assert(offsetof(ATrapActor, TrapType) == 0x0002B0, "Member 'ATrapActor::TrapType' has a wrong offset!");
static_assert(offsetof(ATrapActor, TrapStatus) == 0x0002B1, "Member 'ATrapActor::TrapStatus' has a wrong offset!");
static_assert(offsetof(ATrapActor, bCanUseMultitoolWhenActivated) == 0x0002B2, "Member 'ATrapActor::bCanUseMultitoolWhenActivated' has a wrong offset!");
static_assert(offsetof(ATrapActor, bInitializeTrapOnBeginPlay) == 0x0002B3, "Member 'ATrapActor::bInitializeTrapOnBeginPlay' has a wrong offset!");
static_assert(offsetof(ATrapActor, CableMesh) == 0x0002B8, "Member 'ATrapActor::CableMesh' has a wrong offset!");
static_assert(offsetof(ATrapActor, CableMaterial) == 0x0002C0, "Member 'ATrapActor::CableMaterial' has a wrong offset!");
static_assert(offsetof(ATrapActor, TrapTriggered) == 0x0002C8, "Member 'ATrapActor::TrapTriggered' has a wrong offset!");

// Class ReadyOrNot.TrapActorAttachedToDoor
// 0x0060 (0x0340 - 0x02E0)
class ATrapActorAttachedToDoor : public ATrapActor
{
public:
	class ADoor*                                  AttachedToDoor;                                    // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WireYPosition;                                     // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29E1[0x4];                                     // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CableTransform;                                    // 0x02F0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class USplineMeshComponent*>           CableMeshComponents;                               // 0x0320(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         CurveStrength;                                     // 0x0330(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MappedSplineLocation;                              // 0x0334(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bChunk1Destroyed : 1;                              // 0x0338(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bChunk2Destroyed : 1;                              // 0x0338(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSubdoorChunk1Destroyed : 1;                       // 0x0338(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSubdoorChunk2Destroyed : 1;                       // 0x0338(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_29E2[0x7];                                     // 0x0339(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrapActorAttachedToDoor">();
	}
	static class ATrapActorAttachedToDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrapActorAttachedToDoor>();
	}
};
static_assert(alignof(ATrapActorAttachedToDoor) == 0x000010, "Wrong alignment on ATrapActorAttachedToDoor");
static_assert(sizeof(ATrapActorAttachedToDoor) == 0x000340, "Wrong size on ATrapActorAttachedToDoor");
static_assert(offsetof(ATrapActorAttachedToDoor, AttachedToDoor) == 0x0002E0, "Member 'ATrapActorAttachedToDoor::AttachedToDoor' has a wrong offset!");
static_assert(offsetof(ATrapActorAttachedToDoor, WireYPosition) == 0x0002E8, "Member 'ATrapActorAttachedToDoor::WireYPosition' has a wrong offset!");
static_assert(offsetof(ATrapActorAttachedToDoor, CableTransform) == 0x0002F0, "Member 'ATrapActorAttachedToDoor::CableTransform' has a wrong offset!");
static_assert(offsetof(ATrapActorAttachedToDoor, CableMeshComponents) == 0x000320, "Member 'ATrapActorAttachedToDoor::CableMeshComponents' has a wrong offset!");
static_assert(offsetof(ATrapActorAttachedToDoor, CurveStrength) == 0x000330, "Member 'ATrapActorAttachedToDoor::CurveStrength' has a wrong offset!");
static_assert(offsetof(ATrapActorAttachedToDoor, MappedSplineLocation) == 0x000334, "Member 'ATrapActorAttachedToDoor::MappedSplineLocation' has a wrong offset!");

// Class ReadyOrNot.TrapDamage
// 0x0008 (0x0048 - 0x0040)
class UTrapDamage final  : public UDamageType
{
public:
	uint8                                         bDestroyAllDoorChunks : 1;                         // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29E3[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrapDamage">();
	}
	static class UTrapDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrapDamage>();
	}
};
static_assert(alignof(UTrapDamage) == 0x000008, "Wrong alignment on UTrapDamage");
static_assert(sizeof(UTrapDamage) == 0x000048, "Wrong size on UTrapDamage");

// Class ReadyOrNot.TraverseHoleActivity
// 0x00B8 (0x0260 - 0x01A8)
class alignas(0x10) UTraverseHoleActivity final  : public UBaseActivity
{
public:
	class AWallHoleTraversal*                     WallHoleTraversalActor;                            // 0x01A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIgnoreCooldown : 1;                               // 0x01B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFromNavLink : 1;                                  // 0x01B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29E4[0x7];                                     // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           EntryAnim;                                         // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ExitAnim;                                          // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           LoopAnim;                                          // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29E5[0x90];                                    // 0x01D0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Enter_EnterHole_State();
	void Enter_ExitHole_State();
	void Enter_Move_State();
	void Enter_MoveToHole_State();
	void Tick_EnterHole_State(float DeltaTime, float Uptime);
	void Tick_ExitHole_State(float DeltaTime, float Uptime);
	void Tick_Move_State(float DeltaTime, float Uptime);
	void Tick_MoveToHole_State(float DeltaTime, float Uptime);

	bool CanEnterHole() const;
	bool CanExitHole() const;
	bool ShouldMove() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraverseHoleActivity">();
	}
	static class UTraverseHoleActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraverseHoleActivity>();
	}
};
static_assert(alignof(UTraverseHoleActivity) == 0x000010, "Wrong alignment on UTraverseHoleActivity");
static_assert(sizeof(UTraverseHoleActivity) == 0x000260, "Wrong size on UTraverseHoleActivity");
static_assert(offsetof(UTraverseHoleActivity, WallHoleTraversalActor) == 0x0001A8, "Member 'UTraverseHoleActivity::WallHoleTraversalActor' has a wrong offset!");
static_assert(offsetof(UTraverseHoleActivity, EntryAnim) == 0x0001B8, "Member 'UTraverseHoleActivity::EntryAnim' has a wrong offset!");
static_assert(offsetof(UTraverseHoleActivity, ExitAnim) == 0x0001C0, "Member 'UTraverseHoleActivity::ExitAnim' has a wrong offset!");
static_assert(offsetof(UTraverseHoleActivity, LoopAnim) == 0x0001C8, "Member 'UTraverseHoleActivity::LoopAnim' has a wrong offset!");

// Class ReadyOrNot.TugOfWarButton
// 0x0048 (0x02C0 - 0x0278)
class ATugOfWarButton final  : public AInteractionActor
{
public:
	ETeamType                                     OnlyTeamUse;                                       // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29E6[0x7];                                     // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ATugOfWarMover*                         Mover;                                             // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       CurrentUser;                                       // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29E7[0x30];                                    // 0x0290(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInfluencerArrested(class APlayerCharacter* ArrestedCharacter, class APlayerCharacter* InstigatorCharacter);
	void OnInfluencerKilled(class AActor* Causer, class ACharacter* InstigatorCharacter, class ACharacter* KilledCharacter, struct FDamageEvent& DamageEvent, class APlayerState* LastPlayerState);
	void OnInfluencerStunned(class APlayerCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TugOfWarButton">();
	}
	static class ATugOfWarButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATugOfWarButton>();
	}
};
static_assert(alignof(ATugOfWarButton) == 0x000008, "Wrong alignment on ATugOfWarButton");
static_assert(sizeof(ATugOfWarButton) == 0x0002C0, "Wrong size on ATugOfWarButton");
static_assert(offsetof(ATugOfWarButton, OnlyTeamUse) == 0x000278, "Member 'ATugOfWarButton::OnlyTeamUse' has a wrong offset!");
static_assert(offsetof(ATugOfWarButton, Mover) == 0x000280, "Member 'ATugOfWarButton::Mover' has a wrong offset!");
static_assert(offsetof(ATugOfWarButton, CurrentUser) == 0x000288, "Member 'ATugOfWarButton::CurrentUser' has a wrong offset!");

// Class ReadyOrNot.TugOfWarGS
// 0x0008 (0x07E8 - 0x07E0)
class ATugOfWarGS final  : public AReadyOrNotGameState
{
public:
	class ATugOfWarMover*                         Mover;                                             // 0x07E0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TugOfWarGS">();
	}
	static class ATugOfWarGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATugOfWarGS>();
	}
};
static_assert(alignof(ATugOfWarGS) == 0x000008, "Wrong alignment on ATugOfWarGS");
static_assert(sizeof(ATugOfWarGS) == 0x0007E8, "Wrong size on ATugOfWarGS");
static_assert(offsetof(ATugOfWarGS, Mover) == 0x0007E0, "Member 'ATugOfWarGS::Mover' has a wrong offset!");

// Class ReadyOrNot.TugOfWarMover
// 0x0048 (0x0268 - 0x0220)
class ATugOfWarMover final  : public AActor
{
public:
	class USplineComponent*                       MoverPath;                                         // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 MoverMesh;                                         // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29E9[0x10];                                    // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoverSpeed;                                        // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertVictoryPositions;                           // 0x0244(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoverForward;                                     // 0x0245(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoverMoving;                                      // 0x0246(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29EA[0x1];                                     // 0x0247(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoverStartingPosition;                             // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoverCurrentPosition;                              // 0x024C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContested;                                        // 0x0250(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29EB[0x7];                                     // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerCharacter*>               Influencers;                                       // 0x0258(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TugOfWarMover">();
	}
	static class ATugOfWarMover* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATugOfWarMover>();
	}
};
static_assert(alignof(ATugOfWarMover) == 0x000008, "Wrong alignment on ATugOfWarMover");
static_assert(sizeof(ATugOfWarMover) == 0x000268, "Wrong size on ATugOfWarMover");
static_assert(offsetof(ATugOfWarMover, MoverPath) == 0x000220, "Member 'ATugOfWarMover::MoverPath' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, MoverMesh) == 0x000228, "Member 'ATugOfWarMover::MoverMesh' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, MoverSpeed) == 0x000240, "Member 'ATugOfWarMover::MoverSpeed' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, bInvertVictoryPositions) == 0x000244, "Member 'ATugOfWarMover::bInvertVictoryPositions' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, bMoverForward) == 0x000245, "Member 'ATugOfWarMover::bMoverForward' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, bMoverMoving) == 0x000246, "Member 'ATugOfWarMover::bMoverMoving' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, MoverStartingPosition) == 0x000248, "Member 'ATugOfWarMover::MoverStartingPosition' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, MoverCurrentPosition) == 0x00024C, "Member 'ATugOfWarMover::MoverCurrentPosition' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, bContested) == 0x000250, "Member 'ATugOfWarMover::bContested' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, Influencers) == 0x000258, "Member 'ATugOfWarMover::Influencers' has a wrong offset!");

// Class ReadyOrNot.TugOfWarZone
// 0x0048 (0x0268 - 0x0220)
class ATugOfWarZone final  : public AActor
{
public:
	bool                                          bZoneDisabled;                                     // 0x0220(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29EC[0x7];                                     // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ATugOfWarMover*                         Mover;                                             // 0x0228(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          Bounds;                                            // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29ED[0x30];                                    // 0x0238(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInfluencerArrested(class APlayerCharacter* ArrestedCharacter, class APlayerCharacter* InstigatorCharacter);
	void OnInfluencerKilled(class AActor* Causer, class ACharacter* InstigatorCharacter, class ACharacter* KilledCharacter, struct FDamageEvent& DamageEvent, class APlayerState* LastPlayerState);
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TugOfWarZone">();
	}
	static class ATugOfWarZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATugOfWarZone>();
	}
};
static_assert(alignof(ATugOfWarZone) == 0x000008, "Wrong alignment on ATugOfWarZone");
static_assert(sizeof(ATugOfWarZone) == 0x000268, "Wrong size on ATugOfWarZone");
static_assert(offsetof(ATugOfWarZone, bZoneDisabled) == 0x000220, "Member 'ATugOfWarZone::bZoneDisabled' has a wrong offset!");
static_assert(offsetof(ATugOfWarZone, Mover) == 0x000228, "Member 'ATugOfWarZone::Mover' has a wrong offset!");
static_assert(offsetof(ATugOfWarZone, Bounds) == 0x000230, "Member 'ATugOfWarZone::Bounds' has a wrong offset!");

// Class ReadyOrNot.TutorialGS
// 0x0320 (0x0C00 - 0x08E0)
class ATutorialGS : public ACoopGS
{
public:
	struct FTutorialMissionData                   CurrentTutorialData;                               // 0x08E0(0x01A0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  TutorialMenuLevel;                                 // 0x0A80(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelStreaming*                        TutorialMenuStreamedLevel;                         // 0x0AA8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelStreaming*                        CurrentTutorialStreamedLevel;                      // 0x0AB0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  ShootingRangeLevel;                                // 0x0AB8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  KillHouseLevel;                                    // 0x0AE0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  BasicControlsLevel;                                // 0x0B08(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  MirrorgunLevel;                                    // 0x0B30(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  StackUpLevel;                                      // 0x0B58(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  ArrestLevel;                                       // 0x0B80(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  GrenadesLevel;                                     // 0x0BA8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  MovementLevel;                                     // 0x0BD0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29F0[0x2];                                     // 0x0BF8(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFinishedUsingTutorialMenu;                        // 0x0BFA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29F1[0x5];                                     // 0x0BFB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TSoftObjectPtr<class UWorld> GetCurrentTutorialStreamedLevel();
	void OnPostUpdateSwatCommands(class USwatCommandWidget* Widget, TArray<struct FSwatCommand>* SwatCommands);
	void SetCurrentTutorialData(const struct FTutorialMissionData& TutorialData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialGS">();
	}
	static class ATutorialGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialGS>();
	}
};
static_assert(alignof(ATutorialGS) == 0x000008, "Wrong alignment on ATutorialGS");
static_assert(sizeof(ATutorialGS) == 0x000C00, "Wrong size on ATutorialGS");
static_assert(offsetof(ATutorialGS, CurrentTutorialData) == 0x0008E0, "Member 'ATutorialGS::CurrentTutorialData' has a wrong offset!");
static_assert(offsetof(ATutorialGS, TutorialMenuLevel) == 0x000A80, "Member 'ATutorialGS::TutorialMenuLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, TutorialMenuStreamedLevel) == 0x000AA8, "Member 'ATutorialGS::TutorialMenuStreamedLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, CurrentTutorialStreamedLevel) == 0x000AB0, "Member 'ATutorialGS::CurrentTutorialStreamedLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, ShootingRangeLevel) == 0x000AB8, "Member 'ATutorialGS::ShootingRangeLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, KillHouseLevel) == 0x000AE0, "Member 'ATutorialGS::KillHouseLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, BasicControlsLevel) == 0x000B08, "Member 'ATutorialGS::BasicControlsLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, MirrorgunLevel) == 0x000B30, "Member 'ATutorialGS::MirrorgunLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, StackUpLevel) == 0x000B58, "Member 'ATutorialGS::StackUpLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, ArrestLevel) == 0x000B80, "Member 'ATutorialGS::ArrestLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, GrenadesLevel) == 0x000BA8, "Member 'ATutorialGS::GrenadesLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, MovementLevel) == 0x000BD0, "Member 'ATutorialGS::MovementLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, bFinishedUsingTutorialMenu) == 0x000BFA, "Member 'ATutorialGS::bFinishedUsingTutorialMenu' has a wrong offset!");

// Class ReadyOrNot.TutorialMenu
// 0x0008 (0x0280 - 0x0278)
class UTutorialMenu : public UBaseWidget
{
public:
	uint8                                         Pad_29F2[0x8];                                     // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialMenu">();
	}
	static class UTutorialMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialMenu>();
	}
};
static_assert(alignof(UTutorialMenu) == 0x000008, "Wrong alignment on UTutorialMenu");
static_assert(sizeof(UTutorialMenu) == 0x000280, "Wrong size on UTutorialMenu");

// Class ReadyOrNot.TutorialMessageVolume
// 0x0050 (0x02A0 - 0x0250)
class ATutorialMessageVolume final  : public AReadyOrNotTriggerVolume
{
public:
	class FString                                 MessageMapID;                                      // 0x0250(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBigPopUp;                                       // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasDisplayedMessage;                              // 0x0261(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29F3[0x6];                                     // 0x0262(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MessageTitle;                                      // 0x0268(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FText>                           MessageContent;                                    // 0x0280(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTutorialActionPromptSlot>      MessageActions;                                    // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void GenerateMessageContent();
	void TutorialBoxBeginOverlap(class AActor* ThisActor, class AActor* OtherActor);
	void TutorialBoxEndOverlap(class AActor* ThisActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialMessageVolume">();
	}
	static class ATutorialMessageVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialMessageVolume>();
	}
};
static_assert(alignof(ATutorialMessageVolume) == 0x000008, "Wrong alignment on ATutorialMessageVolume");
static_assert(sizeof(ATutorialMessageVolume) == 0x0002A0, "Wrong size on ATutorialMessageVolume");
static_assert(offsetof(ATutorialMessageVolume, MessageMapID) == 0x000250, "Member 'ATutorialMessageVolume::MessageMapID' has a wrong offset!");
static_assert(offsetof(ATutorialMessageVolume, bIsBigPopUp) == 0x000260, "Member 'ATutorialMessageVolume::bIsBigPopUp' has a wrong offset!");
static_assert(offsetof(ATutorialMessageVolume, bHasDisplayedMessage) == 0x000261, "Member 'ATutorialMessageVolume::bHasDisplayedMessage' has a wrong offset!");
static_assert(offsetof(ATutorialMessageVolume, MessageTitle) == 0x000268, "Member 'ATutorialMessageVolume::MessageTitle' has a wrong offset!");
static_assert(offsetof(ATutorialMessageVolume, MessageContent) == 0x000280, "Member 'ATutorialMessageVolume::MessageContent' has a wrong offset!");
static_assert(offsetof(ATutorialMessageVolume, MessageActions) == 0x000290, "Member 'ATutorialMessageVolume::MessageActions' has a wrong offset!");

// Class ReadyOrNot.UObjectListener
// 0x0010 (0x0230 - 0x0220)
class AUObjectListener final  : public AActor
{
public:
	uint8                                         Pad_29F4[0x10];                                    // 0x0220(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UObjectListener">();
	}
	static class AUObjectListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUObjectListener>();
	}
};
static_assert(alignof(AUObjectListener) == 0x000008, "Wrong alignment on AUObjectListener");
static_assert(sizeof(AUObjectListener) == 0x000230, "Wrong size on AUObjectListener");

// Class ReadyOrNot.UseabilityInterface
// 0x0000 (0x0028 - 0x0028)
class IUseabilityInterface final  : public IInterface
{
public:
	void DoubleTapInteract(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent);
	void EndFire(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent);
	void EndInteract(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent);
	void Fire(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent);
	void Interact(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent);
	void MeleeInteract(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent);
	void OnFocusGain(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent);
	void OnFocusLost(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent);

	bool CanInteract() const;
	bool CanInteractThroughHitActors(struct FHitResult& Hit) const;
	class FText DetermineActionText() const;
	class FName DetermineAnimatedIcon() const;
	float DetermineCurrentProgress() const;
	EInputEvent DetermineInputEvent() const;
	float DetermineInteractionDistance() const;
	class UInteractableComponent* GetInteractableComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UseabilityInterface">();
	}
	static class IUseabilityInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUseabilityInterface>();
	}
};
static_assert(alignof(IUseabilityInterface) == 0x000008, "Wrong alignment on IUseabilityInterface");
static_assert(sizeof(IUseabilityInterface) == 0x000028, "Wrong size on IUseabilityInterface");

// Class ReadyOrNot.VIPEscortGM
// 0x0050 (0x0820 - 0x07D0)
class AVIPEscortGM final  : public AReadyOrNotGameMode_PVP
{
public:
	FMulticastInlineDelegateProperty_             OnVIPKilled;                                       // 0x07D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVIPFreed;                                        // 0x07E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APlayerController*                      VIPPlayer;                                         // 0x07F0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerStart_VIP_Spawn*                 ChosenVIPSpawn;                                    // 0x07F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APlayerCharacter>           VIPCharacterClass;                                 // 0x0800(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VIPSpawnTag;                                       // 0x0808(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToDeliverVIP;                                  // 0x0810(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HostageHoldTime;                                   // 0x0814(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29F6[0x8];                                     // 0x0818(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsVIPAlive();
	bool IsVIPArrested();
	bool IsVIPDead();
	void OnVIPFreedSignature__DelegateSignature(class ACharacter* Freed, class ACharacter* Freer);
	void OnVIPKilledSignature__DelegateSignature(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void VIPFreed(class ACharacter* Freed, class ACharacter* Freer);
	void VIPKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);

	ETeamType GetCurrentVIPTeam() const;
	class APlayerCharacter* GetVIPCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIPEscortGM">();
	}
	static class AVIPEscortGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVIPEscortGM>();
	}
};
static_assert(alignof(AVIPEscortGM) == 0x000010, "Wrong alignment on AVIPEscortGM");
static_assert(sizeof(AVIPEscortGM) == 0x000820, "Wrong size on AVIPEscortGM");
static_assert(offsetof(AVIPEscortGM, OnVIPKilled) == 0x0007D0, "Member 'AVIPEscortGM::OnVIPKilled' has a wrong offset!");
static_assert(offsetof(AVIPEscortGM, OnVIPFreed) == 0x0007E0, "Member 'AVIPEscortGM::OnVIPFreed' has a wrong offset!");
static_assert(offsetof(AVIPEscortGM, VIPPlayer) == 0x0007F0, "Member 'AVIPEscortGM::VIPPlayer' has a wrong offset!");
static_assert(offsetof(AVIPEscortGM, ChosenVIPSpawn) == 0x0007F8, "Member 'AVIPEscortGM::ChosenVIPSpawn' has a wrong offset!");
static_assert(offsetof(AVIPEscortGM, VIPCharacterClass) == 0x000800, "Member 'AVIPEscortGM::VIPCharacterClass' has a wrong offset!");
static_assert(offsetof(AVIPEscortGM, VIPSpawnTag) == 0x000808, "Member 'AVIPEscortGM::VIPSpawnTag' has a wrong offset!");
static_assert(offsetof(AVIPEscortGM, TimeToDeliverVIP) == 0x000810, "Member 'AVIPEscortGM::TimeToDeliverVIP' has a wrong offset!");
static_assert(offsetof(AVIPEscortGM, HostageHoldTime) == 0x000814, "Member 'AVIPEscortGM::HostageHoldTime' has a wrong offset!");

// Class ReadyOrNot.VIPEscortGS
// 0x0070 (0x0850 - 0x07E0)
class AVIPEscortGS final  : public AReadyOrNotGameState
{
public:
	float                                         HoldVIP_TimeRemaining;                             // 0x07E0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVIPArrested;                                      // 0x07E4(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanKillVIP;                                       // 0x07E5(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29F7[0x2];                                     // 0x07E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       VIPCharacter;                                      // 0x07E8(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      VIPPlayer;                                         // 0x07F0(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotPlayerState*                 VIPPlayerState;                                    // 0x07F8(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     LastWinningTeam;                                   // 0x0800(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVIPSelected;                                      // 0x0801(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVIPKilled;                                        // 0x0802(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     CurrentVIPTeam;                                    // 0x0803(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29F8[0x4];                                     // 0x0804(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   RecentArrester;                                    // 0x0808(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   RecentFreer;                                       // 0x0810(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   RecentVIPKiller;                                   // 0x0818(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   VIPRescueText;                                     // 0x0820(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   VIPExecuteText;                                    // 0x0838(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void OnRep_VIPArrested();
	void OnRep_VIPKilled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIPEscortGS">();
	}
	static class AVIPEscortGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVIPEscortGS>();
	}
};
static_assert(alignof(AVIPEscortGS) == 0x000008, "Wrong alignment on AVIPEscortGS");
static_assert(sizeof(AVIPEscortGS) == 0x000850, "Wrong size on AVIPEscortGS");
static_assert(offsetof(AVIPEscortGS, HoldVIP_TimeRemaining) == 0x0007E0, "Member 'AVIPEscortGS::HoldVIP_TimeRemaining' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, bVIPArrested) == 0x0007E4, "Member 'AVIPEscortGS::bVIPArrested' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, bCanKillVIP) == 0x0007E5, "Member 'AVIPEscortGS::bCanKillVIP' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, VIPCharacter) == 0x0007E8, "Member 'AVIPEscortGS::VIPCharacter' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, VIPPlayer) == 0x0007F0, "Member 'AVIPEscortGS::VIPPlayer' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, VIPPlayerState) == 0x0007F8, "Member 'AVIPEscortGS::VIPPlayerState' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, LastWinningTeam) == 0x000800, "Member 'AVIPEscortGS::LastWinningTeam' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, bVIPSelected) == 0x000801, "Member 'AVIPEscortGS::bVIPSelected' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, bVIPKilled) == 0x000802, "Member 'AVIPEscortGS::bVIPKilled' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, CurrentVIPTeam) == 0x000803, "Member 'AVIPEscortGS::CurrentVIPTeam' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, RecentArrester) == 0x000808, "Member 'AVIPEscortGS::RecentArrester' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, RecentFreer) == 0x000810, "Member 'AVIPEscortGS::RecentFreer' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, RecentVIPKiller) == 0x000818, "Member 'AVIPEscortGS::RecentVIPKiller' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, VIPRescueText) == 0x000820, "Member 'AVIPEscortGS::VIPRescueText' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, VIPExecuteText) == 0x000838, "Member 'AVIPEscortGS::VIPExecuteText' has a wrong offset!");

// Class ReadyOrNot.VIPTriggerBox
// 0x0000 (0x0290 - 0x0290)
class AVIPTriggerBox final  : public APVPTriggerBox
{
public:
	bool IsVIPInTriggerBox(class APlayerCharacter** OutVIPCharacter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIPTriggerBox">();
	}
	static class AVIPTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVIPTriggerBox>();
	}
};
static_assert(alignof(AVIPTriggerBox) == 0x000008, "Wrong alignment on AVIPTriggerBox");
static_assert(sizeof(AVIPTriggerBox) == 0x000290, "Wrong size on AVIPTriggerBox");

// Class ReadyOrNot.VisibilityBlockingVolume
// 0x0000 (0x0258 - 0x0258)
class AVisibilityBlockingVolume final  : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisibilityBlockingVolume">();
	}
	static class AVisibilityBlockingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVisibilityBlockingVolume>();
	}
};
static_assert(alignof(AVisibilityBlockingVolume) == 0x000008, "Wrong alignment on AVisibilityBlockingVolume");
static_assert(sizeof(AVisibilityBlockingVolume) == 0x000258, "Wrong size on AVisibilityBlockingVolume");

// Class ReadyOrNot.Watch
// 0x0030 (0x0250 - 0x0220)
class AWatch final  : public AActor
{
public:
	class UStaticMeshComponent*                   WatchMesh;                                         // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   HourHandMesh;                                      // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   MinuteHandMesh;                                    // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SecondHandMesh;                                    // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DateMesh;                                          // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29FA[0x8];                                     // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Watch">();
	}
	static class AWatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWatch>();
	}
};
static_assert(alignof(AWatch) == 0x000008, "Wrong alignment on AWatch");
static_assert(sizeof(AWatch) == 0x000250, "Wrong size on AWatch");
static_assert(offsetof(AWatch, WatchMesh) == 0x000220, "Member 'AWatch::WatchMesh' has a wrong offset!");
static_assert(offsetof(AWatch, HourHandMesh) == 0x000228, "Member 'AWatch::HourHandMesh' has a wrong offset!");
static_assert(offsetof(AWatch, MinuteHandMesh) == 0x000230, "Member 'AWatch::MinuteHandMesh' has a wrong offset!");
static_assert(offsetof(AWatch, SecondHandMesh) == 0x000238, "Member 'AWatch::SecondHandMesh' has a wrong offset!");
static_assert(offsetof(AWatch, DateMesh) == 0x000240, "Member 'AWatch::DateMesh' has a wrong offset!");

// Class ReadyOrNot.WeaponCacheActor
// 0x0020 (0x0240 - 0x0220)
class AWeaponCacheActor final  : public AActor
{
public:
	TArray<TSubclassOf<class ABaseMagazineWeapon>> AvailableWeapons;                                  // 0x0220(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultScene;                                      // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        ArrowComponent;                                    // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TSubclassOf<class ABaseMagazineWeapon> GetRandomAvailableWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponCacheActor">();
	}
	static class AWeaponCacheActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeaponCacheActor>();
	}
};
static_assert(alignof(AWeaponCacheActor) == 0x000008, "Wrong alignment on AWeaponCacheActor");
static_assert(sizeof(AWeaponCacheActor) == 0x000240, "Wrong size on AWeaponCacheActor");
static_assert(offsetof(AWeaponCacheActor, AvailableWeapons) == 0x000220, "Member 'AWeaponCacheActor::AvailableWeapons' has a wrong offset!");
static_assert(offsetof(AWeaponCacheActor, DefaultScene) == 0x000230, "Member 'AWeaponCacheActor::DefaultScene' has a wrong offset!");
static_assert(offsetof(AWeaponCacheActor, ArrowComponent) == 0x000238, "Member 'AWeaponCacheActor::ArrowComponent' has a wrong offset!");

// Class ReadyOrNot.WeaponWheel_ItemStat_Base
// 0x0000 (0x0260 - 0x0260)
class UWeaponWheel_ItemStat_Base : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponWheel_ItemStat_Base">();
	}
	static class UWeaponWheel_ItemStat_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponWheel_ItemStat_Base>();
	}
};
static_assert(alignof(UWeaponWheel_ItemStat_Base) == 0x000008, "Wrong alignment on UWeaponWheel_ItemStat_Base");
static_assert(sizeof(UWeaponWheel_ItemStat_Base) == 0x000260, "Wrong size on UWeaponWheel_ItemStat_Base");

// Class ReadyOrNot.WeaponWheelScript
// 0x0040 (0x00A8 - 0x0068)
class UWeaponWheelScript final  : public UBaseRadialMenuScript
{
public:
	class FText                                   ItemName;                                          // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ItemCategory;                                      // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UWeaponWheelWidget*                     WeaponWheelOwner;                                  // 0x0098(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponWheelScript">();
	}
	static class UWeaponWheelScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponWheelScript>();
	}
};
static_assert(alignof(UWeaponWheelScript) == 0x000008, "Wrong alignment on UWeaponWheelScript");
static_assert(sizeof(UWeaponWheelScript) == 0x0000A8, "Wrong size on UWeaponWheelScript");
static_assert(offsetof(UWeaponWheelScript, ItemName) == 0x000068, "Member 'UWeaponWheelScript::ItemName' has a wrong offset!");
static_assert(offsetof(UWeaponWheelScript, ItemCategory) == 0x000080, "Member 'UWeaponWheelScript::ItemCategory' has a wrong offset!");
static_assert(offsetof(UWeaponWheelScript, WeaponWheelOwner) == 0x000098, "Member 'UWeaponWheelScript::WeaponWheelOwner' has a wrong offset!");
static_assert(offsetof(UWeaponWheelScript, PlayerCharacter) == 0x0000A0, "Member 'UWeaponWheelScript::PlayerCharacter' has a wrong offset!");

// Class ReadyOrNot.WeaponWheelWidget
// 0x0010 (0x0410 - 0x0400)
class UWeaponWheelWidget : public URadialWidgetBase
{
public:
	TArray<class FName>                           Categories;                                        // 0x0400(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	bool RemoveNullItemsFromAllCategories();
	bool RemoveNullItemsFromCategory(class FName& WeaponWheelCategoryName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponWheelWidget">();
	}
	static class UWeaponWheelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponWheelWidget>();
	}
};
static_assert(alignof(UWeaponWheelWidget) == 0x000008, "Wrong alignment on UWeaponWheelWidget");
static_assert(sizeof(UWeaponWheelWidget) == 0x000410, "Wrong size on UWeaponWheelWidget");
static_assert(offsetof(UWeaponWheelWidget, Categories) == 0x000400, "Member 'UWeaponWheelWidget::Categories' has a wrong offset!");

// Class ReadyOrNot.SpectatorCharacterHUD
// 0x0000 (0x0278 - 0x0278)
class USpectatorCharacterHUD : public UBaseWidget
{
public:
	void CenterPrint(class FName MessageType, float Duration, class APlayerCharacter* Other);
	void ChatPressed();
	void OnNewCharacterViewed(class AReadyOrNotCharacter* NewViewTarget);
	void TeamChatPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatorCharacterHUD">();
	}
	static class USpectatorCharacterHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpectatorCharacterHUD>();
	}
};
static_assert(alignof(USpectatorCharacterHUD) == 0x000008, "Wrong alignment on USpectatorCharacterHUD");
static_assert(sizeof(USpectatorCharacterHUD) == 0x000278, "Wrong size on USpectatorCharacterHUD");

// Class ReadyOrNot.WidgetsData
// 0x0220 (0x0250 - 0x0030)
class UWidgetsData final  : public UDataAsset
{
public:
	TSubclassOf<class UUserWidget>                MagCheckUI;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FireModeUI;                                        // 0x0038(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   StartupMenu;                                       // 0x0060(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AuthenticationMenu;                                // 0x0088(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MainMenu;                                          // 0x00B0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   OptionsMenu;                                       // 0x00D8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CustomizationMenu;                                 // 0x0100(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ChatBox;                                           // 0x0128(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           Overlays;                                          // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Scoreboard;                                        // 0x0160(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                LoadingScreen;                                     // 0x0188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MessageDisplayBoxClass;                            // 0x0190(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Leaderboards;                                      // 0x01B8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CrosshairOverlay;                                  // 0x01E0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     UISoundClasses;                                    // 0x0208(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EscapeMenu;                                        // 0x0218(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponWheelWidget>         WeaponWheelWidget;                                 // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBaseWidget>                ItemSelectionWidget;                               // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetsData">();
	}
	static class UWidgetsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetsData>();
	}
};
static_assert(alignof(UWidgetsData) == 0x000008, "Wrong alignment on UWidgetsData");
static_assert(sizeof(UWidgetsData) == 0x000250, "Wrong size on UWidgetsData");
static_assert(offsetof(UWidgetsData, MagCheckUI) == 0x000030, "Member 'UWidgetsData::MagCheckUI' has a wrong offset!");
static_assert(offsetof(UWidgetsData, FireModeUI) == 0x000038, "Member 'UWidgetsData::FireModeUI' has a wrong offset!");
static_assert(offsetof(UWidgetsData, StartupMenu) == 0x000060, "Member 'UWidgetsData::StartupMenu' has a wrong offset!");
static_assert(offsetof(UWidgetsData, AuthenticationMenu) == 0x000088, "Member 'UWidgetsData::AuthenticationMenu' has a wrong offset!");
static_assert(offsetof(UWidgetsData, MainMenu) == 0x0000B0, "Member 'UWidgetsData::MainMenu' has a wrong offset!");
static_assert(offsetof(UWidgetsData, OptionsMenu) == 0x0000D8, "Member 'UWidgetsData::OptionsMenu' has a wrong offset!");
static_assert(offsetof(UWidgetsData, CustomizationMenu) == 0x000100, "Member 'UWidgetsData::CustomizationMenu' has a wrong offset!");
static_assert(offsetof(UWidgetsData, ChatBox) == 0x000128, "Member 'UWidgetsData::ChatBox' has a wrong offset!");
static_assert(offsetof(UWidgetsData, Overlays) == 0x000150, "Member 'UWidgetsData::Overlays' has a wrong offset!");
static_assert(offsetof(UWidgetsData, Scoreboard) == 0x000160, "Member 'UWidgetsData::Scoreboard' has a wrong offset!");
static_assert(offsetof(UWidgetsData, LoadingScreen) == 0x000188, "Member 'UWidgetsData::LoadingScreen' has a wrong offset!");
static_assert(offsetof(UWidgetsData, MessageDisplayBoxClass) == 0x000190, "Member 'UWidgetsData::MessageDisplayBoxClass' has a wrong offset!");
static_assert(offsetof(UWidgetsData, Leaderboards) == 0x0001B8, "Member 'UWidgetsData::Leaderboards' has a wrong offset!");
static_assert(offsetof(UWidgetsData, CrosshairOverlay) == 0x0001E0, "Member 'UWidgetsData::CrosshairOverlay' has a wrong offset!");
static_assert(offsetof(UWidgetsData, UISoundClasses) == 0x000208, "Member 'UWidgetsData::UISoundClasses' has a wrong offset!");
static_assert(offsetof(UWidgetsData, EscapeMenu) == 0x000218, "Member 'UWidgetsData::EscapeMenu' has a wrong offset!");
static_assert(offsetof(UWidgetsData, WeaponWheelWidget) == 0x000240, "Member 'UWidgetsData::WeaponWheelWidget' has a wrong offset!");
static_assert(offsetof(UWidgetsData, ItemSelectionWidget) == 0x000248, "Member 'UWidgetsData::ItemSelectionWidget' has a wrong offset!");

// Class ReadyOrNot.WorldBuildingPlacementActor
// 0x0028 (0x0248 - 0x0220)
class AWorldBuildingPlacementActor final  : public AActor
{
public:
	TSubclassOf<class UWorldBuildingActivity>     Activity;                                          // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticController*                  InUseByController;                                 // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorldBuildingActivity*                 ActivityInstance;                                  // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoveActivity*                          MoveToActivityInstance;                            // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultScene;                                      // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnWorldBuildingActivityFinished(class UBaseActivity* InActivity, class ACyberneticController* CyberneticController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldBuildingPlacementActor">();
	}
	static class AWorldBuildingPlacementActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldBuildingPlacementActor>();
	}
};
static_assert(alignof(AWorldBuildingPlacementActor) == 0x000008, "Wrong alignment on AWorldBuildingPlacementActor");
static_assert(sizeof(AWorldBuildingPlacementActor) == 0x000248, "Wrong size on AWorldBuildingPlacementActor");
static_assert(offsetof(AWorldBuildingPlacementActor, Activity) == 0x000220, "Member 'AWorldBuildingPlacementActor::Activity' has a wrong offset!");
static_assert(offsetof(AWorldBuildingPlacementActor, InUseByController) == 0x000228, "Member 'AWorldBuildingPlacementActor::InUseByController' has a wrong offset!");
static_assert(offsetof(AWorldBuildingPlacementActor, ActivityInstance) == 0x000230, "Member 'AWorldBuildingPlacementActor::ActivityInstance' has a wrong offset!");
static_assert(offsetof(AWorldBuildingPlacementActor, MoveToActivityInstance) == 0x000238, "Member 'AWorldBuildingPlacementActor::MoveToActivityInstance' has a wrong offset!");
static_assert(offsetof(AWorldBuildingPlacementActor, DefaultScene) == 0x000240, "Member 'AWorldBuildingPlacementActor::DefaultScene' has a wrong offset!");

// Class ReadyOrNot.WorldGenSave
// 0x0040 (0x0068 - 0x0028)
class UWorldGenSave final  : public USaveGame
{
public:
	TArray<struct FSavedThreatAwarenessActor>     SavedThreatAwarenessActors;                        // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedDoorActor>                SavedDoorActors;                                   // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedCoverActor>               SavedCoverActors;                                  // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedRoomData>                 SavedRooms;                                        // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldGenSave">();
	}
	static class UWorldGenSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldGenSave>();
	}
};
static_assert(alignof(UWorldGenSave) == 0x000008, "Wrong alignment on UWorldGenSave");
static_assert(sizeof(UWorldGenSave) == 0x000068, "Wrong size on UWorldGenSave");
static_assert(offsetof(UWorldGenSave, SavedThreatAwarenessActors) == 0x000028, "Member 'UWorldGenSave::SavedThreatAwarenessActors' has a wrong offset!");
static_assert(offsetof(UWorldGenSave, SavedDoorActors) == 0x000038, "Member 'UWorldGenSave::SavedDoorActors' has a wrong offset!");
static_assert(offsetof(UWorldGenSave, SavedCoverActors) == 0x000048, "Member 'UWorldGenSave::SavedCoverActors' has a wrong offset!");
static_assert(offsetof(UWorldGenSave, SavedRooms) == 0x000058, "Member 'UWorldGenSave::SavedRooms' has a wrong offset!");

// Class ReadyOrNot.WorldDataGenerator
// 0x0070 (0x0290 - 0x0220)
class AWorldDataGenerator final  : public AInfo
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          VisitedDoors;                                      // 0x0228(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_29FD[0x1];                                     // 0x0238(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasWorldEverBeenGenerated;                        // 0x0239(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29FE[0x6];                                     // 0x023A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AThreatAwarenessActor*>          IgnoredExitThreats;                                // 0x0240(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_29FF[0x1];                                     // 0x0250(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDoorwaysBlocked;                                  // 0x0251(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A00[0x6];                                     // 0x0252(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRoomGenData                           RoomData;                                          // 0x0258(0x0020)(Edit, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A01[0x18];                                    // 0x0278(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlockAllDoorways();
	void CalculateAllExits();
	void ClearNullReferences();
	void DestroyAllStackups();
	void DestroyAllThreats();
	void DestroyCoverPoints();
	void GenerateAllDoorClearPoints();
	void GenerateAllDoorPositions();
	void GenerateAllDoorThreatAwarenessActors();
	void GenerateCoverPoints();
	void GenerateRooms();
	void GenerateStackUpPoints();
	void GenerateWorld();
	void GenerateWorldThreatAwarenessActors();
	void ReportAllUnreachableSpawns();
	void UnblockAllDoorways();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldDataGenerator">();
	}
	static class AWorldDataGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldDataGenerator>();
	}
};
static_assert(alignof(AWorldDataGenerator) == 0x000008, "Wrong alignment on AWorldDataGenerator");
static_assert(sizeof(AWorldDataGenerator) == 0x000290, "Wrong size on AWorldDataGenerator");
static_assert(offsetof(AWorldDataGenerator, SceneComponent) == 0x000220, "Member 'AWorldDataGenerator::SceneComponent' has a wrong offset!");
static_assert(offsetof(AWorldDataGenerator, VisitedDoors) == 0x000228, "Member 'AWorldDataGenerator::VisitedDoors' has a wrong offset!");
static_assert(offsetof(AWorldDataGenerator, bHasWorldEverBeenGenerated) == 0x000239, "Member 'AWorldDataGenerator::bHasWorldEverBeenGenerated' has a wrong offset!");
static_assert(offsetof(AWorldDataGenerator, IgnoredExitThreats) == 0x000240, "Member 'AWorldDataGenerator::IgnoredExitThreats' has a wrong offset!");
static_assert(offsetof(AWorldDataGenerator, bDoorwaysBlocked) == 0x000251, "Member 'AWorldDataGenerator::bDoorwaysBlocked' has a wrong offset!");
static_assert(offsetof(AWorldDataGenerator, RoomData) == 0x000258, "Member 'AWorldDataGenerator::RoomData' has a wrong offset!");

// Class ReadyOrNot.WorldTutorial
// 0x00B8 (0x02D8 - 0x0220)
class AWorldTutorial final  : public AActor
{
public:
	class AActor*                                 AttachedObject;                                    // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTutorialWidgetData                    WidgetData;                                        // 0x0228(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bEnableScreenspaceMarker;                          // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTutorialLocationForScreenspaceMarker;          // 0x02A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitForCompletionClose;                           // 0x02A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetAfterCompletion;                             // 0x02A3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoginsUntilInvalid;                                // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETooltipActivationType                        TutorialActivationType;                            // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScreenspaceMarkerType                        ScreenspaceMarkerType;                             // 0x02A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETutorialWidgetLocation                       TutorialWidgetLocation;                            // 0x02AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A02[0x1];                                     // 0x02AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TutorialActivationDistance;                        // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayerInRange;                                  // 0x02B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTutorialVisible;                                // 0x02B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A03[0x6];                                     // 0x02B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTutorialWidget*                        TutorialWidget;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       ActivationComponent;                               // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A04[0x10];                                    // 0x02C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CompletionEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldTutorial">();
	}
	static class AWorldTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldTutorial>();
	}
};
static_assert(alignof(AWorldTutorial) == 0x000008, "Wrong alignment on AWorldTutorial");
static_assert(sizeof(AWorldTutorial) == 0x0002D8, "Wrong size on AWorldTutorial");
static_assert(offsetof(AWorldTutorial, AttachedObject) == 0x000220, "Member 'AWorldTutorial::AttachedObject' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, WidgetData) == 0x000228, "Member 'AWorldTutorial::WidgetData' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, bEnableScreenspaceMarker) == 0x0002A0, "Member 'AWorldTutorial::bEnableScreenspaceMarker' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, bUseTutorialLocationForScreenspaceMarker) == 0x0002A1, "Member 'AWorldTutorial::bUseTutorialLocationForScreenspaceMarker' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, bWaitForCompletionClose) == 0x0002A2, "Member 'AWorldTutorial::bWaitForCompletionClose' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, bResetAfterCompletion) == 0x0002A3, "Member 'AWorldTutorial::bResetAfterCompletion' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, LoginsUntilInvalid) == 0x0002A4, "Member 'AWorldTutorial::LoginsUntilInvalid' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, TutorialActivationType) == 0x0002A8, "Member 'AWorldTutorial::TutorialActivationType' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, ScreenspaceMarkerType) == 0x0002A9, "Member 'AWorldTutorial::ScreenspaceMarkerType' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, TutorialWidgetLocation) == 0x0002AA, "Member 'AWorldTutorial::TutorialWidgetLocation' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, TutorialActivationDistance) == 0x0002AC, "Member 'AWorldTutorial::TutorialActivationDistance' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, bIsPlayerInRange) == 0x0002B0, "Member 'AWorldTutorial::bIsPlayerInRange' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, bIsTutorialVisible) == 0x0002B1, "Member 'AWorldTutorial::bIsTutorialVisible' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, TutorialWidget) == 0x0002B8, "Member 'AWorldTutorial::TutorialWidget' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, ActivationComponent) == 0x0002C0, "Member 'AWorldTutorial::ActivationComponent' has a wrong offset!");

// Class ReadyOrNot.ZeuzMatchmakingWidget
// 0x0120 (0x0380 - 0x0260)
class UZeuzMatchmakingWidget final  : public UUserWidget
{
public:
	uint8                                         Pad_2A05[0x48];                                    // 0x0260(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	EMatchmakingStatus                            MatchmakingStatus;                                 // 0x02A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A06[0x7];                                     // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FZeuzMatchMakingStatus                 ZeuzMatchMakingStatus;                             // 0x02B0(0x00D0)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void MatchmakingUpdate();
	void OnZeuzMatchmakingCreate(struct FZeuzMatchMakingStatus& Status, const class FString& Error);
	void OnZeuzMatchmakingUpdate(struct FZeuzMatchMakingStatus& Status, const class FString& Error);
	void ResetMatchmaking();
	void StartMatchmaking(const class FString& Region);
	void StartPartyMatchmaking();
	void StopMatchmaking();
	void StopPartyMatchmaking();
	void TryConnectServer(const class FString& ConnectIp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZeuzMatchmakingWidget">();
	}
	static class UZeuzMatchmakingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZeuzMatchmakingWidget>();
	}
};
static_assert(alignof(UZeuzMatchmakingWidget) == 0x000008, "Wrong alignment on UZeuzMatchmakingWidget");
static_assert(sizeof(UZeuzMatchmakingWidget) == 0x000380, "Wrong size on UZeuzMatchmakingWidget");
static_assert(offsetof(UZeuzMatchmakingWidget, MatchmakingStatus) == 0x0002A8, "Member 'UZeuzMatchmakingWidget::MatchmakingStatus' has a wrong offset!");
static_assert(offsetof(UZeuzMatchmakingWidget, ZeuzMatchMakingStatus) == 0x0002B0, "Member 'UZeuzMatchmakingWidget::ZeuzMatchMakingStatus' has a wrong offset!");

// Class ReadyOrNot.Zipcuffs
// 0x0110 (0x0AE0 - 0x09D0)
class AZipcuffs : public ABaseItem
{
public:
	class APlayerCharacter*                       PendingArrestCharacter;                            // 0x09D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   TargetedCharacter;                                 // 0x09D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArresting;                                        // 0x09E0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A07[0x7];                                     // 0x09E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArrestMaxDistance;                                 // 0x09E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A08[0x4];                                     // 0x09EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     ArrestCollisionChannels;                           // 0x09F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UseZipcuffs_1P;                                    // 0x0A00(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UseZipcuffs_3P;                                    // 0x0A08(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrestTime;                                        // 0x0A10(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A09[0xC];                                     // 0x0A14(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionsData*                      ForcedInteractionData;                             // 0x0A20(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInteractionsData*>              StandingArrestInteractionSuspects;                 // 0x0A28(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UInteractionsData*>              StandingArrestInteractionCivilians;                // 0x0A38(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UInteractionsData*>              PvPArrestInteraction;                              // 0x0A48(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UInteractionsData*                      ArrestRagdoll_Up;                                  // 0x0A58(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractionsData*                      ArrestRagdoll_Down;                                // 0x0A60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractionsData*                      ArrestRagdoll_Left;                                // 0x0A68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractionsData*                      ArrestRagdoll_Right;                               // 0x0A70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APlacedZipcuffs>            SpawnedZipcuffsClass;                              // 0x0A78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ZipcuffBone;                                       // 0x0A80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0A[0x8];                                     // 0x0A88(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnCuffsTransform;                               // 0x0A90(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnCuffsRelativeRotation;                        // 0x0AC0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                SpawnCuffsRelativeTranslation;                     // 0x0ACC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODZipcuffsArrest;                                // 0x0AD8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Client_ArrestComplete();
	void Multicast_OnRagdollArrestStart(class AReadyOrNotCharacter* ArrestTarget);
	void OnRagdollArrestComplete_Driver(class AActor* Driver);
	void OnRagdollArrestComplete_Slave(class AActor* Slave);
	void OnRagdollArrestInteractionStarted();
	void Server_ArrestCancelled();
	void Server_ArrestComplete();
	void Server_ArrestStart(class AReadyOrNotCharacter* TargetedChar);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Zipcuffs">();
	}
	static class AZipcuffs* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZipcuffs>();
	}
};
static_assert(alignof(AZipcuffs) == 0x000010, "Wrong alignment on AZipcuffs");
static_assert(sizeof(AZipcuffs) == 0x000AE0, "Wrong size on AZipcuffs");
static_assert(offsetof(AZipcuffs, PendingArrestCharacter) == 0x0009D0, "Member 'AZipcuffs::PendingArrestCharacter' has a wrong offset!");
static_assert(offsetof(AZipcuffs, TargetedCharacter) == 0x0009D8, "Member 'AZipcuffs::TargetedCharacter' has a wrong offset!");
static_assert(offsetof(AZipcuffs, bArresting) == 0x0009E0, "Member 'AZipcuffs::bArresting' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ArrestMaxDistance) == 0x0009E8, "Member 'AZipcuffs::ArrestMaxDistance' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ArrestCollisionChannels) == 0x0009F0, "Member 'AZipcuffs::ArrestCollisionChannels' has a wrong offset!");
static_assert(offsetof(AZipcuffs, UseZipcuffs_1P) == 0x000A00, "Member 'AZipcuffs::UseZipcuffs_1P' has a wrong offset!");
static_assert(offsetof(AZipcuffs, UseZipcuffs_3P) == 0x000A08, "Member 'AZipcuffs::UseZipcuffs_3P' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ArrestTime) == 0x000A10, "Member 'AZipcuffs::ArrestTime' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ForcedInteractionData) == 0x000A20, "Member 'AZipcuffs::ForcedInteractionData' has a wrong offset!");
static_assert(offsetof(AZipcuffs, StandingArrestInteractionSuspects) == 0x000A28, "Member 'AZipcuffs::StandingArrestInteractionSuspects' has a wrong offset!");
static_assert(offsetof(AZipcuffs, StandingArrestInteractionCivilians) == 0x000A38, "Member 'AZipcuffs::StandingArrestInteractionCivilians' has a wrong offset!");
static_assert(offsetof(AZipcuffs, PvPArrestInteraction) == 0x000A48, "Member 'AZipcuffs::PvPArrestInteraction' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ArrestRagdoll_Up) == 0x000A58, "Member 'AZipcuffs::ArrestRagdoll_Up' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ArrestRagdoll_Down) == 0x000A60, "Member 'AZipcuffs::ArrestRagdoll_Down' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ArrestRagdoll_Left) == 0x000A68, "Member 'AZipcuffs::ArrestRagdoll_Left' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ArrestRagdoll_Right) == 0x000A70, "Member 'AZipcuffs::ArrestRagdoll_Right' has a wrong offset!");
static_assert(offsetof(AZipcuffs, SpawnedZipcuffsClass) == 0x000A78, "Member 'AZipcuffs::SpawnedZipcuffsClass' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ZipcuffBone) == 0x000A80, "Member 'AZipcuffs::ZipcuffBone' has a wrong offset!");
static_assert(offsetof(AZipcuffs, SpawnCuffsTransform) == 0x000A90, "Member 'AZipcuffs::SpawnCuffsTransform' has a wrong offset!");
static_assert(offsetof(AZipcuffs, SpawnCuffsRelativeRotation) == 0x000AC0, "Member 'AZipcuffs::SpawnCuffsRelativeRotation' has a wrong offset!");
static_assert(offsetof(AZipcuffs, SpawnCuffsRelativeTranslation) == 0x000ACC, "Member 'AZipcuffs::SpawnCuffsRelativeTranslation' has a wrong offset!");
static_assert(offsetof(AZipcuffs, FMODZipcuffsArrest) == 0x000AD8, "Member 'AZipcuffs::FMODZipcuffsArrest' has a wrong offset!");

}

