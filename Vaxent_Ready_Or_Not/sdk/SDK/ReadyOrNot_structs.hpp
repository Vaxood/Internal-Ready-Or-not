#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ReadyOrNot

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "SlateCore_structs.hpp"
#include "InputCore_structs.hpp"
#include "DynamicCoverSystem_structs.hpp"
#include "UMG_structs.hpp"
#include "Debug_structs.hpp"
#include "Slate_structs.hpp"


namespace SDK
{

// Enum ReadyOrNot.EItemCategory
// NumValues: 0x0034
enum class EItemCategory : uint8
{
	IC_None                                  = 0,
	IC_Primary                               = 1,
	IC_Secondary                             = 2,
	IC_Grenade                               = 3,
	IC_Gadget                                = 4,
	IC_Magazine                              = 5,
	IC_Helmet                                = 6,
	IC_Helmet_Light                          = 7,
	IC_Headset                               = 8,
	IC_Goggles                               = 9,
	IC_Chest                                 = 10,
	IC_Watch                                 = 11,
	IC_Radio                                 = 12,
	IC_NVG                                   = 13,
	IC_UseableWithShield                     = 14,
	IC_Grenade_Keybind1                      = 15,
	IC_Grenade_Keybind2                      = 16,
	IC_Grenade_Keybind3                      = 17,
	IC_Grenade_Keybind4                      = 18,
	IC_Device_Keybind1                       = 19,
	IC_Device_Keybind2                       = 20,
	IC_Device_Keybind3                       = 21,
	IC_Device_Keybind4                       = 22,
	IC_Badge_Armour                          = 23,
	IC_OCSpray                               = 24,
	IC_Multitool                             = 25,
	IC_Zipcuffs                              = 26,
	IC_Armor                                 = 27,
	IC_Chemlight                             = 28,
	IC_Shield                                = 29,
	IC_Flashbang                             = 30,
	IC_Ninebang                              = 31,
	IC_CSGas                                 = 32,
	IC_Stingball                             = 33,
	IC_Optiwand                              = 34,
	IC_Beanbag                               = 35,
	IC_Taser                                 = 36,
	IC_Pepperball                            = 37,
	IC_C2Explosive                           = 38,
	IC_Detonator                             = 39,
	IC_Doorjam                               = 40,
	IC_BatteringRam                          = 41,
	IC_BreachingShotgun                      = 42,
	IC_Tablet                                = 43,
	IC_TacticalDevice                        = 44,
	IC_LongTactical                          = 45,
	IC_GasMask                               = 46,
	IC_Launcher                              = 47,
	IC_MedicalKit                            = 48,
	IC_LockpickGun                           = 49,
	IC_Shotgun                               = 50,
	IC_MAX                                   = 51,
};

// Enum ReadyOrNot.EBlockingAnimationExclusion
// NumValues: 0x0008
enum class EBlockingAnimationExclusion : uint8
{
	BAE_None                                 = 0,
	BAE_Holster                              = 1,
	BAE_Draw                                 = 2,
	BAE_FireSelect                           = 3,
	BAE_MagCheck                             = 4,
	BAE_PullPin                              = 5,
	BAE_Throw                                = 6,
	BAE_MAX                                  = 7,
};

// Enum ReadyOrNot.EStunType
// NumValues: 0x000A
enum class EStunType : uint8
{
	ST_None                                  = 0,
	ST_Tased                                 = 1,
	ST_Gassed                                = 2,
	ST_Flash                                 = 3,
	ST_Stung                                 = 4,
	ST_Beanbag                               = 5,
	ST_Pepperball                            = 6,
	ST_Rubberball                            = 7,
	ST_Pepperspray                           = 8,
	ST_MAX                                   = 9,
};

// Enum ReadyOrNot.EItemAttachment
// NumValues: 0x0004
enum class EItemAttachment : uint8
{
	IA_None                                  = 0,
	IA_Flashlight                            = 1,
	IA_NVG                                   = 2,
	IA_MAX                                   = 3,
};

// Enum ReadyOrNot.EMotionBlockType
// NumValues: 0x0008
enum class EMotionBlockType : uint8
{
	MB_None                                  = 0,
	MB_Rifle                                 = 1,
	MB_Pistol                                = 2,
	MB_Item                                  = 3,
	MB_HeavyItem                             = 4,
	MB_Special                               = 5,
	MB_Unarmed                               = 6,
	MB_MAX                                   = 7,
};

// Enum ReadyOrNot.EWeaponType
// NumValues: 0x000B
enum class EWeaponType : uint8
{
	WT_None                                  = 0,
	WT_Rifles                                = 1,
	WT_SubmachineGun                         = 2,
	WT_Shotgun                               = 3,
	WT_PistolsLethal                         = 4,
	WT_PistolsNonLethal                      = 5,
	WT_PrimaryNonLethal                      = 6,
	WT_Launcher                              = 7,
	WT_Special                               = 8,
	WT_Unarmed                               = 9,
	WT_MAX                                   = 10,
};

// Enum ReadyOrNot.EGameVersionRestriction
// NumValues: 0x0006
enum class EGameVersionRestriction : uint8
{
	GVR_NoRestriction                        = 0,
	GVR_Base                                 = 1,
	GVR_Supporter                            = 2,
	GVR_PreorderBonus                        = 3,
	GVR_Demo                                 = 255,
	GVR_MAX                                  = 256,
};

// Enum ReadyOrNot.EItemType
// NumValues: 0x001E
enum class EItemType : uint8
{
	IT_None                                  = 0,
	IT_Rifles                                = 1,
	IT_SubmachineGun                         = 2,
	IT_LightMachineGun                       = 3,
	IT_Shotgun                               = 4,
	IT_Sniper                                = 5,
	IT_PistolsLethal                         = 6,
	IT_PistolsNonLethal                      = 7,
	IT_PrimaryNonLethal                      = 8,
	IT_Launcher                              = 9,
	IT_Melee                                 = 10,
	IT_LessLethal                            = 11,
	IT_Headwear                              = 12,
	IT_BodyArmor                             = 13,
	IT_Grenade                               = 14,
	IT_GrenadeNonLethal                      = 15,
	IT_TacticalDevice                        = 16,
	IT_TacticalDeviceNonLethal               = 17,
	IT_TacticalOne                           = 18,
	IT_TacticalTwo                           = 19,
	IT_TacticalThree                         = 20,
	IT_TacticalFour                          = 21,
	IT_TacticalFive                          = 22,
	IT_TacticalSix                           = 23,
	IT_TacticalSeven                         = 24,
	IT_TacticalEight                         = 25,
	IT_LongTactical                          = 26,
	IT_Skins                                 = 27,
	IT_Loadouts                              = 28,
	IT_MAX                                   = 29,
};

// Enum ReadyOrNot.EItemClass
// NumValues: 0x0015
enum class EItemClass : uint8
{
	IC_NoClass                               = 0,
	IC_AssaultRifle                          = 1,
	IC_SMG                                   = 2,
	IC_LMG                                   = 3,
	IC_Pistol                                = 4,
	IC_Sniper                                = 5,
	IC_Melee                                 = 6,
	IC_LessLethal                            = 7,
	IC_Shotgun                               = 8,
	IC_Launcher                              = 9,
	IC_Grenade                               = 10,
	IC_Shield                                = 11,
	IC_Armor                                 = 12,
	IC_Headgear                              = 13,
	IC_TacticalDevice                        = 14,
	IC_LongTactical                          = 15,
	IC_Officer                               = 16,
	IC_Uniform                               = 17,
	IC_Plates                                = 18,
	IC_Patches                               = 19,
	IC_MAX                                   = 20,
};

// Enum ReadyOrNot.EGrenadeType
// NumValues: 0x0008
enum class EGrenadeType : uint8
{
	None                                     = 0,
	Flashbang                                = 1,
	Stinger                                  = 2,
	Gas                                      = 3,
	Smoke                                    = 4,
	Frag                                     = 5,
	Custom                                   = 6,
	EGrenadeType_MAX                         = 7,
};

// Enum ReadyOrNot.EWeaponUnderbarrelAnimationType
// NumValues: 0x0005
enum class EWeaponUnderbarrelAnimationType : uint8
{
	WU_None                                  = 0,
	WU_VFG                                   = 1,
	WU_AFG                                   = 2,
	WU_Handstop                              = 3,
	WU_MAX                                   = 4,
};

// Enum ReadyOrNot.EFireMode
// NumValues: 0x0006
enum class EFireMode : uint8
{
	FM_Single                                = 0,
	FM_Auto                                  = 1,
	FM_Burst                                 = 2,
	FM_Continuous                            = 3,
	FM_Safe                                  = 4,
	FM_MAX                                   = 5,
};

// Enum ReadyOrNot.EReloadAnimEvent
// NumValues: 0x0009
enum class EReloadAnimEvent : uint8
{
	RAE_MagIn                                = 0,
	RAE_MagOut                               = 1,
	RAE_MagInQuick                           = 2,
	RAE_MagOutQuick                          = 3,
	RAE_BoltClosed                           = 4,
	RAE_BoltClosedQuick                      = 5,
	RAE_BoltOpened                           = 6,
	RAE_BoltOpenedQuick                      = 7,
	RAE_MAX                                  = 8,
};

// Enum ReadyOrNot.EDoorDamageType
// NumValues: 0x0007
enum class EDoorDamageType : uint8
{
	DDT_None                                 = 0,
	DDT_Blasting                             = 1,
	DDT_Shotgunning                          = 2,
	DDT_Ramming                              = 3,
	DDT_Kicking                              = 4,
	DDT_Bash                                 = 5,
	DDT_MAX                                  = 6,
};

// Enum ReadyOrNot.EStackupGenArea
// NumValues: 0x0007
enum class EStackupGenArea : uint8
{
	SGA_None                                 = 0,
	SGA_FrontLeft                            = 1,
	SGA_FrontRight                           = 2,
	SGA_BackLeft                             = 3,
	SGA_BackRight                            = 4,
	SGA_All                                  = 5,
	SGA_MAX                                  = 6,
};

// Enum ReadyOrNot.EActorOutlineType
// NumValues: 0x0008
enum class EActorOutlineType : uint8
{
	Outline_0                                = 0,
	Outline_1                                = 1,
	Outline_2                                = 2,
	Outline_3                                = 3,
	Outline_4                                = 4,
	Outline_5                                = 5,
	Outline_6                                = 6,
	Outline_MAX                              = 7,
};

// Enum ReadyOrNot.EDoorInteraction
// NumValues: 0x0009
enum class EDoorInteraction : uint8
{
	None                                     = 0,
	Open                                     = 1,
	Close                                    = 2,
	Peek                                     = 3,
	Push                                     = 4,
	Kick                                     = 5,
	Kick_Fail                                = 6,
	Ram                                      = 7,
	EDoorInteraction_MAX                     = 8,
};

// Enum ReadyOrNot.ETrapType
// NumValues: 0x0005
enum class ETrapType : uint8
{
	Alarm                                    = 0,
	Flashbang                                = 1,
	Explosive                                = 2,
	Unknown                                  = 3,
	ETrapType_MAX                            = 4,
};

// Enum ReadyOrNot.EDoorTrapSide
// NumValues: 0x0003
enum class EDoorTrapSide : uint8
{
	Front                                    = 0,
	Back                                     = 1,
	EDoorTrapSide_MAX                        = 2,
};

// Enum ReadyOrNot.EDoorRoomPosition
// NumValues: 0x0007
enum class EDoorRoomPosition : uint8
{
	Center                                   = 0,
	CornerLeft                               = 1,
	CornerRight                              = 2,
	Hallway                                  = 3,
	HallwayLeft                              = 4,
	HallwayRight                             = 5,
	EDoorRoomPosition_MAX                    = 6,
};

// Enum ReadyOrNot.EClearDirection
// NumValues: 0x0004
enum class EClearDirection : uint8
{
	None                                     = 0,
	Right                                    = 1,
	Forward                                  = 2,
	EClearDirection_MAX                      = 3,
};

// Enum ReadyOrNot.EDoorOneWayDirection
// NumValues: 0x0003
enum class EDoorOneWayDirection : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	EDoorOneWayDirection_MAX                 = 2,
};

// Enum ReadyOrNot.ECOOPMode
// NumValues: 0x0007
enum class ECOOPMode : uint8
{
	CM_None                                  = 0,
	CM_BombThreat                            = 1,
	CM_ActiveShooter                         = 2,
	CM_HostageRescue                         = 3,
	CM_BarricadedSuspects                    = 4,
	CM_Raid                                  = 5,
	CM_MAX                                   = 6,
};

// Enum ReadyOrNot.EBombState
// NumValues: 0x0006
enum class EBombState : uint8
{
	BS_None                                  = 0,
	BS_Active                                = 1,
	BS_Disabled                              = 2,
	BS_Exploded                              = 3,
	BS_HiddenAndFullyDisabled                = 4,
	BS_MAX                                   = 5,
};

// Enum ReadyOrNot.EClueState
// NumValues: 0x0004
enum class EClueState : uint8
{
	Unclaimed                                = 0,
	Collected                                = 1,
	Dropped                                  = 2,
	EClueState_MAX                           = 3,
};

// Enum ReadyOrNot.ETeamType
// NumValues: 0x0007
enum class ETeamType : uint8
{
	TT_NONE                                  = 0,
	TT_SERT_RED                              = 1,
	TT_SERT_BLUE                             = 2,
	TT_SUSPECT                               = 3,
	TT_CIVILIAN                              = 4,
	TT_SQUAD                                 = 5,
	TT_MAX                                   = 6,
};

// Enum ReadyOrNot.EVoiceType
// NumValues: 0x0003
enum class EVoiceType : uint8
{
	VT_Local                                 = 0,
	VT_Team                                  = 1,
	VT_MAX                                   = 2,
};

// Enum ReadyOrNot.EArmourCoverage
// NumValues: 0x0005
enum class EArmourCoverage : uint8
{
	AC_None                                  = 0,
	AC_FrontOnly                             = 1,
	AC_FrontBack                             = 2,
	AC_FrontBackSides                        = 3,
	AC_MAX                                   = 4,
};

// Enum ReadyOrNot.EHUDStyle
// NumValues: 0x0005
enum class EHUDStyle : uint8
{
	Default                                  = 0,
	Minimal                                  = 1,
	Detail                                   = 2,
	Immersive                                = 3,
	EHUDStyle_MAX                            = 4,
};

// Enum ReadyOrNot.EVolumeShape
// NumValues: 0x0004
enum class EVolumeShape : uint8
{
	Box                                      = 0,
	Sphere                                   = 1,
	Capsule                                  = 2,
	EVolumeShape_MAX                         = 3,
};

// Enum ReadyOrNot.ELimbType
// NumValues: 0x0007
enum class ELimbType : uint8
{
	LT_None                                  = 0,
	LT_RightLeg                              = 1,
	LT_LeftLeg                               = 2,
	LT_RightArm                              = 3,
	LT_LeftArm                               = 4,
	LT_Head                                  = 5,
	LT_MAX                                   = 6,
};

// Enum ReadyOrNot.EPlayerHealthStatus
// NumValues: 0x0008
enum class EPlayerHealthStatus : uint8
{
	HS_Healthy                               = 0,
	HS_Injured                               = 1,
	HS_Downed                                = 2,
	HS_Incapacitated                         = 3,
	HS_Dead                                  = 4,
	HS_Arrested                              = 5,
	HS_NotAvailable                          = 6,
	HS_MAX                                   = 7,
};

// Enum ReadyOrNot.EAnimWeaponType
// NumValues: 0x0007
enum class EAnimWeaponType : uint8
{
	CWT_Unarmed                              = 0,
	CWT_Pistol                               = 1,
	CWT_Rifle                                = 2,
	CWT_Arrested                             = 3,
	CWT_Surrendered                          = 4,
	CWT_Any                                  = 5,
	CWT_MAX                                  = 6,
};

// Enum ReadyOrNot.ECharacterEmotion
// NumValues: 0x0007
enum class ECharacterEmotion : uint8
{
	None                                     = 0,
	Angry                                    = 1,
	Wince                                    = 2,
	Sad                                      = 3,
	Afraid                                   = 4,
	Alert                                    = 5,
	ECharacterEmotion_MAX                    = 6,
};

// Enum ReadyOrNot.EGibAreas
// NumValues: 0x0007
enum class EGibAreas : uint8
{
	GA_None                                  = 0,
	GA_LeftLeg                               = 1,
	GA_RightLeg                              = 2,
	GA_LeftArm                               = 3,
	GA_RightArm                              = 4,
	GA_Head                                  = 5,
	GA_MAX                                   = 6,
};

// Enum ReadyOrNot.ETOCPriority
// NumValues: 0x0005
enum class ETOCPriority : uint8
{
	ETP_Flush                                = 0,
	ETP_HighPriority                         = 1,
	ETP_MediumPriority                       = 2,
	ETP_LowPriority                          = 3,
	ETP_MAX                                  = 4,
};

// Enum ReadyOrNot.ESquadPosition
// NumValues: 0x000A
enum class ESquadPosition : uint8
{
	SP_Alpha                                 = 0,
	SP_Beta                                  = 1,
	SP_Charlie                               = 2,
	SP_Delta                                 = 3,
	SP_Foxtrot                               = 4,
	SP_Golf                                  = 5,
	SP_Hotel                                 = 6,
	SP_India                                 = 7,
	SP_NONE                                  = 8,
	SP_MAX                                   = 9,
};

// Enum ReadyOrNot.ECharacterDeathReason
// NumValues: 0x000C
enum class ECharacterDeathReason : uint8
{
	None                                     = 0,
	PrimaryWeapon                            = 1,
	SecondaryWeapon                          = 2,
	TasedToDeath                             = 3,
	FellFromHighHeight                       = 4,
	Suicide                                  = 5,
	Headshot                                 = 6,
	Bleedout                                 = 7,
	Grenade                                  = 8,
	Explosion                                = 9,
	MultipleUnhealedWounds                   = 10,
	ECharacterDeathReason_MAX                = 11,
};

// Enum ReadyOrNot.ESwatCommand
// NumValues: 0x007B
enum class ESwatCommand : uint8
{
	SC_None                                  = 0,
	SC_MoveTo                                = 1,
	SC_FallIn                                = 2,
	SC_FallIn_Snake                          = 3,
	SC_FallIn_HalfSnake                      = 4,
	SC_FallIn_Diamond                        = 5,
	SC_FallIn_Flock                          = 6,
	SC_Cover                                 = 7,
	SC_Hold                                  = 8,
	SC_Resume                                = 9,
	SC_DeployFlashbang                       = 10,
	SC_DeployStinger                         = 11,
	SC_DeployCSGas                           = 12,
	SC_DeployChemlight                       = 13,
	SC_DoArrestTarget                        = 14,
	SC_DoCollectEvidence                     = 15,
	SC_DoReportTarget                        = 16,
	SC_DisarmStandaloneTrap                  = 17,
	SC_KillMe                                = 18,
	SC_StackUp                               = 19,
	SC_StackUpSplit                          = 20,
	SC_StackUpLeft                           = 21,
	SC_StackUpRight                          = 22,
	SC_PickLock                              = 23,
	SC_RemoveDoorJam                         = 24,
	SC_DeployMirrorgun                       = 25,
	SC_DeployDoorJam                         = 26,
	SC_CheckForTrap                          = 27,
	SC_DisarmTrap                            = 28,
	SC_OpenDoor                              = 29,
	SC_CloseDoor                             = 30,
	SC_Slide                                 = 31,
	SC_Slice                                 = 32,
	SC_Snap                                  = 33,
	SC_SearchAndSecure                       = 34,
	SC_SearchAndSecureRoom                   = 35,
	SC_SearchAndSecureRoom_Individual        = 36,
	SC_MoveAndClear                          = 37,
	SC_MoveAndClearFlashbang                 = 38,
	SC_MoveAndClearStinger                   = 39,
	SC_MoveAndClearCSGas                     = 40,
	SC_MoveAndClearLauncher                  = 41,
	SC_MoveAndClearLeader                    = 42,
	SC_OpenAndClear                          = 43,
	SC_OpenAndClearFlashbang                 = 44,
	SC_OpenAndClearStinger                   = 45,
	SC_OpenAndClearCSGas                     = 46,
	SC_OpenAndClearLauncher                  = 47,
	SC_OpenAndClearLeader                    = 48,
	SC_KickAndClear                          = 49,
	SC_KickAndClearFlashbang                 = 50,
	SC_KickAndClearStinger                   = 51,
	SC_KickAndClearCSGas                     = 52,
	SC_KickAndClearLauncher                  = 53,
	SC_KickAndClearLeader                    = 54,
	SC_ShotgunClear                          = 55,
	SC_ShotgunClearFlashbang                 = 56,
	SC_ShotgunClearStinger                   = 57,
	SC_ShotgunClearCSGas                     = 58,
	SC_ShotgunClearLeader                    = 59,
	SC_ShotgunClearLauncher                  = 60,
	SC_RamAndClear                           = 61,
	SC_RamAndClearFlashbang                  = 62,
	SC_RamAndClearStinger                    = 63,
	SC_RamAndClearCSGas                      = 64,
	SC_RamAndClearLauncher                   = 65,
	SC_RamAndClearLeader                     = 66,
	SC_C2Clear                               = 67,
	SC_C2ClearFlashbang                      = 68,
	SC_C2ClearStinger                        = 69,
	SC_C2ClearCSGas                          = 70,
	SC_C2ClearLauncher                       = 71,
	SC_C2ClearLeader                         = 72,
	SC_LeaderAndClear                        = 73,
	SC_LeaderAndClearFlashbang               = 74,
	SC_LeaderAndClearStinger                 = 75,
	SC_LeaderAndClearCSGas                   = 76,
	SC_LeaderAndClearLauncher                = 77,
	SC_LeaderAndClearLeader                  = 78,
	SC_SwapWithAlpha                         = 79,
	SC_SwapWithBeta                          = 80,
	SC_SwapWithCharlie                       = 81,
	SC_SwapWithDelta                         = 82,
	SC_SwapWithAlphaOpposite                 = 83,
	SC_SwapWithBetaOpposite                  = 84,
	SC_SwapWithCharlieOpposite               = 85,
	SC_SwapWithDeltaOpposite                 = 86,
	SC_MoveToAlpha                           = 87,
	SC_MoveToBeta                            = 88,
	SC_MoveToCharlie                         = 89,
	SC_MoveToDelta                           = 90,
	SC_MoveTo_Individual                     = 91,
	SC_MoveTo_MyPosition_Individual          = 92,
	SC_MoveTo_Stop_Individual                = 93,
	SC_MoveTo_Exit_Individual                = 94,
	SC_MoveToAndBack_Individual              = 95,
	SC_Focus_Individual                      = 96,
	SC_Focus_MyPosition_Individual           = 97,
	SC_UnFocus_Individual                    = 98,
	SC_FocusDoor_Individual                  = 99,
	SC_FocusTarget_Individual                = 100,
	SC_TurnAround_Individual                 = 101,
	SC_Execute                               = 102,
	SC_Cancel                                = 103,
	SC_DeployShield                          = 104,
	SC_HolsterShield                         = 105,
	SC_DeployTaser                           = 106,
	SC_DeployPepperspray                     = 107,
	SC_DeployPepperball                      = 108,
	SC_DeployBeanbag                         = 109,
	SC_MeleeTarget                           = 110,
	SC_Roger                                 = 111,
	SC_Negative                              = 112,
	PC_Deploy                                = 113,
	PC_ConfirmOrderRequest                   = 114,
	PC_StackUp                               = 115,
	PC_Open                                  = 116,
	PC_Move                                  = 117,
	PC_Kick                                  = 118,
	PC_Shotgun                               = 119,
	PC_C2                                    = 120,
	PC_Breach                                = 121,
	ESwatCommand_MAX                         = 122,
};

// Enum ReadyOrNot.EItemSelectionInterfaceType
// NumValues: 0x0003
enum class EItemSelectionInterfaceType : uint8
{
	Wheel                                    = 0,
	Panel                                    = 1,
	EItemSelectionInterfaceType_MAX          = 2,
};

// Enum ReadyOrNot.ELedgeHeight
// NumValues: 0x0005
enum class ELedgeHeight : uint8
{
	LH_None                                  = 0,
	LH_Step                                  = 1,
	LH_Vault                                 = 2,
	LH_Mantle                                = 3,
	LH_MAX                                   = 4,
};

// Enum ReadyOrNot.ELedgeWidth
// NumValues: 0x0005
enum class ELedgeWidth : uint8
{
	LW_None                                  = 0,
	LW_Ledge                                 = 1,
	LW_Rail                                  = 2,
	LW_Fall                                  = 3,
	LW_MAX                                   = 4,
};

// Enum ReadyOrNot.EMultitoolFunctions
// NumValues: 0x0005
enum class EMultitoolFunctions : uint8
{
	MF_None                                  = 0,
	MF_Lockpick                              = 1,
	MF_Knife                                 = 2,
	MF_Wirecutter                            = 3,
	MF_MAX                                   = 4,
};

// Enum ReadyOrNot.ELightRadialSelection
// NumValues: 0x0005
enum class ELightRadialSelection : uint8
{
	LR_None                                  = 0,
	LR_NVGs                                  = 1,
	LR_WeaponLight                           = 2,
	LR_Chemlight                             = 3,
	LR_MAX                                   = 4,
};

// Enum ReadyOrNot.EFootConstEnum
// NumValues: 0x0003
enum class EFootConstEnum : uint8
{
	FCE_Forward                              = 0,
	FCE_Inverse                              = 1,
	FCE_MAX                                  = 2,
};

// Enum ReadyOrNot.ETrapState
// NumValues: 0x0004
enum class ETrapState : uint8
{
	TS_Live                                  = 0,
	TS_Activated                             = 1,
	TS_Disabled                              = 2,
	TS_MAX                                   = 3,
};

// Enum ReadyOrNot.EMatchState
// NumValues: 0x0007
enum class EMatchState : uint8
{
	MS_None                                  = 0,
	MS_Warmup                                = 1,
	MS_Playing                               = 2,
	MS_RoundEnded                            = 3,
	MS_MatchEnded                            = 4,
	MS_GoingToNextLevel                      = 5,
	MS_MAX                                   = 6,
};

// Enum ReadyOrNot.ERespawnMode
// NumValues: 0x0004
enum class ERespawnMode : uint8
{
	NoRespawn                                = 0,
	ImmediateRespawn                         = 1,
	DelayedRespawn                           = 2,
	ERespawnMode_MAX                         = 3,
};

// Enum ReadyOrNot.EProjectileReaction
// NumValues: 0x0004
enum class EProjectileReaction : uint8
{
	PR_None                                  = 0,
	PR_Richochet                             = 1,
	PR_Pierce                                = 2,
	PR_MAX                                   = 3,
};

// Enum ReadyOrNot.EActivityStatus
// NumValues: 0x0006
enum class EActivityStatus : uint8
{
	Uninitialized                            = 0,
	Initialized                              = 1,
	Started                                  = 2,
	Paused                                   = 3,
	Complete                                 = 4,
	EActivityStatus_MAX                      = 5,
};

// Enum ReadyOrNot.ERonNavigationQueryResult
// NumValues: 0x0005
enum class ERonNavigationQueryResult : uint8
{
	Invalid                                  = 0,
	Error                                    = 1,
	Fail                                     = 2,
	Success                                  = 3,
	ERonNavigationQueryResult_MAX            = 4,
};

// Enum ReadyOrNot.EAIAwarenessState
// NumValues: 0x0004
enum class EAIAwarenessState : uint8
{
	Unalerted                                = 0,
	Suspicious                               = 1,
	Alerted                                  = 2,
	EAIAwarenessState_MAX                    = 3,
};

// Enum ReadyOrNot.ESurrenderExitType
// NumValues: 0x0005
enum class ESurrenderExitType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Gun                                      = 2,
	Knife                                    = 3,
	ESurrenderExitType_MAX                   = 4,
};

// Enum ReadyOrNot.ECombatState
// NumValues: 0x0007
enum class ECombatState : uint8
{
	CS_Unaware                               = 0,
	CS_Suspicious                            = 1,
	CS_Fleeing                               = 2,
	CS_Hesitation                            = 3,
	CS_Cover                                 = 4,
	CS_ArmedAndDangerous                     = 5,
	CS_MAX                                   = 6,
};

// Enum ReadyOrNot.EPlayerStatus
// NumValues: 0x0005
enum class EPlayerStatus : uint8
{
	PS_None                                  = 0,
	PS_NotReady                              = 1,
	PS_Ready                                 = 2,
	PS_Deployed                              = 3,
	PS_MAX                                   = 4,
};

// Enum ReadyOrNot.EFreeDrawColor
// NumValues: 0x0009
enum class EFreeDrawColor : uint8
{
	FDC_Black                                = 0,
	FDC_Red                                  = 1,
	FDC_Blue                                 = 2,
	FDC_Gold                                 = 3,
	FDC_Green                                = 4,
	FDC_Purple                               = 5,
	FDC_Orange                               = 6,
	FDC_Cyan                                 = 7,
	FDC_MAX                                  = 8,
};

// Enum ReadyOrNot.EKillfeedType
// NumValues: 0x0007
enum class EKillfeedType : uint8
{
	KT_None                                  = 0,
	KT_Kill                                  = 1,
	KT_Arrest                                = 2,
	KT_Free                                  = 3,
	KT_Recovered                             = 4,
	KT_Death                                 = 5,
	KT_MAX                                   = 6,
};

// Enum ReadyOrNot.EVoteState
// NumValues: 0x0004
enum class EVoteState : uint8
{
	Undecided                                = 0,
	Yes                                      = 1,
	No                                       = 2,
	EVoteState_MAX                           = 3,
};

// Enum ReadyOrNot.ESelectedSpawn
// NumValues: 0x0006
enum class ESelectedSpawn : uint8
{
	SS_None                                  = 0,
	SS_FirstSpawn                            = 1,
	SS_SecondSpawn                           = 2,
	SS_ThirdSpawn                            = 3,
	SS_FourthSpawn                           = 4,
	SS_MAX                                   = 5,
};

// Enum ReadyOrNot.EServerValidationState
// NumValues: 0x0004
enum class EServerValidationState : uint8
{
	Unvalidated                              = 0,
	Validated                                = 1,
	Invalid                                  = 2,
	EServerValidationState_MAX               = 3,
};

// Enum ReadyOrNot.EPlanningLineTeam
// NumValues: 0x0004
enum class EPlanningLineTeam : uint8
{
	PLT_Gold                                 = 0,
	PLT_Red                                  = 1,
	PLT_Blue                                 = 2,
	PLT_MAX                                  = 3,
};

// Enum ReadyOrNot.ERadialMenuCloseReason
// NumValues: 0x0003
enum class ERadialMenuCloseReason : uint8
{
	MCR_UserClosed                           = 0,
	MCR_ForceClosed                          = 1,
	MCR_MAX                                  = 2,
};

// Enum ReadyOrNot.ERadialCursorBehaviour
// NumValues: 0x0003
enum class ERadialCursorBehaviour : uint8
{
	RCB_Clamped                              = 0,
	RCB_Continuous                           = 1,
	RCB_MAX                                  = 2,
};

// Enum ReadyOrNot.EEquippingSwat
// NumValues: 0x0006
enum class EEquippingSwat : uint8
{
	ES_None                                  = 0,
	ES_BlueOne                               = 1,
	ES_BlueTwo                               = 2,
	ES_RedOne                                = 3,
	ES_RedTwo                                = 4,
	ES_MAX                                   = 5,
};

// Enum ReadyOrNot.EPreMissionSubCategory
// NumValues: 0x000A
enum class EPreMissionSubCategory : uint8
{
	None                                     = 0,
	Primary                                  = 1,
	Secondary                                = 2,
	Tactical                                 = 3,
	Appearance                               = 4,
	Protection                               = 5,
	ItemSelection                            = 6,
	Grenades                                 = 7,
	Clean                                    = 8,
	EPreMissionSubCategory_MAX               = 9,
};

// Enum ReadyOrNot.EEvidenceActorState
// NumValues: 0x0005
enum class EEvidenceActorState : uint8
{
	Unclaimed                                = 0,
	Collected                                = 1,
	Extraction                               = 2,
	Dropped                                  = 3,
	EEvidenceActorState_MAX                  = 4,
};

// Enum ReadyOrNot.EWeaponAttachmentType
// NumValues: 0x000A
enum class EWeaponAttachmentType : uint8
{
	Null                                     = 0,
	Optics                                   = 1,
	Muzzle                                   = 2,
	Underbarrel                              = 3,
	Overbarrel                               = 4,
	Stock                                    = 5,
	Grip                                     = 6,
	Illuminators                             = 7,
	Ammunition                               = 8,
	EWeaponAttachmentType_MAX                = 9,
};

// Enum ReadyOrNot.ELoadoutCategory
// NumValues: 0x0006
enum class ELoadoutCategory : uint8
{
	None                                     = 0,
	Primary                                  = 1,
	Secondary                                = 2,
	LongTactical                             = 8,
	TacticalDevice                           = 16,
	ELoadoutCategory_MAX                     = 17,
};

// Enum ReadyOrNot.ELoginState
// NumValues: 0x0006
enum class ReadyOrNot::ELoginState : uint8
{
	LS_None                                  = 0,
	LS_LoggingIn                             = 1,
	LS_LoggedIn                              = 2,
	LS_LoggedOut                             = 3,
	LS_LoginFail                             = 4,
	LS_MAX                                   = 5,
};

// Enum ReadyOrNot.EReplayEventType
// NumValues: 0x0006
enum class EReplayEventType : uint8
{
	PlayerKilled                             = 0,
	SwatKilled                               = 1,
	SuspectKilled                            = 2,
	CivilianArrested                         = 3,
	EvidenceCollected                        = 4,
	EReplayEventType_MAX                     = 5,
};

// Enum ReadyOrNot.ELastMenuStateBeforeJoin
// NumValues: 0x0005
enum class ELastMenuStateBeforeJoin : uint8
{
	LM_None                                  = 0,
	LM_ServerBrowser                         = 1,
	LM_FromFriends                           = 2,
	LM_SinglePlayer                          = 3,
	LM_MAX                                   = 4,
};

// Enum ReadyOrNot.EPersonnel
// NumValues: 0x000B
enum class EPersonnel : uint8
{
	PERS_None                                = 0,
	PERS_TruckDriver                         = 1,
	PERS_NoisemakerOperator                  = 2,
	PERS_VentilationExpert                   = 3,
	PERS_Spotter                             = 4,
	PERS_Marksman                            = 5,
	PERS_Sniper                              = 6,
	PERS_FloodlightOperator                  = 7,
	PERS_PowerCrew                           = 8,
	PERS_Negotiator                          = 9,
	PERS_MAX                                 = 10,
};

// Enum ReadyOrNot.ESessionType
// NumValues: 0x0005
enum class ESessionType : uint8
{
	ST_None                                  = 0,
	ST_SinglePlayer                          = 1,
	ST_Public                                = 2,
	ST_Friends                               = 3,
	ST_MAX                                   = 4,
};

// Enum ReadyOrNot.ELightType
// NumValues: 0x0004
enum class ELightType : uint8
{
	LT_None                                  = 0,
	LT_Day                                   = 1,
	LT_Night                                 = 2,
	LT_MAX                                   = 3,
};

// Enum ReadyOrNot.EGenerationType
// NumValues: 0x0003
enum class EGenerationType : uint8
{
	GT_None                                  = 0,
	GT_RandomScenarios                       = 1,
	GT_MAX                                   = 2,
};

// Enum ReadyOrNot.EPVPEvent
// NumValues: 0x0012
enum class EPVPEvent : uint8
{
	None                                     = 0,
	PlayerKilled                             = 1,
	PlayerArrested                           = 2,
	PlayerFreed                              = 3,
	KillConfirmed                            = 4,
	ReportedEvidence                         = 5,
	VIPSecured                               = 6,
	VIPArrested                              = 7,
	VIPFreed                                 = 8,
	VIPKilled                                = 9,
	FlagCaptured                             = 10,
	FlagDropped                              = 11,
	IntelCollected                           = 12,
	IntelDropped                             = 13,
	IntelExtracting                          = 14,
	IntelExtracted                           = 15,
	IncrimClueFound                          = 16,
	EPVPEvent_MAX                            = 17,
};

// Enum ReadyOrNot.EAchievementStats
// NumValues: 0x0019
enum class EAchievementStats : uint8
{
	SCORE_GAS                                = 0,
	SCORE_COYOTE                             = 1,
	SCORE_METH                               = 2,
	SCORE_CAMPUS                             = 3,
	SCORE_HOSPITAL                           = 4,
	SCORE_CLUB                               = 5,
	SCORE_FARM                               = 6,
	SCORE_SINS                               = 7,
	SCORE_PENTHOUSE                          = 8,
	SCORE_RIDGELINE                          = 9,
	SCORE_DEALER                             = 10,
	SCORE_PORT                               = 11,
	SCORE_BEACHFRONT                         = 12,
	SCORE_IMPORTER                           = 13,
	SCORE_AGENCY                             = 14,
	SCORE_VALLEY                             = 15,
	SCORE_DATACENTER                         = 16,
	SCORE_STREAMER                           = 17,
	PROGRESS_A1                              = 18,
	PROGRESS_A2                              = 19,
	PROGRESS_A3                              = 20,
	PROGRESS_A4                              = 21,
	PROGRESS_A5                              = 22,
	PROGRESS_A6                              = 23,
	EAchievementStats_MAX                    = 24,
};

// Enum ReadyOrNot.EAchievement
// NumValues: 0x0010
enum class EAchievement : uint8
{
	THE_WAR                                  = 0,
	THE_DECAYING_CITY                        = 1,
	THE_LEFT_BEHIND                          = 2,
	THE_ABDUCTED                             = 3,
	THE_EXPLOITED                            = 4,
	MEDAL_OF_VALOR                           = 5,
	THE_WORLD                                = 6,
	THE_HERMIT                               = 7,
	THE_HANGED_MAN                           = 8,
	WAY_OUT_WEST                             = 9,
	THE_DEVIL                                = 10,
	THE_MAGICIAN                             = 11,
	THE_FOOL                                 = 12,
	FIRST_ARREST                             = 13,
	DUE_PROCESS                              = 14,
	EAchievement_MAX                         = 15,
};

// Enum ReadyOrNot.EUniversalStatType
// NumValues: 0x0004
enum class EUniversalStatType : uint8
{
	STAT_INT                                 = 0,
	STAT_FLOAT                               = 1,
	STAT_AVGRATE                             = 2,
	STAT_MAX                                 = 3,
};

// Enum ReadyOrNot.EAIConsiderationScoringMethod
// NumValues: 0x0004
enum class EAIConsiderationScoringMethod : uint8
{
	Additive                                 = 0,
	Subtractive                              = 1,
	Multiplicative                           = 2,
	EAIConsiderationScoringMethod_MAX        = 3,
};

// Enum ReadyOrNot.EAIAction
// NumValues: 0x0017
enum class EAIAction : uint8
{
	None                                     = 0,
	FireWeapon                               = 1,
	Melee                                    = 2,
	HardCover                                = 3,
	Hide                                     = 4,
	HideExit                                 = 5,
	Surrender                                = 6,
	FakeSurrender                            = 7,
	PlayDead                                 = 8,
	Flee                                     = 9,
	Rush                                     = 10,
	Flank                                    = 11,
	Duel                                     = 12,
	Suppress                                 = 13,
	Push                                     = 14,
	Reposition                               = 15,
	TraverseHole                             = 16,
	Investigate                              = 17,
	PickUpItem                               = 18,
	Suicide                                  = 19,
	NeverFakeSuicide                         = 20,
	Custom                                   = 21,
	EAIAction_MAX                            = 22,
};

// Enum ReadyOrNot.EComparisonOp
// NumValues: 0x0007
enum class EComparisonOp : uint8
{
	Equals                                   = 0,
	NotEquals                                = 1,
	GreaterThan                              = 2,
	GreaterThanEquals                        = 3,
	LessThan                                 = 4,
	LessThanEquals                           = 5,
	EComparisonOp_MAX                        = 6,
};

// Enum ReadyOrNot.EAITeamTactic
// NumValues: 0x0008
enum class EAITeamTactic : uint8
{
	None                                     = 0,
	Suppress                                 = 1,
	Cover                                    = 2,
	Flank                                    = 3,
	Push                                     = 4,
	Charge                                   = 5,
	Custom                                   = 6,
	EAITeamTactic_MAX                        = 7,
};

// Enum ReadyOrNot.EAnimCardinalDirection
// NumValues: 0x0005
enum class EAnimCardinalDirection : uint8
{
	North                                    = 0,
	East                                     = 1,
	South                                    = 2,
	West                                     = 3,
	EAnimCardinalDirection_MAX               = 4,
};

// Enum ReadyOrNot.ETransitionAnimationType
// NumValues: 0x0005
enum class ETransitionAnimationType : uint8
{
	Start                                    = 0,
	Stop                                     = 1,
	Pivot                                    = 2,
	None                                     = 3,
	ETransitionAnimationType_MAX             = 4,
};

// Enum ReadyOrNot.EDistanceMatchingType
// NumValues: 0x0007
enum class EDistanceMatchingType : uint8
{
	Start                                    = 0,
	Stop                                     = 1,
	Pivot                                    = 2,
	Jump                                     = 3,
	Fall                                     = 4,
	None                                     = 5,
	EDistanceMatchingType_MAX                = 6,
};

// Enum ReadyOrNot.EItemSocket
// NumValues: 0x0003
enum class EItemSocket : uint8
{
	Body                                     = 0,
	Hand                                     = 1,
	EItemSocket_MAX                          = 2,
};

// Enum ReadyOrNot.ECombatEngagementType
// NumValues: 0x0005
enum class ECombatEngagementType : uint8
{
	FireWeapon                               = 0,
	Melee                                    = 1,
	ExplosiveVest                            = 2,
	Custom                                   = 3,
	ECombatEngagementType_MAX                = 4,
};

// Enum ReadyOrNot.ENavLOS
// NumValues: 0x0005
enum class ENavLOS : uint8
{
	NL_Any                                   = 0,
	NL_BreakLOS                              = 1,
	NL_RequireLOS                            = 2,
	NL_RequireLOSToMyself                    = 3,
	NL_MAX                                   = 4,
};

// Enum ReadyOrNot.ENavType
// NumValues: 0x0004
enum class ENavType : uint8
{
	NT_SinglePoint                           = 0,
	NT_Circle                                = 1,
	NT_Grid                                  = 2,
	NT_MAX                                   = 3,
};

// Enum ReadyOrNot.EShellType
// NumValues: 0x0003
enum class EShellType : uint8
{
	Bullet                                   = 0,
	Shotgun                                  = 1,
	EShellType_MAX                           = 2,
};

// Enum ReadyOrNot.EStructureCastPathway
// NumValues: 0x0003
enum class EStructureCastPathway : uint8
{
	CastSuccess                              = 0,
	CastFailed                               = 1,
	EStructureCastPathway_MAX                = 2,
};

// Enum ReadyOrNot.EBioType
// NumValues: 0x0004
enum class EBioType : uint8
{
	BT_None                                  = 0,
	BT_Suspect                               = 1,
	BT_Civilian                              = 2,
	BT_MAX                                   = 3,
};

// Enum ReadyOrNot.EConsoleHotkeysLayout
// NumValues: 0x0004
enum class EConsoleHotkeysLayout : uint8
{
	DefaultLayout                            = 0,
	CommandLayout                            = 1,
	ItemWheelLayout                          = 2,
	EConsoleHotkeysLayout_MAX                = 3,
};

// Enum ReadyOrNot.ELobbyPrivacy
// NumValues: 0x0004
enum class ELobbyPrivacy : uint8
{
	LP_Public                                = 0,
	LP_Private                               = 1,
	LP_Invite                                = 2,
	LP_MAX                                   = 3,
};

// Enum ReadyOrNot.EMissionEndVoteState
// NumValues: 0x0005
enum class EMissionEndVoteState : uint8
{
	VS_NotStarted                            = 0,
	VS_InProgress                            = 1,
	VS_MajorityYes                           = 2,
	VS_MajorityNo                            = 3,
	VS_MAX                                   = 4,
};

// Enum ReadyOrNot.ECoverLandmarkType
// NumValues: 0x0007
enum class ECoverLandmarkType : uint8
{
	None                                     = 0,
	Closet                                   = 1,
	Bed                                      = 2,
	Table                                    = 3,
	Corner                                   = 4,
	Custom                                   = 5,
	ECoverLandmarkType_MAX                   = 6,
};

// Enum ReadyOrNot.ECoverLandmarkAnimDirection
// NumValues: 0x0004
enum class ECoverLandmarkAnimDirection : uint8
{
	Forward                                  = 0,
	Left                                     = 1,
	Right                                    = 2,
	ECoverLandmarkAnimDirection_MAX          = 3,
};

// Enum ReadyOrNot.ECustomizationAssetCookRule
// NumValues: 0x0004
enum class ECustomizationAssetCookRule : uint8
{
	EditorOnly                               = 0,
	DevelopmentOnly                          = 1,
	AlwaysCook                               = 2,
	ECustomizationAssetCookRule_MAX          = 3,
};

// Enum ReadyOrNot.ECustomizationType
// NumValues: 0x0012
enum class ECustomizationType : uint8
{
	None                                     = 0,
	Character                                = 1,
	Voice                                    = 2,
	Helmet                                   = 3,
	Shirt                                    = 4,
	Pants                                    = 5,
	Shoes                                    = 6,
	Eyewear                                  = 7,
	Belt                                     = 8,
	Gloves                                   = 9,
	Watch                                    = 10,
	Tattoo                                   = 11,
	PrimarySkin                              = 12,
	SecondarySkin                            = 13,
	ArmorSkin                                = 14,
	HeadwearSkin                             = 15,
	Any                                      = 16,
	ECustomizationType_MAX                   = 17,
};

// Enum ReadyOrNot.EPseudoSpeedType
// NumValues: 0x0009
enum class EPseudoSpeedType : uint8
{
	Null                                     = 0,
	Slow                                     = 1,
	Walk                                     = 2,
	Run                                      = 3,
	Sprint                                   = 4,
	LimpWalk                                 = 5,
	LimpRun                                  = 6,
	Last                                     = 7,
	EPseudoSpeedType_MAX                     = 8,
};

// Enum ReadyOrNot.EAITargetType
// NumValues: 0x0005
enum class EAITargetType : uint8
{
	None                                     = 0,
	Enemy                                    = 1,
	Neutral                                  = 2,
	Friendly                                 = 4,
	EAITargetType_MAX                        = 5,
};

// Enum ReadyOrNot.EActorSenseType
// NumValues: 0x0004
enum class EActorSenseType : uint8
{
	Sight                                    = 0,
	Sound                                    = 1,
	Damage                                   = 2,
	EActorSenseType_MAX                      = 3,
};

// Enum ReadyOrNot.ETacticalAuthorityVoice
// NumValues: 0x000E
enum class ETacticalAuthorityVoice : uint8
{
	TAV_None                                 = 0,
	TAV_Surrender                            = 1,
	TAV_PickUpItem                           = 2,
	TAV_DropTheGun                           = 3,
	TAV_GetOnTheFloor                        = 4,
	TAV_ComeHere                             = 5,
	TAV_Wait                                 = 6,
	TAV_PutHandsUp                           = 7,
	TAV_MoveOverThere                        = 8,
	TAV_ReportDead                           = 9,
	TAV_ReportArrested                       = 10,
	TAV_ReportIncapacitated                  = 11,
	TAV_ReportEvidence                       = 12,
	TAV_MAX                                  = 13,
};

// Enum ReadyOrNot.EDefusalMatchSate
// NumValues: 0x0006
enum class EDefusalMatchSate : uint8
{
	DMS_Warmup                               = 0,
	DMS_PreRoundTimer                        = 1,
	DMS_Playing                              = 2,
	DMS_HalfTime                             = 3,
	DMS_MatchFinished                        = 4,
	DMS_MAX                                  = 5,
};

// Enum ReadyOrNot.ETrapSetup
// NumValues: 0x0003
enum class ETrapSetup : uint8
{
	Automatic                                = 0,
	Manual                                   = 1,
	ETrapSetup_MAX                           = 2,
};

// Enum ReadyOrNot.ESubDoorPosition
// NumValues: 0x0004
enum class ESubDoorPosition : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	ESubDoorPosition_MAX                     = 3,
};

// Enum ReadyOrNot.EDroneDamageSpeed
// NumValues: 0x000A
enum class EDroneDamageSpeed : uint8
{
	DDS_10PercentSpeed                       = 0,
	DDS_20PercentSpeed                       = 1,
	DDS_30PercentSpeed                       = 2,
	DDS_40PercentSpeed                       = 3,
	DDS_50PercentSpeed                       = 4,
	DDS_60PercentSpeed                       = 5,
	DDS_70PercentSpeed                       = 6,
	DDS_80PercentSpeed                       = 7,
	DDS_90PercentSpeed                       = 8,
	DDS_MAX                                  = 9,
};

// Enum ReadyOrNot.ETargetEvent
// NumValues: 0x0010
enum class ETargetEvent : uint8
{
	E_None                                   = 0,
	E_LockDoor                               = 1,
	E_UnlockDoor                             = 2,
	E_DisableDoor                            = 3,
	E_EnableDoor                             = 4,
	E_DisableDoorInteraction                 = 5,
	E_EnableDoorInteraction                  = 6,
	E_EnableDoorOpen                         = 7,
	E_EnableDoorPeek                         = 8,
	E_EnableDoorKick                         = 9,
	E_EnableDoorOptiwand                     = 10,
	E_ActivateTriggerable                    = 11,
	E_DeactivateTriggerable                  = 12,
	E_SpawnAi                                = 13,
	E_SetPlayerSpawn                         = 14,
	E_MAX                                    = 15,
};

// Enum ReadyOrNot.EStandaloneEvent
// NumValues: 0x0019
enum class EStandaloneEvent : uint8
{
	E_None                                   = 0,
	E_LockPlayerMovement                     = 1,
	E_UnlockPlayerMovement                   = 2,
	E_LockPlayerItemSelection                = 3,
	E_UnlockPlayerItemSelection              = 4,
	E_LockAllPlayerActions                   = 5,
	E_UnlockAllPlayerActions                 = 6,
	E_LockPlayerCommandMenu                  = 7,
	E_UnlockPlayerCommandMenu                = 8,
	E_LockWeaponAttachments                  = 9,
	E_UnlockWeaponAttachments                = 10,
	E_LockCantedSights                       = 11,
	E_UnlockCantedSights                     = 12,
	E_SetPlayerLowReady                      = 13,
	E_SetPlayerNotLowReady                   = 14,
	E_SpawnPolice                            = 15,
	E_SpawnPoliceAtPlayer                    = 16,
	E_HidePlayerWeapon                       = 17,
	E_EquipTrainingLoadout                   = 18,
	E_RemoveAmmoFromLoadout                  = 19,
	E_AddAmmoToLoadout                       = 20,
	E_AddGrenadesToLoadout                   = 21,
	E_AddChemlightsToLoadout                 = 22,
	E_AddEmptyMagPrimary                     = 23,
	E_MAX                                    = 24,
};

// Enum ReadyOrNot.EEventType
// NumValues: 0x0005
enum class EEventType : uint8
{
	E_Standalone                             = 0,
	E_Target                                 = 1,
	E_FmodAudio                              = 2,
	E_UnrealAudio                            = 3,
	E_MAX                                    = 4,
};

// Enum ReadyOrNot.EActivity
// NumValues: 0x0030
enum class EActivity : uint8
{
	A_GoToLocation                           = 0,
	A_Delay                                  = 1,
	A_UIOnly                                 = 2,
	A_MoveForward                            = 3,
	A_MoveBackward                           = 4,
	A_MoveRight                              = 5,
	A_MoveLeft                               = 6,
	A_MoveForwardLowReady                    = 7,
	A_Interact                               = 8,
	A_InteractTriggerable                    = 9,
	A_OpenDoor                               = 10,
	A_SecureEvidence                         = 11,
	A_EquipPrimary                           = 12,
	A_EquipSecondary                         = 13,
	A_ShootPrimaryHip                        = 14,
	A_ShootPrimaryADS                        = 15,
	A_ShootSecondaryHip                      = 16,
	A_ShootSecondaryADS                      = 17,
	A_Reload                                 = 18,
	A_ReloadEmpty                            = 19,
	A_ReloadAiming                           = 20,
	A_ReloadQuick                            = 21,
	A_SwitchAmmoType                         = 22,
	A_SwitchFireMode                         = 23,
	A_ToggleTacticalLight                    = 24,
	A_ToggleCantedSight                      = 25,
	A_ThrowFlashbangGrenade                  = 26,
	A_ThrowCSGasGrenade                      = 27,
	A_ThrowStingerGrenade                    = 28,
	A_ThrowNineBangerGrenade                 = 29,
	A_UseChemlight                           = 30,
	A_UseOptiwand                            = 31,
	A_UseDoorjam                             = 32,
	A_UseBatteringRam                        = 33,
	A_UseC2Explosive                         = 34,
	A_UseLockpick                            = 35,
	A_UseNVGs                                = 36,
	A_IssueSwatCommand                       = 37,
	A_ArrestOrKillAi                         = 38,
	A_ShootTarget                            = 39,
	A_ShootTargetADS                         = 40,
	A_ShootTargetCanted                      = 41,
	A_ShootTargetLaser                       = 42,
	A_GrenadeTarget                          = 43,
	A_SwitchTeamCamera                       = 44,
	A_SwitchSwatElement                      = 45,
	A_Exfiltrate                             = 46,
	A_MAX                                    = 47,
};

// Enum ReadyOrNot.ETutorialWidgetLocation
// NumValues: 0x0004
enum class ETutorialWidgetLocation : uint8
{
	TWL_Bottom                               = 0,
	TWL_Right                                = 1,
	TWL_Left                                 = 2,
	TWL_MAX                                  = 3,
};

// Enum ReadyOrNot.ETrainingState
// NumValues: 0x001A
enum class ETrainingState : uint8
{
	TS_Invalid                               = 0,
	TS_Spawned                               = 1,
	TS_PickupWeapon                          = 2,
	TS_MoveToShooting                        = 3,
	TS_ReloadWeapon                          = 4,
	TS_TargetShooting1                       = 5,
	TS_TargetShooting2                       = 6,
	TS_EquipSecondary                        = 7,
	TS_ShootingChallenge1                    = 8,
	TS_ShootingChallenge2                    = 9,
	TS_UseLoadout                            = 10,
	TS_TargetGrenades                        = 11,
	TS_MoveToTraining                        = 12,
	TS_OpenDoor                              = 13,
	TS_KickDoor                              = 14,
	TS_MeetTheTeam                           = 15,
	TS_EnterTraining                         = 16,
	TS_ClearRoom1                            = 17,
	TS_ClearRoom2                            = 18,
	TS_ClearRoom3                            = 19,
	TS_ClearRoom4                            = 20,
	TS_Exfiltrate                            = 21,
	TS_Completed                             = 22,
	TS_Start                                 = 1,
	TS_Finish                                = 22,
	TS_MAX                                   = 23,
};

// Enum ReadyOrNot.EGameEventMetric
// NumValues: 0x0007
enum class EGameEventMetric : uint8
{
	GEM_NONE                                 = 0,
	GEM_GAME_STARTED                         = 1,
	GEM_GAME_JOINED                          = 2,
	GEM_GAME_FINISHED                        = 3,
	GEM_GAME_CRASHED                         = 4,
	GEM_PLAYER_GAME_FINISHED                 = 5,
	GEM_MAX                                  = 6,
};

// Enum ReadyOrNot.ETutorialMessageContext
// NumValues: 0x0002
enum class ETutorialMessageContext : uint8
{
	Movement                                 = 0,
	ETutorialMessageContext_MAX              = 1,
};

// Enum ReadyOrNot.ERONBuildConfiguration
// NumValues: 0x0008
enum class ERONBuildConfiguration : uint8
{
	Unknown                                  = 0,
	Editor                                   = 1,
	Debug                                    = 2,
	Development                              = 3,
	Shipping                                 = 4,
	FinalRelease                             = 5,
	Test                                     = 6,
	ERONBuildConfiguration_MAX               = 7,
};

// Enum ReadyOrNot.ECommWheelLockOnBehaviour
// NumValues: 0x0004
enum class ECommWheelLockOnBehaviour : uint8
{
	LB_LockOnToObstruction                   = 0,
	LB_KeepLockOn                            = 1,
	LB_CancelLockOnWhenObstructed            = 2,
	LB_MAX                                   = 3,
};

// Enum ReadyOrNot.EMedicalHealScreen
// NumValues: 0x0005
enum class EMedicalHealScreen : uint8
{
	MHS_Healer                               = 0,
	MHS_Healee                               = 1,
	MHS_MortallyWounded                      = 2,
	MHS_NoBrokenLimbs                        = 3,
	MHS_MAX                                  = 4,
};

// Enum ReadyOrNot.EFallInPattern
// NumValues: 0x0005
enum class EFallInPattern : uint8
{
	Snake                                    = 0,
	HalfSnake                                = 1,
	Diamond                                  = 2,
	Flock                                    = 3,
	EFallInPattern_MAX                       = 4,
};

// Enum ReadyOrNot.EDoorBreachType
// NumValues: 0x000A
enum class EDoorBreachType : uint8
{
	None                                     = 0,
	Open                                     = 1,
	Move                                     = 2,
	Kick                                     = 3,
	Shotgun                                  = 4,
	Ram                                      = 5,
	C2                                       = 6,
	Leader                                   = 7,
	Custom                                   = 8,
	EDoorBreachType_MAX                      = 9,
};

// Enum ReadyOrNot.EFilterMovePointGeneration
// NumValues: 0x0006
enum class EFilterMovePointGeneration : uint8
{
	FMNP_None                                = 0,
	FNMP_LeftOnly                            = 1,
	FNMP_RightOnly                           = 2,
	FNMP_HardLeft                            = 3,
	FNMP_HardRight                           = 4,
	EFilterMovePointGeneration_MAX           = 5,
};

// Enum ReadyOrNot.EChangeBehaviour
// NumValues: 0x0003
enum class EChangeBehaviour : uint8
{
	CB_Add                                   = 0,
	CB_Remove                                = 1,
	CB_MAX                                   = 2,
};

// Enum ReadyOrNot.EToggleBoneVis
// NumValues: 0x0004
enum class EToggleBoneVis : uint8
{
	TBV_None                                 = 0,
	TBV_HideBone                             = 1,
	TBV_ShowBone                             = 2,
	TBV_MAX                                  = 3,
};

// Enum ReadyOrNot.EScenarioImportance
// NumValues: 0x0004
enum class EScenarioImportance : uint8
{
	SI_None                                  = 0,
	SI_AlwaysSpawn                           = 1,
	SI_Pooled                                = 2,
	SI_MAX                                   = 3,
};

// Enum ReadyOrNot.EPathedAwareness
// NumValues: 0x0005
enum class EPathedAwareness : uint8
{
	PA_None                                  = 0,
	PA_Noise                                 = 1,
	PA_LastKnownEnemyPosition                = 2,
	PA_ActivityLocation                      = 3,
	PA_MAX                                   = 4,
};

// Enum ReadyOrNot.ETargetingCompTracking
// NumValues: 0x0012
enum class ETargetingCompTracking : uint8
{
	TCT_None                                 = 0,
	TCT_TrackingActivity                     = 1,
	TCT_TrackingCombatMoveActivity           = 2,
	TCT_TrackingVisibleNeutrals              = 3,
	TCT_TrackingEnemyLastKnownPosition       = 4,
	TCT_TrackingNoiseStimulus                = 5,
	TCT_TrackingOverrideInterests            = 6,
	TCT_TrackingStairThreatAwarenessActor    = 7,
	TCT_TrackingThreatAwarenessActor         = 8,
	TCT_TrackingLatestStimulus               = 9,
	TCT_TrackingVisibleTarget                = 10,
	TCT_TrackingMoveVector                   = 11,
	TCT_TrackScriptedFireAtActor             = 12,
	TCT_TrackNearestDoor                     = 13,
	TCT_TrackUncheckedThreatAwareness        = 14,
	TCT_TrackMontagePosition                 = 15,
	TCT_TrackCustomLocation                  = 16,
	TCT_MAX                                  = 17,
};

// Enum ReadyOrNot.EDoorCheckResult
// NumValues: 0x0006
enum class EDoorCheckResult : uint8
{
	None                                     = 0,
	Unlocked                                 = 1,
	Locked                                   = 2,
	Jammed                                   = 3,
	Blocked                                  = 4,
	EDoorCheckResult_MAX                     = 5,
};

// Enum ReadyOrNot.EClearingStyle
// NumValues: 0x0005
enum class EClearingStyle : uint8
{
	None                                     = 0,
	StrongWall                               = 1,
	PointsOfDomination                       = 2,
	RunningTheRabbit                         = 3,
	EClearingStyle_MAX                       = 4,
};

// Enum ReadyOrNot.EEntryMethod
// NumValues: 0x0003
enum class EEntryMethod : uint8
{
	Flow                                     = 0,
	ButtonHook                               = 1,
	EEntryMethod_MAX                         = 2,
};

// Enum ReadyOrNot.EThresholdAssessment
// NumValues: 0x0004
enum class EThresholdAssessment : uint8
{
	None                                     = 0,
	Pie                                      = 1,
	CenterCheck                              = 2,
	EThresholdAssessment_MAX                 = 3,
};

// Enum ReadyOrNot.EStackUpStyle
// NumValues: 0x0005
enum class EStackUpStyle : uint8
{
	Auto                                     = 0,
	Split                                    = 1,
	Left                                     = 2,
	Right                                    = 3,
	EStackUpStyle_MAX                        = 4,
};

// Enum ReadyOrNot.EItemVisualizationType
// NumValues: 0x0008
enum class EItemVisualizationType : uint8
{
	IVT_None                                 = 0,
	IVT_Primary                              = 1,
	IVT_Secondary                            = 2,
	IVT_LongTactical                         = 3,
	IVT_Helmet                               = 4,
	IVT_Armor                                = 5,
	IVT_Equipped                             = 6,
	IVT_MAX                                  = 7,
};

// Enum ReadyOrNot.EItemVisualizationStatus
// NumValues: 0x0003
enum class EItemVisualizationStatus : uint8
{
	IVS_None                                 = 0,
	IVS_FPEquipped                           = 1,
	IVS_MAX                                  = 2,
};

// Enum ReadyOrNot.EToggleInventoryVis
// NumValues: 0x0006
enum class EToggleInventoryVis : uint8
{
	TIV_None                                 = 0,
	TIV_HideAll                              = 1,
	TIV_ShowAll                              = 2,
	TIV_HideEquipped                         = 3,
	TIV_ShowEquipped                         = 4,
	TIV_MAX                                  = 5,
};

// Enum ReadyOrNot.EOptiwandViewMode
// NumValues: 0x0003
enum class EOptiwandViewMode : uint8
{
	PiP                                      = 0,
	Fullscreen                               = 1,
	EOptiwandViewMode_MAX                    = 2,
};

// Enum ReadyOrNot.EGameFeature
// NumValues: 0x0007
enum class EGameFeature : uint8
{
	GF_None                                  = 0,
	GF_Practice                              = 1,
	GF_Training                              = 2,
	GF_Commander                             = 3,
	GF_Mulitplayer                           = 4,
	GF_ModSupport                            = 5,
	MAX                                      = 6,
};

// Enum ReadyOrNot.ECoverQueryTestPurpose
// NumValues: 0x0004
enum class ECoverQueryTestPurpose : uint8
{
	FilterOnly                               = 0,
	ScoreOnly                                = 1,
	FilterAndScore                           = 2,
	ECoverQueryTestPurpose_MAX               = 3,
};

// Enum ReadyOrNot.EFleeType
// NumValues: 0x0004
enum class EFleeType : uint8
{
	FT_None                                  = 0,
	FT_Regular                               = 1,
	FT_Gas                                   = 2,
	FT_MAX                                   = 3,
};

// Enum ReadyOrNot.EGraphNodeType
// NumValues: 0x0004
enum class EGraphNodeType : uint8
{
	Portal                                   = 0,
	Listener                                 = 1,
	SoundSource                              = 2,
	EGraphNodeType_MAX                       = 3,
};

// Enum ReadyOrNot.EImpactEffectType
// NumValues: 0x0009
enum class EImpactEffectType : uint8
{
	Default                                  = 0,
	Rifle                                    = 1,
	Pistol                                   = 2,
	Shotgun                                  = 3,
	Ricochet                                 = 4,
	Beanbag                                  = 5,
	Pepperball                               = 6,
	Flare                                    = 7,
	EImpactEffectType_MAX                    = 8,
};

// Enum ReadyOrNot.EObjectiveDoorInteractions
// NumValues: 0x0004
enum class EObjectiveDoorInteractions : uint8
{
	ODI_Open                                 = 0,
	ODI_Close                                = 1,
	ODI_Kick                                 = 2,
	ODI_MAX                                  = 3,
};

// Enum ReadyOrNot.EInterestPointType
// NumValues: 0x0006
enum class EInterestPointType : uint8
{
	Manual                                   = 0,
	Threat                                   = 1,
	Door                                     = 2,
	Spawner                                  = 3,
	CustomActor                              = 4,
	EInterestPointType_MAX                   = 5,
};

// Enum ReadyOrNot.ELoadoutTacticalSlotType
// NumValues: 0x0005
enum class ELoadoutTacticalSlotType : uint8
{
	TacticalSlot                             = 0,
	PrimaryAmmunition                        = 1,
	SecondaryAmmunition                      = 2,
	GrenadeSlot                              = 3,
	ELoadoutTacticalSlotType_MAX             = 4,
};

// Enum ReadyOrNot.EMaskMagState
// NumValues: 0x0003
enum class EMaskMagState : uint8
{
	Show                                     = 0,
	Hide                                     = 1,
	EMaskMagState_MAX                        = 2,
};

// Enum ReadyOrNot.EMaskMag
// NumValues: 0x0004
enum class EMaskMag : uint8
{
	Mag01                                    = 0,
	Mag02                                    = 1,
	Dummy                                    = 2,
	EMaskMag_MAX                             = 3,
};

// Enum ReadyOrNot.ESuspectStateData
// NumValues: 0x0006
enum class ESuspectStateData : uint8
{
	SSD_NONE                                 = 0,
	SSD_IS_TRACKING                          = 1,
	SSD_HAS_BEST_ACTION                      = 2,
	SSD_HAS_BEST_CONTINUOUS_ACTION           = 4,
	SSD_HAS_BEST_COMBAT_MOVE_ACTION          = 8,
	SSD_MAX                                  = 9,
};

// Enum ReadyOrNot.EActorAnalyticsState
// NumValues: 0x0005
enum class EActorAnalyticsState : uint8
{
	AAS_None                                 = 0,
	AAS_Wounded                              = 1,
	AAS_Dead                                 = 2,
	AAS_Arrested                             = 3,
	AAS_MAX                                  = 4,
};

// Enum ReadyOrNot.EMirrorContactType
// NumValues: 0x0005
enum class EMirrorContactType : uint8
{
	AI                                       = 0,
	Trap                                     = 1,
	Custom                                   = 2,
	Both                                     = 3,
	EMirrorContactType_MAX                   = 4,
};

// Enum ReadyOrNot.EReadyState
// NumValues: 0x0005
enum class EReadyState : uint8
{
	RS_None                                  = 0,
	RS_Minority                              = 1,
	RS_Majority                              = 2,
	RS_All                                   = 3,
	RS_MAX                                   = 4,
};

// Enum ReadyOrNot.EModStatus
// NumValues: 0x0008
enum class EModStatus : uint8
{
	Unsubscribed                             = 0,
	Installing                               = 1,
	Updating                                 = 2,
	Installed                                = 3,
	Disabled                                 = 4,
	Uninstalling                             = 5,
	Error                                    = 6,
	EModStatus_MAX                           = 7,
};

// Enum ReadyOrNot.EMusicState
// NumValues: 0x0005
enum class EMusicState : uint8
{
	MS_Preplanning                           = 0,
	MS_Ambient                               = 1,
	MS_Action                                = 2,
	MS_Scripted                              = 3,
	MS_MAX                                   = 4,
};

// Enum ReadyOrNot.EHiddenObjectiveUnlockMethod
// NumValues: 0x0005
enum class EHiddenObjectiveUnlockMethod : uint8
{
	Unlock_None                              = 0,
	Unlock_Reportable                        = 1,
	Unlock_Objective                         = 2,
	Unlock_Self                              = 3,
	Unlock_MAX                               = 4,
};

// Enum ReadyOrNot.EObjectiveStatus
// NumValues: 0x0004
enum class EObjectiveStatus : uint8
{
	Objective_InProgress                     = 0,
	Objective_Complete                       = 1,
	Objective_Failed                         = 2,
	Objective_MAX                            = 3,
};

// Enum ReadyOrNot.EInputExclusiveType
// NumValues: 0x0005
enum class EInputExclusiveType : uint8
{
	AllInputs                                = 0,
	MouseAndKeyboard                         = 1,
	Gamepad                                  = 2,
	Touch                                    = 3,
	EInputExclusiveType_MAX                  = 4,
};

// Enum ReadyOrNot.EPlanningMapTool
// NumValues: 0x0003
enum class EPlanningMapTool : uint8
{
	PMT_Draw                                 = 0,
	PMT_Pan                                  = 1,
	PMT_MAX                                  = 2,
};

// Enum ReadyOrNot.EPlanningMapStage
// NumValues: 0x0008
enum class EPlanningMapStage : uint8
{
	PMS_Overview                             = 0,
	PMS_Spawn                                = 1,
	PMS_Deployables                          = 2,
	PMS_PersonnelMain                        = 3,
	PMS_PersonnelPoint                       = 4,
	PMS_PersonnelMapZones                    = 5,
	PMS_FreeDraw                             = 6,
	PMS_MAX                                  = 7,
};

// Enum ReadyOrNot.EPlanningStage
// NumValues: 0x0005
enum class EPlanningStage : uint8
{
	PS_None                                  = 0,
	PS_Planning                              = 1,
	PS_Situation                             = 2,
	PS_Loadout                               = 3,
	PS_MAX                                   = 4,
};

// Enum ReadyOrNot.ESituationPage
// NumValues: 0x0006
enum class ESituationPage : uint8
{
	SP_None                                  = 0,
	SP_Objectives                            = 1,
	SP_Suspects                              = 2,
	SP_Civilians                             = 3,
	SP_Timeline                              = 4,
	SP_MAX                                   = 5,
};

// Enum ReadyOrNot.EPlanningPage
// NumValues: 0x0007
enum class EPlanningPage : uint8
{
	PP_None                                  = 0,
	PP_Overview                              = 1,
	PP_Spawn                                 = 2,
	PP_Deployables                           = 3,
	PP_Tactics                               = 4,
	PP_FreePlanning                          = 5,
	PP_MAX                                   = 6,
};

// Enum ReadyOrNot.EIKStateEnum
// NumValues: 0x0004
enum class EIKStateEnum : uint8
{
	IKE_None                                 = 0,
	IKE_Optimize                             = 1,
	IKE_Full                                 = 2,
	IKE_MAX                                  = 3,
};

// Enum ReadyOrNot.EHolsterAnimationType
// NumValues: 0x0004
enum class EHolsterAnimationType : uint8
{
	HAT_Normal                               = 0,
	HAT_SkipHolster                          = 1,
	HAT_AlwaysPlayHolster                    = 2,
	HAT_MAX                                  = 3,
};

// Enum ReadyOrNot.ERecoilModifierOption
// NumValues: 0x0004
enum class ERecoilModifierOption : uint8
{
	RMO_ModifyRecoil                         = 0,
	RMO_AddRecoil                            = 1,
	RMO_SubtractRecoil                       = 2,
	RMO_MAX                                  = 3,
};

// Enum ReadyOrNot.EPortalType
// NumValues: 0x0003
enum class EPortalType : uint8
{
	Vertical                                 = 0,
	Horizontal                               = 1,
	EPortalType_MAX                          = 2,
};

// Enum ReadyOrNot.EPostProcessState
// NumValues: 0x0006
enum class EPostProcessState : uint8
{
	Hold                                     = 0,
	Forward                                  = 1,
	Reverse                                  = 2,
	WaitingForReverse                        = 3,
	Ended                                    = 4,
	EPostProcessState_MAX                    = 5,
};

// Enum ReadyOrNot.EPostProcessEndOptions
// NumValues: 0x0005
enum class EPostProcessEndOptions : uint8
{
	End                                      = 0,
	Hold                                     = 1,
	Loop                                     = 2,
	Reverse                                  = 3,
	EPostProcessEndOptions_MAX               = 4,
};

// Enum ReadyOrNot.EPostProcessStartingState
// NumValues: 0x0003
enum class EPostProcessStartingState : uint8
{
	Forward                                  = 0,
	Reverse                                  = 1,
	EPostProcessStartingState_MAX            = 2,
};

// Enum ReadyOrNot.EPostProcessPlayDirection
// NumValues: 0x0003
enum class EPostProcessPlayDirection : uint8
{
	Forwards                                 = 0,
	Backwards                                = 1,
	EPostProcessPlayDirection_MAX            = 2,
};

// Enum ReadyOrNot.ELevelGrade
// NumValues: 0x0009
enum class ELevelGrade : uint32
{
	S                                        = 0,
	APlus                                    = 1,
	A                                        = 2,
	B                                        = 3,
	C                                        = 4,
	D                                        = 5,
	E                                        = 6,
	F                                        = 7,
	ELevelGrade_MAX                          = 8,
};

// Enum ReadyOrNot.EMoveDirectionExt
// NumValues: 0x0009
enum class EMoveDirectionExt : uint8
{
	F                                        = 0,
	L                                        = 1,
	R                                        = 2,
	B                                        = 3,
	FL                                       = 4,
	FR                                       = 5,
	BR                                       = 6,
	BL                                       = 7,
	EMoveDirectionExt_MAX                    = 8,
};

// Enum ReadyOrNot.EMoveDirection
// NumValues: 0x0005
enum class EMoveDirection : uint8
{
	F                                        = 0,
	L                                        = 1,
	R                                        = 2,
	B                                        = 3,
	EMoveDirection_MAX                       = 4,
};

// Enum ReadyOrNot.ERuntimeDevice
// NumValues: 0x000B
enum class ERuntimeDevice : uint8
{
	PS4                                      = 0,
	PS4_Pro                                  = 1,
	PS4_Pro_4K                               = 2,
	PS5                                      = 3,
	XBoxOne                                  = 4,
	XBoxOneS                                 = 5,
	XBoxOneX                                 = 6,
	XBoxSeriesX                              = 7,
	XBoxSeriesS                              = 8,
	PC                                       = 9,
	ERuntimeDevice_MAX                       = 10,
};

// Enum ReadyOrNot.EHighScoreCategory
// NumValues: 0x0006
enum class EHighScoreCategory : uint8
{
	HSC_None                                 = 0,
	HSC_COOP_DAILY                           = 1,
	HSC_COOP_SEASON                          = 2,
	HSC_PVP_DAILY                            = 3,
	HSC_PVP_SEASON                           = 4,
	HSC_MAX                                  = 5,
};

// Enum ReadyOrNot.PTTKey
// NumValues: 0x0004
enum class EPTTKey : uint8
{
	PTTNoChannel                             = 0,
	PTTAreaChannel                           = 1,
	PTTTeamChannel                           = 2,
	PTTKey_MAX                               = 3,
};

// Enum ReadyOrNot.ESubtitlesSize
// NumValues: 0x0005
enum class ESubtitlesSize : uint8
{
	Small                                    = 0,
	Normal                                   = 1,
	Large                                    = 2,
	ExtraLarge                               = 3,
	ESubtitlesSize_MAX                       = 4,
};

// Enum ReadyOrNot.ENVGStyle
// NumValues: 0x0003
enum class ENVGStyle : uint8
{
	GreenPhosphor                            = 0,
	WhitePhosphor                            = 1,
	ENVGStyle_MAX                            = 2,
};

// Enum ReadyOrNot.EScoreReadoutMode
// NumValues: 0x0005
enum class EScoreReadoutMode : uint8
{
	AllScores                                = 0,
	OnlyPositive                             = 1,
	OnlyNegative                             = 2,
	Disabled                                 = 3,
	EScoreReadoutMode_MAX                    = 4,
};

// Enum ReadyOrNot.EEmptyMagReloadType
// NumValues: 0x0003
enum class EEmptyMagReloadType : uint8
{
	RegularReload                            = 0,
	FastReload                               = 1,
	EEmptyMagReloadType_MAX                  = 2,
};

// Enum ReadyOrNot.EShotgunReloadType
// NumValues: 0x0003
enum class EShotgunReloadType : uint8
{
	SRT_SingleLoad                           = 0,
	SRT_MultiLoad                            = 1,
	SRT_MAX                                  = 2,
};

// Enum ReadyOrNot.EGrenadeThrowSettingType
// NumValues: 0x0003
enum class EGrenadeThrowSettingType : uint8
{
	GUT_QuickGrenadeThrow                    = 0,
	GUT_ClassicGrenadeThrow                  = 1,
	GUT_MAX                                  = 2,
};

// Enum ReadyOrNot.ECommandInterfaceType
// NumValues: 0x0003
enum class ECommandInterfaceType : uint8
{
	CI_GraphicCommandInterface               = 0,
	CI_ClassicCommandInterface               = 1,
	CI_MAX                                   = 2,
};

// Enum ReadyOrNot.ELoadoutMunitionSlotType
// NumValues: 0x0005
enum class ELoadoutMunitionSlotType : uint8
{
	TacticalSlot                             = 0,
	PrimaryAmmunition                        = 1,
	SecondaryAmmunition                      = 2,
	GrenadeSlot                              = 3,
	ELoadoutMunitionSlotType_MAX             = 4,
};

// Enum ReadyOrNot.EAnimationType
// NumValues: 0x0005
enum class EAnimationType : uint8
{
	AT_Gun_FP                                = 0,
	AT_Gun_TP                                = 1,
	AT_Body_FP                               = 2,
	AT_Body_TP                               = 3,
	AT_MAX                                   = 4,
};

// Enum ReadyOrNot.EBaseAnimType_TP
// NumValues: 0x0011
enum class EBaseAnimType_TP : uint8
{
	IdlePose_Low_TP                          = 0,
	IdlePose_Up_TP                           = 1,
	IdlePose_Shld_TP                         = 2,
	IdlePose_Sights_TP                       = 3,
	IdlePose_Ret_TP                          = 4,
	IdlePose_Ovr_TP                          = 5,
	Crouch_IdlePose_Low_TP                   = 6,
	Crouch_IdlePose_Up_TP                    = 7,
	Crouch_IdlePose_Shld_TP                  = 8,
	Crouch_IdlePose_Sights_TP                = 9,
	Crouch_IdlePose_Ret_TP                   = 10,
	Crouch_IdlePose_Ovr_TP                   = 11,
	IdlePose_AFG_TP                          = 12,
	IdlePose_VFG_TP                          = 13,
	IdlePose_HSTOP_TP                        = 14,
	ENone                                    = 15,
	EBaseAnimType_MAX                        = 16,
};

// Enum ReadyOrNot.EBaseBlendspaces_FP
// NumValues: 0x0003
enum class EBaseBlendspaces_FP : uint8
{
	Look_BS_FP                               = 0,
	ENone                                    = 1,
	EBaseBlendspaces_MAX                     = 2,
};

// Enum ReadyOrNot.EBaseAnimType_FP
// NumValues: 0x0011
enum class EBaseAnimType_FP : uint8
{
	IdlePose_FP                              = 0,
	Idle_FP                                  = 1,
	Run_FP                                   = 2,
	Walk_FP                                  = 3,
	Run_Limp_FP                              = 4,
	Walk_Limp_FP                             = 5,
	Lowered_Up_Pose_FP                       = 6,
	Lowered_Down_Pose_FP                     = 7,
	ADS_Run_FP                               = 8,
	ADS_Walk_FP                              = 9,
	ADS_Run_Limp_FP                          = 10,
	ADS_Walk_Limp_FP                         = 11,
	IdlePose_AFG_FP                          = 12,
	IdlePose_VFG_FP                          = 13,
	IdlePose_HSTOP_FP                        = 14,
	ENone                                    = 15,
	EBaseAnimType_MAX                        = 16,
};

// Enum ReadyOrNot.ESplineRotation
// NumValues: 0x0004
enum class ESplineRotation : uint8
{
	IntoPath                                 = 0,
	Default                                  = 1,
	Free                                     = 2,
	ESplineRotation_MAX                      = 3,
};

// Enum ReadyOrNot.ECameraState
// NumValues: 0x0004
enum class ECameraState : uint8
{
	Freecam                                  = 0,
	Orbit                                    = 1,
	Mounted                                  = 2,
	ECameraState_MAX                         = 3,
};

// Enum ReadyOrNot.EStrafeDirection
// NumValues: 0x0009
enum class EStrafeDirection : uint8
{
	F                                        = 0,
	L                                        = 1,
	R                                        = 2,
	B                                        = 3,
	FL                                       = 4,
	FR                                       = 5,
	BR                                       = 6,
	BL                                       = 7,
	EStrafeDirection_MAX                     = 8,
};

// Enum ReadyOrNot.EItemOverrideRule
// NumValues: 0x0005
enum class EItemOverrideRule : uint8
{
	NONE                                     = 0,
	ADDITIVE_ONLY                            = 1,
	LAYERED_ONLY                             = 2,
	ADDITIVE_LAYERED                         = 3,
	EItemOverrideRule_MAX                    = 4,
};

// Enum ReadyOrNot.ERoNGaitState
// NumValues: 0x0005
enum class ERoNGaitState : uint8
{
	RON_TURN                                 = 0,
	RON_WALK                                 = 1,
	RON_RUN                                  = 2,
	RON_SPRINT                               = 3,
	RON_MAX                                  = 4,
};

// Enum ReadyOrNot.ERoomSize
// NumValues: 0x0005
enum class ERoomSize : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	Corridor                                 = 3,
	ERoomSize_MAX                            = 4,
};

// Enum ReadyOrNot.ERosterRemovalReason
// NumValues: 0x0005
enum class ERosterRemovalReason : uint8
{
	None                                     = 0,
	Deceased                                 = 1,
	Overstressed                             = 2,
	Fired                                    = 3,
	ERosterRemovalReason_MAX                 = 4,
};

// Enum ReadyOrNot.ERosterSquadPosition
// NumValues: 0x0006
enum class ERosterSquadPosition : uint8
{
	Unassigned                               = 0,
	RedOne                                   = 1,
	RedTwo                                   = 2,
	BlueOne                                  = 3,
	BlueTwo                                  = 4,
	ERosterSquadPosition_MAX                 = 5,
};

// Enum ReadyOrNot.ERosterCharacterState
// NumValues: 0x0005
enum class ERosterCharacterState : uint8
{
	Available                                = 0,
	Incapacitated                            = 1,
	InTherapy                                = 2,
	Deceased                                 = 3,
	ERosterCharacterState_MAX                = 4,
};

// Enum ReadyOrNot.ERosterPortalType
// NumValues: 0x0005
enum class ERosterPortalType : uint8
{
	Roster                                   = 0,
	Therapist                                = 1,
	Loadout                                  = 2,
	Training                                 = 3,
	ERosterPortalType_MAX                    = 4,
};

// Enum ReadyOrNot.EDoorScanMethod
// NumValues: 0x0006
enum class EDoorScanMethod : uint8
{
	None                                     = 0,
	Slide                                    = 1,
	Slice                                    = 2,
	Snap                                     = 3,
	CenterCheck                              = 4,
	EDoorScanMethod_MAX                      = 5,
};

// Enum ReadyOrNot.EObjectiveLevel
// NumValues: 0x0004
enum class EObjectiveLevel : uint8
{
	PrimaryObjective                         = 0,
	SecondaryObjective                       = 1,
	TertiaryObjective                        = 2,
	EObjectiveLevel_MAX                      = 3,
};

// Enum ReadyOrNot.EInputKeyCategoryV2
// NumValues: 0x0004
enum class EInputKeyCategoryV2 : uint8
{
	KE_Shared                                = 0,
	KE_Character                             = 1,
	KE_Drone                                 = 2,
	KE_MAX                                   = 3,
};

// Enum ReadyOrNot.EHierarchyType
// NumValues: 0x0004
enum class EHierarchyType : uint8
{
	HT_Default                               = 0,
	HT_Parent                                = 1,
	HT_Child                                 = 2,
	HT_MAX                                   = 3,
};

// Enum ReadyOrNot.EPropagationType
// NumValues: 0x0003
enum class EPropagationType : uint8
{
	PT_None                                  = 0,
	PT_Portal                                = 1,
	PT_MAX                                   = 2,
};

// Enum ReadyOrNot.EOcclusionType
// NumValues: 0x0004
enum class EOcclusionType : uint8
{
	OT_None                                  = 0,
	OT_Depth                                 = 1,
	OT_Angular                               = 2,
	OT_MAX                                   = 3,
};

// Enum ReadyOrNot.ESoundSourceType
// NumValues: 0x0003
enum class ESoundSourceType : uint8
{
	SST_FirstPerson                          = 0,
	SST_ThirdPerson                          = 1,
	SST_MAX                                  = 2,
};

// Enum ReadyOrNot.EPriorityOfLife
// NumValues: 0x0006
enum class EPriorityOfLife : uint8
{
	Hostages                                 = 0,
	Civilians                                = 1,
	EmergencyPersonnel                       = 2,
	Suspects                                 = 3,
	Evidence                                 = 4,
	EPriorityOfLife_MAX                      = 5,
};

// Enum ReadyOrNot.EAbortCoverReason
// NumValues: 0x0009
enum class EAbortCoverReason : uint8
{
	Success                                  = 0,
	Forced                                   = 1,
	EnemySensed                              = 2,
	SeenEnemyApproaching                     = 3,
	HeardEnemyApproaching                    = 4,
	EnemyMovingTowardsUs                     = 5,
	EnemyBehindUs                            = 6,
	EnemyFiredNearUs                         = 7,
	EAbortCoverReason_MAX                    = 8,
};

// Enum ReadyOrNot.EThreatLevel
// NumValues: 0x0007
enum class EThreatLevel : uint8
{
	TL_None                                  = 0,
	TL_Low                                   = 1,
	TL_Medium                                = 2,
	TL_High                                  = 3,
	TL_Extreme                               = 4,
	TL_Stairs                                = 5,
	TL_MAX                                   = 6,
};

// Enum ReadyOrNot.ETutorialMissionType
// NumValues: 0x000A
enum class ETutorialMissionType : uint8
{
	ETM_None                                 = 0,
	ETM_ShootingRange                        = 1,
	ETM_KillHouse                            = 2,
	ETM_BasicControls                        = 3,
	ETM_Mirrorgun                            = 4,
	ETM_StackUp                              = 5,
	ETM_Arrest                               = 6,
	ETM_Grenades                             = 7,
	ETM_Movement                             = 8,
	ETM_MAX                                  = 9,
};

// Enum ReadyOrNot.ECompletedActionType
// NumValues: 0x0010
enum class ECompletedActionType : uint8
{
	CAT_ArrestedTarget                       = 0,
	CAT_ReportedTarget                       = 1,
	CAT_FreedTarget                          = 2,
	CAT_LockPicked                           = 3,
	CAT_LadderRetracted                      = 4,
	CAT_ItemRetrieved                        = 5,
	CAT_MagInserted                          = 6,
	CAT_MagRemoved                           = 7,
	CAT_MagChanged                           = 8,
	CAT_InteractActor                        = 9,
	CAT_WedgeDeployed                        = 10,
	CAT_C2Deployed                           = 11,
	CAT_WedgeRemoved                         = 12,
	CAT_TrapDisarmed                         = 13,
	CAT_C2Removed                            = 14,
	CAT_MAX                                  = 15,
};

// Enum ReadyOrNot.EPlayerObjectiveMarkerType
// NumValues: 0x0005
enum class EPlayerObjectiveMarkerType : uint8
{
	POMT_None                                = 0,
	POMT_VipRescue                           = 1,
	POMT_VipExecute                          = 2,
	POMT_Free                                = 3,
	POMT_MAX                                 = 4,
};

// Enum ReadyOrNot.EMapType
// NumValues: 0x0004
enum class EMapType : uint8
{
	Axis                                     = 0,
	Action                                   = 1,
	Auto                                     = 2,
	EMapType_MAX                             = 3,
};

// Enum ReadyOrNot.EInterfaceSoundType
// NumValues: 0x0004
enum class EInterfaceSoundType : uint8
{
	IST_None                                 = 0,
	IST_Checkmark                            = 1,
	IST_Button                               = 2,
	IST_MAX                                  = 3,
};

// Enum ReadyOrNot.EScreenspaceMarkerType
// NumValues: 0x0003
enum class EScreenspaceMarkerType : uint8
{
	SMT_InActivationArea                     = 0,
	SMT_TutorialClosed                       = 1,
	SMT_MAX                                  = 2,
};

// Enum ReadyOrNot.ETooltipActivationType
// NumValues: 0x0004
enum class ETooltipActivationType : uint8
{
	TAT_EnterArea                            = 0,
	TAT_DirectLook                           = 1,
	TAT_LineOfSight                          = 2,
	TAT_MAX                                  = 3,
};

// Enum ReadyOrNot.EMatchmakingStatus
// NumValues: 0x0006
enum class EMatchmakingStatus : uint8
{
	MS_None                                  = 0,
	MS_Matchmaking                           = 1,
	MS_Success                               = 2,
	MS_Failure                               = 3,
	MS_Cancelled                             = 4,
	MS_MAX                                   = 5,
};

// ScriptStruct ReadyOrNot.LevelDeployableData
// 0x0010 (0x0010 - 0x0000)
struct FLevelDeployableData final 
{
public:
	class UDeployableData*                        DeployableData;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PtsCost;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ED6[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelDeployableData) == 0x000008, "Wrong alignment on FLevelDeployableData");
static_assert(sizeof(FLevelDeployableData) == 0x000010, "Wrong size on FLevelDeployableData");
static_assert(offsetof(FLevelDeployableData, DeployableData) == 0x000000, "Member 'FLevelDeployableData::DeployableData' has a wrong offset!");
static_assert(offsetof(FLevelDeployableData, PtsCost) == 0x000008, "Member 'FLevelDeployableData::PtsCost' has a wrong offset!");

// ScriptStruct ReadyOrNot.SpawnPoints
// 0x0090 (0x0090 - 0x0000)
struct FSpawnPoints final 
{
public:
	class FText                                   SpawnPointName;                                    // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              SpawnImage;                                        // 0x0018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SpawnDescription;                                  // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FLevelDeployableData>           RecommendedDeployables;                            // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PlanningFloorNum;                                  // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlanningZoomLevel;                                 // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PlanningShift;                                     // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PlanningCoordinate;                                // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PtsCost;                                           // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnDisabled;                                    // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ED7[0x3];                                     // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpawnLabel;                                        // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnPoints) == 0x000008, "Wrong alignment on FSpawnPoints");
static_assert(sizeof(FSpawnPoints) == 0x000090, "Wrong size on FSpawnPoints");
static_assert(offsetof(FSpawnPoints, SpawnPointName) == 0x000000, "Member 'FSpawnPoints::SpawnPointName' has a wrong offset!");
static_assert(offsetof(FSpawnPoints, SpawnImage) == 0x000018, "Member 'FSpawnPoints::SpawnImage' has a wrong offset!");
static_assert(offsetof(FSpawnPoints, SpawnDescription) == 0x000040, "Member 'FSpawnPoints::SpawnDescription' has a wrong offset!");
static_assert(offsetof(FSpawnPoints, RecommendedDeployables) == 0x000058, "Member 'FSpawnPoints::RecommendedDeployables' has a wrong offset!");
static_assert(offsetof(FSpawnPoints, PlanningFloorNum) == 0x000068, "Member 'FSpawnPoints::PlanningFloorNum' has a wrong offset!");
static_assert(offsetof(FSpawnPoints, PlanningZoomLevel) == 0x00006C, "Member 'FSpawnPoints::PlanningZoomLevel' has a wrong offset!");
static_assert(offsetof(FSpawnPoints, PlanningShift) == 0x000070, "Member 'FSpawnPoints::PlanningShift' has a wrong offset!");
static_assert(offsetof(FSpawnPoints, PlanningCoordinate) == 0x000078, "Member 'FSpawnPoints::PlanningCoordinate' has a wrong offset!");
static_assert(offsetof(FSpawnPoints, PtsCost) == 0x000080, "Member 'FSpawnPoints::PtsCost' has a wrong offset!");
static_assert(offsetof(FSpawnPoints, bSpawnDisabled) == 0x000084, "Member 'FSpawnPoints::bSpawnDisabled' has a wrong offset!");
static_assert(offsetof(FSpawnPoints, SpawnLabel) == 0x000088, "Member 'FSpawnPoints::SpawnLabel' has a wrong offset!");

// ScriptStruct ReadyOrNot.WeaponAnim
// 0x0020 (0x0020 - 0x0000)
struct FWeaponAnim final 
{
public:
	class UAnimMontage*                           Body_FP;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Body_TP;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Gun_FP;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Gun_TP;                                            // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponAnim) == 0x000008, "Wrong alignment on FWeaponAnim");
static_assert(sizeof(FWeaponAnim) == 0x000020, "Wrong size on FWeaponAnim");
static_assert(offsetof(FWeaponAnim, Body_FP) == 0x000000, "Member 'FWeaponAnim::Body_FP' has a wrong offset!");
static_assert(offsetof(FWeaponAnim, Body_TP) == 0x000008, "Member 'FWeaponAnim::Body_TP' has a wrong offset!");
static_assert(offsetof(FWeaponAnim, Gun_FP) == 0x000010, "Member 'FWeaponAnim::Gun_FP' has a wrong offset!");
static_assert(offsetof(FWeaponAnim, Gun_TP) == 0x000018, "Member 'FWeaponAnim::Gun_TP' has a wrong offset!");

// ScriptStruct ReadyOrNot.RonInputKeyGamePadIconTable
// 0x0110 (0x0118 - 0x0008)
struct FRonInputKeyGamePadIconTable final  : public FTableRowBase
{
public:
	struct FSlateBrush                            PS5;                                               // 0x0008(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            XSX;                                               // 0x0090(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRonInputKeyGamePadIconTable) == 0x000008, "Wrong alignment on FRonInputKeyGamePadIconTable");
static_assert(sizeof(FRonInputKeyGamePadIconTable) == 0x000118, "Wrong size on FRonInputKeyGamePadIconTable");
static_assert(offsetof(FRonInputKeyGamePadIconTable, PS5) == 0x000008, "Member 'FRonInputKeyGamePadIconTable::PS5' has a wrong offset!");
static_assert(offsetof(FRonInputKeyGamePadIconTable, XSX) == 0x000090, "Member 'FRonInputKeyGamePadIconTable::XSX' has a wrong offset!");

// ScriptStruct ReadyOrNot.WeaponData
// 0x00B8 (0x00B8 - 0x0000)
struct FWeaponData final 
{
public:
	TArray<EWeaponType>                           IncludedInWeaponCategories;                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   WeaponType;                                        // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EItemClass                                    ItemClass;                                         // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ED8[0x7];                                     // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseWeapon>                Blueprint;                                         // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointsAvailable;                                   // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ED9[0x4];                                     // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              FactorySkinImage;                                  // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class USkinComponent>>     AvailableSkins;                                    // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class USkinComponent>             CurrentSkin;                                       // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponData) == 0x000008, "Wrong alignment on FWeaponData");
static_assert(sizeof(FWeaponData) == 0x0000B8, "Wrong size on FWeaponData");
static_assert(offsetof(FWeaponData, IncludedInWeaponCategories) == 0x000000, "Member 'FWeaponData::IncludedInWeaponCategories' has a wrong offset!");
static_assert(offsetof(FWeaponData, Name) == 0x000010, "Member 'FWeaponData::Name' has a wrong offset!");
static_assert(offsetof(FWeaponData, Image) == 0x000020, "Member 'FWeaponData::Image' has a wrong offset!");
static_assert(offsetof(FWeaponData, WeaponType) == 0x000048, "Member 'FWeaponData::WeaponType' has a wrong offset!");
static_assert(offsetof(FWeaponData, ItemClass) == 0x000060, "Member 'FWeaponData::ItemClass' has a wrong offset!");
static_assert(offsetof(FWeaponData, Blueprint) == 0x000068, "Member 'FWeaponData::Blueprint' has a wrong offset!");
static_assert(offsetof(FWeaponData, PointsAvailable) == 0x000070, "Member 'FWeaponData::PointsAvailable' has a wrong offset!");
static_assert(offsetof(FWeaponData, FactorySkinImage) == 0x000078, "Member 'FWeaponData::FactorySkinImage' has a wrong offset!");
static_assert(offsetof(FWeaponData, AvailableSkins) == 0x0000A0, "Member 'FWeaponData::AvailableSkins' has a wrong offset!");
static_assert(offsetof(FWeaponData, CurrentSkin) == 0x0000B0, "Member 'FWeaponData::CurrentSkin' has a wrong offset!");

// ScriptStruct ReadyOrNot.MeshFOVMaterials
// 0x0010 (0x0010 - 0x0000)
struct FMeshFOVMaterials final 
{
public:
	TArray<class UMaterialInstanceDynamic*>       FovMats;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshFOVMaterials) == 0x000008, "Wrong alignment on FMeshFOVMaterials");
static_assert(sizeof(FMeshFOVMaterials) == 0x000010, "Wrong size on FMeshFOVMaterials");
static_assert(offsetof(FMeshFOVMaterials, FovMats) == 0x000000, "Member 'FMeshFOVMaterials::FovMats' has a wrong offset!");

// ScriptStruct ReadyOrNot.SavedWeaponAttachmentData
// 0x0058 (0x0058 - 0x0000)
struct FSavedWeaponAttachmentData final 
{
public:
	bool                                          bHasSavedData;                                     // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EDA[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UWeaponAttachment>          ScopeAttachment;                                   // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          MuzzleAttachment;                                  // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          UnderbarrelAttachment;                             // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          OverbarrelAttachment;                              // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          StockAttachment;                                   // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          GripAttachment;                                    // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          IlluminatorAttachment;                             // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          AmmunitionAttachment;                              // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class USkinComponent>             Skin;                                              // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoCount;                                         // 0x0050(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EDB[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSavedWeaponAttachmentData) == 0x000008, "Wrong alignment on FSavedWeaponAttachmentData");
static_assert(sizeof(FSavedWeaponAttachmentData) == 0x000058, "Wrong size on FSavedWeaponAttachmentData");
static_assert(offsetof(FSavedWeaponAttachmentData, bHasSavedData) == 0x000000, "Member 'FSavedWeaponAttachmentData::bHasSavedData' has a wrong offset!");
static_assert(offsetof(FSavedWeaponAttachmentData, ScopeAttachment) == 0x000008, "Member 'FSavedWeaponAttachmentData::ScopeAttachment' has a wrong offset!");
static_assert(offsetof(FSavedWeaponAttachmentData, MuzzleAttachment) == 0x000010, "Member 'FSavedWeaponAttachmentData::MuzzleAttachment' has a wrong offset!");
static_assert(offsetof(FSavedWeaponAttachmentData, UnderbarrelAttachment) == 0x000018, "Member 'FSavedWeaponAttachmentData::UnderbarrelAttachment' has a wrong offset!");
static_assert(offsetof(FSavedWeaponAttachmentData, OverbarrelAttachment) == 0x000020, "Member 'FSavedWeaponAttachmentData::OverbarrelAttachment' has a wrong offset!");
static_assert(offsetof(FSavedWeaponAttachmentData, StockAttachment) == 0x000028, "Member 'FSavedWeaponAttachmentData::StockAttachment' has a wrong offset!");
static_assert(offsetof(FSavedWeaponAttachmentData, GripAttachment) == 0x000030, "Member 'FSavedWeaponAttachmentData::GripAttachment' has a wrong offset!");
static_assert(offsetof(FSavedWeaponAttachmentData, IlluminatorAttachment) == 0x000038, "Member 'FSavedWeaponAttachmentData::IlluminatorAttachment' has a wrong offset!");
static_assert(offsetof(FSavedWeaponAttachmentData, AmmunitionAttachment) == 0x000040, "Member 'FSavedWeaponAttachmentData::AmmunitionAttachment' has a wrong offset!");
static_assert(offsetof(FSavedWeaponAttachmentData, Skin) == 0x000048, "Member 'FSavedWeaponAttachmentData::Skin' has a wrong offset!");
static_assert(offsetof(FSavedWeaponAttachmentData, AmmoCount) == 0x000050, "Member 'FSavedWeaponAttachmentData::AmmoCount' has a wrong offset!");

// ScriptStruct ReadyOrNot.AnimInput_CapsuleLocomotion
// 0x0044 (0x0044 - 0x0000)
struct FAnimInput_CapsuleLocomotion final 
{
public:
	struct FVector                                WorldVelocity;                                     // 0x0000(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LocalVelocity;                                     // 0x000C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                WorldAcceleration;                                 // 0x0018(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LocalAcceleration;                                 // 0x0024(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VelocityYawAngle;                                  // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccelerationYawAngle;                              // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed2D;                                           // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovingThreshold;                                   // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMoving2D;                                       // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasAcceleration2D;                                // 0x0041(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAccelerationOpposesVelocity;                      // 0x0042(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOnGround;                                       // 0x0043(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FAnimInput_CapsuleLocomotion) == 0x000004, "Wrong alignment on FAnimInput_CapsuleLocomotion");
static_assert(sizeof(FAnimInput_CapsuleLocomotion) == 0x000044, "Wrong size on FAnimInput_CapsuleLocomotion");
static_assert(offsetof(FAnimInput_CapsuleLocomotion, WorldVelocity) == 0x000000, "Member 'FAnimInput_CapsuleLocomotion::WorldVelocity' has a wrong offset!");
static_assert(offsetof(FAnimInput_CapsuleLocomotion, LocalVelocity) == 0x00000C, "Member 'FAnimInput_CapsuleLocomotion::LocalVelocity' has a wrong offset!");
static_assert(offsetof(FAnimInput_CapsuleLocomotion, WorldAcceleration) == 0x000018, "Member 'FAnimInput_CapsuleLocomotion::WorldAcceleration' has a wrong offset!");
static_assert(offsetof(FAnimInput_CapsuleLocomotion, LocalAcceleration) == 0x000024, "Member 'FAnimInput_CapsuleLocomotion::LocalAcceleration' has a wrong offset!");
static_assert(offsetof(FAnimInput_CapsuleLocomotion, VelocityYawAngle) == 0x000030, "Member 'FAnimInput_CapsuleLocomotion::VelocityYawAngle' has a wrong offset!");
static_assert(offsetof(FAnimInput_CapsuleLocomotion, AccelerationYawAngle) == 0x000034, "Member 'FAnimInput_CapsuleLocomotion::AccelerationYawAngle' has a wrong offset!");
static_assert(offsetof(FAnimInput_CapsuleLocomotion, Speed2D) == 0x000038, "Member 'FAnimInput_CapsuleLocomotion::Speed2D' has a wrong offset!");
static_assert(offsetof(FAnimInput_CapsuleLocomotion, MovingThreshold) == 0x00003C, "Member 'FAnimInput_CapsuleLocomotion::MovingThreshold' has a wrong offset!");
static_assert(offsetof(FAnimInput_CapsuleLocomotion, bIsMoving2D) == 0x000040, "Member 'FAnimInput_CapsuleLocomotion::bIsMoving2D' has a wrong offset!");
static_assert(offsetof(FAnimInput_CapsuleLocomotion, bHasAcceleration2D) == 0x000041, "Member 'FAnimInput_CapsuleLocomotion::bHasAcceleration2D' has a wrong offset!");
static_assert(offsetof(FAnimInput_CapsuleLocomotion, bAccelerationOpposesVelocity) == 0x000042, "Member 'FAnimInput_CapsuleLocomotion::bAccelerationOpposesVelocity' has a wrong offset!");
static_assert(offsetof(FAnimInput_CapsuleLocomotion, bIsOnGround) == 0x000043, "Member 'FAnimInput_CapsuleLocomotion::bIsOnGround' has a wrong offset!");

// ScriptStruct ReadyOrNot.ActivityRoute
// 0x0018 (0x0018 - 0x0000)
struct FActivityRoute final 
{
public:
	float                                         TimeDoingActivity;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EDC[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AWorldBuildingPlacementActor*           WorldBuildingPlacementActor;                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowFemale;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveOnly;                                         // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EDD[0x6];                                     // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActivityRoute) == 0x000008, "Wrong alignment on FActivityRoute");
static_assert(sizeof(FActivityRoute) == 0x000018, "Wrong size on FActivityRoute");
static_assert(offsetof(FActivityRoute, TimeDoingActivity) == 0x000000, "Member 'FActivityRoute::TimeDoingActivity' has a wrong offset!");
static_assert(offsetof(FActivityRoute, WorldBuildingPlacementActor) == 0x000008, "Member 'FActivityRoute::WorldBuildingPlacementActor' has a wrong offset!");
static_assert(offsetof(FActivityRoute, bAllowFemale) == 0x000010, "Member 'FActivityRoute::bAllowFemale' has a wrong offset!");
static_assert(offsetof(FActivityRoute, bMoveOnly) == 0x000011, "Member 'FActivityRoute::bMoveOnly' has a wrong offset!");

// ScriptStruct ReadyOrNot.LevelDeployableDepot
// 0x0070 (0x0070 - 0x0000)
struct FLevelDeployableDepot final 
{
public:
	class FName                                   DepotLabel;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DepotCost;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EDE[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DepotShortName;                                    // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DepotLongName;                                     // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DepotDescription;                                  // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         MapFloorNum;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MapCoordinates;                                    // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MapShiftAmount;                                    // 0x0064(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapZoomLevel;                                      // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelDeployableDepot) == 0x000008, "Wrong alignment on FLevelDeployableDepot");
static_assert(sizeof(FLevelDeployableDepot) == 0x000070, "Wrong size on FLevelDeployableDepot");
static_assert(offsetof(FLevelDeployableDepot, DepotLabel) == 0x000000, "Member 'FLevelDeployableDepot::DepotLabel' has a wrong offset!");
static_assert(offsetof(FLevelDeployableDepot, DepotCost) == 0x000008, "Member 'FLevelDeployableDepot::DepotCost' has a wrong offset!");
static_assert(offsetof(FLevelDeployableDepot, DepotShortName) == 0x000010, "Member 'FLevelDeployableDepot::DepotShortName' has a wrong offset!");
static_assert(offsetof(FLevelDeployableDepot, DepotLongName) == 0x000028, "Member 'FLevelDeployableDepot::DepotLongName' has a wrong offset!");
static_assert(offsetof(FLevelDeployableDepot, DepotDescription) == 0x000040, "Member 'FLevelDeployableDepot::DepotDescription' has a wrong offset!");
static_assert(offsetof(FLevelDeployableDepot, MapFloorNum) == 0x000058, "Member 'FLevelDeployableDepot::MapFloorNum' has a wrong offset!");
static_assert(offsetof(FLevelDeployableDepot, MapCoordinates) == 0x00005C, "Member 'FLevelDeployableDepot::MapCoordinates' has a wrong offset!");
static_assert(offsetof(FLevelDeployableDepot, MapShiftAmount) == 0x000064, "Member 'FLevelDeployableDepot::MapShiftAmount' has a wrong offset!");
static_assert(offsetof(FLevelDeployableDepot, MapZoomLevel) == 0x00006C, "Member 'FLevelDeployableDepot::MapZoomLevel' has a wrong offset!");

// ScriptStruct ReadyOrNot.GrenadeDamage
// 0x0028 (0x0028 - 0x0000)
struct FGrenadeDamage final 
{
public:
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDamageOnDetonation;                             // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDamageOnDetonation;                             // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageInnerRadius;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageOuterRadius;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSecondTrace;                                   // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EDF[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondTraceStartDistance;                          // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondTraceRadiusFactor;                           // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EE0[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGrenadeDamage) == 0x000008, "Wrong alignment on FGrenadeDamage");
static_assert(sizeof(FGrenadeDamage) == 0x000028, "Wrong size on FGrenadeDamage");
static_assert(offsetof(FGrenadeDamage, DamageType) == 0x000000, "Member 'FGrenadeDamage::DamageType' has a wrong offset!");
static_assert(offsetof(FGrenadeDamage, MaxDamageOnDetonation) == 0x000008, "Member 'FGrenadeDamage::MaxDamageOnDetonation' has a wrong offset!");
static_assert(offsetof(FGrenadeDamage, MinDamageOnDetonation) == 0x00000C, "Member 'FGrenadeDamage::MinDamageOnDetonation' has a wrong offset!");
static_assert(offsetof(FGrenadeDamage, DamageInnerRadius) == 0x000010, "Member 'FGrenadeDamage::DamageInnerRadius' has a wrong offset!");
static_assert(offsetof(FGrenadeDamage, DamageOuterRadius) == 0x000014, "Member 'FGrenadeDamage::DamageOuterRadius' has a wrong offset!");
static_assert(offsetof(FGrenadeDamage, bUseSecondTrace) == 0x000018, "Member 'FGrenadeDamage::bUseSecondTrace' has a wrong offset!");
static_assert(offsetof(FGrenadeDamage, SecondTraceStartDistance) == 0x00001C, "Member 'FGrenadeDamage::SecondTraceStartDistance' has a wrong offset!");
static_assert(offsetof(FGrenadeDamage, SecondTraceRadiusFactor) == 0x000020, "Member 'FGrenadeDamage::SecondTraceRadiusFactor' has a wrong offset!");

// ScriptStruct ReadyOrNot.CharacterCollisionTemplate
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x08) FCharacterCollisionTemplate final 
{
public:
	uint8                                         Pad_1EE1[0x90];                                    // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterCollisionTemplate) == 0x000008, "Wrong alignment on FCharacterCollisionTemplate");
static_assert(sizeof(FCharacterCollisionTemplate) == 0x000090, "Wrong size on FCharacterCollisionTemplate");

// ScriptStruct ReadyOrNot.Magazine
// 0x0004 (0x0004 - 0x0000)
struct FMagazine final 
{
public:
	uint16                                        Ammo;                                              // 0x0000(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        AmmoType;                                          // 0x0002(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMagazine) == 0x000002, "Wrong alignment on FMagazine");
static_assert(sizeof(FMagazine) == 0x000004, "Wrong size on FMagazine");
static_assert(offsetof(FMagazine, Ammo) == 0x000000, "Member 'FMagazine::Ammo' has a wrong offset!");
static_assert(offsetof(FMagazine, AmmoType) == 0x000002, "Member 'FMagazine::AmmoType' has a wrong offset!");

// ScriptStruct ReadyOrNot.PlanningLine
// 0x001C (0x0028 - 0x000C)
struct FPlanningLine final  : public FFastArraySerializerItem
{
public:
	int32                                         PlayerNumber;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      Points;                                            // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Floor;                                             // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlanningLineTeam                             PlanningLineTeam;                                  // 0x0024(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EE2[0x3];                                     // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlanningLine) == 0x000008, "Wrong alignment on FPlanningLine");
static_assert(sizeof(FPlanningLine) == 0x000028, "Wrong size on FPlanningLine");
static_assert(offsetof(FPlanningLine, PlayerNumber) == 0x00000C, "Member 'FPlanningLine::PlayerNumber' has a wrong offset!");
static_assert(offsetof(FPlanningLine, Points) == 0x000010, "Member 'FPlanningLine::Points' has a wrong offset!");
static_assert(offsetof(FPlanningLine, Floor) == 0x000020, "Member 'FPlanningLine::Floor' has a wrong offset!");
static_assert(offsetof(FPlanningLine, PlanningLineTeam) == 0x000024, "Member 'FPlanningLine::PlanningLineTeam' has a wrong offset!");

// ScriptStruct ReadyOrNot.AIActionGateData
// 0x0068 (0x0068 - 0x0000)
struct FAIActionGateData final 
{
public:
	class UAIActionGate*                          Type;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNot;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCooldown;                                      // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EE3[0x2];                                     // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cooldown;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockGateOnCooldown;                               // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContributeToFailCount;                            // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EE4[0x6];                                     // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ACyberneticController*, float>     Cooldowns;                                         // 0x0018(0x0050)(Edit, EditFixedSize, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIActionGateData) == 0x000008, "Wrong alignment on FAIActionGateData");
static_assert(sizeof(FAIActionGateData) == 0x000068, "Wrong size on FAIActionGateData");
static_assert(offsetof(FAIActionGateData, Type) == 0x000000, "Member 'FAIActionGateData::Type' has a wrong offset!");
static_assert(offsetof(FAIActionGateData, bNot) == 0x000008, "Member 'FAIActionGateData::bNot' has a wrong offset!");
static_assert(offsetof(FAIActionGateData, bUseCooldown) == 0x000009, "Member 'FAIActionGateData::bUseCooldown' has a wrong offset!");
static_assert(offsetof(FAIActionGateData, Cooldown) == 0x00000C, "Member 'FAIActionGateData::Cooldown' has a wrong offset!");
static_assert(offsetof(FAIActionGateData, bLockGateOnCooldown) == 0x000010, "Member 'FAIActionGateData::bLockGateOnCooldown' has a wrong offset!");
static_assert(offsetof(FAIActionGateData, bContributeToFailCount) == 0x000011, "Member 'FAIActionGateData::bContributeToFailCount' has a wrong offset!");
static_assert(offsetof(FAIActionGateData, Cooldowns) == 0x000018, "Member 'FAIActionGateData::Cooldowns' has a wrong offset!");

// ScriptStruct ReadyOrNot.AIActionData_NameOnly
// 0x0008 (0x0008 - 0x0000)
struct FAIActionData_NameOnly final 
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIActionData_NameOnly) == 0x000004, "Wrong alignment on FAIActionData_NameOnly");
static_assert(sizeof(FAIActionData_NameOnly) == 0x000008, "Wrong size on FAIActionData_NameOnly");
static_assert(offsetof(FAIActionData_NameOnly, Name) == 0x000000, "Member 'FAIActionData_NameOnly::Name' has a wrong offset!");

// ScriptStruct ReadyOrNot.AIActionConsiderationData
// 0x0060 (0x0060 - 0x0000)
struct FAIActionConsiderationData final 
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIConsiderationScoringMethod                 ScoringMethod;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EE5[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIActionConsideration*                 Type;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class ACyberneticController*, float>     Scores;                                            // 0x0010(0x0050)(Edit, EditFixedSize, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIActionConsiderationData) == 0x000008, "Wrong alignment on FAIActionConsiderationData");
static_assert(sizeof(FAIActionConsiderationData) == 0x000060, "Wrong size on FAIActionConsiderationData");
static_assert(offsetof(FAIActionConsiderationData, Weight) == 0x000000, "Member 'FAIActionConsiderationData::Weight' has a wrong offset!");
static_assert(offsetof(FAIActionConsiderationData, ScoringMethod) == 0x000004, "Member 'FAIActionConsiderationData::ScoringMethod' has a wrong offset!");
static_assert(offsetof(FAIActionConsiderationData, Type) == 0x000008, "Member 'FAIActionConsiderationData::Type' has a wrong offset!");
static_assert(offsetof(FAIActionConsiderationData, Scores) == 0x000010, "Member 'FAIActionConsiderationData::Scores' has a wrong offset!");

// ScriptStruct ReadyOrNot.AIActionData
// 0x02D0 (0x02D0 - 0x0000)
struct FAIActionData final 
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIAction                                     ActionType;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EE6[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAIAction>                  CustomActionClass;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreThreshold;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDisallowWhenLastAlive : 1;                        // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDoOnce : 1;                                       // 0x0020(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysActive : 1;                                 // 0x0020(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bContinueBetweenAwarenessStates : 1;               // 0x0020(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableActionWhenFailedToConsider : 1;            // 0x0020(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1EE7[0x3];                                     // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DisableActionConsiderCount;                        // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCommitUntilEnd : 1;                               // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1EE8[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CommitTime;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCommitTimeFromConfig : 1;                         // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1EE9[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CommitTimeConfigKey;                               // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanInterruptAnyAction : 1;                        // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1EEA[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIActionData_NameOnly>         CommitInterrupts;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bUseCooldown : 1;                                  // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1EEB[0x3];                                     // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cooldown;                                          // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCooldownFromConfig : 1;                           // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1EEC[0x7];                                     // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CooldownConfigKey;                                 // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAIActionGateData>              Gates;                                             // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FAIActionConsiderationData>     Considerations;                                    // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class ACyberneticController*, float>     Scores;                                            // 0x00A0(0x0050)(Edit, EditFixedSize, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<class ACyberneticController*, float>     Cooldowns;                                         // 0x00F0(0x0050)(Edit, EditFixedSize, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<class ACyberneticController*, float>     CommitTimes;                                       // 0x0140(0x0050)(Edit, EditFixedSize, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<class ACyberneticController*, int32>     SuccessConsiderCount;                              // 0x0190(0x0050)(Edit, EditFixedSize, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<class ACyberneticController*, int32>     FailConsiderCount;                                 // 0x01E0(0x0050)(Edit, EditFixedSize, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	TMap<class ACyberneticController*, class UAIAction*> CustomActions;                                     // 0x0230(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<class ACyberneticController*, uint32>    RunCount;                                          // 0x0280(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIActionData) == 0x000008, "Wrong alignment on FAIActionData");
static_assert(sizeof(FAIActionData) == 0x0002D0, "Wrong size on FAIActionData");
static_assert(offsetof(FAIActionData, Name) == 0x000000, "Member 'FAIActionData::Name' has a wrong offset!");
static_assert(offsetof(FAIActionData, ActionType) == 0x000008, "Member 'FAIActionData::ActionType' has a wrong offset!");
static_assert(offsetof(FAIActionData, CustomActionClass) == 0x000010, "Member 'FAIActionData::CustomActionClass' has a wrong offset!");
static_assert(offsetof(FAIActionData, Weight) == 0x000018, "Member 'FAIActionData::Weight' has a wrong offset!");
static_assert(offsetof(FAIActionData, ScoreThreshold) == 0x00001C, "Member 'FAIActionData::ScoreThreshold' has a wrong offset!");
static_assert(offsetof(FAIActionData, DisableActionConsiderCount) == 0x000024, "Member 'FAIActionData::DisableActionConsiderCount' has a wrong offset!");
static_assert(offsetof(FAIActionData, CommitTime) == 0x00002C, "Member 'FAIActionData::CommitTime' has a wrong offset!");
static_assert(offsetof(FAIActionData, CommitTimeConfigKey) == 0x000038, "Member 'FAIActionData::CommitTimeConfigKey' has a wrong offset!");
static_assert(offsetof(FAIActionData, CommitInterrupts) == 0x000050, "Member 'FAIActionData::CommitInterrupts' has a wrong offset!");
static_assert(offsetof(FAIActionData, Cooldown) == 0x000064, "Member 'FAIActionData::Cooldown' has a wrong offset!");
static_assert(offsetof(FAIActionData, CooldownConfigKey) == 0x000070, "Member 'FAIActionData::CooldownConfigKey' has a wrong offset!");
static_assert(offsetof(FAIActionData, Gates) == 0x000080, "Member 'FAIActionData::Gates' has a wrong offset!");
static_assert(offsetof(FAIActionData, Considerations) == 0x000090, "Member 'FAIActionData::Considerations' has a wrong offset!");
static_assert(offsetof(FAIActionData, Scores) == 0x0000A0, "Member 'FAIActionData::Scores' has a wrong offset!");
static_assert(offsetof(FAIActionData, Cooldowns) == 0x0000F0, "Member 'FAIActionData::Cooldowns' has a wrong offset!");
static_assert(offsetof(FAIActionData, CommitTimes) == 0x000140, "Member 'FAIActionData::CommitTimes' has a wrong offset!");
static_assert(offsetof(FAIActionData, SuccessConsiderCount) == 0x000190, "Member 'FAIActionData::SuccessConsiderCount' has a wrong offset!");
static_assert(offsetof(FAIActionData, FailConsiderCount) == 0x0001E0, "Member 'FAIActionData::FailConsiderCount' has a wrong offset!");
static_assert(offsetof(FAIActionData, CustomActions) == 0x000230, "Member 'FAIActionData::CustomActions' has a wrong offset!");
static_assert(offsetof(FAIActionData, RunCount) == 0x000280, "Member 'FAIActionData::RunCount' has a wrong offset!");

// ScriptStruct ReadyOrNot.AIActionDataContainer
// 0x02E0 (0x02E0 - 0x0000)
struct FAIActionDataContainer final 
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIActionData                          Data;                                              // 0x0008(0x02D0)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAIActionPresetData*                    Preset;                                            // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIActionDataContainer) == 0x000008, "Wrong alignment on FAIActionDataContainer");
static_assert(sizeof(FAIActionDataContainer) == 0x0002E0, "Wrong size on FAIActionDataContainer");
static_assert(offsetof(FAIActionDataContainer, Name) == 0x000000, "Member 'FAIActionDataContainer::Name' has a wrong offset!");
static_assert(offsetof(FAIActionDataContainer, Data) == 0x000008, "Member 'FAIActionDataContainer::Data' has a wrong offset!");
static_assert(offsetof(FAIActionDataContainer, Preset) == 0x0002D8, "Member 'FAIActionDataContainer::Preset' has a wrong offset!");

// ScriptStruct ReadyOrNot.AITraitActionData
// 0x0028 (0x0028 - 0x0000)
struct FAITraitActionData final 
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EAIAwarenessState>                     AllowedInAwarenessState;                           // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAIActionDataContainer>         Actions;                                           // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAITraitActionData) == 0x000008, "Wrong alignment on FAITraitActionData");
static_assert(sizeof(FAITraitActionData) == 0x000028, "Wrong size on FAITraitActionData");
static_assert(offsetof(FAITraitActionData, Name) == 0x000000, "Member 'FAITraitActionData::Name' has a wrong offset!");
static_assert(offsetof(FAITraitActionData, AllowedInAwarenessState) == 0x000008, "Member 'FAITraitActionData::AllowedInAwarenessState' has a wrong offset!");
static_assert(offsetof(FAITraitActionData, Actions) == 0x000018, "Member 'FAITraitActionData::Actions' has a wrong offset!");

// ScriptStruct ReadyOrNot.NavGenerationParameters
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FNavGenerationParameters final 
{
public:
	uint8                                         Pad_1EED[0xC];                                     // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavGenerationParameters) == 0x000004, "Wrong alignment on FNavGenerationParameters");
static_assert(sizeof(FNavGenerationParameters) == 0x00000C, "Wrong size on FNavGenerationParameters");

// ScriptStruct ReadyOrNot.MovementSound
// 0x0010 (0x0010 - 0x0000)
struct FMovementSound final 
{
public:
	class USoundCue*                              Sound;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToPlay;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EEE[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovementSound) == 0x000008, "Wrong alignment on FMovementSound");
static_assert(sizeof(FMovementSound) == 0x000010, "Wrong size on FMovementSound");
static_assert(offsetof(FMovementSound, Sound) == 0x000000, "Member 'FMovementSound::Sound' has a wrong offset!");
static_assert(offsetof(FMovementSound, ChanceToPlay) == 0x000008, "Member 'FMovementSound::ChanceToPlay' has a wrong offset!");

// ScriptStruct ReadyOrNot.TherapistReminderEvent
// 0x0020 (0x0020 - 0x0000)
struct FTherapistReminderEvent final 
{
public:
	float                                         SquadAverageStressRequired;                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EEF[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   EventText;                                         // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTherapistReminderEvent) == 0x000008, "Wrong alignment on FTherapistReminderEvent");
static_assert(sizeof(FTherapistReminderEvent) == 0x000020, "Wrong size on FTherapistReminderEvent");
static_assert(offsetof(FTherapistReminderEvent, SquadAverageStressRequired) == 0x000000, "Member 'FTherapistReminderEvent::SquadAverageStressRequired' has a wrong offset!");
static_assert(offsetof(FTherapistReminderEvent, EventText) == 0x000008, "Member 'FTherapistReminderEvent::EventText' has a wrong offset!");

// ScriptStruct ReadyOrNot.WeightStunMultiplier
// 0x0010 (0x0010 - 0x0000)
struct FWeightStunMultiplier final 
{
public:
	float                                         MinimumWeight;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumWeight;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumWeightMultiplier;                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumWeightMultiplier;                           // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeightStunMultiplier) == 0x000004, "Wrong alignment on FWeightStunMultiplier");
static_assert(sizeof(FWeightStunMultiplier) == 0x000010, "Wrong size on FWeightStunMultiplier");
static_assert(offsetof(FWeightStunMultiplier, MinimumWeight) == 0x000000, "Member 'FWeightStunMultiplier::MinimumWeight' has a wrong offset!");
static_assert(offsetof(FWeightStunMultiplier, MaximumWeight) == 0x000004, "Member 'FWeightStunMultiplier::MaximumWeight' has a wrong offset!");
static_assert(offsetof(FWeightStunMultiplier, MinimumWeightMultiplier) == 0x000008, "Member 'FWeightStunMultiplier::MinimumWeightMultiplier' has a wrong offset!");
static_assert(offsetof(FWeightStunMultiplier, MaximumWeightMultiplier) == 0x00000C, "Member 'FWeightStunMultiplier::MaximumWeightMultiplier' has a wrong offset!");

// ScriptStruct ReadyOrNot.AmmoTypeData
// 0x0158 (0x0160 - 0x0008)
struct FAmmoTypeData final  : public FTableRowBase
{
public:
	class FText                                   AmmoVariety;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   AmmoCaliber;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   AmmoDescription;                                   // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EF0[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     DamageOverRangeCurve;                              // 0x0058(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         ProjectileCount;                                   // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EF1[0x3];                                     // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SpreadPattern;                                     // 0x00E4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIgnoresArmour : 1;                                // 0x00EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1EF2[0x3];                                     // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurabilityDamage;                                  // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PenetrationLevel;                                  // 0x00F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EF3[0x3];                                     // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PenetrationDistance;                               // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RicochetChance;                                    // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpallingDamage;                                    // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpallingRadius;                                    // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DismembermentDamage;                               // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArteryHitChance;                                   // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitsChance;                                        // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmouredHitsChance;                                // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WoundSize;                                         // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsUsableByPlayer : 1;                             // 0x011C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1EF4[0x3];                                     // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             LoadoutIcon;                                       // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SmallIcon;                                         // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadDamageMultiplier;                              // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperBodyDamageMultiplier;                         // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerBodyDamageMultiplier;                         // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmDamageMultiplier;                               // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandDamageMultiplier;                              // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegDamageMultiplier;                               // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootDamageMultiplier;                              // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultRagdollImpulseStrength;                     // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadRagdollImpulseStrength;                        // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmRagdollImpulseStrength;                         // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegRagdollImpulseStrength;                         // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TorsoRagdollImpulseStrength;                       // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAmmoTypeData) == 0x000008, "Wrong alignment on FAmmoTypeData");
static_assert(sizeof(FAmmoTypeData) == 0x000160, "Wrong size on FAmmoTypeData");
static_assert(offsetof(FAmmoTypeData, AmmoVariety) == 0x000008, "Member 'FAmmoTypeData::AmmoVariety' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, AmmoCaliber) == 0x000020, "Member 'FAmmoTypeData::AmmoCaliber' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, AmmoDescription) == 0x000038, "Member 'FAmmoTypeData::AmmoDescription' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, Damage) == 0x000050, "Member 'FAmmoTypeData::Damage' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, DamageOverRangeCurve) == 0x000058, "Member 'FAmmoTypeData::DamageOverRangeCurve' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, ProjectileCount) == 0x0000E0, "Member 'FAmmoTypeData::ProjectileCount' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, SpreadPattern) == 0x0000E4, "Member 'FAmmoTypeData::SpreadPattern' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, DurabilityDamage) == 0x0000F0, "Member 'FAmmoTypeData::DurabilityDamage' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, PenetrationLevel) == 0x0000F4, "Member 'FAmmoTypeData::PenetrationLevel' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, PenetrationDistance) == 0x0000F8, "Member 'FAmmoTypeData::PenetrationDistance' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, RicochetChance) == 0x0000FC, "Member 'FAmmoTypeData::RicochetChance' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, SpallingDamage) == 0x000100, "Member 'FAmmoTypeData::SpallingDamage' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, SpallingRadius) == 0x000104, "Member 'FAmmoTypeData::SpallingRadius' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, DismembermentDamage) == 0x000108, "Member 'FAmmoTypeData::DismembermentDamage' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, ArteryHitChance) == 0x00010C, "Member 'FAmmoTypeData::ArteryHitChance' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, HitsChance) == 0x000110, "Member 'FAmmoTypeData::HitsChance' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, ArmouredHitsChance) == 0x000114, "Member 'FAmmoTypeData::ArmouredHitsChance' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, WoundSize) == 0x000118, "Member 'FAmmoTypeData::WoundSize' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, LoadoutIcon) == 0x000120, "Member 'FAmmoTypeData::LoadoutIcon' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, SmallIcon) == 0x000128, "Member 'FAmmoTypeData::SmallIcon' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, HeadDamageMultiplier) == 0x000130, "Member 'FAmmoTypeData::HeadDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, UpperBodyDamageMultiplier) == 0x000134, "Member 'FAmmoTypeData::UpperBodyDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, LowerBodyDamageMultiplier) == 0x000138, "Member 'FAmmoTypeData::LowerBodyDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, ArmDamageMultiplier) == 0x00013C, "Member 'FAmmoTypeData::ArmDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, HandDamageMultiplier) == 0x000140, "Member 'FAmmoTypeData::HandDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, LegDamageMultiplier) == 0x000144, "Member 'FAmmoTypeData::LegDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, FootDamageMultiplier) == 0x000148, "Member 'FAmmoTypeData::FootDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, DefaultRagdollImpulseStrength) == 0x00014C, "Member 'FAmmoTypeData::DefaultRagdollImpulseStrength' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, HeadRagdollImpulseStrength) == 0x000150, "Member 'FAmmoTypeData::HeadRagdollImpulseStrength' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, ArmRagdollImpulseStrength) == 0x000154, "Member 'FAmmoTypeData::ArmRagdollImpulseStrength' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, LegRagdollImpulseStrength) == 0x000158, "Member 'FAmmoTypeData::LegRagdollImpulseStrength' has a wrong offset!");
static_assert(offsetof(FAmmoTypeData, TorsoRagdollImpulseStrength) == 0x00015C, "Member 'FAmmoTypeData::TorsoRagdollImpulseStrength' has a wrong offset!");

// ScriptStruct ReadyOrNot.ItemVisualData
// 0x0030 (0x0030 - 0x0000)
struct FItemVisualData final 
{
public:
	class UTexture2D*                             ItemIcon;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PremissionPlanningItemIcon;                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             RadialItemIcon;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          ItemMesh;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     AmmoIcons;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemVisualData) == 0x000008, "Wrong alignment on FItemVisualData");
static_assert(sizeof(FItemVisualData) == 0x000030, "Wrong size on FItemVisualData");
static_assert(offsetof(FItemVisualData, ItemIcon) == 0x000000, "Member 'FItemVisualData::ItemIcon' has a wrong offset!");
static_assert(offsetof(FItemVisualData, PremissionPlanningItemIcon) == 0x000008, "Member 'FItemVisualData::PremissionPlanningItemIcon' has a wrong offset!");
static_assert(offsetof(FItemVisualData, RadialItemIcon) == 0x000010, "Member 'FItemVisualData::RadialItemIcon' has a wrong offset!");
static_assert(offsetof(FItemVisualData, ItemMesh) == 0x000018, "Member 'FItemVisualData::ItemMesh' has a wrong offset!");
static_assert(offsetof(FItemVisualData, AmmoIcons) == 0x000020, "Member 'FItemVisualData::AmmoIcons' has a wrong offset!");

// ScriptStruct ReadyOrNot.TakeHostageAnimState
// 0x0018 (0x0018 - 0x0000)
struct FTakeHostageAnimState final 
{
public:
	uint8                                         bIsTakingHostage : 1;                              // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsLooping : 1;                                    // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1EF5[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          LoopAnim;                                          // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   AimOffset;                                         // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTakeHostageAnimState) == 0x000008, "Wrong alignment on FTakeHostageAnimState");
static_assert(sizeof(FTakeHostageAnimState) == 0x000018, "Wrong size on FTakeHostageAnimState");
static_assert(offsetof(FTakeHostageAnimState, LoopAnim) == 0x000008, "Member 'FTakeHostageAnimState::LoopAnim' has a wrong offset!");
static_assert(offsetof(FTakeHostageAnimState, AimOffset) == 0x000010, "Member 'FTakeHostageAnimState::AimOffset' has a wrong offset!");

// ScriptStruct ReadyOrNot.CharacterPersonalizationData
// 0x0050 (0x0050 - 0x0000)
struct FCharacterPersonalizationData final 
{
public:
	EGameVersionRestriction                       LockedToDLC;                                       // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EF6[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RowName;                                           // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EF7[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FriendlyName;                                      // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0028(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterPersonalizationData) == 0x000008, "Wrong alignment on FCharacterPersonalizationData");
static_assert(sizeof(FCharacterPersonalizationData) == 0x000050, "Wrong size on FCharacterPersonalizationData");
static_assert(offsetof(FCharacterPersonalizationData, LockedToDLC) == 0x000000, "Member 'FCharacterPersonalizationData::LockedToDLC' has a wrong offset!");
static_assert(offsetof(FCharacterPersonalizationData, RowName) == 0x000004, "Member 'FCharacterPersonalizationData::RowName' has a wrong offset!");
static_assert(offsetof(FCharacterPersonalizationData, FriendlyName) == 0x000010, "Member 'FCharacterPersonalizationData::FriendlyName' has a wrong offset!");
static_assert(offsetof(FCharacterPersonalizationData, Icon) == 0x000028, "Member 'FCharacterPersonalizationData::Icon' has a wrong offset!");

// ScriptStruct ReadyOrNot.HitscanShot
// 0x001C (0x001C - 0x0000)
struct FHitscanShot final 
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitscanShot) == 0x000004, "Wrong alignment on FHitscanShot");
static_assert(sizeof(FHitscanShot) == 0x00001C, "Wrong size on FHitscanShot");
static_assert(offsetof(FHitscanShot, Location) == 0x000000, "Member 'FHitscanShot::Location' has a wrong offset!");
static_assert(offsetof(FHitscanShot, Direction) == 0x00000C, "Member 'FHitscanShot::Direction' has a wrong offset!");
static_assert(offsetof(FHitscanShot, Seed) == 0x000018, "Member 'FHitscanShot::Seed' has a wrong offset!");

// ScriptStruct ReadyOrNot.PlanningDrawing
// 0x001C (0x0028 - 0x000C)
struct FPlanningDrawing final  : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_1EF8[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      Points;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Floor;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlanningDrawing) == 0x000008, "Wrong alignment on FPlanningDrawing");
static_assert(sizeof(FPlanningDrawing) == 0x000028, "Wrong size on FPlanningDrawing");
static_assert(offsetof(FPlanningDrawing, Points) == 0x000010, "Member 'FPlanningDrawing::Points' has a wrong offset!");
static_assert(offsetof(FPlanningDrawing, Floor) == 0x000020, "Member 'FPlanningDrawing::Floor' has a wrong offset!");
static_assert(offsetof(FPlanningDrawing, Time) == 0x000024, "Member 'FPlanningDrawing::Time' has a wrong offset!");

// ScriptStruct ReadyOrNot.TutorialDescriptionInput
// 0x000C (0x000C - 0x0000)
struct FTutorialDescriptionInput final 
{
public:
	class FName                                   InputName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KeyIndex;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialDescriptionInput) == 0x000004, "Wrong alignment on FTutorialDescriptionInput");
static_assert(sizeof(FTutorialDescriptionInput) == 0x00000C, "Wrong size on FTutorialDescriptionInput");
static_assert(offsetof(FTutorialDescriptionInput, InputName) == 0x000000, "Member 'FTutorialDescriptionInput::InputName' has a wrong offset!");
static_assert(offsetof(FTutorialDescriptionInput, KeyIndex) == 0x000008, "Member 'FTutorialDescriptionInput::KeyIndex' has a wrong offset!");

// ScriptStruct ReadyOrNot.TutorialWidgetData
// 0x0078 (0x0078 - 0x0000)
struct FTutorialWidgetData final 
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FTutorialDescriptionInput>      DescriptionInputs;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bGamepadDescription;                               // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EF9[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   GamepadDescription;                                // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FTutorialDescriptionInput>      GamepadDescriptionInputs;                          // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             Media;                                             // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialWidgetData) == 0x000008, "Wrong alignment on FTutorialWidgetData");
static_assert(sizeof(FTutorialWidgetData) == 0x000078, "Wrong size on FTutorialWidgetData");
static_assert(offsetof(FTutorialWidgetData, Title) == 0x000000, "Member 'FTutorialWidgetData::Title' has a wrong offset!");
static_assert(offsetof(FTutorialWidgetData, Description) == 0x000018, "Member 'FTutorialWidgetData::Description' has a wrong offset!");
static_assert(offsetof(FTutorialWidgetData, DescriptionInputs) == 0x000030, "Member 'FTutorialWidgetData::DescriptionInputs' has a wrong offset!");
static_assert(offsetof(FTutorialWidgetData, bGamepadDescription) == 0x000040, "Member 'FTutorialWidgetData::bGamepadDescription' has a wrong offset!");
static_assert(offsetof(FTutorialWidgetData, GamepadDescription) == 0x000048, "Member 'FTutorialWidgetData::GamepadDescription' has a wrong offset!");
static_assert(offsetof(FTutorialWidgetData, GamepadDescriptionInputs) == 0x000060, "Member 'FTutorialWidgetData::GamepadDescriptionInputs' has a wrong offset!");
static_assert(offsetof(FTutorialWidgetData, Media) == 0x000070, "Member 'FTutorialWidgetData::Media' has a wrong offset!");

// ScriptStruct ReadyOrNot.EntryPoint
// 0x0078 (0x0078 - 0x0000)
struct FEntryPoint final 
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EFA[0x8];                                     // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECOOPMode>                             ExcludedGameModes;                                 // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEntryPoint) == 0x000008, "Wrong alignment on FEntryPoint");
static_assert(sizeof(FEntryPoint) == 0x000078, "Wrong size on FEntryPoint");
static_assert(offsetof(FEntryPoint, Name) == 0x000000, "Member 'FEntryPoint::Name' has a wrong offset!");
static_assert(offsetof(FEntryPoint, Tag) == 0x000018, "Member 'FEntryPoint::Tag' has a wrong offset!");
static_assert(offsetof(FEntryPoint, Description) == 0x000020, "Member 'FEntryPoint::Description' has a wrong offset!");
static_assert(offsetof(FEntryPoint, Image) == 0x000038, "Member 'FEntryPoint::Image' has a wrong offset!");
static_assert(offsetof(FEntryPoint, ExcludedGameModes) == 0x000068, "Member 'FEntryPoint::ExcludedGameModes' has a wrong offset!");

// ScriptStruct ReadyOrNot.MODParam
// 0x000C (0x000C - 0x0000)
struct FMODParam final 
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParamVal;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMODParam) == 0x000004, "Wrong alignment on FMODParam");
static_assert(sizeof(FMODParam) == 0x00000C, "Wrong size on FMODParam");
static_assert(offsetof(FMODParam, ParamName) == 0x000000, "Member 'FMODParam::ParamName' has a wrong offset!");
static_assert(offsetof(FMODParam, ParamVal) == 0x000008, "Member 'FMODParam::ParamVal' has a wrong offset!");

// ScriptStruct ReadyOrNot.LimbHealthData
// 0x0034 (0x0034 - 0x0000)
struct FLimbHealthData final 
{
public:
	uint8                                         Pad_1EFB[0x8];                                     // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHealth;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHealthLimit;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowHealthThreshold;                                // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LimbDamageMultiplier;                              // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxTickets;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Tickets;                                           // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxLimbHealthHalving;                              // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OriginalMaxHealth;                                 // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowHealth;                                         // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviousHealth;                                    // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FLimbHealthData) == 0x000004, "Wrong alignment on FLimbHealthData");
static_assert(sizeof(FLimbHealthData) == 0x000034, "Wrong size on FLimbHealthData");
static_assert(offsetof(FLimbHealthData, Health) == 0x000008, "Member 'FLimbHealthData::Health' has a wrong offset!");
static_assert(offsetof(FLimbHealthData, MaxHealth) == 0x00000C, "Member 'FLimbHealthData::MaxHealth' has a wrong offset!");
static_assert(offsetof(FLimbHealthData, MaxHealthLimit) == 0x000010, "Member 'FLimbHealthData::MaxHealthLimit' has a wrong offset!");
static_assert(offsetof(FLimbHealthData, LowHealthThreshold) == 0x000014, "Member 'FLimbHealthData::LowHealthThreshold' has a wrong offset!");
static_assert(offsetof(FLimbHealthData, LimbDamageMultiplier) == 0x000018, "Member 'FLimbHealthData::LimbDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FLimbHealthData, MaxTickets) == 0x00001C, "Member 'FLimbHealthData::MaxTickets' has a wrong offset!");
static_assert(offsetof(FLimbHealthData, Tickets) == 0x000020, "Member 'FLimbHealthData::Tickets' has a wrong offset!");
static_assert(offsetof(FLimbHealthData, MaxLimbHealthHalving) == 0x000024, "Member 'FLimbHealthData::MaxLimbHealthHalving' has a wrong offset!");
static_assert(offsetof(FLimbHealthData, OriginalMaxHealth) == 0x000028, "Member 'FLimbHealthData::OriginalMaxHealth' has a wrong offset!");
static_assert(offsetof(FLimbHealthData, LowHealth) == 0x00002C, "Member 'FLimbHealthData::LowHealth' has a wrong offset!");
static_assert(offsetof(FLimbHealthData, PreviousHealth) == 0x000030, "Member 'FLimbHealthData::PreviousHealth' has a wrong offset!");

// ScriptStruct ReadyOrNot.ObituaryForBone
// 0x0010 (0x0010 - 0x0000)
struct FObituaryForBone final 
{
public:
	TArray<class FText>                           DeathMessages;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObituaryForBone) == 0x000008, "Wrong alignment on FObituaryForBone");
static_assert(sizeof(FObituaryForBone) == 0x000010, "Wrong size on FObituaryForBone");
static_assert(offsetof(FObituaryForBone, DeathMessages) == 0x000000, "Member 'FObituaryForBone::DeathMessages' has a wrong offset!");

// ScriptStruct ReadyOrNot.TrapData
// 0x0048 (0x0050 - 0x0008)
struct FTrapData final  : public FTableRowBase
{
public:
	uint8                                         Pad_1EFC[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TrapRelativeTransform;                             // 0x0010(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ATrapActorAttachedToDoor>   TrapClass;                                         // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToDoor;                                     // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrapType                                     TrapType;                                          // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EFD[0x2];                                     // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvertOffset;                                      // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrapData) == 0x000010, "Wrong alignment on FTrapData");
static_assert(sizeof(FTrapData) == 0x000050, "Wrong size on FTrapData");
static_assert(offsetof(FTrapData, TrapRelativeTransform) == 0x000010, "Member 'FTrapData::TrapRelativeTransform' has a wrong offset!");
static_assert(offsetof(FTrapData, TrapClass) == 0x000040, "Member 'FTrapData::TrapClass' has a wrong offset!");
static_assert(offsetof(FTrapData, bAttachToDoor) == 0x000048, "Member 'FTrapData::bAttachToDoor' has a wrong offset!");
static_assert(offsetof(FTrapData, TrapType) == 0x000049, "Member 'FTrapData::TrapType' has a wrong offset!");
static_assert(offsetof(FTrapData, InvertOffset) == 0x00004C, "Member 'FTrapData::InvertOffset' has a wrong offset!");

// ScriptStruct ReadyOrNot.AnimWeaponData
// 0x0010 (0x0010 - 0x0000)
struct FAnimWeaponData final 
{
public:
	TArray<class UAnimMontage*>                   AnimMontages;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimWeaponData) == 0x000008, "Wrong alignment on FAnimWeaponData");
static_assert(sizeof(FAnimWeaponData) == 0x000010, "Wrong size on FAnimWeaponData");
static_assert(offsetof(FAnimWeaponData, AnimMontages) == 0x000000, "Member 'FAnimWeaponData::AnimMontages' has a wrong offset!");

// ScriptStruct ReadyOrNot.HoleTraversalAnimStateMachineData
// 0x0010 (0x0010 - 0x0000)
struct FHoleTraversalAnimStateMachineData final 
{
public:
	uint8                                         bIsTraversing : 1;                                 // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLooping : 1;                                      // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1EFE[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          LoopAnim;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoleTraversalAnimStateMachineData) == 0x000008, "Wrong alignment on FHoleTraversalAnimStateMachineData");
static_assert(sizeof(FHoleTraversalAnimStateMachineData) == 0x000010, "Wrong size on FHoleTraversalAnimStateMachineData");
static_assert(offsetof(FHoleTraversalAnimStateMachineData, LoopAnim) == 0x000008, "Member 'FHoleTraversalAnimStateMachineData::LoopAnim' has a wrong offset!");

// ScriptStruct ReadyOrNot.DoorChunkData
// 0x0020 (0x0020 - 0x0000)
struct FDoorChunkData final 
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHinge;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoorHandleChunk;                                // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCannotKickIfDestroyed;                            // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EFF[0x5];                                     // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SupportChunks;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDoorChunkData) == 0x000008, "Wrong alignment on FDoorChunkData");
static_assert(sizeof(FDoorChunkData) == 0x000020, "Wrong size on FDoorChunkData");
static_assert(offsetof(FDoorChunkData, Mesh) == 0x000000, "Member 'FDoorChunkData::Mesh' has a wrong offset!");
static_assert(offsetof(FDoorChunkData, bIsHinge) == 0x000008, "Member 'FDoorChunkData::bIsHinge' has a wrong offset!");
static_assert(offsetof(FDoorChunkData, bIsDoorHandleChunk) == 0x000009, "Member 'FDoorChunkData::bIsDoorHandleChunk' has a wrong offset!");
static_assert(offsetof(FDoorChunkData, bCannotKickIfDestroyed) == 0x00000A, "Member 'FDoorChunkData::bCannotKickIfDestroyed' has a wrong offset!");
static_assert(offsetof(FDoorChunkData, SupportChunks) == 0x000010, "Member 'FDoorChunkData::SupportChunks' has a wrong offset!");

// ScriptStruct ReadyOrNot.DoorData
// 0x01E8 (0x01F0 - 0x0008)
struct FDoorData final  : public FTableRowBase
{
public:
	float                                         DoorMaxOpenClose;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsDestructible : 1;                               // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanMirrorUnderDoor : 1;                           // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanBreakOffWithKick : 1;                          // 0x000C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanBreakOffOneWayDoorWithKick : 1;                // 0x000C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F00[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDoorChunkData>                 DestructibleChunks;                                // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UStaticMesh*                            DoorMesh;                                          // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            DoorHandle;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DoorwayOffset;                                     // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DoorwayOffsetScale;                                // 0x003C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLockable : 1;                                     // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomLockpickLocation : 1;                       // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F01[0x3];                                     // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LockpickRelativeLocation;                          // 0x004C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCustomDoorPeekLocation : 1;                       // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F02[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DoorPeekRelativeLocation;                          // 0x005C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDoorHandleFront : 1;                              // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDoorHandleBack : 1;                               // 0x0068(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F03[0x7];                                     // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             DoorHandleFrontRelativeTransform;                  // 0x0070(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             DoorHandleBackRelativeTransform;                   // 0x00A0(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumSuccessfulKicksToBreakDown;                     // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorKickSuccessChance;                             // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F04[0x8];                                     // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             KickParticleTransform;                             // 0x00E0(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         KickedParticleSystem;                              // 0x0110(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         LockBrokenParticleSystem;                          // 0x0138(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                C2PlacementPoint_Front;                            // 0x0160(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                C2PlacementPoint_Back;                             // 0x016C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        C2ExplosionParticle;                               // 0x0178(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             C2ExplosionEvent;                                  // 0x0180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             OpenSound;                                         // 0x0188(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             CloseSound;                                        // 0x0190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             PushOpenSound;                                     // 0x0198(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             PushCloseSound;                                    // 0x01A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ManipulateSound;                                   // 0x01A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BashSound;                                         // 0x01B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             LockedSound;                                       // 0x01B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             RamSound;                                          // 0x01C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             KickSuccessSound;                                  // 0x01C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             KickFailSound;                                     // 0x01D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             AlarmSound;                                        // 0x01D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             KeycardSound;                                      // 0x01E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             KeycardDenySound;                                  // 0x01E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDoorData) == 0x000010, "Wrong alignment on FDoorData");
static_assert(sizeof(FDoorData) == 0x0001F0, "Wrong size on FDoorData");
static_assert(offsetof(FDoorData, DoorMaxOpenClose) == 0x000008, "Member 'FDoorData::DoorMaxOpenClose' has a wrong offset!");
static_assert(offsetof(FDoorData, DestructibleChunks) == 0x000010, "Member 'FDoorData::DestructibleChunks' has a wrong offset!");
static_assert(offsetof(FDoorData, DoorMesh) == 0x000020, "Member 'FDoorData::DoorMesh' has a wrong offset!");
static_assert(offsetof(FDoorData, DoorHandle) == 0x000028, "Member 'FDoorData::DoorHandle' has a wrong offset!");
static_assert(offsetof(FDoorData, DoorwayOffset) == 0x000030, "Member 'FDoorData::DoorwayOffset' has a wrong offset!");
static_assert(offsetof(FDoorData, DoorwayOffsetScale) == 0x00003C, "Member 'FDoorData::DoorwayOffsetScale' has a wrong offset!");
static_assert(offsetof(FDoorData, LockpickRelativeLocation) == 0x00004C, "Member 'FDoorData::LockpickRelativeLocation' has a wrong offset!");
static_assert(offsetof(FDoorData, DoorPeekRelativeLocation) == 0x00005C, "Member 'FDoorData::DoorPeekRelativeLocation' has a wrong offset!");
static_assert(offsetof(FDoorData, DoorHandleFrontRelativeTransform) == 0x000070, "Member 'FDoorData::DoorHandleFrontRelativeTransform' has a wrong offset!");
static_assert(offsetof(FDoorData, DoorHandleBackRelativeTransform) == 0x0000A0, "Member 'FDoorData::DoorHandleBackRelativeTransform' has a wrong offset!");
static_assert(offsetof(FDoorData, NumSuccessfulKicksToBreakDown) == 0x0000D0, "Member 'FDoorData::NumSuccessfulKicksToBreakDown' has a wrong offset!");
static_assert(offsetof(FDoorData, DoorKickSuccessChance) == 0x0000D4, "Member 'FDoorData::DoorKickSuccessChance' has a wrong offset!");
static_assert(offsetof(FDoorData, KickParticleTransform) == 0x0000E0, "Member 'FDoorData::KickParticleTransform' has a wrong offset!");
static_assert(offsetof(FDoorData, KickedParticleSystem) == 0x000110, "Member 'FDoorData::KickedParticleSystem' has a wrong offset!");
static_assert(offsetof(FDoorData, LockBrokenParticleSystem) == 0x000138, "Member 'FDoorData::LockBrokenParticleSystem' has a wrong offset!");
static_assert(offsetof(FDoorData, C2PlacementPoint_Front) == 0x000160, "Member 'FDoorData::C2PlacementPoint_Front' has a wrong offset!");
static_assert(offsetof(FDoorData, C2PlacementPoint_Back) == 0x00016C, "Member 'FDoorData::C2PlacementPoint_Back' has a wrong offset!");
static_assert(offsetof(FDoorData, C2ExplosionParticle) == 0x000178, "Member 'FDoorData::C2ExplosionParticle' has a wrong offset!");
static_assert(offsetof(FDoorData, C2ExplosionEvent) == 0x000180, "Member 'FDoorData::C2ExplosionEvent' has a wrong offset!");
static_assert(offsetof(FDoorData, OpenSound) == 0x000188, "Member 'FDoorData::OpenSound' has a wrong offset!");
static_assert(offsetof(FDoorData, CloseSound) == 0x000190, "Member 'FDoorData::CloseSound' has a wrong offset!");
static_assert(offsetof(FDoorData, PushOpenSound) == 0x000198, "Member 'FDoorData::PushOpenSound' has a wrong offset!");
static_assert(offsetof(FDoorData, PushCloseSound) == 0x0001A0, "Member 'FDoorData::PushCloseSound' has a wrong offset!");
static_assert(offsetof(FDoorData, ManipulateSound) == 0x0001A8, "Member 'FDoorData::ManipulateSound' has a wrong offset!");
static_assert(offsetof(FDoorData, BashSound) == 0x0001B0, "Member 'FDoorData::BashSound' has a wrong offset!");
static_assert(offsetof(FDoorData, LockedSound) == 0x0001B8, "Member 'FDoorData::LockedSound' has a wrong offset!");
static_assert(offsetof(FDoorData, RamSound) == 0x0001C0, "Member 'FDoorData::RamSound' has a wrong offset!");
static_assert(offsetof(FDoorData, KickSuccessSound) == 0x0001C8, "Member 'FDoorData::KickSuccessSound' has a wrong offset!");
static_assert(offsetof(FDoorData, KickFailSound) == 0x0001D0, "Member 'FDoorData::KickFailSound' has a wrong offset!");
static_assert(offsetof(FDoorData, AlarmSound) == 0x0001D8, "Member 'FDoorData::AlarmSound' has a wrong offset!");
static_assert(offsetof(FDoorData, KeycardSound) == 0x0001E0, "Member 'FDoorData::KeycardSound' has a wrong offset!");
static_assert(offsetof(FDoorData, KeycardDenySound) == 0x0001E8, "Member 'FDoorData::KeycardDenySound' has a wrong offset!");

// ScriptStruct ReadyOrNot.ItemChangeRequest
// 0x0028 (0x0028 - 0x0000)
struct FItemChangeRequest final 
{
public:
	struct FGuid                                  ChangeId;                                          // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              FromItem;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              ToItem;                                            // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstant;                                          // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoDraw;                                           // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsComplete;                                       // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F05[0x5];                                     // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemChangeRequest) == 0x000008, "Wrong alignment on FItemChangeRequest");
static_assert(sizeof(FItemChangeRequest) == 0x000028, "Wrong size on FItemChangeRequest");
static_assert(offsetof(FItemChangeRequest, ChangeId) == 0x000000, "Member 'FItemChangeRequest::ChangeId' has a wrong offset!");
static_assert(offsetof(FItemChangeRequest, FromItem) == 0x000010, "Member 'FItemChangeRequest::FromItem' has a wrong offset!");
static_assert(offsetof(FItemChangeRequest, ToItem) == 0x000018, "Member 'FItemChangeRequest::ToItem' has a wrong offset!");
static_assert(offsetof(FItemChangeRequest, bInstant) == 0x000020, "Member 'FItemChangeRequest::bInstant' has a wrong offset!");
static_assert(offsetof(FItemChangeRequest, bNoDraw) == 0x000021, "Member 'FItemChangeRequest::bNoDraw' has a wrong offset!");
static_assert(offsetof(FItemChangeRequest, bIsComplete) == 0x000022, "Member 'FItemChangeRequest::bIsComplete' has a wrong offset!");

// ScriptStruct ReadyOrNot.ObjectiveSpawn
// 0x0028 (0x0028 - 0x0000)
struct FObjectiveSpawn final 
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    Type;                                              // 0x0008(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class AAISpawn*>                       Spawners;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveSpawn) == 0x000008, "Wrong alignment on FObjectiveSpawn");
static_assert(sizeof(FObjectiveSpawn) == 0x000028, "Wrong size on FObjectiveSpawn");
static_assert(offsetof(FObjectiveSpawn, Tag) == 0x000000, "Member 'FObjectiveSpawn::Tag' has a wrong offset!");
static_assert(offsetof(FObjectiveSpawn, Type) == 0x000008, "Member 'FObjectiveSpawn::Type' has a wrong offset!");
static_assert(offsetof(FObjectiveSpawn, Spawners) == 0x000018, "Member 'FObjectiveSpawn::Spawners' has a wrong offset!");

// ScriptStruct ReadyOrNot.ClearPoint
// 0x0038 (0x0038 - 0x0000)
struct FClearPoint final 
{
public:
	struct FVector                                Location_Relative;                                 // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Stage;                                             // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EClearDirection                               Direction;                                         // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F06[0x6];                                     // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACoverLandmark*>                 CoverLandmarks;                                    // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasLineOfSightToDoor;                             // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F07[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClearPoint) == 0x000008, "Wrong alignment on FClearPoint");
static_assert(sizeof(FClearPoint) == 0x000038, "Wrong size on FClearPoint");
static_assert(offsetof(FClearPoint, Location_Relative) == 0x000000, "Member 'FClearPoint::Location_Relative' has a wrong offset!");
static_assert(offsetof(FClearPoint, Location) == 0x00000C, "Member 'FClearPoint::Location' has a wrong offset!");
static_assert(offsetof(FClearPoint, Stage) == 0x000018, "Member 'FClearPoint::Stage' has a wrong offset!");
static_assert(offsetof(FClearPoint, Direction) == 0x000019, "Member 'FClearPoint::Direction' has a wrong offset!");
static_assert(offsetof(FClearPoint, CoverLandmarks) == 0x000020, "Member 'FClearPoint::CoverLandmarks' has a wrong offset!");
static_assert(offsetof(FClearPoint, bHasLineOfSightToDoor) == 0x000030, "Member 'FClearPoint::bHasLineOfSightToDoor' has a wrong offset!");

// ScriptStruct ReadyOrNot.LevelStreamOptions
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FLevelStreamOptions final 
{
public:
	uint8                                         Pad_1F08[0x28];                                    // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelStreamOptions) == 0x000008, "Wrong alignment on FLevelStreamOptions");
static_assert(sizeof(FLevelStreamOptions) == 0x000028, "Wrong size on FLevelStreamOptions");

// ScriptStruct ReadyOrNot.PlanningMarker
// 0x001C (0x0028 - 0x000C)
struct FPlanningMarker final  : public FFastArraySerializerItem
{
public:
	int32                                         PlayerNumber;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Position;                                          // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Floor;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Style;                                             // 0x001C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlanningMarker) == 0x000004, "Wrong alignment on FPlanningMarker");
static_assert(sizeof(FPlanningMarker) == 0x000028, "Wrong size on FPlanningMarker");
static_assert(offsetof(FPlanningMarker, PlayerNumber) == 0x00000C, "Member 'FPlanningMarker::PlayerNumber' has a wrong offset!");
static_assert(offsetof(FPlanningMarker, Position) == 0x000010, "Member 'FPlanningMarker::Position' has a wrong offset!");
static_assert(offsetof(FPlanningMarker, Floor) == 0x000018, "Member 'FPlanningMarker::Floor' has a wrong offset!");
static_assert(offsetof(FPlanningMarker, Style) == 0x00001C, "Member 'FPlanningMarker::Style' has a wrong offset!");
static_assert(offsetof(FPlanningMarker, Rotation) == 0x000024, "Member 'FPlanningMarker::Rotation' has a wrong offset!");

// ScriptStruct ReadyOrNot.SavedLoadout
// 0x0188 (0x0188 - 0x0000)
struct FSavedLoadout final 
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PresetName;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActiveLoadoutPreset;                               // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseItem>                  Primary;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          PrimaryScope;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          PrimaryMuzzle;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          PrimaryUnderbarrel;                                // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          PrimaryOverbarrel;                                 // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          PrimaryStock;                                      // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          PrimaryGrip;                                       // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          PrimaryIlluminator;                                // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          PrimaryAmmunition;                                 // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           PrimaryAmmoSlots;                                  // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PrimaryAmmoSlotsCount;                             // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F09[0x4];                                     // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USkinComponent>             PrimarySkin;                                       // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseItem>                  Secondary;                                         // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          SecondaryScope;                                    // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          SecondaryMuzzle;                                   // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          SecondaryUnderbarrel;                              // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          SecondaryOverbarrel;                               // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          SecondaryStock;                                    // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          SecondaryGrip;                                     // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          SecondaryIlluminator;                              // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          SecondaryAmmunition;                               // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SecondaryAmmoSlots;                                // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SecondaryAmmoSlotsCount;                           // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0A[0x4];                                     // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USkinComponent>             SecondarySkin;                                     // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharacterType;                                     // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseItem>                  LongTactical;                                      // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ABaseItem>>          GrenadeSlots;                                      // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         GrenadeSlotsCount;                                 // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0B[0x4];                                     // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ABaseItem>>          TacticalSlots;                                     // 0x0120(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         TacticalSlotsCount;                                // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0C[0x4];                                     // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseItem>                  Armor;                                             // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseItem>                  Helmet;                                            // 0x0140(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseItem>                  RandomGear;                                        // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ABaseItem>>          Miscelaneous;                                      // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class USkinComponent>             PlayerSkin;                                        // 0x0160(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterLookOverride;                             // 0x0168(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArmourCoverage                               ArmourCoverage;                                    // 0x0178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0D[0x7];                                     // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmourMaterial*                        ArmourMaterial;                                    // 0x0180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedLoadout) == 0x000008, "Wrong alignment on FSavedLoadout");
static_assert(sizeof(FSavedLoadout) == 0x000188, "Wrong size on FSavedLoadout");
static_assert(offsetof(FSavedLoadout, Name) == 0x000000, "Member 'FSavedLoadout::Name' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, PresetName) == 0x000010, "Member 'FSavedLoadout::PresetName' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, ActiveLoadoutPreset) == 0x000020, "Member 'FSavedLoadout::ActiveLoadoutPreset' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, Primary) == 0x000028, "Member 'FSavedLoadout::Primary' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, PrimaryScope) == 0x000030, "Member 'FSavedLoadout::PrimaryScope' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, PrimaryMuzzle) == 0x000038, "Member 'FSavedLoadout::PrimaryMuzzle' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, PrimaryUnderbarrel) == 0x000040, "Member 'FSavedLoadout::PrimaryUnderbarrel' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, PrimaryOverbarrel) == 0x000048, "Member 'FSavedLoadout::PrimaryOverbarrel' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, PrimaryStock) == 0x000050, "Member 'FSavedLoadout::PrimaryStock' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, PrimaryGrip) == 0x000058, "Member 'FSavedLoadout::PrimaryGrip' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, PrimaryIlluminator) == 0x000060, "Member 'FSavedLoadout::PrimaryIlluminator' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, PrimaryAmmunition) == 0x000068, "Member 'FSavedLoadout::PrimaryAmmunition' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, PrimaryAmmoSlots) == 0x000070, "Member 'FSavedLoadout::PrimaryAmmoSlots' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, PrimaryAmmoSlotsCount) == 0x000080, "Member 'FSavedLoadout::PrimaryAmmoSlotsCount' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, PrimarySkin) == 0x000088, "Member 'FSavedLoadout::PrimarySkin' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, Secondary) == 0x000090, "Member 'FSavedLoadout::Secondary' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, SecondaryScope) == 0x000098, "Member 'FSavedLoadout::SecondaryScope' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, SecondaryMuzzle) == 0x0000A0, "Member 'FSavedLoadout::SecondaryMuzzle' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, SecondaryUnderbarrel) == 0x0000A8, "Member 'FSavedLoadout::SecondaryUnderbarrel' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, SecondaryOverbarrel) == 0x0000B0, "Member 'FSavedLoadout::SecondaryOverbarrel' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, SecondaryStock) == 0x0000B8, "Member 'FSavedLoadout::SecondaryStock' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, SecondaryGrip) == 0x0000C0, "Member 'FSavedLoadout::SecondaryGrip' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, SecondaryIlluminator) == 0x0000C8, "Member 'FSavedLoadout::SecondaryIlluminator' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, SecondaryAmmunition) == 0x0000D0, "Member 'FSavedLoadout::SecondaryAmmunition' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, SecondaryAmmoSlots) == 0x0000D8, "Member 'FSavedLoadout::SecondaryAmmoSlots' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, SecondaryAmmoSlotsCount) == 0x0000E8, "Member 'FSavedLoadout::SecondaryAmmoSlotsCount' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, SecondarySkin) == 0x0000F0, "Member 'FSavedLoadout::SecondarySkin' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, CharacterType) == 0x0000F8, "Member 'FSavedLoadout::CharacterType' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, LongTactical) == 0x000100, "Member 'FSavedLoadout::LongTactical' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, GrenadeSlots) == 0x000108, "Member 'FSavedLoadout::GrenadeSlots' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, GrenadeSlotsCount) == 0x000118, "Member 'FSavedLoadout::GrenadeSlotsCount' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, TacticalSlots) == 0x000120, "Member 'FSavedLoadout::TacticalSlots' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, TacticalSlotsCount) == 0x000130, "Member 'FSavedLoadout::TacticalSlotsCount' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, Armor) == 0x000138, "Member 'FSavedLoadout::Armor' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, Helmet) == 0x000140, "Member 'FSavedLoadout::Helmet' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, RandomGear) == 0x000148, "Member 'FSavedLoadout::RandomGear' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, Miscelaneous) == 0x000150, "Member 'FSavedLoadout::Miscelaneous' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, PlayerSkin) == 0x000160, "Member 'FSavedLoadout::PlayerSkin' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, CharacterLookOverride) == 0x000168, "Member 'FSavedLoadout::CharacterLookOverride' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, ArmourCoverage) == 0x000178, "Member 'FSavedLoadout::ArmourCoverage' has a wrong offset!");
static_assert(offsetof(FSavedLoadout, ArmourMaterial) == 0x000180, "Member 'FSavedLoadout::ArmourMaterial' has a wrong offset!");

// ScriptStruct ReadyOrNot.SavedCustomization
// 0x00D0 (0x00D0 - 0x0000)
struct FSavedCustomization final 
{
public:
	class UCustomizationDataBase*                 Character;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationDataBase*                 Voice;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationDataBase*                 Helmet;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationDataBase*                 Shirt;                                             // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationDataBase*                 Pants;                                             // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationDataBase*                 Shoes;                                             // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationDataBase*                 Eyewear;                                           // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationDataBase*                 Belt;                                              // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationDataBase*                 Gloves;                                            // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationDataBase*                 Watch;                                             // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationDataBase*                 Tattoo;                                            // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationDataBase*                 PrimarySkin;                                       // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationDataBase*                 SecondarySkin;                                     // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationDataBase*                 ArmorSkin;                                         // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationDataBase*                 HeadwearSkin;                                      // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasHelmet;                                        // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0E[0x7];                                     // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSoftClassPtr<class UClass>, class UCustomizationDataBase*> PreviousSkinsMap;                                  // 0x0080(0x0050)(RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedCustomization) == 0x000008, "Wrong alignment on FSavedCustomization");
static_assert(sizeof(FSavedCustomization) == 0x0000D0, "Wrong size on FSavedCustomization");
static_assert(offsetof(FSavedCustomization, Character) == 0x000000, "Member 'FSavedCustomization::Character' has a wrong offset!");
static_assert(offsetof(FSavedCustomization, Voice) == 0x000008, "Member 'FSavedCustomization::Voice' has a wrong offset!");
static_assert(offsetof(FSavedCustomization, Helmet) == 0x000010, "Member 'FSavedCustomization::Helmet' has a wrong offset!");
static_assert(offsetof(FSavedCustomization, Shirt) == 0x000018, "Member 'FSavedCustomization::Shirt' has a wrong offset!");
static_assert(offsetof(FSavedCustomization, Pants) == 0x000020, "Member 'FSavedCustomization::Pants' has a wrong offset!");
static_assert(offsetof(FSavedCustomization, Shoes) == 0x000028, "Member 'FSavedCustomization::Shoes' has a wrong offset!");
static_assert(offsetof(FSavedCustomization, Eyewear) == 0x000030, "Member 'FSavedCustomization::Eyewear' has a wrong offset!");
static_assert(offsetof(FSavedCustomization, Belt) == 0x000038, "Member 'FSavedCustomization::Belt' has a wrong offset!");
static_assert(offsetof(FSavedCustomization, Gloves) == 0x000040, "Member 'FSavedCustomization::Gloves' has a wrong offset!");
static_assert(offsetof(FSavedCustomization, Watch) == 0x000048, "Member 'FSavedCustomization::Watch' has a wrong offset!");
static_assert(offsetof(FSavedCustomization, Tattoo) == 0x000050, "Member 'FSavedCustomization::Tattoo' has a wrong offset!");
static_assert(offsetof(FSavedCustomization, PrimarySkin) == 0x000058, "Member 'FSavedCustomization::PrimarySkin' has a wrong offset!");
static_assert(offsetof(FSavedCustomization, SecondarySkin) == 0x000060, "Member 'FSavedCustomization::SecondarySkin' has a wrong offset!");
static_assert(offsetof(FSavedCustomization, ArmorSkin) == 0x000068, "Member 'FSavedCustomization::ArmorSkin' has a wrong offset!");
static_assert(offsetof(FSavedCustomization, HeadwearSkin) == 0x000070, "Member 'FSavedCustomization::HeadwearSkin' has a wrong offset!");
static_assert(offsetof(FSavedCustomization, bHasHelmet) == 0x000078, "Member 'FSavedCustomization::bHasHelmet' has a wrong offset!");
static_assert(offsetof(FSavedCustomization, PreviousSkinsMap) == 0x000080, "Member 'FSavedCustomization::PreviousSkinsMap' has a wrong offset!");

// ScriptStruct ReadyOrNot.BuildingFloor
// 0x0038 (0x0038 - 0x0000)
struct FBuildingFloor final 
{
public:
	int32                                         Number;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0014(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBuildingFloor) == 0x000008, "Wrong alignment on FBuildingFloor");
static_assert(sizeof(FBuildingFloor) == 0x000038, "Wrong size on FBuildingFloor");
static_assert(offsetof(FBuildingFloor, Number) == 0x000000, "Member 'FBuildingFloor::Number' has a wrong offset!");
static_assert(offsetof(FBuildingFloor, Height) == 0x000004, "Member 'FBuildingFloor::Height' has a wrong offset!");
static_assert(offsetof(FBuildingFloor, Location) == 0x000008, "Member 'FBuildingFloor::Location' has a wrong offset!");
static_assert(offsetof(FBuildingFloor, Extent) == 0x000014, "Member 'FBuildingFloor::Extent' has a wrong offset!");
static_assert(offsetof(FBuildingFloor, Name) == 0x000020, "Member 'FBuildingFloor::Name' has a wrong offset!");

// ScriptStruct ReadyOrNot.PlanningDrawingArray
// 0x0010 (0x0118 - 0x0108)
struct FPlanningDrawingArray final  : public FFastArraySerializer
{
public:
	TArray<struct FPlanningDrawing>               Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlanningDrawingArray) == 0x000008, "Wrong alignment on FPlanningDrawingArray");
static_assert(sizeof(FPlanningDrawingArray) == 0x000118, "Wrong size on FPlanningDrawingArray");
static_assert(offsetof(FPlanningDrawingArray, Items) == 0x000108, "Member 'FPlanningDrawingArray::Items' has a wrong offset!");

// ScriptStruct ReadyOrNot.ItemSelectionGroup
// 0x0048 (0x0048 - 0x0000)
struct FItemSelectionGroup final 
{
public:
	class FName                                   ItemGroupName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InputActionName;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 ItemCategory;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0F[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EItemCategory>                         AdditionalItemCategories;                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ABaseItem>>          Items;                                             // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         ItemIndex;                                         // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F10[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ItemGroupIcon;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemSelectionGroup) == 0x000008, "Wrong alignment on FItemSelectionGroup");
static_assert(sizeof(FItemSelectionGroup) == 0x000048, "Wrong size on FItemSelectionGroup");
static_assert(offsetof(FItemSelectionGroup, ItemGroupName) == 0x000000, "Member 'FItemSelectionGroup::ItemGroupName' has a wrong offset!");
static_assert(offsetof(FItemSelectionGroup, InputActionName) == 0x000008, "Member 'FItemSelectionGroup::InputActionName' has a wrong offset!");
static_assert(offsetof(FItemSelectionGroup, ItemCategory) == 0x000010, "Member 'FItemSelectionGroup::ItemCategory' has a wrong offset!");
static_assert(offsetof(FItemSelectionGroup, AdditionalItemCategories) == 0x000018, "Member 'FItemSelectionGroup::AdditionalItemCategories' has a wrong offset!");
static_assert(offsetof(FItemSelectionGroup, Items) == 0x000028, "Member 'FItemSelectionGroup::Items' has a wrong offset!");
static_assert(offsetof(FItemSelectionGroup, ItemIndex) == 0x000038, "Member 'FItemSelectionGroup::ItemIndex' has a wrong offset!");
static_assert(offsetof(FItemSelectionGroup, ItemGroupIcon) == 0x000040, "Member 'FItemSelectionGroup::ItemGroupIcon' has a wrong offset!");

// ScriptStruct ReadyOrNot.SpawnedGear
// 0x0078 (0x0078 - 0x0000)
struct FSpawnedGear final 
{
public:
	struct FGuid                                  Guid;                                              // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              Primary;                                           // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              Secondary;                                         // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              Armor;                                             // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              Helmet;                                            // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              RandomGear;                                        // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayableCharacterData*                 Character;                                         // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              LongTactical;                                      // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      Grenades;                                          // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      TacticalDevices;                                   // 0x0058(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      Miscelaneous;                                      // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnedGear) == 0x000008, "Wrong alignment on FSpawnedGear");
static_assert(sizeof(FSpawnedGear) == 0x000078, "Wrong size on FSpawnedGear");
static_assert(offsetof(FSpawnedGear, Guid) == 0x000000, "Member 'FSpawnedGear::Guid' has a wrong offset!");
static_assert(offsetof(FSpawnedGear, Primary) == 0x000010, "Member 'FSpawnedGear::Primary' has a wrong offset!");
static_assert(offsetof(FSpawnedGear, Secondary) == 0x000018, "Member 'FSpawnedGear::Secondary' has a wrong offset!");
static_assert(offsetof(FSpawnedGear, Armor) == 0x000020, "Member 'FSpawnedGear::Armor' has a wrong offset!");
static_assert(offsetof(FSpawnedGear, Helmet) == 0x000028, "Member 'FSpawnedGear::Helmet' has a wrong offset!");
static_assert(offsetof(FSpawnedGear, RandomGear) == 0x000030, "Member 'FSpawnedGear::RandomGear' has a wrong offset!");
static_assert(offsetof(FSpawnedGear, Character) == 0x000038, "Member 'FSpawnedGear::Character' has a wrong offset!");
static_assert(offsetof(FSpawnedGear, LongTactical) == 0x000040, "Member 'FSpawnedGear::LongTactical' has a wrong offset!");
static_assert(offsetof(FSpawnedGear, Grenades) == 0x000048, "Member 'FSpawnedGear::Grenades' has a wrong offset!");
static_assert(offsetof(FSpawnedGear, TacticalDevices) == 0x000058, "Member 'FSpawnedGear::TacticalDevices' has a wrong offset!");
static_assert(offsetof(FSpawnedGear, Miscelaneous) == 0x000068, "Member 'FSpawnedGear::Miscelaneous' has a wrong offset!");

// ScriptStruct ReadyOrNot.SuppressionData
// 0x0028 (0x0028 - 0x0000)
struct FSuppressionData final 
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   Instigator;                                        // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSuppressionData) == 0x000008, "Wrong alignment on FSuppressionData");
static_assert(sizeof(FSuppressionData) == 0x000028, "Wrong size on FSuppressionData");
static_assert(offsetof(FSuppressionData, Origin) == 0x000000, "Member 'FSuppressionData::Origin' has a wrong offset!");
static_assert(offsetof(FSuppressionData, Direction) == 0x00000C, "Member 'FSuppressionData::Direction' has a wrong offset!");
static_assert(offsetof(FSuppressionData, Strength) == 0x000018, "Member 'FSuppressionData::Strength' has a wrong offset!");
static_assert(offsetof(FSuppressionData, Distance) == 0x00001C, "Member 'FSuppressionData::Distance' has a wrong offset!");
static_assert(offsetof(FSuppressionData, Instigator) == 0x000020, "Member 'FSuppressionData::Instigator' has a wrong offset!");

// ScriptStruct ReadyOrNot.MapLayout
// 0x0088 (0x0088 - 0x0000)
struct FMapLayout final 
{
public:
	struct FVector2D                              MapOrigin;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapSize;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F11[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              MapOverviewTexture;                                // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, TSoftObjectPtr<class UTexture2D>> MapCells;                                          // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapLayout) == 0x000008, "Wrong alignment on FMapLayout");
static_assert(sizeof(FMapLayout) == 0x000088, "Wrong size on FMapLayout");
static_assert(offsetof(FMapLayout, MapOrigin) == 0x000000, "Member 'FMapLayout::MapOrigin' has a wrong offset!");
static_assert(offsetof(FMapLayout, MapSize) == 0x000008, "Member 'FMapLayout::MapSize' has a wrong offset!");
static_assert(offsetof(FMapLayout, MapOverviewTexture) == 0x000010, "Member 'FMapLayout::MapOverviewTexture' has a wrong offset!");
static_assert(offsetof(FMapLayout, MapCells) == 0x000038, "Member 'FMapLayout::MapCells' has a wrong offset!");

// ScriptStruct ReadyOrNot.RChatMessage
// 0x0068 (0x0068 - 0x0000)
struct FRChatMessage final 
{
public:
	class FString                                 SenderName;                                        // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotPlayerState*                 SenderPlayerState;                                 // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Timestamp;                                         // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Args;                                              // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     AssociatedTeam;                                    // 0x0050(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKillfeed;                                         // 0x0051(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCommand;                                          // 0x0052(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F12[0x5];                                     // 0x0053(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      TargetPlayerController;                            // 0x0058(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     TargetTeam;                                        // 0x0060(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F13[0x7];                                     // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRChatMessage) == 0x000008, "Wrong alignment on FRChatMessage");
static_assert(sizeof(FRChatMessage) == 0x000068, "Wrong size on FRChatMessage");
static_assert(offsetof(FRChatMessage, SenderName) == 0x000000, "Member 'FRChatMessage::SenderName' has a wrong offset!");
static_assert(offsetof(FRChatMessage, SenderPlayerState) == 0x000010, "Member 'FRChatMessage::SenderPlayerState' has a wrong offset!");
static_assert(offsetof(FRChatMessage, Message) == 0x000018, "Member 'FRChatMessage::Message' has a wrong offset!");
static_assert(offsetof(FRChatMessage, Color) == 0x000028, "Member 'FRChatMessage::Color' has a wrong offset!");
static_assert(offsetof(FRChatMessage, Timestamp) == 0x000038, "Member 'FRChatMessage::Timestamp' has a wrong offset!");
static_assert(offsetof(FRChatMessage, Args) == 0x000040, "Member 'FRChatMessage::Args' has a wrong offset!");
static_assert(offsetof(FRChatMessage, AssociatedTeam) == 0x000050, "Member 'FRChatMessage::AssociatedTeam' has a wrong offset!");
static_assert(offsetof(FRChatMessage, bKillfeed) == 0x000051, "Member 'FRChatMessage::bKillfeed' has a wrong offset!");
static_assert(offsetof(FRChatMessage, bCommand) == 0x000052, "Member 'FRChatMessage::bCommand' has a wrong offset!");
static_assert(offsetof(FRChatMessage, TargetPlayerController) == 0x000058, "Member 'FRChatMessage::TargetPlayerController' has a wrong offset!");
static_assert(offsetof(FRChatMessage, TargetTeam) == 0x000060, "Member 'FRChatMessage::TargetTeam' has a wrong offset!");

// ScriptStruct ReadyOrNot.CharacterSnapshot
// 0x0020 (0x0020 - 0x0000)
struct FCharacterSnapshot final 
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   BoundingBox;                                       // 0x0004(0x001C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSnapshot) == 0x000004, "Wrong alignment on FCharacterSnapshot");
static_assert(sizeof(FCharacterSnapshot) == 0x000020, "Wrong size on FCharacterSnapshot");
static_assert(offsetof(FCharacterSnapshot, Time) == 0x000000, "Member 'FCharacterSnapshot::Time' has a wrong offset!");
static_assert(offsetof(FCharacterSnapshot, BoundingBox) == 0x000004, "Member 'FCharacterSnapshot::BoundingBox' has a wrong offset!");

// ScriptStruct ReadyOrNot.FactionSuspectTeam
// 0x0020 (0x0020 - 0x0000)
struct FFactionSuspectTeam final 
{
public:
	TArray<class ASuspectCharacter*>              Suspects;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TArray<EAITeamTactic>                         Tactics;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFactionSuspectTeam) == 0x000008, "Wrong alignment on FFactionSuspectTeam");
static_assert(sizeof(FFactionSuspectTeam) == 0x000020, "Wrong size on FFactionSuspectTeam");
static_assert(offsetof(FFactionSuspectTeam, Suspects) == 0x000000, "Member 'FFactionSuspectTeam::Suspects' has a wrong offset!");
static_assert(offsetof(FFactionSuspectTeam, Tactics) == 0x000010, "Member 'FFactionSuspectTeam::Tactics' has a wrong offset!");

// ScriptStruct ReadyOrNot.AIMoveDataBlock
// 0x0098 (0x0098 - 0x0000)
struct FAIMoveDataBlock final 
{
public:
	class FName                                   UnarmedMovementStyle;                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RifleMovementStyle;                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RifleStrafeMovementStyle;                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RifleStrafeFastMovementStyle;                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HeavyRifleStrafeMovementStyle;                     // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RifleStrafeCrouchMovementSet;                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PistolMovementStyle;                               // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PistolStrafeMovementStyle;                         // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PistolStrafeCrouchMovementStyle;                   // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComplyMovementStyle;                               // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CuffedMovementStyle;                               // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StunnedMovementStyle;                              // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GassedMovementStyle;                               // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InjuredMovementStyle;                              // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SprintMovementStyle;                               // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           UnarmedCalmStyles;                                 // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           UnarmedPanicStyles;                                // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIMoveDataBlock) == 0x000008, "Wrong alignment on FAIMoveDataBlock");
static_assert(sizeof(FAIMoveDataBlock) == 0x000098, "Wrong size on FAIMoveDataBlock");
static_assert(offsetof(FAIMoveDataBlock, UnarmedMovementStyle) == 0x000000, "Member 'FAIMoveDataBlock::UnarmedMovementStyle' has a wrong offset!");
static_assert(offsetof(FAIMoveDataBlock, RifleMovementStyle) == 0x000008, "Member 'FAIMoveDataBlock::RifleMovementStyle' has a wrong offset!");
static_assert(offsetof(FAIMoveDataBlock, RifleStrafeMovementStyle) == 0x000010, "Member 'FAIMoveDataBlock::RifleStrafeMovementStyle' has a wrong offset!");
static_assert(offsetof(FAIMoveDataBlock, RifleStrafeFastMovementStyle) == 0x000018, "Member 'FAIMoveDataBlock::RifleStrafeFastMovementStyle' has a wrong offset!");
static_assert(offsetof(FAIMoveDataBlock, HeavyRifleStrafeMovementStyle) == 0x000020, "Member 'FAIMoveDataBlock::HeavyRifleStrafeMovementStyle' has a wrong offset!");
static_assert(offsetof(FAIMoveDataBlock, RifleStrafeCrouchMovementSet) == 0x000028, "Member 'FAIMoveDataBlock::RifleStrafeCrouchMovementSet' has a wrong offset!");
static_assert(offsetof(FAIMoveDataBlock, PistolMovementStyle) == 0x000030, "Member 'FAIMoveDataBlock::PistolMovementStyle' has a wrong offset!");
static_assert(offsetof(FAIMoveDataBlock, PistolStrafeMovementStyle) == 0x000038, "Member 'FAIMoveDataBlock::PistolStrafeMovementStyle' has a wrong offset!");
static_assert(offsetof(FAIMoveDataBlock, PistolStrafeCrouchMovementStyle) == 0x000040, "Member 'FAIMoveDataBlock::PistolStrafeCrouchMovementStyle' has a wrong offset!");
static_assert(offsetof(FAIMoveDataBlock, ComplyMovementStyle) == 0x000048, "Member 'FAIMoveDataBlock::ComplyMovementStyle' has a wrong offset!");
static_assert(offsetof(FAIMoveDataBlock, CuffedMovementStyle) == 0x000050, "Member 'FAIMoveDataBlock::CuffedMovementStyle' has a wrong offset!");
static_assert(offsetof(FAIMoveDataBlock, StunnedMovementStyle) == 0x000058, "Member 'FAIMoveDataBlock::StunnedMovementStyle' has a wrong offset!");
static_assert(offsetof(FAIMoveDataBlock, GassedMovementStyle) == 0x000060, "Member 'FAIMoveDataBlock::GassedMovementStyle' has a wrong offset!");
static_assert(offsetof(FAIMoveDataBlock, InjuredMovementStyle) == 0x000068, "Member 'FAIMoveDataBlock::InjuredMovementStyle' has a wrong offset!");
static_assert(offsetof(FAIMoveDataBlock, SprintMovementStyle) == 0x000070, "Member 'FAIMoveDataBlock::SprintMovementStyle' has a wrong offset!");
static_assert(offsetof(FAIMoveDataBlock, UnarmedCalmStyles) == 0x000078, "Member 'FAIMoveDataBlock::UnarmedCalmStyles' has a wrong offset!");
static_assert(offsetof(FAIMoveDataBlock, UnarmedPanicStyles) == 0x000088, "Member 'FAIMoveDataBlock::UnarmedPanicStyles' has a wrong offset!");

// ScriptStruct ReadyOrNot.RonReplicatedAcceleration
// 0x0003 (0x0003 - 0x0000)
struct FRonReplicatedAcceleration final 
{
public:
	uint8                                         AccelXYRadians;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AccelXYMagnitude;                                  // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          AccelZ;                                            // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRonReplicatedAcceleration) == 0x000001, "Wrong alignment on FRonReplicatedAcceleration");
static_assert(sizeof(FRonReplicatedAcceleration) == 0x000003, "Wrong size on FRonReplicatedAcceleration");
static_assert(offsetof(FRonReplicatedAcceleration, AccelXYRadians) == 0x000000, "Member 'FRonReplicatedAcceleration::AccelXYRadians' has a wrong offset!");
static_assert(offsetof(FRonReplicatedAcceleration, AccelXYMagnitude) == 0x000001, "Member 'FRonReplicatedAcceleration::AccelXYMagnitude' has a wrong offset!");
static_assert(offsetof(FRonReplicatedAcceleration, AccelZ) == 0x000002, "Member 'FRonReplicatedAcceleration::AccelZ' has a wrong offset!");

// ScriptStruct ReadyOrNot.SavedExitRoute
// 0x0030 (0x0030 - 0x0000)
struct FSavedExitRoute final 
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathCost;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Doors;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ThreatsOnRoute;                                    // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedExitRoute) == 0x000008, "Wrong alignment on FSavedExitRoute");
static_assert(sizeof(FSavedExitRoute) == 0x000030, "Wrong size on FSavedExitRoute");
static_assert(offsetof(FSavedExitRoute, Location) == 0x000000, "Member 'FSavedExitRoute::Location' has a wrong offset!");
static_assert(offsetof(FSavedExitRoute, PathCost) == 0x00000C, "Member 'FSavedExitRoute::PathCost' has a wrong offset!");
static_assert(offsetof(FSavedExitRoute, Doors) == 0x000010, "Member 'FSavedExitRoute::Doors' has a wrong offset!");
static_assert(offsetof(FSavedExitRoute, ThreatsOnRoute) == 0x000020, "Member 'FSavedExitRoute::ThreatsOnRoute' has a wrong offset!");

// ScriptStruct ReadyOrNot.SavedExitData
// 0x0020 (0x0020 - 0x0000)
struct FSavedExitData final 
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F14[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSavedExitRoute>                PossibleRoutes;                                    // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedExitData) == 0x000008, "Wrong alignment on FSavedExitData");
static_assert(sizeof(FSavedExitData) == 0x000020, "Wrong size on FSavedExitData");
static_assert(offsetof(FSavedExitData, Location) == 0x000000, "Member 'FSavedExitData::Location' has a wrong offset!");
static_assert(offsetof(FSavedExitData, PossibleRoutes) == 0x000010, "Member 'FSavedExitData::PossibleRoutes' has a wrong offset!");

// ScriptStruct ReadyOrNot.SavedSwatLookAtPoint
// 0x0018 (0x0018 - 0x0000)
struct FSavedSwatLookAtPoint final 
{
public:
	struct FIntVector                             Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LinkedDoorID;                                      // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedSwatLookAtPoint) == 0x000004, "Wrong alignment on FSavedSwatLookAtPoint");
static_assert(sizeof(FSavedSwatLookAtPoint) == 0x000018, "Wrong size on FSavedSwatLookAtPoint");
static_assert(offsetof(FSavedSwatLookAtPoint, Location) == 0x000000, "Member 'FSavedSwatLookAtPoint::Location' has a wrong offset!");
static_assert(offsetof(FSavedSwatLookAtPoint, LinkedDoorID) == 0x00000C, "Member 'FSavedSwatLookAtPoint::LinkedDoorID' has a wrong offset!");

// ScriptStruct ReadyOrNot.SavedThreatAwarenessActor
// 0x0080 (0x0080 - 0x0000)
struct FSavedThreatAwarenessActor final 
{
public:
	struct FVector                                UniqueId;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EThreatLevel                                  ThreatLevel;                                       // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F15[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSavedExitData>                 Exits;                                             // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        UniqueExits;                                       // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 OwningRoom;                                        // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Door;                                              // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFrontDoorThreat;                                  // 0x005C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOutside;                                        // 0x005D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F16[0x2];                                     // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSavedSwatLookAtPoint>          SwatLookAtPoints;                                  // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PathableThreats;                                   // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedThreatAwarenessActor) == 0x000008, "Wrong alignment on FSavedThreatAwarenessActor");
static_assert(sizeof(FSavedThreatAwarenessActor) == 0x000080, "Wrong size on FSavedThreatAwarenessActor");
static_assert(offsetof(FSavedThreatAwarenessActor, UniqueId) == 0x000000, "Member 'FSavedThreatAwarenessActor::UniqueId' has a wrong offset!");
static_assert(offsetof(FSavedThreatAwarenessActor, Location) == 0x00000C, "Member 'FSavedThreatAwarenessActor::Location' has a wrong offset!");
static_assert(offsetof(FSavedThreatAwarenessActor, ThreatLevel) == 0x000018, "Member 'FSavedThreatAwarenessActor::ThreatLevel' has a wrong offset!");
static_assert(offsetof(FSavedThreatAwarenessActor, Exits) == 0x000020, "Member 'FSavedThreatAwarenessActor::Exits' has a wrong offset!");
static_assert(offsetof(FSavedThreatAwarenessActor, UniqueExits) == 0x000030, "Member 'FSavedThreatAwarenessActor::UniqueExits' has a wrong offset!");
static_assert(offsetof(FSavedThreatAwarenessActor, OwningRoom) == 0x000040, "Member 'FSavedThreatAwarenessActor::OwningRoom' has a wrong offset!");
static_assert(offsetof(FSavedThreatAwarenessActor, Door) == 0x000050, "Member 'FSavedThreatAwarenessActor::Door' has a wrong offset!");
static_assert(offsetof(FSavedThreatAwarenessActor, bFrontDoorThreat) == 0x00005C, "Member 'FSavedThreatAwarenessActor::bFrontDoorThreat' has a wrong offset!");
static_assert(offsetof(FSavedThreatAwarenessActor, bIsOutside) == 0x00005D, "Member 'FSavedThreatAwarenessActor::bIsOutside' has a wrong offset!");
static_assert(offsetof(FSavedThreatAwarenessActor, SwatLookAtPoints) == 0x000060, "Member 'FSavedThreatAwarenessActor::SwatLookAtPoints' has a wrong offset!");
static_assert(offsetof(FSavedThreatAwarenessActor, PathableThreats) == 0x000070, "Member 'FSavedThreatAwarenessActor::PathableThreats' has a wrong offset!");

// ScriptStruct ReadyOrNot.SavedClearPoint
// 0x0038 (0x0038 - 0x0000)
struct FSavedClearPoint final 
{
public:
	struct FVector                                Location_Relative;                                 // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Stage;                                             // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EClearDirection                               Direction;                                         // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F17[0x6];                                     // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         CoverLandmarks;                                    // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasLineOfSightToDoor;                             // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F18[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSavedClearPoint) == 0x000008, "Wrong alignment on FSavedClearPoint");
static_assert(sizeof(FSavedClearPoint) == 0x000038, "Wrong size on FSavedClearPoint");
static_assert(offsetof(FSavedClearPoint, Location_Relative) == 0x000000, "Member 'FSavedClearPoint::Location_Relative' has a wrong offset!");
static_assert(offsetof(FSavedClearPoint, Location) == 0x00000C, "Member 'FSavedClearPoint::Location' has a wrong offset!");
static_assert(offsetof(FSavedClearPoint, Stage) == 0x000018, "Member 'FSavedClearPoint::Stage' has a wrong offset!");
static_assert(offsetof(FSavedClearPoint, Direction) == 0x000019, "Member 'FSavedClearPoint::Direction' has a wrong offset!");
static_assert(offsetof(FSavedClearPoint, CoverLandmarks) == 0x000020, "Member 'FSavedClearPoint::CoverLandmarks' has a wrong offset!");
static_assert(offsetof(FSavedClearPoint, bHasLineOfSightToDoor) == 0x000030, "Member 'FSavedClearPoint::bHasLineOfSightToDoor' has a wrong offset!");

// ScriptStruct ReadyOrNot.SavedStackUpActor
// 0x001C (0x001C - 0x0000)
struct FSavedStackUpActor final 
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Depth;                                             // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESquadPosition                                StackUpPosition;                                   // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F19[0x2];                                     // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LinkedDoorID;                                      // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedStackUpActor) == 0x000004, "Wrong alignment on FSavedStackUpActor");
static_assert(sizeof(FSavedStackUpActor) == 0x00001C, "Wrong size on FSavedStackUpActor");
static_assert(offsetof(FSavedStackUpActor, Location) == 0x000000, "Member 'FSavedStackUpActor::Location' has a wrong offset!");
static_assert(offsetof(FSavedStackUpActor, Depth) == 0x00000C, "Member 'FSavedStackUpActor::Depth' has a wrong offset!");
static_assert(offsetof(FSavedStackUpActor, StackUpPosition) == 0x00000D, "Member 'FSavedStackUpActor::StackUpPosition' has a wrong offset!");
static_assert(offsetof(FSavedStackUpActor, LinkedDoorID) == 0x000010, "Member 'FSavedStackUpActor::LinkedDoorID' has a wrong offset!");

// ScriptStruct ReadyOrNot.SavedDoorActor
// 0x01B8 (0x01B8 - 0x0000)
struct FSavedDoorActor final 
{
public:
	struct FVector                                UniqueId;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1A[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedThreatAwarenessActor             FrontDoorThreat;                                   // 0x0010(0x0080)(NativeAccessSpecifierPublic)
	struct FSavedThreatAwarenessActor             BackDoorThreat;                                    // 0x0090(0x0080)(NativeAccessSpecifierPublic)
	TArray<struct FSavedClearPoint>               FrontLeftClearPoints;                              // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedClearPoint>               FrontRightClearPoints;                             // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedClearPoint>               BackLeftClearPoints;                               // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedClearPoint>               BackRightClearPoints;                              // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedThreatAwarenessActor>     FrontThreats;                                      // 0x0150(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedThreatAwarenessActor>     BackThreats;                                       // 0x0160(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedStackUpActor>             FrontLeftStackups;                                 // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedStackUpActor>             FrontRightStackups;                                // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedStackUpActor>             BackLeftStackups;                                  // 0x0190(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedStackUpActor>             BackRightStackups;                                 // 0x01A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EDoorRoomPosition                             FrontRoomPosition;                                 // 0x01B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoorRoomPosition                             BackRoomPosition;                                  // 0x01B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasFrame;                                         // 0x01B2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanIssueOrdersOnFrontSide;                        // 0x01B3(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanIssueOrdersOnBackSide;                         // 0x01B4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1B[0x3];                                     // 0x01B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSavedDoorActor) == 0x000008, "Wrong alignment on FSavedDoorActor");
static_assert(sizeof(FSavedDoorActor) == 0x0001B8, "Wrong size on FSavedDoorActor");
static_assert(offsetof(FSavedDoorActor, UniqueId) == 0x000000, "Member 'FSavedDoorActor::UniqueId' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, FrontDoorThreat) == 0x000010, "Member 'FSavedDoorActor::FrontDoorThreat' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, BackDoorThreat) == 0x000090, "Member 'FSavedDoorActor::BackDoorThreat' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, FrontLeftClearPoints) == 0x000110, "Member 'FSavedDoorActor::FrontLeftClearPoints' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, FrontRightClearPoints) == 0x000120, "Member 'FSavedDoorActor::FrontRightClearPoints' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, BackLeftClearPoints) == 0x000130, "Member 'FSavedDoorActor::BackLeftClearPoints' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, BackRightClearPoints) == 0x000140, "Member 'FSavedDoorActor::BackRightClearPoints' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, FrontThreats) == 0x000150, "Member 'FSavedDoorActor::FrontThreats' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, BackThreats) == 0x000160, "Member 'FSavedDoorActor::BackThreats' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, FrontLeftStackups) == 0x000170, "Member 'FSavedDoorActor::FrontLeftStackups' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, FrontRightStackups) == 0x000180, "Member 'FSavedDoorActor::FrontRightStackups' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, BackLeftStackups) == 0x000190, "Member 'FSavedDoorActor::BackLeftStackups' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, BackRightStackups) == 0x0001A0, "Member 'FSavedDoorActor::BackRightStackups' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, FrontRoomPosition) == 0x0001B0, "Member 'FSavedDoorActor::FrontRoomPosition' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, BackRoomPosition) == 0x0001B1, "Member 'FSavedDoorActor::BackRoomPosition' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, bHasFrame) == 0x0001B2, "Member 'FSavedDoorActor::bHasFrame' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, bCanIssueOrdersOnFrontSide) == 0x0001B3, "Member 'FSavedDoorActor::bCanIssueOrdersOnFrontSide' has a wrong offset!");
static_assert(offsetof(FSavedDoorActor, bCanIssueOrdersOnBackSide) == 0x0001B4, "Member 'FSavedDoorActor::bCanIssueOrdersOnBackSide' has a wrong offset!");

// ScriptStruct ReadyOrNot.CharacterLookOverride
// 0x00C8 (0x00D0 - 0x0008)
struct FCharacterLookOverride final  : public FTableRowBase
{
public:
	EGameVersionRestriction                       LockedToDLC;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1C[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FriendlyBodyName;                                  // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 SpeechCharacterName;                               // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             BodyIcon;                                          // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   FriendlyHeadName;                                  // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UTexture2D*                             HeadIcon;                                          // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseArmour>, class USkeletalMesh*> ArmorOverrideMap;                                  // 0x0060(0x0050)(Edit, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          FPMeshOverride;                                    // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          FPBodyMeshOverride;                                // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          FaceMeshOverride;                                  // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          BodyMeshOverride;                                  // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterLookOverride) == 0x000008, "Wrong alignment on FCharacterLookOverride");
static_assert(sizeof(FCharacterLookOverride) == 0x0000D0, "Wrong size on FCharacterLookOverride");
static_assert(offsetof(FCharacterLookOverride, LockedToDLC) == 0x000008, "Member 'FCharacterLookOverride::LockedToDLC' has a wrong offset!");
static_assert(offsetof(FCharacterLookOverride, FriendlyBodyName) == 0x000010, "Member 'FCharacterLookOverride::FriendlyBodyName' has a wrong offset!");
static_assert(offsetof(FCharacterLookOverride, SpeechCharacterName) == 0x000028, "Member 'FCharacterLookOverride::SpeechCharacterName' has a wrong offset!");
static_assert(offsetof(FCharacterLookOverride, BodyIcon) == 0x000038, "Member 'FCharacterLookOverride::BodyIcon' has a wrong offset!");
static_assert(offsetof(FCharacterLookOverride, FriendlyHeadName) == 0x000040, "Member 'FCharacterLookOverride::FriendlyHeadName' has a wrong offset!");
static_assert(offsetof(FCharacterLookOverride, HeadIcon) == 0x000058, "Member 'FCharacterLookOverride::HeadIcon' has a wrong offset!");
static_assert(offsetof(FCharacterLookOverride, ArmorOverrideMap) == 0x000060, "Member 'FCharacterLookOverride::ArmorOverrideMap' has a wrong offset!");
static_assert(offsetof(FCharacterLookOverride, FPMeshOverride) == 0x0000B0, "Member 'FCharacterLookOverride::FPMeshOverride' has a wrong offset!");
static_assert(offsetof(FCharacterLookOverride, FPBodyMeshOverride) == 0x0000B8, "Member 'FCharacterLookOverride::FPBodyMeshOverride' has a wrong offset!");
static_assert(offsetof(FCharacterLookOverride, FaceMeshOverride) == 0x0000C0, "Member 'FCharacterLookOverride::FaceMeshOverride' has a wrong offset!");
static_assert(offsetof(FCharacterLookOverride, BodyMeshOverride) == 0x0000C8, "Member 'FCharacterLookOverride::BodyMeshOverride' has a wrong offset!");

// ScriptStruct ReadyOrNot.MissionPhoto
// 0x0058 (0x0058 - 0x0000)
struct FMissionPhoto final 
{
public:
	class FText                                   PhotoTitle;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Photo;                                             // 0x0018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PhotoCaption;                                      // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionPhoto) == 0x000008, "Wrong alignment on FMissionPhoto");
static_assert(sizeof(FMissionPhoto) == 0x000058, "Wrong size on FMissionPhoto");
static_assert(offsetof(FMissionPhoto, PhotoTitle) == 0x000000, "Member 'FMissionPhoto::PhotoTitle' has a wrong offset!");
static_assert(offsetof(FMissionPhoto, Photo) == 0x000018, "Member 'FMissionPhoto::Photo' has a wrong offset!");
static_assert(offsetof(FMissionPhoto, PhotoCaption) == 0x000040, "Member 'FMissionPhoto::PhotoCaption' has a wrong offset!");

// ScriptStruct ReadyOrNot.CarryArrestedAnimState
// 0x0008 (0x0008 - 0x0000)
struct FCarryArrestedAnimState final 
{
public:
	class UAnimSequence*                          LoopAnim;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCarryArrestedAnimState) == 0x000008, "Wrong alignment on FCarryArrestedAnimState");
static_assert(sizeof(FCarryArrestedAnimState) == 0x000008, "Wrong size on FCarryArrestedAnimState");
static_assert(offsetof(FCarryArrestedAnimState, LoopAnim) == 0x000000, "Member 'FCarryArrestedAnimState::LoopAnim' has a wrong offset!");

// ScriptStruct ReadyOrNot.CharacterDamageEvent
// 0x0028 (0x0028 - 0x0000)
struct FCharacterDamageEvent final 
{
public:
	float                                         RawDamage;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalDamage;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDamageEvent                           DamageEvent;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class AController*                            Instigator;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Causer;                                            // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterDamageEvent) == 0x000008, "Wrong alignment on FCharacterDamageEvent");
static_assert(sizeof(FCharacterDamageEvent) == 0x000028, "Wrong size on FCharacterDamageEvent");
static_assert(offsetof(FCharacterDamageEvent, RawDamage) == 0x000000, "Member 'FCharacterDamageEvent::RawDamage' has a wrong offset!");
static_assert(offsetof(FCharacterDamageEvent, FinalDamage) == 0x000004, "Member 'FCharacterDamageEvent::FinalDamage' has a wrong offset!");
static_assert(offsetof(FCharacterDamageEvent, DamageEvent) == 0x000008, "Member 'FCharacterDamageEvent::DamageEvent' has a wrong offset!");
static_assert(offsetof(FCharacterDamageEvent, Instigator) == 0x000018, "Member 'FCharacterDamageEvent::Instigator' has a wrong offset!");
static_assert(offsetof(FCharacterDamageEvent, Causer) == 0x000020, "Member 'FCharacterDamageEvent::Causer' has a wrong offset!");

// ScriptStruct ReadyOrNot.ActorSense
// 0x0058 (0x0058 - 0x0000)
struct FActorSense final 
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1D[0x50];                                    // 0x0008(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorSense) == 0x000008, "Wrong alignment on FActorSense");
static_assert(sizeof(FActorSense) == 0x000058, "Wrong size on FActorSense");
static_assert(offsetof(FActorSense, Actor) == 0x000000, "Member 'FActorSense::Actor' has a wrong offset!");

// ScriptStruct ReadyOrNot.CameraFreelookSetting
// 0x0010 (0x0010 - 0x0000)
struct FCameraFreelookSetting final 
{
public:
	float                                         PitchMin;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMax;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawMin;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawMax;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraFreelookSetting) == 0x000004, "Wrong alignment on FCameraFreelookSetting");
static_assert(sizeof(FCameraFreelookSetting) == 0x000010, "Wrong size on FCameraFreelookSetting");
static_assert(offsetof(FCameraFreelookSetting, PitchMin) == 0x000000, "Member 'FCameraFreelookSetting::PitchMin' has a wrong offset!");
static_assert(offsetof(FCameraFreelookSetting, PitchMax) == 0x000004, "Member 'FCameraFreelookSetting::PitchMax' has a wrong offset!");
static_assert(offsetof(FCameraFreelookSetting, YawMin) == 0x000008, "Member 'FCameraFreelookSetting::YawMin' has a wrong offset!");
static_assert(offsetof(FCameraFreelookSetting, YawMax) == 0x00000C, "Member 'FCameraFreelookSetting::YawMax' has a wrong offset!");

// ScriptStruct ReadyOrNot.WeaponSoundData
// 0x0020 (0x0020 - 0x0000)
struct FWeaponSoundData final 
{
public:
	class USoundCue*                              Gunshot;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              Gunshot_Supressed;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GunTail;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GunTail_Supressed;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponSoundData) == 0x000008, "Wrong alignment on FWeaponSoundData");
static_assert(sizeof(FWeaponSoundData) == 0x000020, "Wrong size on FWeaponSoundData");
static_assert(offsetof(FWeaponSoundData, Gunshot) == 0x000000, "Member 'FWeaponSoundData::Gunshot' has a wrong offset!");
static_assert(offsetof(FWeaponSoundData, Gunshot_Supressed) == 0x000008, "Member 'FWeaponSoundData::Gunshot_Supressed' has a wrong offset!");
static_assert(offsetof(FWeaponSoundData, GunTail) == 0x000010, "Member 'FWeaponSoundData::GunTail' has a wrong offset!");
static_assert(offsetof(FWeaponSoundData, GunTail_Supressed) == 0x000018, "Member 'FWeaponSoundData::GunTail_Supressed' has a wrong offset!");

// ScriptStruct ReadyOrNot.Loadout
// 0x0020 (0x0020 - 0x0000)
struct FLoadout final 
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ABaseItem>>          Items;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadout) == 0x000008, "Wrong alignment on FLoadout");
static_assert(sizeof(FLoadout) == 0x000020, "Wrong size on FLoadout");
static_assert(offsetof(FLoadout, Name) == 0x000000, "Member 'FLoadout::Name' has a wrong offset!");
static_assert(offsetof(FLoadout, Items) == 0x000010, "Member 'FLoadout::Items' has a wrong offset!");

// ScriptStruct ReadyOrNot.CoverInstigatorStimulus
// 0x0050 (0x0050 - 0x0000)
struct FCoverInstigatorStimulus final 
{
public:
	class AReadyOrNotCharacter*                   InstigatorCharacter;                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1E[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ThreatTransform;                                   // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1F[0x10];                                    // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoverInstigatorStimulus) == 0x000010, "Wrong alignment on FCoverInstigatorStimulus");
static_assert(sizeof(FCoverInstigatorStimulus) == 0x000050, "Wrong size on FCoverInstigatorStimulus");
static_assert(offsetof(FCoverInstigatorStimulus, InstigatorCharacter) == 0x000000, "Member 'FCoverInstigatorStimulus::InstigatorCharacter' has a wrong offset!");
static_assert(offsetof(FCoverInstigatorStimulus, ThreatTransform) == 0x000010, "Member 'FCoverInstigatorStimulus::ThreatTransform' has a wrong offset!");

// ScriptStruct ReadyOrNot.SequencedVOLookup
// 0x0010 (0x0010 - 0x0000)
struct FSequencedVOLookup final 
{
public:
	TArray<int32>                                 LookupOrder;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSequencedVOLookup) == 0x000008, "Wrong alignment on FSequencedVOLookup");
static_assert(sizeof(FSequencedVOLookup) == 0x000010, "Wrong size on FSequencedVOLookup");
static_assert(offsetof(FSequencedVOLookup, LookupOrder) == 0x000000, "Member 'FSequencedVOLookup::LookupOrder' has a wrong offset!");

// ScriptStruct ReadyOrNot.KillFeedData
// 0x0018 (0x0018 - 0x0000)
struct FKillFeedData final 
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKillfeedType                                 Type;                                              // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F20[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKillFeedData) == 0x000008, "Wrong alignment on FKillFeedData");
static_assert(sizeof(FKillFeedData) == 0x000018, "Wrong size on FKillFeedData");
static_assert(offsetof(FKillFeedData, Name) == 0x000000, "Member 'FKillFeedData::Name' has a wrong offset!");
static_assert(offsetof(FKillFeedData, Type) == 0x000010, "Member 'FKillFeedData::Type' has a wrong offset!");

// ScriptStruct ReadyOrNot.InputEntry
// 0x0070 (0x0070 - 0x0000)
struct FInputEntry final 
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 Bind;                                              // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   DefaultKeyBind1;                                   // 0x0028(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   DefaultKeyBind2;                                   // 0x0040(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapType                                      MappingType;                                       // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F21[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AxisScale;                                         // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayOnScreen;                                  // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F22[0x7];                                     // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseItem>                  ShowWithEquippedItem;                              // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputEntry) == 0x000008, "Wrong alignment on FInputEntry");
static_assert(sizeof(FInputEntry) == 0x000070, "Wrong size on FInputEntry");
static_assert(offsetof(FInputEntry, DisplayName) == 0x000000, "Member 'FInputEntry::DisplayName' has a wrong offset!");
static_assert(offsetof(FInputEntry, Bind) == 0x000018, "Member 'FInputEntry::Bind' has a wrong offset!");
static_assert(offsetof(FInputEntry, DefaultKeyBind1) == 0x000028, "Member 'FInputEntry::DefaultKeyBind1' has a wrong offset!");
static_assert(offsetof(FInputEntry, DefaultKeyBind2) == 0x000040, "Member 'FInputEntry::DefaultKeyBind2' has a wrong offset!");
static_assert(offsetof(FInputEntry, MappingType) == 0x000058, "Member 'FInputEntry::MappingType' has a wrong offset!");
static_assert(offsetof(FInputEntry, AxisScale) == 0x00005C, "Member 'FInputEntry::AxisScale' has a wrong offset!");
static_assert(offsetof(FInputEntry, bDisplayOnScreen) == 0x000060, "Member 'FInputEntry::bDisplayOnScreen' has a wrong offset!");
static_assert(offsetof(FInputEntry, ShowWithEquippedItem) == 0x000068, "Member 'FInputEntry::ShowWithEquippedItem' has a wrong offset!");

// ScriptStruct ReadyOrNot.ExposedToNoise
// 0x0030 (0x0030 - 0x0000)
struct FExposedToNoise final 
{
public:
	class AReadyOrNotCharacter*                   Instigator;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeardAtDistance;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StimulusLocation;                                  // 0x0014(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAggressive;                                       // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFriendly;                                         // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F23[0x2];                                     // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceExposed;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpiryTime;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F24[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExposedToNoise) == 0x000008, "Wrong alignment on FExposedToNoise");
static_assert(sizeof(FExposedToNoise) == 0x000030, "Wrong size on FExposedToNoise");
static_assert(offsetof(FExposedToNoise, Instigator) == 0x000000, "Member 'FExposedToNoise::Instigator' has a wrong offset!");
static_assert(offsetof(FExposedToNoise, Tag) == 0x000008, "Member 'FExposedToNoise::Tag' has a wrong offset!");
static_assert(offsetof(FExposedToNoise, HeardAtDistance) == 0x000010, "Member 'FExposedToNoise::HeardAtDistance' has a wrong offset!");
static_assert(offsetof(FExposedToNoise, StimulusLocation) == 0x000014, "Member 'FExposedToNoise::StimulusLocation' has a wrong offset!");
static_assert(offsetof(FExposedToNoise, bAggressive) == 0x000020, "Member 'FExposedToNoise::bAggressive' has a wrong offset!");
static_assert(offsetof(FExposedToNoise, bFriendly) == 0x000021, "Member 'FExposedToNoise::bFriendly' has a wrong offset!");
static_assert(offsetof(FExposedToNoise, TimeSinceExposed) == 0x000024, "Member 'FExposedToNoise::TimeSinceExposed' has a wrong offset!");
static_assert(offsetof(FExposedToNoise, ExpiryTime) == 0x000028, "Member 'FExposedToNoise::ExpiryTime' has a wrong offset!");

// ScriptStruct ReadyOrNot.DebugData
// 0x0030 (0x0030 - 0x0000)
struct FDebugData final 
{
public:
	class FText                                   Label;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Value;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugData) == 0x000008, "Wrong alignment on FDebugData");
static_assert(sizeof(FDebugData) == 0x000030, "Wrong size on FDebugData");
static_assert(offsetof(FDebugData, Label) == 0x000000, "Member 'FDebugData::Label' has a wrong offset!");
static_assert(offsetof(FDebugData, Value) == 0x000018, "Member 'FDebugData::Value' has a wrong offset!");

// ScriptStruct ReadyOrNot.Transcript
// 0x0038 (0x0038 - 0x0000)
struct FTranscript final 
{
public:
	float                                         AudioTimestamp;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SpeakerName;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Transcription;                                     // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTranscript) == 0x000008, "Wrong alignment on FTranscript");
static_assert(sizeof(FTranscript) == 0x000038, "Wrong size on FTranscript");
static_assert(offsetof(FTranscript, AudioTimestamp) == 0x000000, "Member 'FTranscript::AudioTimestamp' has a wrong offset!");
static_assert(offsetof(FTranscript, Duration) == 0x000004, "Member 'FTranscript::Duration' has a wrong offset!");
static_assert(offsetof(FTranscript, SpeakerName) == 0x000008, "Member 'FTranscript::SpeakerName' has a wrong offset!");
static_assert(offsetof(FTranscript, Transcription) == 0x000020, "Member 'FTranscript::Transcription' has a wrong offset!");

// ScriptStruct ReadyOrNot.AttachedMeshData
// 0x0018 (0x0018 - 0x0000)
struct FAttachedMeshData final 
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttachedMeshData) == 0x000008, "Wrong alignment on FAttachedMeshData");
static_assert(sizeof(FAttachedMeshData) == 0x000018, "Wrong size on FAttachedMeshData");
static_assert(offsetof(FAttachedMeshData, StaticMesh) == 0x000000, "Member 'FAttachedMeshData::StaticMesh' has a wrong offset!");
static_assert(offsetof(FAttachedMeshData, Socket) == 0x000008, "Member 'FAttachedMeshData::Socket' has a wrong offset!");
static_assert(offsetof(FAttachedMeshData, StaticMeshComponent) == 0x000010, "Member 'FAttachedMeshData::StaticMeshComponent' has a wrong offset!");

// ScriptStruct ReadyOrNot.AttachedSkeletalMeshData
// 0x0020 (0x0020 - 0x0000)
struct FAttachedSkeletalMeshData final 
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMasterPose;                                    // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F25[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Socket;                                            // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F26[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttachedSkeletalMeshData) == 0x000008, "Wrong alignment on FAttachedSkeletalMeshData");
static_assert(sizeof(FAttachedSkeletalMeshData) == 0x000020, "Wrong size on FAttachedSkeletalMeshData");
static_assert(offsetof(FAttachedSkeletalMeshData, SkeletalMesh) == 0x000000, "Member 'FAttachedSkeletalMeshData::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FAttachedSkeletalMeshData, bUseMasterPose) == 0x000008, "Member 'FAttachedSkeletalMeshData::bUseMasterPose' has a wrong offset!");
static_assert(offsetof(FAttachedSkeletalMeshData, Socket) == 0x00000C, "Member 'FAttachedSkeletalMeshData::Socket' has a wrong offset!");
static_assert(offsetof(FAttachedSkeletalMeshData, SkeletalMeshComponent) == 0x000018, "Member 'FAttachedSkeletalMeshData::SkeletalMeshComponent' has a wrong offset!");

// ScriptStruct ReadyOrNot.CharacterMesh
// 0x0088 (0x0088 - 0x0000)
struct FCharacterMesh final 
{
public:
	struct FGuid                                  Guid;                                              // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          Body;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          Head;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseAsset*                             FaceROM;                                           // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFemale;                                         // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsChild;                                          // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F27[0x6];                                     // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CharacterSpeechHandle;                             // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             Footsteps;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MovementFoley;                                     // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MovementFoleySocket;                               // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAttachedMeshData>              AttachedMeshData;                                  // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FAttachedSkeletalMeshData>      AttachedSkeletalMeshData;                          // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class FName>                           DamageExcludedBones;                               // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterMesh) == 0x000008, "Wrong alignment on FCharacterMesh");
static_assert(sizeof(FCharacterMesh) == 0x000088, "Wrong size on FCharacterMesh");
static_assert(offsetof(FCharacterMesh, Guid) == 0x000000, "Member 'FCharacterMesh::Guid' has a wrong offset!");
static_assert(offsetof(FCharacterMesh, Body) == 0x000010, "Member 'FCharacterMesh::Body' has a wrong offset!");
static_assert(offsetof(FCharacterMesh, Head) == 0x000018, "Member 'FCharacterMesh::Head' has a wrong offset!");
static_assert(offsetof(FCharacterMesh, FaceROM) == 0x000020, "Member 'FCharacterMesh::FaceROM' has a wrong offset!");
static_assert(offsetof(FCharacterMesh, bIsFemale) == 0x000028, "Member 'FCharacterMesh::bIsFemale' has a wrong offset!");
static_assert(offsetof(FCharacterMesh, bIsChild) == 0x000029, "Member 'FCharacterMesh::bIsChild' has a wrong offset!");
static_assert(offsetof(FCharacterMesh, CharacterSpeechHandle) == 0x000030, "Member 'FCharacterMesh::CharacterSpeechHandle' has a wrong offset!");
static_assert(offsetof(FCharacterMesh, Footsteps) == 0x000040, "Member 'FCharacterMesh::Footsteps' has a wrong offset!");
static_assert(offsetof(FCharacterMesh, MovementFoley) == 0x000048, "Member 'FCharacterMesh::MovementFoley' has a wrong offset!");
static_assert(offsetof(FCharacterMesh, MovementFoleySocket) == 0x000050, "Member 'FCharacterMesh::MovementFoleySocket' has a wrong offset!");
static_assert(offsetof(FCharacterMesh, AttachedMeshData) == 0x000058, "Member 'FCharacterMesh::AttachedMeshData' has a wrong offset!");
static_assert(offsetof(FCharacterMesh, AttachedSkeletalMeshData) == 0x000068, "Member 'FCharacterMesh::AttachedSkeletalMeshData' has a wrong offset!");
static_assert(offsetof(FCharacterMesh, DamageExcludedBones) == 0x000078, "Member 'FCharacterMesh::DamageExcludedBones' has a wrong offset!");

// ScriptStruct ReadyOrNot.KeyBinding
// 0x0048 (0x0048 - 0x0000)
struct FKeyBinding final 
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Axis;                                              // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F28[0x2];                                     // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BindingName;                                       // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F29[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FriendlyName;                                      // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         AxisScale;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputKeyCategoryV2                           InputKeyCategory;                                  // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CannotBeUnbindable;                                // 0x0045(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReadOnly;                                        // 0x0046(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F2A[0x1];                                     // 0x0047(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKeyBinding) == 0x000008, "Wrong alignment on FKeyBinding");
static_assert(sizeof(FKeyBinding) == 0x000048, "Wrong size on FKeyBinding");
static_assert(offsetof(FKeyBinding, Enabled) == 0x000000, "Member 'FKeyBinding::Enabled' has a wrong offset!");
static_assert(offsetof(FKeyBinding, Axis) == 0x000001, "Member 'FKeyBinding::Axis' has a wrong offset!");
static_assert(offsetof(FKeyBinding, BindingName) == 0x000004, "Member 'FKeyBinding::BindingName' has a wrong offset!");
static_assert(offsetof(FKeyBinding, FriendlyName) == 0x000010, "Member 'FKeyBinding::FriendlyName' has a wrong offset!");
static_assert(offsetof(FKeyBinding, Description) == 0x000028, "Member 'FKeyBinding::Description' has a wrong offset!");
static_assert(offsetof(FKeyBinding, AxisScale) == 0x000040, "Member 'FKeyBinding::AxisScale' has a wrong offset!");
static_assert(offsetof(FKeyBinding, InputKeyCategory) == 0x000044, "Member 'FKeyBinding::InputKeyCategory' has a wrong offset!");
static_assert(offsetof(FKeyBinding, CannotBeUnbindable) == 0x000045, "Member 'FKeyBinding::CannotBeUnbindable' has a wrong offset!");
static_assert(offsetof(FKeyBinding, IsReadOnly) == 0x000046, "Member 'FKeyBinding::IsReadOnly' has a wrong offset!");

// ScriptStruct ReadyOrNot.RadialWidgetSpawnProperties
// 0x0060 (0x0060 - 0x0000)
struct FRadialWidgetSpawnProperties final 
{
public:
	int32                                         StartingSectorIndex;                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IconSize;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IconPadding;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingSectorAngle;                               // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SectorInnerRadius;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SectorOuterRadius;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GapSize;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WheelSize;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WheelCursorDistanceFromCenterWheel;                // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHideRadialWheelCursorOnMenuOpened : 1;            // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F2B[0x3];                                     // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           SelectedColor;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           UnselectedColor;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           UnselectableColor;                                 // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  Font;                                              // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRadialWidgetSpawnProperties) == 0x000008, "Wrong alignment on FRadialWidgetSpawnProperties");
static_assert(sizeof(FRadialWidgetSpawnProperties) == 0x000060, "Wrong size on FRadialWidgetSpawnProperties");
static_assert(offsetof(FRadialWidgetSpawnProperties, StartingSectorIndex) == 0x000000, "Member 'FRadialWidgetSpawnProperties::StartingSectorIndex' has a wrong offset!");
static_assert(offsetof(FRadialWidgetSpawnProperties, IconSize) == 0x000004, "Member 'FRadialWidgetSpawnProperties::IconSize' has a wrong offset!");
static_assert(offsetof(FRadialWidgetSpawnProperties, IconPadding) == 0x000008, "Member 'FRadialWidgetSpawnProperties::IconPadding' has a wrong offset!");
static_assert(offsetof(FRadialWidgetSpawnProperties, StartingSectorAngle) == 0x00000C, "Member 'FRadialWidgetSpawnProperties::StartingSectorAngle' has a wrong offset!");
static_assert(offsetof(FRadialWidgetSpawnProperties, SectorInnerRadius) == 0x000010, "Member 'FRadialWidgetSpawnProperties::SectorInnerRadius' has a wrong offset!");
static_assert(offsetof(FRadialWidgetSpawnProperties, SectorOuterRadius) == 0x000014, "Member 'FRadialWidgetSpawnProperties::SectorOuterRadius' has a wrong offset!");
static_assert(offsetof(FRadialWidgetSpawnProperties, GapSize) == 0x000018, "Member 'FRadialWidgetSpawnProperties::GapSize' has a wrong offset!");
static_assert(offsetof(FRadialWidgetSpawnProperties, WheelSize) == 0x00001C, "Member 'FRadialWidgetSpawnProperties::WheelSize' has a wrong offset!");
static_assert(offsetof(FRadialWidgetSpawnProperties, WheelCursorDistanceFromCenterWheel) == 0x000020, "Member 'FRadialWidgetSpawnProperties::WheelCursorDistanceFromCenterWheel' has a wrong offset!");
static_assert(offsetof(FRadialWidgetSpawnProperties, SelectedColor) == 0x000028, "Member 'FRadialWidgetSpawnProperties::SelectedColor' has a wrong offset!");
static_assert(offsetof(FRadialWidgetSpawnProperties, UnselectedColor) == 0x000038, "Member 'FRadialWidgetSpawnProperties::UnselectedColor' has a wrong offset!");
static_assert(offsetof(FRadialWidgetSpawnProperties, UnselectableColor) == 0x000048, "Member 'FRadialWidgetSpawnProperties::UnselectableColor' has a wrong offset!");
static_assert(offsetof(FRadialWidgetSpawnProperties, Font) == 0x000058, "Member 'FRadialWidgetSpawnProperties::Font' has a wrong offset!");

// ScriptStruct ReadyOrNot.GameModeSettings
// 0x0050 (0x0058 - 0x0008)
struct FGameModeSettings final  : public FTableRowBase
{
public:
	int32                                         MaxPlayers;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundStartTime;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReinforcementTimer;                                // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnTimer;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timelimit;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundsPerMap;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TDMScoreLimit;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F2C[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MatchStartInformationSwat;                         // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   MatchStartInformationMlo;                          // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameModeSettings) == 0x000008, "Wrong alignment on FGameModeSettings");
static_assert(sizeof(FGameModeSettings) == 0x000058, "Wrong size on FGameModeSettings");
static_assert(offsetof(FGameModeSettings, MaxPlayers) == 0x000008, "Member 'FGameModeSettings::MaxPlayers' has a wrong offset!");
static_assert(offsetof(FGameModeSettings, RoundStartTime) == 0x00000C, "Member 'FGameModeSettings::RoundStartTime' has a wrong offset!");
static_assert(offsetof(FGameModeSettings, ReinforcementTimer) == 0x000010, "Member 'FGameModeSettings::ReinforcementTimer' has a wrong offset!");
static_assert(offsetof(FGameModeSettings, RespawnTimer) == 0x000014, "Member 'FGameModeSettings::RespawnTimer' has a wrong offset!");
static_assert(offsetof(FGameModeSettings, Timelimit) == 0x000018, "Member 'FGameModeSettings::Timelimit' has a wrong offset!");
static_assert(offsetof(FGameModeSettings, RoundsPerMap) == 0x00001C, "Member 'FGameModeSettings::RoundsPerMap' has a wrong offset!");
static_assert(offsetof(FGameModeSettings, TDMScoreLimit) == 0x000020, "Member 'FGameModeSettings::TDMScoreLimit' has a wrong offset!");
static_assert(offsetof(FGameModeSettings, MatchStartInformationSwat) == 0x000028, "Member 'FGameModeSettings::MatchStartInformationSwat' has a wrong offset!");
static_assert(offsetof(FGameModeSettings, MatchStartInformationMlo) == 0x000040, "Member 'FGameModeSettings::MatchStartInformationMlo' has a wrong offset!");

// ScriptStruct ReadyOrNot.WorldBuildingAnimState
// 0x0010 (0x0010 - 0x0000)
struct FWorldBuildingAnimState final 
{
public:
	bool                                          bIsPlaying;                                        // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLooping;                                        // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F2D[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          LoopAnim;                                          // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWorldBuildingAnimState) == 0x000008, "Wrong alignment on FWorldBuildingAnimState");
static_assert(sizeof(FWorldBuildingAnimState) == 0x000010, "Wrong size on FWorldBuildingAnimState");
static_assert(offsetof(FWorldBuildingAnimState, bIsPlaying) == 0x000000, "Member 'FWorldBuildingAnimState::bIsPlaying' has a wrong offset!");
static_assert(offsetof(FWorldBuildingAnimState, bIsLooping) == 0x000001, "Member 'FWorldBuildingAnimState::bIsLooping' has a wrong offset!");
static_assert(offsetof(FWorldBuildingAnimState, LoopAnim) == 0x000008, "Member 'FWorldBuildingAnimState::LoopAnim' has a wrong offset!");

// ScriptStruct ReadyOrNot.AIMovementStyleData
// 0x0040 (0x0040 - 0x0000)
struct FAIMovementStyleData final 
{
public:
	class FName                                   UnarmedMoveStyle;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StunnedMoveStyle;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoweredTwoHandedMoveStyle;                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RaisedTwoHandedMoveStyle;                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HesitationMoveStyle;                               // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HesitationRifleMoveStyle;                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SurrenderedMoveStyle;                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ArrestedMoveStyle;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIMovementStyleData) == 0x000004, "Wrong alignment on FAIMovementStyleData");
static_assert(sizeof(FAIMovementStyleData) == 0x000040, "Wrong size on FAIMovementStyleData");
static_assert(offsetof(FAIMovementStyleData, UnarmedMoveStyle) == 0x000000, "Member 'FAIMovementStyleData::UnarmedMoveStyle' has a wrong offset!");
static_assert(offsetof(FAIMovementStyleData, StunnedMoveStyle) == 0x000008, "Member 'FAIMovementStyleData::StunnedMoveStyle' has a wrong offset!");
static_assert(offsetof(FAIMovementStyleData, LoweredTwoHandedMoveStyle) == 0x000010, "Member 'FAIMovementStyleData::LoweredTwoHandedMoveStyle' has a wrong offset!");
static_assert(offsetof(FAIMovementStyleData, RaisedTwoHandedMoveStyle) == 0x000018, "Member 'FAIMovementStyleData::RaisedTwoHandedMoveStyle' has a wrong offset!");
static_assert(offsetof(FAIMovementStyleData, HesitationMoveStyle) == 0x000020, "Member 'FAIMovementStyleData::HesitationMoveStyle' has a wrong offset!");
static_assert(offsetof(FAIMovementStyleData, HesitationRifleMoveStyle) == 0x000028, "Member 'FAIMovementStyleData::HesitationRifleMoveStyle' has a wrong offset!");
static_assert(offsetof(FAIMovementStyleData, SurrenderedMoveStyle) == 0x000030, "Member 'FAIMovementStyleData::SurrenderedMoveStyle' has a wrong offset!");
static_assert(offsetof(FAIMovementStyleData, ArrestedMoveStyle) == 0x000038, "Member 'FAIMovementStyleData::ArrestedMoveStyle' has a wrong offset!");

// ScriptStruct ReadyOrNot.ActivityRouteCollection
// 0x0020 (0x0020 - 0x0000)
struct FActivityRouteCollection final 
{
public:
	TArray<struct FActivityRoute>                 ActivityRoutes;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bReturnToOriginalSpot;                             // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnAtFirstRoute;                                // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F2E[0x2];                                     // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cooldown;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ActivityIdx;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F2F[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActivityRouteCollection) == 0x000008, "Wrong alignment on FActivityRouteCollection");
static_assert(sizeof(FActivityRouteCollection) == 0x000020, "Wrong size on FActivityRouteCollection");
static_assert(offsetof(FActivityRouteCollection, ActivityRoutes) == 0x000000, "Member 'FActivityRouteCollection::ActivityRoutes' has a wrong offset!");
static_assert(offsetof(FActivityRouteCollection, bReturnToOriginalSpot) == 0x000010, "Member 'FActivityRouteCollection::bReturnToOriginalSpot' has a wrong offset!");
static_assert(offsetof(FActivityRouteCollection, bSpawnAtFirstRoute) == 0x000011, "Member 'FActivityRouteCollection::bSpawnAtFirstRoute' has a wrong offset!");
static_assert(offsetof(FActivityRouteCollection, Cooldown) == 0x000014, "Member 'FActivityRouteCollection::Cooldown' has a wrong offset!");
static_assert(offsetof(FActivityRouteCollection, ActivityIdx) == 0x000018, "Member 'FActivityRouteCollection::ActivityIdx' has a wrong offset!");

// ScriptStruct ReadyOrNot.HidingAnimStateMachineData
// 0x0010 (0x0010 - 0x0000)
struct FHidingAnimStateMachineData final 
{
public:
	uint8                                         bIsHiding : 1;                                     // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLooping : 1;                                      // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F30[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          LoopAnim;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHidingAnimStateMachineData) == 0x000008, "Wrong alignment on FHidingAnimStateMachineData");
static_assert(sizeof(FHidingAnimStateMachineData) == 0x000010, "Wrong size on FHidingAnimStateMachineData");
static_assert(offsetof(FHidingAnimStateMachineData, LoopAnim) == 0x000008, "Member 'FHidingAnimStateMachineData::LoopAnim' has a wrong offset!");

// ScriptStruct ReadyOrNot.InterestStationPoint
// 0x0060 (0x0060 - 0x0000)
struct FInterestStationPoint final 
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequiredTimeStationing;                            // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class ACyberneticCharacter*, float>      TimeStationing;                                    // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterestStationPoint) == 0x000008, "Wrong alignment on FInterestStationPoint");
static_assert(sizeof(FInterestStationPoint) == 0x000060, "Wrong size on FInterestStationPoint");
static_assert(offsetof(FInterestStationPoint, Location) == 0x000000, "Member 'FInterestStationPoint::Location' has a wrong offset!");
static_assert(offsetof(FInterestStationPoint, RequiredTimeStationing) == 0x00000C, "Member 'FInterestStationPoint::RequiredTimeStationing' has a wrong offset!");
static_assert(offsetof(FInterestStationPoint, TimeStationing) == 0x000010, "Member 'FInterestStationPoint::TimeStationing' has a wrong offset!");

// ScriptStruct ReadyOrNot.CoverAnimStateMachineData
// 0x0018 (0x0018 - 0x0000)
struct FCoverAnimStateMachineData final 
{
public:
	bool                                          bIsInCover;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFiring;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReturningToIdle;                                // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverDirection                               ActiveCoverDirection;                              // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F31[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ActiveCoverFirePose;                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ActiveCoverIdlePose;                               // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverAnimStateMachineData) == 0x000008, "Wrong alignment on FCoverAnimStateMachineData");
static_assert(sizeof(FCoverAnimStateMachineData) == 0x000018, "Wrong size on FCoverAnimStateMachineData");
static_assert(offsetof(FCoverAnimStateMachineData, bIsInCover) == 0x000000, "Member 'FCoverAnimStateMachineData::bIsInCover' has a wrong offset!");
static_assert(offsetof(FCoverAnimStateMachineData, bIsFiring) == 0x000001, "Member 'FCoverAnimStateMachineData::bIsFiring' has a wrong offset!");
static_assert(offsetof(FCoverAnimStateMachineData, bIsReturningToIdle) == 0x000002, "Member 'FCoverAnimStateMachineData::bIsReturningToIdle' has a wrong offset!");
static_assert(offsetof(FCoverAnimStateMachineData, ActiveCoverDirection) == 0x000003, "Member 'FCoverAnimStateMachineData::ActiveCoverDirection' has a wrong offset!");
static_assert(offsetof(FCoverAnimStateMachineData, ActiveCoverFirePose) == 0x000008, "Member 'FCoverAnimStateMachineData::ActiveCoverFirePose' has a wrong offset!");
static_assert(offsetof(FCoverAnimStateMachineData, ActiveCoverIdlePose) == 0x000010, "Member 'FCoverAnimStateMachineData::ActiveCoverIdlePose' has a wrong offset!");

// ScriptStruct ReadyOrNot.AnimatedIcon
// 0x0018 (0x0018 - 0x0000)
struct FAnimatedIcon final 
{
public:
	TArray<class UTexture2D*>                     Icons;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FrameRate;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F32[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimatedIcon) == 0x000008, "Wrong alignment on FAnimatedIcon");
static_assert(sizeof(FAnimatedIcon) == 0x000018, "Wrong size on FAnimatedIcon");
static_assert(offsetof(FAnimatedIcon, Icons) == 0x000000, "Member 'FAnimatedIcon::Icons' has a wrong offset!");
static_assert(offsetof(FAnimatedIcon, FrameRate) == 0x000010, "Member 'FAnimatedIcon::FrameRate' has a wrong offset!");

// ScriptStruct ReadyOrNot.AnimatedIconTable
// 0x0018 (0x0020 - 0x0008)
struct FAnimatedIconTable final  : public FTableRowBase
{
public:
	struct FAnimatedIcon                          AnimatedIcon;                                      // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimatedIconTable) == 0x000008, "Wrong alignment on FAnimatedIconTable");
static_assert(sizeof(FAnimatedIconTable) == 0x000020, "Wrong size on FAnimatedIconTable");
static_assert(offsetof(FAnimatedIconTable, AnimatedIcon) == 0x000008, "Member 'FAnimatedIconTable::AnimatedIcon' has a wrong offset!");

// ScriptStruct ReadyOrNot.RoNStyleIdleData
// 0x0010 (0x0010 - 0x0000)
struct FRoNStyleIdleData final 
{
public:
	TArray<class UAnimSequence*>                  BaseIdleData;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoNStyleIdleData) == 0x000008, "Wrong alignment on FRoNStyleIdleData");
static_assert(sizeof(FRoNStyleIdleData) == 0x000010, "Wrong size on FRoNStyleIdleData");
static_assert(offsetof(FRoNStyleIdleData, BaseIdleData) == 0x000000, "Member 'FRoNStyleIdleData::BaseIdleData' has a wrong offset!");

// ScriptStruct ReadyOrNot.RoNStyleTurnData
// 0x0048 (0x0048 - 0x0000)
struct FRoNStyleTurnData final 
{
public:
	class UAimOffsetBlendSpace*                   AimOffset;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Turn45_Left;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Turn45_Right;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Turn90_Left;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Turn90_Right;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Turn180_Left;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Turn180_Right;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Turn135_Left;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Turn135_Right;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoNStyleTurnData) == 0x000008, "Wrong alignment on FRoNStyleTurnData");
static_assert(sizeof(FRoNStyleTurnData) == 0x000048, "Wrong size on FRoNStyleTurnData");
static_assert(offsetof(FRoNStyleTurnData, AimOffset) == 0x000000, "Member 'FRoNStyleTurnData::AimOffset' has a wrong offset!");
static_assert(offsetof(FRoNStyleTurnData, Turn45_Left) == 0x000008, "Member 'FRoNStyleTurnData::Turn45_Left' has a wrong offset!");
static_assert(offsetof(FRoNStyleTurnData, Turn45_Right) == 0x000010, "Member 'FRoNStyleTurnData::Turn45_Right' has a wrong offset!");
static_assert(offsetof(FRoNStyleTurnData, Turn90_Left) == 0x000018, "Member 'FRoNStyleTurnData::Turn90_Left' has a wrong offset!");
static_assert(offsetof(FRoNStyleTurnData, Turn90_Right) == 0x000020, "Member 'FRoNStyleTurnData::Turn90_Right' has a wrong offset!");
static_assert(offsetof(FRoNStyleTurnData, Turn180_Left) == 0x000028, "Member 'FRoNStyleTurnData::Turn180_Left' has a wrong offset!");
static_assert(offsetof(FRoNStyleTurnData, Turn180_Right) == 0x000030, "Member 'FRoNStyleTurnData::Turn180_Right' has a wrong offset!");
static_assert(offsetof(FRoNStyleTurnData, Turn135_Left) == 0x000038, "Member 'FRoNStyleTurnData::Turn135_Left' has a wrong offset!");
static_assert(offsetof(FRoNStyleTurnData, Turn135_Right) == 0x000040, "Member 'FRoNStyleTurnData::Turn135_Right' has a wrong offset!");

// ScriptStruct ReadyOrNot.RoNGaitTransitionData
// 0x0120 (0x0120 - 0x0000)
struct FRoNGaitTransitionData final 
{
public:
	class FString                                 Start_Section;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Start;                                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Start_45_Left;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Start_45_Right;                                    // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Start_90_Left;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Start_90_Right;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Start_180;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Start_180_Left;                                    // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Start_180_Right;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Start_135_Left;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Start_135_Right;                                   // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Stop_Section;                                      // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop;                                              // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_45_Left;                                      // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_45_Right;                                     // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_90_Left;                                      // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_90_Right;                                     // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_180;                                          // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_180_Left;                                     // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_180_Right;                                    // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_135_Left;                                     // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Stop_135_Right;                                    // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Pivot_Section;                                     // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Pivot;                                             // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Pivot_45_Left;                                     // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Pivot_45_Right;                                    // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Pivot_90_Left;                                     // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Pivot_90_Right;                                    // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Pivot_180;                                         // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Pivot_180_Left;                                    // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Pivot_180_Right;                                   // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Pivot_135_Left;                                    // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Pivot_135_Right;                                   // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoNGaitTransitionData) == 0x000008, "Wrong alignment on FRoNGaitTransitionData");
static_assert(sizeof(FRoNGaitTransitionData) == 0x000120, "Wrong size on FRoNGaitTransitionData");
static_assert(offsetof(FRoNGaitTransitionData, Start_Section) == 0x000000, "Member 'FRoNGaitTransitionData::Start_Section' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Start) == 0x000010, "Member 'FRoNGaitTransitionData::Start' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Start_45_Left) == 0x000018, "Member 'FRoNGaitTransitionData::Start_45_Left' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Start_45_Right) == 0x000020, "Member 'FRoNGaitTransitionData::Start_45_Right' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Start_90_Left) == 0x000028, "Member 'FRoNGaitTransitionData::Start_90_Left' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Start_90_Right) == 0x000030, "Member 'FRoNGaitTransitionData::Start_90_Right' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Start_180) == 0x000038, "Member 'FRoNGaitTransitionData::Start_180' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Start_180_Left) == 0x000040, "Member 'FRoNGaitTransitionData::Start_180_Left' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Start_180_Right) == 0x000048, "Member 'FRoNGaitTransitionData::Start_180_Right' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Start_135_Left) == 0x000050, "Member 'FRoNGaitTransitionData::Start_135_Left' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Start_135_Right) == 0x000058, "Member 'FRoNGaitTransitionData::Start_135_Right' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Stop_Section) == 0x000060, "Member 'FRoNGaitTransitionData::Stop_Section' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Stop) == 0x000070, "Member 'FRoNGaitTransitionData::Stop' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Stop_45_Left) == 0x000078, "Member 'FRoNGaitTransitionData::Stop_45_Left' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Stop_45_Right) == 0x000080, "Member 'FRoNGaitTransitionData::Stop_45_Right' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Stop_90_Left) == 0x000088, "Member 'FRoNGaitTransitionData::Stop_90_Left' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Stop_90_Right) == 0x000090, "Member 'FRoNGaitTransitionData::Stop_90_Right' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Stop_180) == 0x000098, "Member 'FRoNGaitTransitionData::Stop_180' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Stop_180_Left) == 0x0000A0, "Member 'FRoNGaitTransitionData::Stop_180_Left' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Stop_180_Right) == 0x0000A8, "Member 'FRoNGaitTransitionData::Stop_180_Right' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Stop_135_Left) == 0x0000B0, "Member 'FRoNGaitTransitionData::Stop_135_Left' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Stop_135_Right) == 0x0000B8, "Member 'FRoNGaitTransitionData::Stop_135_Right' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Pivot_Section) == 0x0000C0, "Member 'FRoNGaitTransitionData::Pivot_Section' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Pivot) == 0x0000D0, "Member 'FRoNGaitTransitionData::Pivot' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Pivot_45_Left) == 0x0000D8, "Member 'FRoNGaitTransitionData::Pivot_45_Left' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Pivot_45_Right) == 0x0000E0, "Member 'FRoNGaitTransitionData::Pivot_45_Right' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Pivot_90_Left) == 0x0000E8, "Member 'FRoNGaitTransitionData::Pivot_90_Left' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Pivot_90_Right) == 0x0000F0, "Member 'FRoNGaitTransitionData::Pivot_90_Right' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Pivot_180) == 0x0000F8, "Member 'FRoNGaitTransitionData::Pivot_180' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Pivot_180_Left) == 0x000100, "Member 'FRoNGaitTransitionData::Pivot_180_Left' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Pivot_180_Right) == 0x000108, "Member 'FRoNGaitTransitionData::Pivot_180_Right' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Pivot_135_Left) == 0x000110, "Member 'FRoNGaitTransitionData::Pivot_135_Left' has a wrong offset!");
static_assert(offsetof(FRoNGaitTransitionData, Pivot_135_Right) == 0x000118, "Member 'FRoNGaitTransitionData::Pivot_135_Right' has a wrong offset!");

// ScriptStruct ReadyOrNot.RoNLeanMotion
// 0x0018 (0x0018 - 0x0000)
struct FRoNLeanMotion final 
{
public:
	class UAnimSequence*                          Base;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BaseLeanLeft;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BaseLeanRight;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoNLeanMotion) == 0x000008, "Wrong alignment on FRoNLeanMotion");
static_assert(sizeof(FRoNLeanMotion) == 0x000018, "Wrong size on FRoNLeanMotion");
static_assert(offsetof(FRoNLeanMotion, Base) == 0x000000, "Member 'FRoNLeanMotion::Base' has a wrong offset!");
static_assert(offsetof(FRoNLeanMotion, BaseLeanLeft) == 0x000008, "Member 'FRoNLeanMotion::BaseLeanLeft' has a wrong offset!");
static_assert(offsetof(FRoNLeanMotion, BaseLeanRight) == 0x000010, "Member 'FRoNLeanMotion::BaseLeanRight' has a wrong offset!");

// ScriptStruct ReadyOrNot.RoNGaitLocomotionData
// 0x00C0 (0x00C0 - 0x0000)
struct FRoNGaitLocomotionData final 
{
public:
	struct FRoNLeanMotion                         Fwd;                                               // 0x0000(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRoNLeanMotion                         FwdLeft;                                           // 0x0018(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRoNLeanMotion                         FwdRight;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRoNLeanMotion                         Left;                                              // 0x0048(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRoNLeanMotion                         Right;                                             // 0x0060(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRoNLeanMotion                         Bwd;                                               // 0x0078(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRoNLeanMotion                         BwdLeft;                                           // 0x0090(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRoNLeanMotion                         BwdRight;                                          // 0x00A8(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoNGaitLocomotionData) == 0x000008, "Wrong alignment on FRoNGaitLocomotionData");
static_assert(sizeof(FRoNGaitLocomotionData) == 0x0000C0, "Wrong size on FRoNGaitLocomotionData");
static_assert(offsetof(FRoNGaitLocomotionData, Fwd) == 0x000000, "Member 'FRoNGaitLocomotionData::Fwd' has a wrong offset!");
static_assert(offsetof(FRoNGaitLocomotionData, FwdLeft) == 0x000018, "Member 'FRoNGaitLocomotionData::FwdLeft' has a wrong offset!");
static_assert(offsetof(FRoNGaitLocomotionData, FwdRight) == 0x000030, "Member 'FRoNGaitLocomotionData::FwdRight' has a wrong offset!");
static_assert(offsetof(FRoNGaitLocomotionData, Left) == 0x000048, "Member 'FRoNGaitLocomotionData::Left' has a wrong offset!");
static_assert(offsetof(FRoNGaitLocomotionData, Right) == 0x000060, "Member 'FRoNGaitLocomotionData::Right' has a wrong offset!");
static_assert(offsetof(FRoNGaitLocomotionData, Bwd) == 0x000078, "Member 'FRoNGaitLocomotionData::Bwd' has a wrong offset!");
static_assert(offsetof(FRoNGaitLocomotionData, BwdLeft) == 0x000090, "Member 'FRoNGaitLocomotionData::BwdLeft' has a wrong offset!");
static_assert(offsetof(FRoNGaitLocomotionData, BwdRight) == 0x0000A8, "Member 'FRoNGaitLocomotionData::BwdRight' has a wrong offset!");

// ScriptStruct ReadyOrNot.RoNGaitType
// 0x01F0 (0x01F0 - 0x0000)
struct FRoNGaitType final 
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRoNGaitTransitionData                 TransitionData;                                    // 0x0010(0x0120)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRoNGaitLocomotionData                 LocomotionData;                                    // 0x0130(0x00C0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoNGaitType) == 0x000008, "Wrong alignment on FRoNGaitType");
static_assert(sizeof(FRoNGaitType) == 0x0001F0, "Wrong size on FRoNGaitType");
static_assert(offsetof(FRoNGaitType, Name) == 0x000000, "Member 'FRoNGaitType::Name' has a wrong offset!");
static_assert(offsetof(FRoNGaitType, Speed) == 0x000008, "Member 'FRoNGaitType::Speed' has a wrong offset!");
static_assert(offsetof(FRoNGaitType, Acceleration) == 0x00000C, "Member 'FRoNGaitType::Acceleration' has a wrong offset!");
static_assert(offsetof(FRoNGaitType, TransitionData) == 0x000010, "Member 'FRoNGaitType::TransitionData' has a wrong offset!");
static_assert(offsetof(FRoNGaitType, LocomotionData) == 0x000130, "Member 'FRoNGaitType::LocomotionData' has a wrong offset!");

// ScriptStruct ReadyOrNot.RoNMovementStyle
// 0x0088 (0x0088 - 0x0000)
struct FRoNMovementStyle final 
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStrafeMovement;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoweredSet;                                     // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemOverrideRule                             ItemOverrideRule;                                  // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F33[0x5];                                     // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRoNStyleIdleData                      IdleData;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRoNStyleTurnData                      TurnData;                                          // 0x0020(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FRoNGaitType>                   GaitEntries;                                       // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StrafeBS;                                          // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            NonStrafeBS;                                       // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoNMovementStyle) == 0x000008, "Wrong alignment on FRoNMovementStyle");
static_assert(sizeof(FRoNMovementStyle) == 0x000088, "Wrong size on FRoNMovementStyle");
static_assert(offsetof(FRoNMovementStyle, Name) == 0x000000, "Member 'FRoNMovementStyle::Name' has a wrong offset!");
static_assert(offsetof(FRoNMovementStyle, bIsStrafeMovement) == 0x000008, "Member 'FRoNMovementStyle::bIsStrafeMovement' has a wrong offset!");
static_assert(offsetof(FRoNMovementStyle, bIsLoweredSet) == 0x000009, "Member 'FRoNMovementStyle::bIsLoweredSet' has a wrong offset!");
static_assert(offsetof(FRoNMovementStyle, ItemOverrideRule) == 0x00000A, "Member 'FRoNMovementStyle::ItemOverrideRule' has a wrong offset!");
static_assert(offsetof(FRoNMovementStyle, IdleData) == 0x000010, "Member 'FRoNMovementStyle::IdleData' has a wrong offset!");
static_assert(offsetof(FRoNMovementStyle, TurnData) == 0x000020, "Member 'FRoNMovementStyle::TurnData' has a wrong offset!");
static_assert(offsetof(FRoNMovementStyle, GaitEntries) == 0x000068, "Member 'FRoNMovementStyle::GaitEntries' has a wrong offset!");
static_assert(offsetof(FRoNMovementStyle, StrafeBS) == 0x000078, "Member 'FRoNMovementStyle::StrafeBS' has a wrong offset!");
static_assert(offsetof(FRoNMovementStyle, NonStrafeBS) == 0x000080, "Member 'FRoNMovementStyle::NonStrafeBS' has a wrong offset!");

// ScriptStruct ReadyOrNot.DeploymentStatus
// 0x0028 (0x0028 - 0x0000)
struct FDeploymentStatus final 
{
public:
	class FText                                   Position;                                          // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EPlayerStatus                                 Status;                                            // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F34[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotPlayerState*                 PlayerState;                                       // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeploymentStatus) == 0x000008, "Wrong alignment on FDeploymentStatus");
static_assert(sizeof(FDeploymentStatus) == 0x000028, "Wrong size on FDeploymentStatus");
static_assert(offsetof(FDeploymentStatus, Position) == 0x000000, "Member 'FDeploymentStatus::Position' has a wrong offset!");
static_assert(offsetof(FDeploymentStatus, Status) == 0x000018, "Member 'FDeploymentStatus::Status' has a wrong offset!");
static_assert(offsetof(FDeploymentStatus, PlayerState) == 0x000020, "Member 'FDeploymentStatus::PlayerState' has a wrong offset!");

// ScriptStruct ReadyOrNot.LookAtPoint
// 0x0018 (0x0018 - 0x0000)
struct FLookAtPoint final 
{
public:
	struct FIntVector                             Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F35[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  LinkedDoor;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLookAtPoint) == 0x000008, "Wrong alignment on FLookAtPoint");
static_assert(sizeof(FLookAtPoint) == 0x000018, "Wrong size on FLookAtPoint");
static_assert(offsetof(FLookAtPoint, Location) == 0x000000, "Member 'FLookAtPoint::Location' has a wrong offset!");
static_assert(offsetof(FLookAtPoint, LinkedDoor) == 0x000010, "Member 'FLookAtPoint::LinkedDoor' has a wrong offset!");

// ScriptStruct ReadyOrNot.MapData
// 0x0018 (0x0018 - 0x0000)
struct FMapData final 
{
public:
	TArray<struct FVector2D>                      PointData;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EFreeDrawColor                                ColorType;                                         // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F36[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapData) == 0x000008, "Wrong alignment on FMapData");
static_assert(sizeof(FMapData) == 0x000018, "Wrong size on FMapData");
static_assert(offsetof(FMapData, PointData) == 0x000000, "Member 'FMapData::PointData' has a wrong offset!");
static_assert(offsetof(FMapData, ColorType) == 0x000010, "Member 'FMapData::ColorType' has a wrong offset!");
static_assert(offsetof(FMapData, Thickness) == 0x000014, "Member 'FMapData::Thickness' has a wrong offset!");

// ScriptStruct ReadyOrNot.FloorMapPointData
// 0x0010 (0x0010 - 0x0000)
struct FFloorMapPointData final 
{
public:
	TArray<struct FMapData>                       MapData;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloorMapPointData) == 0x000008, "Wrong alignment on FFloorMapPointData");
static_assert(sizeof(FFloorMapPointData) == 0x000010, "Wrong size on FFloorMapPointData");
static_assert(offsetof(FFloorMapPointData, MapData) == 0x000000, "Member 'FFloorMapPointData::MapData' has a wrong offset!");

// ScriptStruct ReadyOrNot.PersonnelEntry
// 0x0048 (0x0048 - 0x0000)
struct FPersonnelEntry final 
{
public:
	EPersonnel                                    PersonnelType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F37[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AvailableMapPoints;                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PtsCost;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F38[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              PersonnelTexture;                                  // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPersonnelEntry) == 0x000008, "Wrong alignment on FPersonnelEntry");
static_assert(sizeof(FPersonnelEntry) == 0x000048, "Wrong size on FPersonnelEntry");
static_assert(offsetof(FPersonnelEntry, PersonnelType) == 0x000000, "Member 'FPersonnelEntry::PersonnelType' has a wrong offset!");
static_assert(offsetof(FPersonnelEntry, AvailableMapPoints) == 0x000008, "Member 'FPersonnelEntry::AvailableMapPoints' has a wrong offset!");
static_assert(offsetof(FPersonnelEntry, PtsCost) == 0x000018, "Member 'FPersonnelEntry::PtsCost' has a wrong offset!");
static_assert(offsetof(FPersonnelEntry, PersonnelTexture) == 0x000020, "Member 'FPersonnelEntry::PersonnelTexture' has a wrong offset!");

// ScriptStruct ReadyOrNot.VoteData
// 0x0030 (0x0030 - 0x0000)
struct FVoteData final 
{
public:
	EVoteState                                    CurrentVoteState;                                  // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F39[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VoteReason;                                        // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VoteQuestion;                                      // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bVoteEnabled : 1;                                  // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanVoteNo : 1;                                    // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F3A[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVoteData) == 0x000008, "Wrong alignment on FVoteData");
static_assert(sizeof(FVoteData) == 0x000030, "Wrong size on FVoteData");
static_assert(offsetof(FVoteData, CurrentVoteState) == 0x000000, "Member 'FVoteData::CurrentVoteState' has a wrong offset!");
static_assert(offsetof(FVoteData, VoteReason) == 0x000008, "Member 'FVoteData::VoteReason' has a wrong offset!");
static_assert(offsetof(FVoteData, VoteQuestion) == 0x000018, "Member 'FVoteData::VoteQuestion' has a wrong offset!");

// ScriptStruct ReadyOrNot.SharedTeamData
// 0x002C (0x002C - 0x0000)
struct FSharedTeamData
{
public:
	uint8                                         Pad_1F3B[0x10];                                    // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CommandLocation;                                   // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousCommandLocation;                           // 0x001C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     CommandTeam;                                       // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumInTeam;                                         // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F3C[0x2];                                     // 0x002A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSharedTeamData) == 0x000004, "Wrong alignment on FSharedTeamData");
static_assert(sizeof(FSharedTeamData) == 0x00002C, "Wrong size on FSharedTeamData");
static_assert(offsetof(FSharedTeamData, CommandLocation) == 0x000010, "Member 'FSharedTeamData::CommandLocation' has a wrong offset!");
static_assert(offsetof(FSharedTeamData, PreviousCommandLocation) == 0x00001C, "Member 'FSharedTeamData::PreviousCommandLocation' has a wrong offset!");
static_assert(offsetof(FSharedTeamData, CommandTeam) == 0x000028, "Member 'FSharedTeamData::CommandTeam' has a wrong offset!");
static_assert(offsetof(FSharedTeamData, NumInTeam) == 0x000029, "Member 'FSharedTeamData::NumInTeam' has a wrong offset!");

// ScriptStruct ReadyOrNot.SharedFallInData
// 0x0004 (0x0030 - 0x002C)
struct FSharedFallInData final  : public FSharedTeamData
{
public:
	uint8                                         Pad_1F3D[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSharedFallInData) == 0x000004, "Wrong alignment on FSharedFallInData");
static_assert(sizeof(FSharedFallInData) == 0x000030, "Wrong size on FSharedFallInData");

// ScriptStruct ReadyOrNot.ProjectileData
// 0x0010 (0x0010 - 0x0000)
struct FProjectileData final 
{
public:
	TArray<class ABulletProjectile*>              Projectiles;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileData) == 0x000008, "Wrong alignment on FProjectileData");
static_assert(sizeof(FProjectileData) == 0x000010, "Wrong size on FProjectileData");
static_assert(offsetof(FProjectileData, Projectiles) == 0x000000, "Member 'FProjectileData::Projectiles' has a wrong offset!");

// ScriptStruct ReadyOrNot.WeaponPreset
// 0x0068 (0x0068 - 0x0000)
struct FWeaponPreset final 
{
public:
	uint8                                         bHasSavedData : 1;                                 // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSelected : 1;                                     // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F3E[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PresetName;                                        // 0x0004(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F3F[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedWeaponAttachmentData             AttachmentData;                                    // 0x0010(0x0058)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponPreset) == 0x000008, "Wrong alignment on FWeaponPreset");
static_assert(sizeof(FWeaponPreset) == 0x000068, "Wrong size on FWeaponPreset");
static_assert(offsetof(FWeaponPreset, PresetName) == 0x000004, "Member 'FWeaponPreset::PresetName' has a wrong offset!");
static_assert(offsetof(FWeaponPreset, AttachmentData) == 0x000010, "Member 'FWeaponPreset::AttachmentData' has a wrong offset!");

// ScriptStruct ReadyOrNot.SavedWeaponPreset
// 0x0010 (0x0010 - 0x0000)
struct FSavedWeaponPreset final 
{
public:
	TArray<struct FWeaponPreset>                  Presets;                                           // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedWeaponPreset) == 0x000008, "Wrong alignment on FSavedWeaponPreset");
static_assert(sizeof(FSavedWeaponPreset) == 0x000010, "Wrong size on FSavedWeaponPreset");
static_assert(offsetof(FSavedWeaponPreset, Presets) == 0x000000, "Member 'FSavedWeaponPreset::Presets' has a wrong offset!");

// ScriptStruct ReadyOrNot.LoadoutPreset
// 0x0190 (0x0190 - 0x0000)
struct FLoadoutPreset final 
{
public:
	class FName                                   PresetName;                                        // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSavedLoadout                          Loadout;                                           // 0x0008(0x0188)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadoutPreset) == 0x000008, "Wrong alignment on FLoadoutPreset");
static_assert(sizeof(FLoadoutPreset) == 0x000190, "Wrong size on FLoadoutPreset");
static_assert(offsetof(FLoadoutPreset, PresetName) == 0x000000, "Member 'FLoadoutPreset::PresetName' has a wrong offset!");
static_assert(offsetof(FLoadoutPreset, Loadout) == 0x000008, "Member 'FLoadoutPreset::Loadout' has a wrong offset!");

// ScriptStruct ReadyOrNot.RosterLoadout
// 0x0038 (0x0038 - 0x0000)
struct FRosterLoadout final 
{
public:
	TSubclassOf<class ABaseItem>                  Primary;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseItem>                  Secondary;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseItem>                  LongTactical;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ABaseItem>>          GrenadeSlots;                                      // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ABaseItem>>          TacticalSlots;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRosterLoadout) == 0x000008, "Wrong alignment on FRosterLoadout");
static_assert(sizeof(FRosterLoadout) == 0x000038, "Wrong size on FRosterLoadout");
static_assert(offsetof(FRosterLoadout, Primary) == 0x000000, "Member 'FRosterLoadout::Primary' has a wrong offset!");
static_assert(offsetof(FRosterLoadout, Secondary) == 0x000008, "Member 'FRosterLoadout::Secondary' has a wrong offset!");
static_assert(offsetof(FRosterLoadout, LongTactical) == 0x000010, "Member 'FRosterLoadout::LongTactical' has a wrong offset!");
static_assert(offsetof(FRosterLoadout, GrenadeSlots) == 0x000018, "Member 'FRosterLoadout::GrenadeSlots' has a wrong offset!");
static_assert(offsetof(FRosterLoadout, TacticalSlots) == 0x000028, "Member 'FRosterLoadout::TacticalSlots' has a wrong offset!");

// ScriptStruct ReadyOrNot.LobbyPlayer
// 0x0058 (0x0058 - 0x0000)
struct FLobbyPlayer final 
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RealName;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Presence;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatusString;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UniqueNetId;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasVoice;                                         // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuted;                                          // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F40[0x6];                                     // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLobbyPlayer) == 0x000008, "Wrong alignment on FLobbyPlayer");
static_assert(sizeof(FLobbyPlayer) == 0x000058, "Wrong size on FLobbyPlayer");
static_assert(offsetof(FLobbyPlayer, DisplayName) == 0x000000, "Member 'FLobbyPlayer::DisplayName' has a wrong offset!");
static_assert(offsetof(FLobbyPlayer, RealName) == 0x000010, "Member 'FLobbyPlayer::RealName' has a wrong offset!");
static_assert(offsetof(FLobbyPlayer, Presence) == 0x000020, "Member 'FLobbyPlayer::Presence' has a wrong offset!");
static_assert(offsetof(FLobbyPlayer, StatusString) == 0x000030, "Member 'FLobbyPlayer::StatusString' has a wrong offset!");
static_assert(offsetof(FLobbyPlayer, UniqueNetId) == 0x000040, "Member 'FLobbyPlayer::UniqueNetId' has a wrong offset!");
static_assert(offsetof(FLobbyPlayer, bHasVoice) == 0x000050, "Member 'FLobbyPlayer::bHasVoice' has a wrong offset!");
static_assert(offsetof(FLobbyPlayer, bIsMuted) == 0x000051, "Member 'FLobbyPlayer::bIsMuted' has a wrong offset!");

// ScriptStruct ReadyOrNot.AttachmentEffects
// 0x0020 (0x0020 - 0x0000)
struct FAttachmentEffects final 
{
public:
	class FText                                   EffectText;                                        // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bEffectIsPos;                                      // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F41[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttachmentEffects) == 0x000008, "Wrong alignment on FAttachmentEffects");
static_assert(sizeof(FAttachmentEffects) == 0x000020, "Wrong size on FAttachmentEffects");
static_assert(offsetof(FAttachmentEffects, EffectText) == 0x000000, "Member 'FAttachmentEffects::EffectText' has a wrong offset!");
static_assert(offsetof(FAttachmentEffects, bEffectIsPos) == 0x000018, "Member 'FAttachmentEffects::bEffectIsPos' has a wrong offset!");

// ScriptStruct ReadyOrNot.Friend
// 0x0060 (0x0060 - 0x0000)
struct FFriend final 
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RealName;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Presence;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatusString;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatusState;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F42[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UniqueNetId;                                       // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunningSameGame;                                  // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasVoice;                                         // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJoinable;                                         // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F43[0x5];                                     // 0x005B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFriend) == 0x000008, "Wrong alignment on FFriend");
static_assert(sizeof(FFriend) == 0x000060, "Wrong size on FFriend");
static_assert(offsetof(FFriend, DisplayName) == 0x000000, "Member 'FFriend::DisplayName' has a wrong offset!");
static_assert(offsetof(FFriend, RealName) == 0x000010, "Member 'FFriend::RealName' has a wrong offset!");
static_assert(offsetof(FFriend, Presence) == 0x000020, "Member 'FFriend::Presence' has a wrong offset!");
static_assert(offsetof(FFriend, StatusString) == 0x000030, "Member 'FFriend::StatusString' has a wrong offset!");
static_assert(offsetof(FFriend, StatusState) == 0x000040, "Member 'FFriend::StatusState' has a wrong offset!");
static_assert(offsetof(FFriend, UniqueNetId) == 0x000048, "Member 'FFriend::UniqueNetId' has a wrong offset!");
static_assert(offsetof(FFriend, bRunningSameGame) == 0x000058, "Member 'FFriend::bRunningSameGame' has a wrong offset!");
static_assert(offsetof(FFriend, bHasVoice) == 0x000059, "Member 'FFriend::bHasVoice' has a wrong offset!");
static_assert(offsetof(FFriend, bJoinable) == 0x00005A, "Member 'FFriend::bJoinable' has a wrong offset!");

// ScriptStruct ReadyOrNot.CoverLandmarkAnimData
// 0x0058 (0x0058 - 0x0000)
struct FCoverLandmarkAnimData final 
{
public:
	uint8                                         bForwardOnly : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFromTable : 1;                                    // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F44[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ForwardAnimRowName;                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LeftAnimRowName;                                   // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RightAnimRowName;                                  // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ForwardAnim;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LeftAnim;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RightAnim;                                         // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimYawOffset;                                     // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F45[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoverLandmarkAnimData) == 0x000008, "Wrong alignment on FCoverLandmarkAnimData");
static_assert(sizeof(FCoverLandmarkAnimData) == 0x000058, "Wrong size on FCoverLandmarkAnimData");
static_assert(offsetof(FCoverLandmarkAnimData, ForwardAnimRowName) == 0x000008, "Member 'FCoverLandmarkAnimData::ForwardAnimRowName' has a wrong offset!");
static_assert(offsetof(FCoverLandmarkAnimData, LeftAnimRowName) == 0x000018, "Member 'FCoverLandmarkAnimData::LeftAnimRowName' has a wrong offset!");
static_assert(offsetof(FCoverLandmarkAnimData, RightAnimRowName) == 0x000028, "Member 'FCoverLandmarkAnimData::RightAnimRowName' has a wrong offset!");
static_assert(offsetof(FCoverLandmarkAnimData, ForwardAnim) == 0x000038, "Member 'FCoverLandmarkAnimData::ForwardAnim' has a wrong offset!");
static_assert(offsetof(FCoverLandmarkAnimData, LeftAnim) == 0x000040, "Member 'FCoverLandmarkAnimData::LeftAnim' has a wrong offset!");
static_assert(offsetof(FCoverLandmarkAnimData, RightAnim) == 0x000048, "Member 'FCoverLandmarkAnimData::RightAnim' has a wrong offset!");
static_assert(offsetof(FCoverLandmarkAnimData, AnimYawOffset) == 0x000050, "Member 'FCoverLandmarkAnimData::AnimYawOffset' has a wrong offset!");

// ScriptStruct ReadyOrNot.StoredWeaponAttachments
// 0x0048 (0x0048 - 0x0000)
struct FStoredWeaponAttachments final 
{
public:
	TSubclassOf<class UWeaponAttachment>          ScopeAttachment;                                   // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          MuzzleAttachment;                                  // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          UnderbarrelAttachment;                             // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          OverbarrelAttachment;                              // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          StockAttachment;                                   // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          GripAttachment;                                    // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          IlluminatorAttachment;                             // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          AmmunitionAttachment;                              // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmpty;                                          // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F46[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoredWeaponAttachments) == 0x000008, "Wrong alignment on FStoredWeaponAttachments");
static_assert(sizeof(FStoredWeaponAttachments) == 0x000048, "Wrong size on FStoredWeaponAttachments");
static_assert(offsetof(FStoredWeaponAttachments, ScopeAttachment) == 0x000000, "Member 'FStoredWeaponAttachments::ScopeAttachment' has a wrong offset!");
static_assert(offsetof(FStoredWeaponAttachments, MuzzleAttachment) == 0x000008, "Member 'FStoredWeaponAttachments::MuzzleAttachment' has a wrong offset!");
static_assert(offsetof(FStoredWeaponAttachments, UnderbarrelAttachment) == 0x000010, "Member 'FStoredWeaponAttachments::UnderbarrelAttachment' has a wrong offset!");
static_assert(offsetof(FStoredWeaponAttachments, OverbarrelAttachment) == 0x000018, "Member 'FStoredWeaponAttachments::OverbarrelAttachment' has a wrong offset!");
static_assert(offsetof(FStoredWeaponAttachments, StockAttachment) == 0x000020, "Member 'FStoredWeaponAttachments::StockAttachment' has a wrong offset!");
static_assert(offsetof(FStoredWeaponAttachments, GripAttachment) == 0x000028, "Member 'FStoredWeaponAttachments::GripAttachment' has a wrong offset!");
static_assert(offsetof(FStoredWeaponAttachments, IlluminatorAttachment) == 0x000030, "Member 'FStoredWeaponAttachments::IlluminatorAttachment' has a wrong offset!");
static_assert(offsetof(FStoredWeaponAttachments, AmmunitionAttachment) == 0x000038, "Member 'FStoredWeaponAttachments::AmmunitionAttachment' has a wrong offset!");
static_assert(offsetof(FStoredWeaponAttachments, bIsEmpty) == 0x000040, "Member 'FStoredWeaponAttachments::bIsEmpty' has a wrong offset!");

// ScriptStruct ReadyOrNot.SwatCommand
// 0x0060 (0x0060 - 0x0000)
struct FSwatCommand final 
{
public:
	struct FKey                                   InputKey;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CommandText;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ESwatCommand                                  CommandType;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGrabContextualDataOnExecute;                      // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0032(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSecondaryContextData;                          // 0x0033(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldPageUntilExecute;                             // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCommandTextAsIssuedText;                          // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F47[0x2];                                     // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CommandTarget;                                     // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CommandTarget2;                                    // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F48[0x14];                                    // 0x004C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSwatCommand) == 0x000008, "Wrong alignment on FSwatCommand");
static_assert(sizeof(FSwatCommand) == 0x000060, "Wrong size on FSwatCommand");
static_assert(offsetof(FSwatCommand, InputKey) == 0x000000, "Member 'FSwatCommand::InputKey' has a wrong offset!");
static_assert(offsetof(FSwatCommand, CommandText) == 0x000018, "Member 'FSwatCommand::CommandText' has a wrong offset!");
static_assert(offsetof(FSwatCommand, CommandType) == 0x000030, "Member 'FSwatCommand::CommandType' has a wrong offset!");
static_assert(offsetof(FSwatCommand, bGrabContextualDataOnExecute) == 0x000031, "Member 'FSwatCommand::bGrabContextualDataOnExecute' has a wrong offset!");
static_assert(offsetof(FSwatCommand, bEnabled) == 0x000032, "Member 'FSwatCommand::bEnabled' has a wrong offset!");
static_assert(offsetof(FSwatCommand, bUseSecondaryContextData) == 0x000033, "Member 'FSwatCommand::bUseSecondaryContextData' has a wrong offset!");
static_assert(offsetof(FSwatCommand, bHoldPageUntilExecute) == 0x000034, "Member 'FSwatCommand::bHoldPageUntilExecute' has a wrong offset!");
static_assert(offsetof(FSwatCommand, bCommandTextAsIssuedText) == 0x000035, "Member 'FSwatCommand::bCommandTextAsIssuedText' has a wrong offset!");
static_assert(offsetof(FSwatCommand, CommandTarget) == 0x000038, "Member 'FSwatCommand::CommandTarget' has a wrong offset!");
static_assert(offsetof(FSwatCommand, CommandTarget2) == 0x000040, "Member 'FSwatCommand::CommandTarget2' has a wrong offset!");
static_assert(offsetof(FSwatCommand, Index) == 0x000048, "Member 'FSwatCommand::Index' has a wrong offset!");

// ScriptStruct ReadyOrNot.QueuedSwatCommand
// 0x00E8 (0x00E8 - 0x0000)
struct FQueuedSwatCommand final 
{
public:
	struct FSwatCommand                           Command;                                           // 0x0000(0x0060)(NativeAccessSpecifierPublic)
	struct FHitResult                             ContextualData;                                    // 0x0060(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQueuedSwatCommand) == 0x000008, "Wrong alignment on FQueuedSwatCommand");
static_assert(sizeof(FQueuedSwatCommand) == 0x0000E8, "Wrong size on FQueuedSwatCommand");
static_assert(offsetof(FQueuedSwatCommand, Command) == 0x000000, "Member 'FQueuedSwatCommand::Command' has a wrong offset!");
static_assert(offsetof(FQueuedSwatCommand, ContextualData) == 0x000060, "Member 'FQueuedSwatCommand::ContextualData' has a wrong offset!");

// ScriptStruct ReadyOrNot.ReplaySocket
// 0x0020 (0x0020 - 0x0000)
struct FReplaySocket final 
{
public:
	class FString                                 SocketName;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FriendlySocketName;                                // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplaySocket) == 0x000008, "Wrong alignment on FReplaySocket");
static_assert(sizeof(FReplaySocket) == 0x000020, "Wrong size on FReplaySocket");
static_assert(offsetof(FReplaySocket, SocketName) == 0x000000, "Member 'FReplaySocket::SocketName' has a wrong offset!");
static_assert(offsetof(FReplaySocket, FriendlySocketName) == 0x000010, "Member 'FReplaySocket::FriendlySocketName' has a wrong offset!");

// ScriptStruct ReadyOrNot.ReplaySubMesh
// 0x0028 (0x0028 - 0x0000)
struct FReplaySubMesh final 
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FriendlyMeshName;                                  // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FReplaySocket>                  ReplaySockets;                                     // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplaySubMesh) == 0x000008, "Wrong alignment on FReplaySubMesh");
static_assert(sizeof(FReplaySubMesh) == 0x000028, "Wrong size on FReplaySubMesh");
static_assert(offsetof(FReplaySubMesh, Mesh) == 0x000000, "Member 'FReplaySubMesh::Mesh' has a wrong offset!");
static_assert(offsetof(FReplaySubMesh, FriendlyMeshName) == 0x000008, "Member 'FReplaySubMesh::FriendlyMeshName' has a wrong offset!");
static_assert(offsetof(FReplaySubMesh, ReplaySockets) == 0x000018, "Member 'FReplaySubMesh::ReplaySockets' has a wrong offset!");

// ScriptStruct ReadyOrNot.ScriptedLookAt
// 0x0018 (0x0018 - 0x0000)
struct FScriptedLookAt final 
{
public:
	class AActor*                                 LookAtActor;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtLocation;                                    // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRemaining;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScriptedLookAt) == 0x000008, "Wrong alignment on FScriptedLookAt");
static_assert(sizeof(FScriptedLookAt) == 0x000018, "Wrong size on FScriptedLookAt");
static_assert(offsetof(FScriptedLookAt, LookAtActor) == 0x000000, "Member 'FScriptedLookAt::LookAtActor' has a wrong offset!");
static_assert(offsetof(FScriptedLookAt, LookAtLocation) == 0x000008, "Member 'FScriptedLookAt::LookAtLocation' has a wrong offset!");
static_assert(offsetof(FScriptedLookAt, TimeRemaining) == 0x000014, "Member 'FScriptedLookAt::TimeRemaining' has a wrong offset!");

// ScriptStruct ReadyOrNot.LobbySaveData
// 0x0038 (0x0038 - 0x0000)
struct FLobbySaveData final 
{
public:
	class FString                                 LevelName;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerTransformSet;                               // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F49[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PlayerLocation;                                    // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PlayerRotation;                                    // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PlayerCameraRotation;                              // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbySaveData) == 0x000008, "Wrong alignment on FLobbySaveData");
static_assert(sizeof(FLobbySaveData) == 0x000038, "Wrong size on FLobbySaveData");
static_assert(offsetof(FLobbySaveData, LevelName) == 0x000000, "Member 'FLobbySaveData::LevelName' has a wrong offset!");
static_assert(offsetof(FLobbySaveData, bPlayerTransformSet) == 0x000010, "Member 'FLobbySaveData::bPlayerTransformSet' has a wrong offset!");
static_assert(offsetof(FLobbySaveData, PlayerLocation) == 0x000014, "Member 'FLobbySaveData::PlayerLocation' has a wrong offset!");
static_assert(offsetof(FLobbySaveData, PlayerRotation) == 0x000020, "Member 'FLobbySaveData::PlayerRotation' has a wrong offset!");
static_assert(offsetof(FLobbySaveData, PlayerCameraRotation) == 0x00002C, "Member 'FLobbySaveData::PlayerCameraRotation' has a wrong offset!");

// ScriptStruct ReadyOrNot.ScriptedFireAt
// 0x0028 (0x0028 - 0x0000)
struct FScriptedFireAt final 
{
public:
	class AActor*                                 FireAtActor;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FireAtLocation;                                    // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRemaining;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTargetedEnemy;                            // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4A[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AccuracyPenaltyMultiplier;                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireAngleThreshold;                                // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInfiniteAmmo;                                     // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4B[0x3];                                     // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScriptedFireAt) == 0x000008, "Wrong alignment on FScriptedFireAt");
static_assert(sizeof(FScriptedFireAt) == 0x000028, "Wrong size on FScriptedFireAt");
static_assert(offsetof(FScriptedFireAt, FireAtActor) == 0x000000, "Member 'FScriptedFireAt::FireAtActor' has a wrong offset!");
static_assert(offsetof(FScriptedFireAt, FireAtLocation) == 0x000008, "Member 'FScriptedFireAt::FireAtLocation' has a wrong offset!");
static_assert(offsetof(FScriptedFireAt, TimeRemaining) == 0x000014, "Member 'FScriptedFireAt::TimeRemaining' has a wrong offset!");
static_assert(offsetof(FScriptedFireAt, bOverrideTargetedEnemy) == 0x000018, "Member 'FScriptedFireAt::bOverrideTargetedEnemy' has a wrong offset!");
static_assert(offsetof(FScriptedFireAt, AccuracyPenaltyMultiplier) == 0x00001C, "Member 'FScriptedFireAt::AccuracyPenaltyMultiplier' has a wrong offset!");
static_assert(offsetof(FScriptedFireAt, FireAngleThreshold) == 0x000020, "Member 'FScriptedFireAt::FireAngleThreshold' has a wrong offset!");
static_assert(offsetof(FScriptedFireAt, bInfiniteAmmo) == 0x000024, "Member 'FScriptedFireAt::bInfiniteAmmo' has a wrong offset!");

// ScriptStruct ReadyOrNot.ConversationData
// 0x0068 (0x0070 - 0x0008)
struct FConversationData final  : public FTableRowBase
{
public:
	class FName                                   SpeakerId;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LookAtSpeakerId;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseVoiceLineFromSpeechTable;                      // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4C[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VoiceLineRowName;                                  // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundWave*                             VoiceLineWav;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   Speaker;                                           // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalDelayAfterVoiceLineBeforeNextSpeaker;    // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RequiredTag;                                       // 0x0044(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     TeamType;                                          // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4D[0x3];                                     // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistance;                                       // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireLineOfSight;                               // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOptionalSpeaker;                                  // 0x0055(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4E[0x2];                                     // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkipXAfterOptionalSpeakerNotFound;                 // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GiveWorldBuildingActivityByTagOnStartConversation; // 0x005C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GiveWorldBuildingActivityByTagAfterConversation;   // 0x0064(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4F[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConversationData) == 0x000008, "Wrong alignment on FConversationData");
static_assert(sizeof(FConversationData) == 0x000070, "Wrong size on FConversationData");
static_assert(offsetof(FConversationData, SpeakerId) == 0x000008, "Member 'FConversationData::SpeakerId' has a wrong offset!");
static_assert(offsetof(FConversationData, LookAtSpeakerId) == 0x000010, "Member 'FConversationData::LookAtSpeakerId' has a wrong offset!");
static_assert(offsetof(FConversationData, bUseVoiceLineFromSpeechTable) == 0x000018, "Member 'FConversationData::bUseVoiceLineFromSpeechTable' has a wrong offset!");
static_assert(offsetof(FConversationData, VoiceLineRowName) == 0x000020, "Member 'FConversationData::VoiceLineRowName' has a wrong offset!");
static_assert(offsetof(FConversationData, VoiceLineWav) == 0x000030, "Member 'FConversationData::VoiceLineWav' has a wrong offset!");
static_assert(offsetof(FConversationData, Speaker) == 0x000038, "Member 'FConversationData::Speaker' has a wrong offset!");
static_assert(offsetof(FConversationData, AdditionalDelayAfterVoiceLineBeforeNextSpeaker) == 0x000040, "Member 'FConversationData::AdditionalDelayAfterVoiceLineBeforeNextSpeaker' has a wrong offset!");
static_assert(offsetof(FConversationData, RequiredTag) == 0x000044, "Member 'FConversationData::RequiredTag' has a wrong offset!");
static_assert(offsetof(FConversationData, TeamType) == 0x00004C, "Member 'FConversationData::TeamType' has a wrong offset!");
static_assert(offsetof(FConversationData, MaxDistance) == 0x000050, "Member 'FConversationData::MaxDistance' has a wrong offset!");
static_assert(offsetof(FConversationData, bRequireLineOfSight) == 0x000054, "Member 'FConversationData::bRequireLineOfSight' has a wrong offset!");
static_assert(offsetof(FConversationData, bOptionalSpeaker) == 0x000055, "Member 'FConversationData::bOptionalSpeaker' has a wrong offset!");
static_assert(offsetof(FConversationData, SkipXAfterOptionalSpeakerNotFound) == 0x000058, "Member 'FConversationData::SkipXAfterOptionalSpeakerNotFound' has a wrong offset!");
static_assert(offsetof(FConversationData, GiveWorldBuildingActivityByTagOnStartConversation) == 0x00005C, "Member 'FConversationData::GiveWorldBuildingActivityByTagOnStartConversation' has a wrong offset!");
static_assert(offsetof(FConversationData, GiveWorldBuildingActivityByTagAfterConversation) == 0x000064, "Member 'FConversationData::GiveWorldBuildingActivityByTagAfterConversation' has a wrong offset!");

// ScriptStruct ReadyOrNot.OptimizationAttachmentData
// 0x0040 (0x0040 - 0x0000)
struct FOptimizationAttachmentData final 
{
public:
	class FName                                   AttachedSocketName;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachedComponent;                                 // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             RelativeTransform;                                 // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOptimizationAttachmentData) == 0x000010, "Wrong alignment on FOptimizationAttachmentData");
static_assert(sizeof(FOptimizationAttachmentData) == 0x000040, "Wrong size on FOptimizationAttachmentData");
static_assert(offsetof(FOptimizationAttachmentData, AttachedSocketName) == 0x000000, "Member 'FOptimizationAttachmentData::AttachedSocketName' has a wrong offset!");
static_assert(offsetof(FOptimizationAttachmentData, AttachedComponent) == 0x000008, "Member 'FOptimizationAttachmentData::AttachedComponent' has a wrong offset!");
static_assert(offsetof(FOptimizationAttachmentData, RelativeTransform) == 0x000010, "Member 'FOptimizationAttachmentData::RelativeTransform' has a wrong offset!");

// ScriptStruct ReadyOrNot.NodePair
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FNodePair final 
{
public:
	uint8                                         Pad_1F50[0x8];                                     // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNodePair) == 0x000004, "Wrong alignment on FNodePair");
static_assert(sizeof(FNodePair) == 0x000008, "Wrong size on FNodePair");

// ScriptStruct ReadyOrNot.ReplayEvent
// 0x0028 (0x0028 - 0x0000)
struct FReplayEvent final 
{
public:
	EReplayEventType                              EventType;                                         // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F51[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AdditionalInformation;                             // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F52[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplayEvent) == 0x000008, "Wrong alignment on FReplayEvent");
static_assert(sizeof(FReplayEvent) == 0x000028, "Wrong size on FReplayEvent");
static_assert(offsetof(FReplayEvent, EventType) == 0x000000, "Member 'FReplayEvent::EventType' has a wrong offset!");
static_assert(offsetof(FReplayEvent, Location) == 0x000004, "Member 'FReplayEvent::Location' has a wrong offset!");
static_assert(offsetof(FReplayEvent, AdditionalInformation) == 0x000010, "Member 'FReplayEvent::AdditionalInformation' has a wrong offset!");
static_assert(offsetof(FReplayEvent, Timestamp) == 0x000020, "Member 'FReplayEvent::Timestamp' has a wrong offset!");

// ScriptStruct ReadyOrNot.ReplayData
// 0x0080 (0x0080 - 0x0000)
struct FReplayData final 
{
public:
	float                                         ReplayLength;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F53[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LetterScore;                                       // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumericalScore;                                    // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPlayers;                                        // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelName;                                         // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelRowName;                                      // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameModeName;                                      // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Timestamp;                                         // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameVersion;                                       // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FReplayEvent>                   ReplayEvents;                                      // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplayData) == 0x000008, "Wrong alignment on FReplayData");
static_assert(sizeof(FReplayData) == 0x000080, "Wrong size on FReplayData");
static_assert(offsetof(FReplayData, ReplayLength) == 0x000000, "Member 'FReplayData::ReplayLength' has a wrong offset!");
static_assert(offsetof(FReplayData, LetterScore) == 0x000008, "Member 'FReplayData::LetterScore' has a wrong offset!");
static_assert(offsetof(FReplayData, NumericalScore) == 0x000018, "Member 'FReplayData::NumericalScore' has a wrong offset!");
static_assert(offsetof(FReplayData, NumPlayers) == 0x00001C, "Member 'FReplayData::NumPlayers' has a wrong offset!");
static_assert(offsetof(FReplayData, LevelName) == 0x000020, "Member 'FReplayData::LevelName' has a wrong offset!");
static_assert(offsetof(FReplayData, LevelRowName) == 0x000030, "Member 'FReplayData::LevelRowName' has a wrong offset!");
static_assert(offsetof(FReplayData, GameModeName) == 0x000040, "Member 'FReplayData::GameModeName' has a wrong offset!");
static_assert(offsetof(FReplayData, Timestamp) == 0x000050, "Member 'FReplayData::Timestamp' has a wrong offset!");
static_assert(offsetof(FReplayData, GameVersion) == 0x000060, "Member 'FReplayData::GameVersion' has a wrong offset!");
static_assert(offsetof(FReplayData, ReplayEvents) == 0x000070, "Member 'FReplayData::ReplayEvents' has a wrong offset!");

// ScriptStruct ReadyOrNot.LevelFloor
// 0x0068 (0x0068 - 0x0000)
struct FLevelFloor final 
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Number;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F54[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              FloorMap;                                          // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEntryPoint>                    EntryPoints;                                       // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECOOPMode>                             ExcludedGameModes;                                 // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelFloor) == 0x000008, "Wrong alignment on FLevelFloor");
static_assert(sizeof(FLevelFloor) == 0x000068, "Wrong size on FLevelFloor");
static_assert(offsetof(FLevelFloor, Name) == 0x000000, "Member 'FLevelFloor::Name' has a wrong offset!");
static_assert(offsetof(FLevelFloor, Number) == 0x000018, "Member 'FLevelFloor::Number' has a wrong offset!");
static_assert(offsetof(FLevelFloor, FloorMap) == 0x000020, "Member 'FLevelFloor::FloorMap' has a wrong offset!");
static_assert(offsetof(FLevelFloor, EntryPoints) == 0x000048, "Member 'FLevelFloor::EntryPoints' has a wrong offset!");
static_assert(offsetof(FLevelFloor, ExcludedGameModes) == 0x000058, "Member 'FLevelFloor::ExcludedGameModes' has a wrong offset!");

// ScriptStruct ReadyOrNot.NVGPostProcessSettings
// 0x0058 (0x0058 - 0x0000)
struct FNVGPostProcessSettings final 
{
public:
	TSoftObjectPtr<class UTexture2D>              DirtMaskTexture;                                   // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDepthOfFieldMethod                           DepthOfFieldMethod;                                // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F55[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BloomIntensity;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomThreshold;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAutoExposureMethod                           AutoExposureMethod;                                // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F56[0x3];                                     // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BloomDirtMaskIntensity;                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFstop;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensFlareIntensity;                                // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensFlareBokehSize;                                // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionIntensity;                         // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IndirectLightingIntensity;                         // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmSlope;                                         // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmToe;                                           // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNVGPostProcessSettings) == 0x000008, "Wrong alignment on FNVGPostProcessSettings");
static_assert(sizeof(FNVGPostProcessSettings) == 0x000058, "Wrong size on FNVGPostProcessSettings");
static_assert(offsetof(FNVGPostProcessSettings, DirtMaskTexture) == 0x000000, "Member 'FNVGPostProcessSettings::DirtMaskTexture' has a wrong offset!");
static_assert(offsetof(FNVGPostProcessSettings, DepthOfFieldMethod) == 0x000028, "Member 'FNVGPostProcessSettings::DepthOfFieldMethod' has a wrong offset!");
static_assert(offsetof(FNVGPostProcessSettings, BloomIntensity) == 0x00002C, "Member 'FNVGPostProcessSettings::BloomIntensity' has a wrong offset!");
static_assert(offsetof(FNVGPostProcessSettings, BloomThreshold) == 0x000030, "Member 'FNVGPostProcessSettings::BloomThreshold' has a wrong offset!");
static_assert(offsetof(FNVGPostProcessSettings, AutoExposureMethod) == 0x000034, "Member 'FNVGPostProcessSettings::AutoExposureMethod' has a wrong offset!");
static_assert(offsetof(FNVGPostProcessSettings, BloomDirtMaskIntensity) == 0x000038, "Member 'FNVGPostProcessSettings::BloomDirtMaskIntensity' has a wrong offset!");
static_assert(offsetof(FNVGPostProcessSettings, DepthOfFieldFstop) == 0x00003C, "Member 'FNVGPostProcessSettings::DepthOfFieldFstop' has a wrong offset!");
static_assert(offsetof(FNVGPostProcessSettings, LensFlareIntensity) == 0x000040, "Member 'FNVGPostProcessSettings::LensFlareIntensity' has a wrong offset!");
static_assert(offsetof(FNVGPostProcessSettings, LensFlareBokehSize) == 0x000044, "Member 'FNVGPostProcessSettings::LensFlareBokehSize' has a wrong offset!");
static_assert(offsetof(FNVGPostProcessSettings, AmbientOcclusionIntensity) == 0x000048, "Member 'FNVGPostProcessSettings::AmbientOcclusionIntensity' has a wrong offset!");
static_assert(offsetof(FNVGPostProcessSettings, IndirectLightingIntensity) == 0x00004C, "Member 'FNVGPostProcessSettings::IndirectLightingIntensity' has a wrong offset!");
static_assert(offsetof(FNVGPostProcessSettings, FilmSlope) == 0x000050, "Member 'FNVGPostProcessSettings::FilmSlope' has a wrong offset!");
static_assert(offsetof(FNVGPostProcessSettings, FilmToe) == 0x000054, "Member 'FNVGPostProcessSettings::FilmToe' has a wrong offset!");

// ScriptStruct ReadyOrNot.MissionAudio
// 0x0060 (0x0060 - 0x0000)
struct FMissionAudio final 
{
public:
	class FText                                   AudioName;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   AudioDescription;                                  // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 AudioInternalName;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SoundFile;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   AudioTranscript;                                   // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionAudio) == 0x000008, "Wrong alignment on FMissionAudio");
static_assert(sizeof(FMissionAudio) == 0x000060, "Wrong size on FMissionAudio");
static_assert(offsetof(FMissionAudio, AudioName) == 0x000000, "Member 'FMissionAudio::AudioName' has a wrong offset!");
static_assert(offsetof(FMissionAudio, AudioDescription) == 0x000018, "Member 'FMissionAudio::AudioDescription' has a wrong offset!");
static_assert(offsetof(FMissionAudio, AudioInternalName) == 0x000030, "Member 'FMissionAudio::AudioInternalName' has a wrong offset!");
static_assert(offsetof(FMissionAudio, SoundFile) == 0x000040, "Member 'FMissionAudio::SoundFile' has a wrong offset!");
static_assert(offsetof(FMissionAudio, AudioTranscript) == 0x000048, "Member 'FMissionAudio::AudioTranscript' has a wrong offset!");

// ScriptStruct ReadyOrNot.LoadAdditionalLevels
// 0x0010 (0x0010 - 0x0000)
struct FLoadAdditionalLevels final 
{
public:
	TArray<class FString>                         SubLevelNames;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadAdditionalLevels) == 0x000008, "Wrong alignment on FLoadAdditionalLevels");
static_assert(sizeof(FLoadAdditionalLevels) == 0x000010, "Wrong size on FLoadAdditionalLevels");
static_assert(offsetof(FLoadAdditionalLevels, SubLevelNames) == 0x000000, "Member 'FLoadAdditionalLevels::SubLevelNames' has a wrong offset!");

// ScriptStruct ReadyOrNot.UnlockRequirements
// 0x0018 (0x0018 - 0x0000)
struct FUnlockRequirements final 
{
public:
	class FString                                 MapURL;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Score;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F57[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnlockRequirements) == 0x000008, "Wrong alignment on FUnlockRequirements");
static_assert(sizeof(FUnlockRequirements) == 0x000018, "Wrong size on FUnlockRequirements");
static_assert(offsetof(FUnlockRequirements, MapURL) == 0x000000, "Member 'FUnlockRequirements::MapURL' has a wrong offset!");
static_assert(offsetof(FUnlockRequirements, Score) == 0x000010, "Member 'FUnlockRequirements::Score' has a wrong offset!");

// ScriptStruct ReadyOrNot.LoadingScreenAnimated
// 0x0050 (0x0050 - 0x0000)
struct FLoadingScreenAnimated final 
{
public:
	TSoftObjectPtr<class UTexture2D>              Foreground;                                        // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Background;                                        // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingScreenAnimated) == 0x000008, "Wrong alignment on FLoadingScreenAnimated");
static_assert(sizeof(FLoadingScreenAnimated) == 0x000050, "Wrong size on FLoadingScreenAnimated");
static_assert(offsetof(FLoadingScreenAnimated, Foreground) == 0x000000, "Member 'FLoadingScreenAnimated::Foreground' has a wrong offset!");
static_assert(offsetof(FLoadingScreenAnimated, Background) == 0x000028, "Member 'FLoadingScreenAnimated::Background' has a wrong offset!");

// ScriptStruct ReadyOrNot.MissionDoc
// 0x0060 (0x0060 - 0x0000)
struct FMissionDoc final 
{
public:
	class FText                                   DocumentTitle;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DocumentText;                                      // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DocumentButtonText;                                // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DocumentButtonDescriptionText;                     // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionDoc) == 0x000008, "Wrong alignment on FMissionDoc");
static_assert(sizeof(FMissionDoc) == 0x000060, "Wrong size on FMissionDoc");
static_assert(offsetof(FMissionDoc, DocumentTitle) == 0x000000, "Member 'FMissionDoc::DocumentTitle' has a wrong offset!");
static_assert(offsetof(FMissionDoc, DocumentText) == 0x000018, "Member 'FMissionDoc::DocumentText' has a wrong offset!");
static_assert(offsetof(FMissionDoc, DocumentButtonText) == 0x000030, "Member 'FMissionDoc::DocumentButtonText' has a wrong offset!");
static_assert(offsetof(FMissionDoc, DocumentButtonDescriptionText) == 0x000048, "Member 'FMissionDoc::DocumentButtonDescriptionText' has a wrong offset!");

// ScriptStruct ReadyOrNot.CriminalRecord
// 0x0038 (0x0038 - 0x0000)
struct FCriminalRecord final 
{
public:
	class FString                                 Date;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Crime;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 CriminalCode;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCriminalRecord) == 0x000008, "Wrong alignment on FCriminalRecord");
static_assert(sizeof(FCriminalRecord) == 0x000038, "Wrong size on FCriminalRecord");
static_assert(offsetof(FCriminalRecord, Date) == 0x000000, "Member 'FCriminalRecord::Date' has a wrong offset!");
static_assert(offsetof(FCriminalRecord, Crime) == 0x000010, "Member 'FCriminalRecord::Crime' has a wrong offset!");
static_assert(offsetof(FCriminalRecord, CriminalCode) == 0x000028, "Member 'FCriminalRecord::CriminalCode' has a wrong offset!");

// ScriptStruct ReadyOrNot.CharacterBio
// 0x0140 (0x0140 - 0x0000)
struct FCharacterBio final 
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IdNumber;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           Aliases;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   Bio;                                               // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ProfileImage;                                      // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Sex;                                               // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Build;                                             // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Height;                                            // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Weight;                                            // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Hair;                                              // 0x00D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Eyes;                                              // 0x00E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DateOfBirth;                                       // 0x0100(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Age;                                               // 0x0118(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FCriminalRecord>                CriminalRecord;                                    // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterBio) == 0x000008, "Wrong alignment on FCharacterBio");
static_assert(sizeof(FCharacterBio) == 0x000140, "Wrong size on FCharacterBio");
static_assert(offsetof(FCharacterBio, Name) == 0x000000, "Member 'FCharacterBio::Name' has a wrong offset!");
static_assert(offsetof(FCharacterBio, IdNumber) == 0x000010, "Member 'FCharacterBio::IdNumber' has a wrong offset!");
static_assert(offsetof(FCharacterBio, Aliases) == 0x000020, "Member 'FCharacterBio::Aliases' has a wrong offset!");
static_assert(offsetof(FCharacterBio, Bio) == 0x000030, "Member 'FCharacterBio::Bio' has a wrong offset!");
static_assert(offsetof(FCharacterBio, ProfileImage) == 0x000048, "Member 'FCharacterBio::ProfileImage' has a wrong offset!");
static_assert(offsetof(FCharacterBio, Sex) == 0x000070, "Member 'FCharacterBio::Sex' has a wrong offset!");
static_assert(offsetof(FCharacterBio, Build) == 0x000088, "Member 'FCharacterBio::Build' has a wrong offset!");
static_assert(offsetof(FCharacterBio, Height) == 0x0000A0, "Member 'FCharacterBio::Height' has a wrong offset!");
static_assert(offsetof(FCharacterBio, Weight) == 0x0000B8, "Member 'FCharacterBio::Weight' has a wrong offset!");
static_assert(offsetof(FCharacterBio, Hair) == 0x0000D0, "Member 'FCharacterBio::Hair' has a wrong offset!");
static_assert(offsetof(FCharacterBio, Eyes) == 0x0000E8, "Member 'FCharacterBio::Eyes' has a wrong offset!");
static_assert(offsetof(FCharacterBio, DateOfBirth) == 0x000100, "Member 'FCharacterBio::DateOfBirth' has a wrong offset!");
static_assert(offsetof(FCharacterBio, Age) == 0x000118, "Member 'FCharacterBio::Age' has a wrong offset!");
static_assert(offsetof(FCharacterBio, CriminalRecord) == 0x000130, "Member 'FCharacterBio::CriminalRecord' has a wrong offset!");

// ScriptStruct ReadyOrNot.TimelineEvent
// 0x0050 (0x0050 - 0x0000)
struct FTimelineEvent final 
{
public:
	class FText                                   EventTitle;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   EventTime;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   EventDescription;                                  // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         EventTimestamp;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventDuration;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTimelineEvent) == 0x000008, "Wrong alignment on FTimelineEvent");
static_assert(sizeof(FTimelineEvent) == 0x000050, "Wrong size on FTimelineEvent");
static_assert(offsetof(FTimelineEvent, EventTitle) == 0x000000, "Member 'FTimelineEvent::EventTitle' has a wrong offset!");
static_assert(offsetof(FTimelineEvent, EventTime) == 0x000018, "Member 'FTimelineEvent::EventTime' has a wrong offset!");
static_assert(offsetof(FTimelineEvent, EventDescription) == 0x000030, "Member 'FTimelineEvent::EventDescription' has a wrong offset!");
static_assert(offsetof(FTimelineEvent, EventTimestamp) == 0x000048, "Member 'FTimelineEvent::EventTimestamp' has a wrong offset!");
static_assert(offsetof(FTimelineEvent, EventDuration) == 0x00004C, "Member 'FTimelineEvent::EventDuration' has a wrong offset!");

// ScriptStruct ReadyOrNot.MissionTimeline
// 0x0010 (0x0010 - 0x0000)
struct FMissionTimeline final 
{
public:
	TArray<struct FTimelineEvent>                 EventsList;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionTimeline) == 0x000008, "Wrong alignment on FMissionTimeline");
static_assert(sizeof(FMissionTimeline) == 0x000010, "Wrong size on FMissionTimeline");
static_assert(offsetof(FMissionTimeline, EventsList) == 0x000000, "Member 'FMissionTimeline::EventsList' has a wrong offset!");

// ScriptStruct ReadyOrNot.LevelFloorData
// 0x0080 (0x0080 - 0x0000)
struct FLevelFloorData final 
{
public:
	class FText                                   FloorFullName;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   FloorShortName;                                    // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              FloorLayout;                                       // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      FloorplanMaterial;                                 // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelFloorData) == 0x000008, "Wrong alignment on FLevelFloorData");
static_assert(sizeof(FLevelFloorData) == 0x000080, "Wrong size on FLevelFloorData");
static_assert(offsetof(FLevelFloorData, FloorFullName) == 0x000000, "Member 'FLevelFloorData::FloorFullName' has a wrong offset!");
static_assert(offsetof(FLevelFloorData, FloorShortName) == 0x000018, "Member 'FLevelFloorData::FloorShortName' has a wrong offset!");
static_assert(offsetof(FLevelFloorData, FloorLayout) == 0x000030, "Member 'FLevelFloorData::FloorLayout' has a wrong offset!");
static_assert(offsetof(FLevelFloorData, FloorplanMaterial) == 0x000058, "Member 'FLevelFloorData::FloorplanMaterial' has a wrong offset!");

// ScriptStruct ReadyOrNot.AIDataPick
// 0x0018 (0x0018 - 0x0000)
struct FAIDataPick final 
{
public:
	int32                                         Chance;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F58[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AILookupTag;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIDataPick) == 0x000008, "Wrong alignment on FAIDataPick");
static_assert(sizeof(FAIDataPick) == 0x000018, "Wrong size on FAIDataPick");
static_assert(offsetof(FAIDataPick, Chance) == 0x000000, "Member 'FAIDataPick::Chance' has a wrong offset!");
static_assert(offsetof(FAIDataPick, AILookupTag) == 0x000008, "Member 'FAIDataPick::AILookupTag' has a wrong offset!");

// ScriptStruct ReadyOrNot.AIRoster
// 0x0028 (0x0028 - 0x0000)
struct FAIRoster final 
{
public:
	int32                                         MinimumSpawn;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumSpawn;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpawnGroup;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAIDataPick>                    SpawnAI;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAffectedByNegotiator;                             // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F59[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIRoster) == 0x000008, "Wrong alignment on FAIRoster");
static_assert(sizeof(FAIRoster) == 0x000028, "Wrong size on FAIRoster");
static_assert(offsetof(FAIRoster, MinimumSpawn) == 0x000000, "Member 'FAIRoster::MinimumSpawn' has a wrong offset!");
static_assert(offsetof(FAIRoster, MaximumSpawn) == 0x000004, "Member 'FAIRoster::MaximumSpawn' has a wrong offset!");
static_assert(offsetof(FAIRoster, SpawnGroup) == 0x000008, "Member 'FAIRoster::SpawnGroup' has a wrong offset!");
static_assert(offsetof(FAIRoster, SpawnAI) == 0x000010, "Member 'FAIRoster::SpawnAI' has a wrong offset!");
static_assert(offsetof(FAIRoster, bAffectedByNegotiator) == 0x000020, "Member 'FAIRoster::bAffectedByNegotiator' has a wrong offset!");

// ScriptStruct ReadyOrNot.DynamicLevelDataPick
// 0x000C (0x000C - 0x0000)
struct FDynamicLevelDataPick final 
{
public:
	class FName                                   Label;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chance;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDynamicLevelDataPick) == 0x000004, "Wrong alignment on FDynamicLevelDataPick");
static_assert(sizeof(FDynamicLevelDataPick) == 0x00000C, "Wrong size on FDynamicLevelDataPick");
static_assert(offsetof(FDynamicLevelDataPick, Label) == 0x000000, "Member 'FDynamicLevelDataPick::Label' has a wrong offset!");
static_assert(offsetof(FDynamicLevelDataPick, Chance) == 0x000008, "Member 'FDynamicLevelDataPick::Chance' has a wrong offset!");

// ScriptStruct ReadyOrNot.DynamicLevelRoster
// 0x0020 (0x0020 - 0x0000)
struct FDynamicLevelRoster final 
{
public:
	float                                         OverallSpawnPercent;                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumPicks;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumPicks;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F5A[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDynamicLevelDataPick>          SpawnLevel;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDynamicLevelRoster) == 0x000008, "Wrong alignment on FDynamicLevelRoster");
static_assert(sizeof(FDynamicLevelRoster) == 0x000020, "Wrong size on FDynamicLevelRoster");
static_assert(offsetof(FDynamicLevelRoster, OverallSpawnPercent) == 0x000000, "Member 'FDynamicLevelRoster::OverallSpawnPercent' has a wrong offset!");
static_assert(offsetof(FDynamicLevelRoster, MinimumPicks) == 0x000004, "Member 'FDynamicLevelRoster::MinimumPicks' has a wrong offset!");
static_assert(offsetof(FDynamicLevelRoster, MaximumPicks) == 0x000008, "Member 'FDynamicLevelRoster::MaximumPicks' has a wrong offset!");
static_assert(offsetof(FDynamicLevelRoster, SpawnLevel) == 0x000010, "Member 'FDynamicLevelRoster::SpawnLevel' has a wrong offset!");

// ScriptStruct ReadyOrNot.TrapRoster
// 0x0010 (0x0010 - 0x0000)
struct FTrapRoster final 
{
public:
	int32                                         MinimumSpawn;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumSpawn;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpawnGroup;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrapRoster) == 0x000004, "Wrong alignment on FTrapRoster");
static_assert(sizeof(FTrapRoster) == 0x000010, "Wrong size on FTrapRoster");
static_assert(offsetof(FTrapRoster, MinimumSpawn) == 0x000000, "Member 'FTrapRoster::MinimumSpawn' has a wrong offset!");
static_assert(offsetof(FTrapRoster, MaximumSpawn) == 0x000004, "Member 'FTrapRoster::MaximumSpawn' has a wrong offset!");
static_assert(offsetof(FTrapRoster, SpawnGroup) == 0x000008, "Member 'FTrapRoster::SpawnGroup' has a wrong offset!");

// ScriptStruct ReadyOrNot.PersonnelMapPoint
// 0x0068 (0x0068 - 0x0000)
struct FPersonnelMapPoint final 
{
public:
	class FName                                   VolumeLabel;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorLabel;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MapPointName;                                      // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   MapPointDescription;                               // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         FloorNum;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MapShiftPosition;                                  // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapShiftZoom;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MapCoordinates;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMapZone;                                          // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F5B[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MapZoneSize;                                       // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F5C[0x4];                                     // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPersonnelMapPoint) == 0x000008, "Wrong alignment on FPersonnelMapPoint");
static_assert(sizeof(FPersonnelMapPoint) == 0x000068, "Wrong size on FPersonnelMapPoint");
static_assert(offsetof(FPersonnelMapPoint, VolumeLabel) == 0x000000, "Member 'FPersonnelMapPoint::VolumeLabel' has a wrong offset!");
static_assert(offsetof(FPersonnelMapPoint, ActorLabel) == 0x000008, "Member 'FPersonnelMapPoint::ActorLabel' has a wrong offset!");
static_assert(offsetof(FPersonnelMapPoint, MapPointName) == 0x000010, "Member 'FPersonnelMapPoint::MapPointName' has a wrong offset!");
static_assert(offsetof(FPersonnelMapPoint, MapPointDescription) == 0x000028, "Member 'FPersonnelMapPoint::MapPointDescription' has a wrong offset!");
static_assert(offsetof(FPersonnelMapPoint, FloorNum) == 0x000040, "Member 'FPersonnelMapPoint::FloorNum' has a wrong offset!");
static_assert(offsetof(FPersonnelMapPoint, MapShiftPosition) == 0x000044, "Member 'FPersonnelMapPoint::MapShiftPosition' has a wrong offset!");
static_assert(offsetof(FPersonnelMapPoint, MapShiftZoom) == 0x00004C, "Member 'FPersonnelMapPoint::MapShiftZoom' has a wrong offset!");
static_assert(offsetof(FPersonnelMapPoint, MapCoordinates) == 0x000050, "Member 'FPersonnelMapPoint::MapCoordinates' has a wrong offset!");
static_assert(offsetof(FPersonnelMapPoint, bMapZone) == 0x000058, "Member 'FPersonnelMapPoint::bMapZone' has a wrong offset!");
static_assert(offsetof(FPersonnelMapPoint, MapZoneSize) == 0x00005C, "Member 'FPersonnelMapPoint::MapZoneSize' has a wrong offset!");

// ScriptStruct ReadyOrNot.LevelDataLookupTable
// 0x0780 (0x0788 - 0x0008)
struct FLevelDataLookupTable final  : public FTableRowBase
{
public:
	class FText                                   FriendlyLevelName;                                 // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LevelNickname;                                     // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              LevelPicture;                                      // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LevelDesignation;                                  // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   TimeOfDayText;                                     // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0090(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   ProgressionTagPrefix;                              // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  MissionSelectMap;                                  // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultFloorIndex;                                 // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F5D[0x4];                                     // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLevelFloor>                    Floors;                                            // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEntryPoint>                    EntryPoints;                                       // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TabletScreenBrightness;                            // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseFixedExposureWhenViewingTablet : 1;            // 0x0104(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F5E[0x3];                                     // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinEV100;                                          // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxEV100;                                          // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ECOOPMode, class FString>                COOPModesLevelMap;                                 // 0x0110(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<ECOOPMode, struct FLoadAdditionalLevels> COOPModesLevelAdditionalMaps;                      // 0x0160(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUnlockRequirements                    UnlockRequirements;                                // 0x01B0(0x0018)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	struct FMapLayout                             MapLayout;                                         // 0x01C8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLoadingScreenAnimated                 LoadingScreen;                                     // 0x0250(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           SupportedGameModes;                                // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FText                                   Author;                                            // 0x02B0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   AuthorContact;                                     // 0x02C8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   RecommendedPlayerCount;                            // 0x02E0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsTestLevel;                                      // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x02F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F5F[0x6];                                     // 0x02FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNVGPostProcessSettings                NVG_PostProcessOverride;                           // 0x0300(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                MVPSequenceLocation;                               // 0x0358(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F60[0x4];                                     // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           Objectives;                                        // 0x0368(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           Challenges;                                        // 0x0378(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FText                                   LevelLocationText;                                 // 0x0388(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LevelMonthNum;                                     // 0x03A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LevelDayNum;                                       // 0x03B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LevelYearNum;                                      // 0x03D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMissionAudio                          TocBriefingAudio;                                  // 0x03E8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FMissionAudio>                  MissionAudio;                                      // 0x0448(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMissionDoc>                    Documents;                                         // 0x0458(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMissionPhoto>                  Photos;                                            // 0x0468(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   MissionStartTocVoiceLine;                          // 0x0478(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCharacterBio>                  SuspectsBios;                                      // 0x0480(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterBio>                  CiviliansBios;                                     // 0x0490(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FMissionTimeline                       MissionTimeline;                                   // 0x04A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         BaseSquadPts;                                      // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F61[0x4];                                     // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLevelFloorData>                MapFloors;                                         // 0x04B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FSpawnPoints                           Spawn_1;                                           // 0x04C8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FSpawnPoints                           Spawn_2;                                           // 0x0558(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FSpawnPoints                           Spawn_3;                                           // 0x05E8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FSpawnPoints                           Spawn_4;                                           // 0x0678(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FAIRoster>                      AISpawnRosters;                                    // 0x0708(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FDynamicLevelRoster>            DynamicLevelSpawnRosters;                          // 0x0718(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTrapRoster>                    TrapRosters;                                       // 0x0728(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FPersonnelMapPoint>             AllPersonnelMapPoints;                             // 0x0738(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FPersonnelEntry>                AllPersonnel;                                      // 0x0748(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLevelDeployableData>           Deployables;                                       // 0x0758(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLevelDeployableDepot>          DeployableDepots;                                  // 0x0768(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    PropHuntMeshes;                                    // 0x0778(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelDataLookupTable) == 0x000008, "Wrong alignment on FLevelDataLookupTable");
static_assert(sizeof(FLevelDataLookupTable) == 0x000788, "Wrong size on FLevelDataLookupTable");
static_assert(offsetof(FLevelDataLookupTable, FriendlyLevelName) == 0x000008, "Member 'FLevelDataLookupTable::FriendlyLevelName' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, LevelNickname) == 0x000020, "Member 'FLevelDataLookupTable::LevelNickname' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, LevelPicture) == 0x000038, "Member 'FLevelDataLookupTable::LevelPicture' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, LevelDesignation) == 0x000060, "Member 'FLevelDataLookupTable::LevelDesignation' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, TimeOfDayText) == 0x000078, "Member 'FLevelDataLookupTable::TimeOfDayText' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, Description) == 0x000090, "Member 'FLevelDataLookupTable::Description' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, ProgressionTagPrefix) == 0x0000A8, "Member 'FLevelDataLookupTable::ProgressionTagPrefix' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, MissionSelectMap) == 0x0000B0, "Member 'FLevelDataLookupTable::MissionSelectMap' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, DefaultFloorIndex) == 0x0000D8, "Member 'FLevelDataLookupTable::DefaultFloorIndex' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, Floors) == 0x0000E0, "Member 'FLevelDataLookupTable::Floors' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, EntryPoints) == 0x0000F0, "Member 'FLevelDataLookupTable::EntryPoints' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, TabletScreenBrightness) == 0x000100, "Member 'FLevelDataLookupTable::TabletScreenBrightness' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, MinEV100) == 0x000108, "Member 'FLevelDataLookupTable::MinEV100' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, MaxEV100) == 0x00010C, "Member 'FLevelDataLookupTable::MaxEV100' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, COOPModesLevelMap) == 0x000110, "Member 'FLevelDataLookupTable::COOPModesLevelMap' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, COOPModesLevelAdditionalMaps) == 0x000160, "Member 'FLevelDataLookupTable::COOPModesLevelAdditionalMaps' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, UnlockRequirements) == 0x0001B0, "Member 'FLevelDataLookupTable::UnlockRequirements' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, MapLayout) == 0x0001C8, "Member 'FLevelDataLookupTable::MapLayout' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, LoadingScreen) == 0x000250, "Member 'FLevelDataLookupTable::LoadingScreen' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, SupportedGameModes) == 0x0002A0, "Member 'FLevelDataLookupTable::SupportedGameModes' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, Author) == 0x0002B0, "Member 'FLevelDataLookupTable::Author' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, AuthorContact) == 0x0002C8, "Member 'FLevelDataLookupTable::AuthorContact' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, RecommendedPlayerCount) == 0x0002E0, "Member 'FLevelDataLookupTable::RecommendedPlayerCount' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, bIsTestLevel) == 0x0002F8, "Member 'FLevelDataLookupTable::bIsTestLevel' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, bVisible) == 0x0002F9, "Member 'FLevelDataLookupTable::bVisible' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, NVG_PostProcessOverride) == 0x000300, "Member 'FLevelDataLookupTable::NVG_PostProcessOverride' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, MVPSequenceLocation) == 0x000358, "Member 'FLevelDataLookupTable::MVPSequenceLocation' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, Objectives) == 0x000368, "Member 'FLevelDataLookupTable::Objectives' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, Challenges) == 0x000378, "Member 'FLevelDataLookupTable::Challenges' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, LevelLocationText) == 0x000388, "Member 'FLevelDataLookupTable::LevelLocationText' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, LevelMonthNum) == 0x0003A0, "Member 'FLevelDataLookupTable::LevelMonthNum' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, LevelDayNum) == 0x0003B8, "Member 'FLevelDataLookupTable::LevelDayNum' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, LevelYearNum) == 0x0003D0, "Member 'FLevelDataLookupTable::LevelYearNum' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, TocBriefingAudio) == 0x0003E8, "Member 'FLevelDataLookupTable::TocBriefingAudio' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, MissionAudio) == 0x000448, "Member 'FLevelDataLookupTable::MissionAudio' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, Documents) == 0x000458, "Member 'FLevelDataLookupTable::Documents' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, Photos) == 0x000468, "Member 'FLevelDataLookupTable::Photos' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, MissionStartTocVoiceLine) == 0x000478, "Member 'FLevelDataLookupTable::MissionStartTocVoiceLine' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, SuspectsBios) == 0x000480, "Member 'FLevelDataLookupTable::SuspectsBios' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, CiviliansBios) == 0x000490, "Member 'FLevelDataLookupTable::CiviliansBios' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, MissionTimeline) == 0x0004A0, "Member 'FLevelDataLookupTable::MissionTimeline' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, BaseSquadPts) == 0x0004B0, "Member 'FLevelDataLookupTable::BaseSquadPts' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, MapFloors) == 0x0004B8, "Member 'FLevelDataLookupTable::MapFloors' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, Spawn_1) == 0x0004C8, "Member 'FLevelDataLookupTable::Spawn_1' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, Spawn_2) == 0x000558, "Member 'FLevelDataLookupTable::Spawn_2' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, Spawn_3) == 0x0005E8, "Member 'FLevelDataLookupTable::Spawn_3' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, Spawn_4) == 0x000678, "Member 'FLevelDataLookupTable::Spawn_4' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, AISpawnRosters) == 0x000708, "Member 'FLevelDataLookupTable::AISpawnRosters' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, DynamicLevelSpawnRosters) == 0x000718, "Member 'FLevelDataLookupTable::DynamicLevelSpawnRosters' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, TrapRosters) == 0x000728, "Member 'FLevelDataLookupTable::TrapRosters' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, AllPersonnelMapPoints) == 0x000738, "Member 'FLevelDataLookupTable::AllPersonnelMapPoints' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, AllPersonnel) == 0x000748, "Member 'FLevelDataLookupTable::AllPersonnel' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, Deployables) == 0x000758, "Member 'FLevelDataLookupTable::Deployables' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, DeployableDepots) == 0x000768, "Member 'FLevelDataLookupTable::DeployableDepots' has a wrong offset!");
static_assert(offsetof(FLevelDataLookupTable, PropHuntMeshes) == 0x000778, "Member 'FLevelDataLookupTable::PropHuntMeshes' has a wrong offset!");

// ScriptStruct ReadyOrNot.AnimTurnTransition
// 0x0010 (0x0010 - 0x0000)
struct FAnimTurnTransition final 
{
public:
	class UAnimSequence*                          Anim;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayBeforeTrigger;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F62[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimTurnTransition) == 0x000008, "Wrong alignment on FAnimTurnTransition");
static_assert(sizeof(FAnimTurnTransition) == 0x000010, "Wrong size on FAnimTurnTransition");
static_assert(offsetof(FAnimTurnTransition, Anim) == 0x000000, "Member 'FAnimTurnTransition::Anim' has a wrong offset!");
static_assert(offsetof(FAnimTurnTransition, DelayBeforeTrigger) == 0x000008, "Member 'FAnimTurnTransition::DelayBeforeTrigger' has a wrong offset!");

// ScriptStruct ReadyOrNot.FactionTeamTactics
// 0x0010 (0x0010 - 0x0000)
struct FFactionTeamTactics final 
{
public:
	TArray<EAITeamTactic>                         Tactics;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFactionTeamTactics) == 0x000008, "Wrong alignment on FFactionTeamTactics");
static_assert(sizeof(FFactionTeamTactics) == 0x000010, "Wrong size on FFactionTeamTactics");
static_assert(offsetof(FFactionTeamTactics, Tactics) == 0x000000, "Member 'FFactionTeamTactics::Tactics' has a wrong offset!");

// ScriptStruct ReadyOrNot.SteamAuthenticationToken
// 0x0020 (0x0020 - 0x0000)
struct FSteamAuthenticationToken final 
{
public:
	class FString                                 RgchTokenString;                                   // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UnTokenLen;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F63[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        SteamId;                                           // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSteamAuthenticationToken) == 0x000008, "Wrong alignment on FSteamAuthenticationToken");
static_assert(sizeof(FSteamAuthenticationToken) == 0x000020, "Wrong size on FSteamAuthenticationToken");
static_assert(offsetof(FSteamAuthenticationToken, RgchTokenString) == 0x000000, "Member 'FSteamAuthenticationToken::RgchTokenString' has a wrong offset!");
static_assert(offsetof(FSteamAuthenticationToken, UnTokenLen) == 0x000010, "Member 'FSteamAuthenticationToken::UnTokenLen' has a wrong offset!");
static_assert(offsetof(FSteamAuthenticationToken, SteamId) == 0x000018, "Member 'FSteamAuthenticationToken::SteamId' has a wrong offset!");

// ScriptStruct ReadyOrNot.InGameLogMessage
// 0x0038 (0x0038 - 0x0000)
struct FInGameLogMessage final 
{
public:
	EDebugLogType                                 LogSeverity;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAutoDetermineIcon : 1;                            // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F64[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LogMessage;                                        // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         DelayBetweenWords;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayBetweenLetters;                               // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOnScreen;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F65[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInGameLogMessage) == 0x000008, "Wrong alignment on FInGameLogMessage");
static_assert(sizeof(FInGameLogMessage) == 0x000038, "Wrong size on FInGameLogMessage");
static_assert(offsetof(FInGameLogMessage, LogSeverity) == 0x000000, "Member 'FInGameLogMessage::LogSeverity' has a wrong offset!");
static_assert(offsetof(FInGameLogMessage, Icon) == 0x000008, "Member 'FInGameLogMessage::Icon' has a wrong offset!");
static_assert(offsetof(FInGameLogMessage, LogMessage) == 0x000010, "Member 'FInGameLogMessage::LogMessage' has a wrong offset!");
static_assert(offsetof(FInGameLogMessage, DelayBetweenWords) == 0x000028, "Member 'FInGameLogMessage::DelayBetweenWords' has a wrong offset!");
static_assert(offsetof(FInGameLogMessage, DelayBetweenLetters) == 0x00002C, "Member 'FInGameLogMessage::DelayBetweenLetters' has a wrong offset!");
static_assert(offsetof(FInGameLogMessage, TimeOnScreen) == 0x000030, "Member 'FInGameLogMessage::TimeOnScreen' has a wrong offset!");

// ScriptStruct ReadyOrNot.DistanceMatchAnimation
// 0x0020 (0x0020 - 0x0000)
struct FDistanceMatchAnimation final 
{
public:
	class UAnimSequence*                          Animation;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DistanceCurveName;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDistanceLimit;                              // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F66[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceLimit;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendoutTime;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F67[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDistanceMatchAnimation) == 0x000008, "Wrong alignment on FDistanceMatchAnimation");
static_assert(sizeof(FDistanceMatchAnimation) == 0x000020, "Wrong size on FDistanceMatchAnimation");
static_assert(offsetof(FDistanceMatchAnimation, Animation) == 0x000000, "Member 'FDistanceMatchAnimation::Animation' has a wrong offset!");
static_assert(offsetof(FDistanceMatchAnimation, DistanceCurveName) == 0x000008, "Member 'FDistanceMatchAnimation::DistanceCurveName' has a wrong offset!");
static_assert(offsetof(FDistanceMatchAnimation, bEnableDistanceLimit) == 0x000010, "Member 'FDistanceMatchAnimation::bEnableDistanceLimit' has a wrong offset!");
static_assert(offsetof(FDistanceMatchAnimation, DistanceLimit) == 0x000014, "Member 'FDistanceMatchAnimation::DistanceLimit' has a wrong offset!");
static_assert(offsetof(FDistanceMatchAnimation, BlendoutTime) == 0x000018, "Member 'FDistanceMatchAnimation::BlendoutTime' has a wrong offset!");

// ScriptStruct ReadyOrNot.InGameLogMessage_PVP
// 0x0038 (0x0038 - 0x0000)
struct FInGameLogMessage_PVP final 
{
public:
	class AReadyOrNotCharacter*                   Causer;                                            // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   Victim;                                            // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPVPEvent                                     PVPEvent;                                          // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F68[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CustomMessage;                                     // 0x0018(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	ECharacterDeathReason                         CauseOfDeath;                                      // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F69[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeOnScreen;                                      // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInGameLogMessage_PVP) == 0x000008, "Wrong alignment on FInGameLogMessage_PVP");
static_assert(sizeof(FInGameLogMessage_PVP) == 0x000038, "Wrong size on FInGameLogMessage_PVP");
static_assert(offsetof(FInGameLogMessage_PVP, Causer) == 0x000000, "Member 'FInGameLogMessage_PVP::Causer' has a wrong offset!");
static_assert(offsetof(FInGameLogMessage_PVP, Victim) == 0x000008, "Member 'FInGameLogMessage_PVP::Victim' has a wrong offset!");
static_assert(offsetof(FInGameLogMessage_PVP, PVPEvent) == 0x000010, "Member 'FInGameLogMessage_PVP::PVPEvent' has a wrong offset!");
static_assert(offsetof(FInGameLogMessage_PVP, CustomMessage) == 0x000018, "Member 'FInGameLogMessage_PVP::CustomMessage' has a wrong offset!");
static_assert(offsetof(FInGameLogMessage_PVP, CauseOfDeath) == 0x000030, "Member 'FInGameLogMessage_PVP::CauseOfDeath' has a wrong offset!");
static_assert(offsetof(FInGameLogMessage_PVP, TimeOnScreen) == 0x000034, "Member 'FInGameLogMessage_PVP::TimeOnScreen' has a wrong offset!");

// ScriptStruct ReadyOrNot.UniversalStat
// 0x000C (0x000C - 0x0000)
struct FUniversalStat final 
{
public:
	EUniversalStatType                            StatType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F6A[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntegerValue;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniversalStat) == 0x000004, "Wrong alignment on FUniversalStat");
static_assert(sizeof(FUniversalStat) == 0x00000C, "Wrong size on FUniversalStat");
static_assert(offsetof(FUniversalStat, StatType) == 0x000000, "Member 'FUniversalStat::StatType' has a wrong offset!");
static_assert(offsetof(FUniversalStat, IntegerValue) == 0x000004, "Member 'FUniversalStat::IntegerValue' has a wrong offset!");
static_assert(offsetof(FUniversalStat, FloatValue) == 0x000008, "Member 'FUniversalStat::FloatValue' has a wrong offset!");

// ScriptStruct ReadyOrNot.SwatCommandData
// 0x0038 (0x0038 - 0x0000)
struct FSwatCommandData final 
{
public:
	ESwatCommand                                  Command;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     Team;                                              // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F6B[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AActor>                  Target;                                            // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQueue;                                            // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F6C[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSwatCommandData) == 0x000008, "Wrong alignment on FSwatCommandData");
static_assert(sizeof(FSwatCommandData) == 0x000038, "Wrong size on FSwatCommandData");
static_assert(offsetof(FSwatCommandData, Command) == 0x000000, "Member 'FSwatCommandData::Command' has a wrong offset!");
static_assert(offsetof(FSwatCommandData, Team) == 0x000001, "Member 'FSwatCommandData::Team' has a wrong offset!");
static_assert(offsetof(FSwatCommandData, Target) == 0x000008, "Member 'FSwatCommandData::Target' has a wrong offset!");
static_assert(offsetof(FSwatCommandData, bQueue) == 0x000030, "Member 'FSwatCommandData::bQueue' has a wrong offset!");

// ScriptStruct ReadyOrNot.ActivityStateTransition
// 0x0038 (0x0038 - 0x0000)
struct FActivityStateTransition final 
{
public:
	int32                                         TransitionToStateID;                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F6D[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TransitionToStateName;                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F6E[0x14];                                    // 0x001C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UActivityState*                         ToState;                                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActivityStateTransition) == 0x000008, "Wrong alignment on FActivityStateTransition");
static_assert(sizeof(FActivityStateTransition) == 0x000038, "Wrong size on FActivityStateTransition");
static_assert(offsetof(FActivityStateTransition, TransitionToStateID) == 0x000000, "Member 'FActivityStateTransition::TransitionToStateID' has a wrong offset!");
static_assert(offsetof(FActivityStateTransition, TransitionToStateName) == 0x000008, "Member 'FActivityStateTransition::TransitionToStateName' has a wrong offset!");
static_assert(offsetof(FActivityStateTransition, Priority) == 0x000018, "Member 'FActivityStateTransition::Priority' has a wrong offset!");
static_assert(offsetof(FActivityStateTransition, ToState) == 0x000030, "Member 'FActivityStateTransition::ToState' has a wrong offset!");

// ScriptStruct ReadyOrNot.ActivityEvent
// 0x0048 (0x0048 - 0x0000)
struct FActivityEvent final 
{
public:
	EEventType                                    EventType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStandaloneEvent                              StandaloneEvent;                                   // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetEvent                                  TargetEvent;                                       // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F6F[0x5];                                     // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AActor>                  TargetActor;                                       // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FmodAudioEvent;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              UnrealAudioEvent;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnlyOnce;                                  // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F70[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActivityEvent) == 0x000008, "Wrong alignment on FActivityEvent");
static_assert(sizeof(FActivityEvent) == 0x000048, "Wrong size on FActivityEvent");
static_assert(offsetof(FActivityEvent, EventType) == 0x000000, "Member 'FActivityEvent::EventType' has a wrong offset!");
static_assert(offsetof(FActivityEvent, StandaloneEvent) == 0x000001, "Member 'FActivityEvent::StandaloneEvent' has a wrong offset!");
static_assert(offsetof(FActivityEvent, TargetEvent) == 0x000002, "Member 'FActivityEvent::TargetEvent' has a wrong offset!");
static_assert(offsetof(FActivityEvent, TargetActor) == 0x000008, "Member 'FActivityEvent::TargetActor' has a wrong offset!");
static_assert(offsetof(FActivityEvent, FmodAudioEvent) == 0x000030, "Member 'FActivityEvent::FmodAudioEvent' has a wrong offset!");
static_assert(offsetof(FActivityEvent, UnrealAudioEvent) == 0x000038, "Member 'FActivityEvent::UnrealAudioEvent' has a wrong offset!");
static_assert(offsetof(FActivityEvent, bTriggerOnlyOnce) == 0x000040, "Member 'FActivityEvent::bTriggerOnlyOnce' has a wrong offset!");

// ScriptStruct ReadyOrNot.LoadoutEquipOptions
// 0x0018 (0x0018 - 0x0000)
struct FLoadoutEquipOptions final 
{
public:
	EItemCategory                                 EquipItemCategory;                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicates;                                       // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F71[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotPlayerState*                 OverridePlayerState;                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSanitizeLoadout;                                  // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F72[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadoutEquipOptions) == 0x000008, "Wrong alignment on FLoadoutEquipOptions");
static_assert(sizeof(FLoadoutEquipOptions) == 0x000018, "Wrong size on FLoadoutEquipOptions");
static_assert(offsetof(FLoadoutEquipOptions, EquipItemCategory) == 0x000000, "Member 'FLoadoutEquipOptions::EquipItemCategory' has a wrong offset!");
static_assert(offsetof(FLoadoutEquipOptions, bReplicates) == 0x000001, "Member 'FLoadoutEquipOptions::bReplicates' has a wrong offset!");
static_assert(offsetof(FLoadoutEquipOptions, OverridePlayerState) == 0x000008, "Member 'FLoadoutEquipOptions::OverridePlayerState' has a wrong offset!");
static_assert(offsetof(FLoadoutEquipOptions, bSanitizeLoadout) == 0x000010, "Member 'FLoadoutEquipOptions::bSanitizeLoadout' has a wrong offset!");

// ScriptStruct ReadyOrNot.ExitRoute
// 0x0030 (0x0030 - 0x0000)
struct FExitRoute final 
{
public:
	TArray<class ADoor*>                          Doors;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class AThreatAwarenessActor*>          ThreatsOnRoute;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         PathCost;                                          // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0024(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExitRoute) == 0x000008, "Wrong alignment on FExitRoute");
static_assert(sizeof(FExitRoute) == 0x000030, "Wrong size on FExitRoute");
static_assert(offsetof(FExitRoute, Doors) == 0x000000, "Member 'FExitRoute::Doors' has a wrong offset!");
static_assert(offsetof(FExitRoute, ThreatsOnRoute) == 0x000010, "Member 'FExitRoute::ThreatsOnRoute' has a wrong offset!");
static_assert(offsetof(FExitRoute, PathCost) == 0x000020, "Member 'FExitRoute::PathCost' has a wrong offset!");
static_assert(offsetof(FExitRoute, Location) == 0x000024, "Member 'FExitRoute::Location' has a wrong offset!");

// ScriptStruct ReadyOrNot.ExitData
// 0x0020 (0x0020 - 0x0000)
struct FExitData final 
{
public:
	TArray<struct FExitRoute>                     PossibleRoutes;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F73[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExitData) == 0x000008, "Wrong alignment on FExitData");
static_assert(sizeof(FExitData) == 0x000020, "Wrong size on FExitData");
static_assert(offsetof(FExitData, PossibleRoutes) == 0x000000, "Member 'FExitData::PossibleRoutes' has a wrong offset!");
static_assert(offsetof(FExitData, Location) == 0x000010, "Member 'FExitData::Location' has a wrong offset!");

// ScriptStruct ReadyOrNot.AIActionDecisionContext
// 0x0010 (0x0010 - 0x0000)
struct FAIActionDecisionContext final 
{
public:
	class ACyberneticController*                  Controller;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIActionDecisionContext) == 0x000008, "Wrong alignment on FAIActionDecisionContext");
static_assert(sizeof(FAIActionDecisionContext) == 0x000010, "Wrong size on FAIActionDecisionContext");
static_assert(offsetof(FAIActionDecisionContext, Controller) == 0x000000, "Member 'FAIActionDecisionContext::Controller' has a wrong offset!");
static_assert(offsetof(FAIActionDecisionContext, World) == 0x000008, "Member 'FAIActionDecisionContext::World' has a wrong offset!");

// ScriptStruct ReadyOrNot.AIDataLookupTable
// 0x0390 (0x0398 - 0x0008)
struct FAIDataLookupTable final  : public FTableRowBase
{
public:
	class UAIArchetypeData*                       Archetype;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ECOOPMode, class UAIArchetypeData*>      GameModeArchetypeOverride;                         // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    Faction;                                           // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bIsLeaderOfFaction : 1;                            // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F74[0x7];                                     // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIMoveDataBlock                       DefaultMoveData;                                   // 0x0078(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAIMovementStyleData                   MovementStyle;                                     // 0x0110(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseRandomLoadout;                                 // 0x0150(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F75[0x7];                                     // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ABaseItem>>          AIWeaponSelection;                                 // 0x0158(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FName>                           AIAmmoTypeSelection;                               // 0x0168(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ChanceToFireGunOnDeath;                            // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F76[0x4];                                     // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AIBodyArmourSelection;                             // 0x0180(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           AIHelmetSelection;                                 // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ASuspectArmour>             AIBodyArmourOverride;                              // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSavedLoadout                          DefaultLoadout;                                    // 0x01A8(0x0188)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ETeamType                                     SpawningTeamType;                                  // 0x0330(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F77[0x7];                                     // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACyberneticCharacter>       CharacterClass;                                    // 0x0338(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCharacterMesh>                 RandomCharacterMesh;                               // 0x0340(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bOverrideControllerClass : 1;                      // 0x0350(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F78[0x7];                                     // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AAIController>              ControllerClass;                                   // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Tags;                                              // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bChanceToSurrenderWithItem : 1;                    // 0x0370(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideSurrenderWithItemChance : 1;              // 0x0370(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F79[0x3];                                     // 0x0371(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SurrenderWithItemChance;                           // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         SurrenderItems;                                    // 0x0378(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCanEverSuicide;                                   // 0x0388(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSuicideChance;                            // 0x0389(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F7A[0x2];                                     // 0x038A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SuicideChance;                                     // 0x038C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmuneToGas;                                      // 0x0390(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F7B[0x7];                                     // 0x0391(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDataLookupTable) == 0x000008, "Wrong alignment on FAIDataLookupTable");
static_assert(sizeof(FAIDataLookupTable) == 0x000398, "Wrong size on FAIDataLookupTable");
static_assert(offsetof(FAIDataLookupTable, Archetype) == 0x000008, "Member 'FAIDataLookupTable::Archetype' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, GameModeArchetypeOverride) == 0x000010, "Member 'FAIDataLookupTable::GameModeArchetypeOverride' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, Faction) == 0x000060, "Member 'FAIDataLookupTable::Faction' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, DefaultMoveData) == 0x000078, "Member 'FAIDataLookupTable::DefaultMoveData' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, MovementStyle) == 0x000110, "Member 'FAIDataLookupTable::MovementStyle' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, bUseRandomLoadout) == 0x000150, "Member 'FAIDataLookupTable::bUseRandomLoadout' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, AIWeaponSelection) == 0x000158, "Member 'FAIDataLookupTable::AIWeaponSelection' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, AIAmmoTypeSelection) == 0x000168, "Member 'FAIDataLookupTable::AIAmmoTypeSelection' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, ChanceToFireGunOnDeath) == 0x000178, "Member 'FAIDataLookupTable::ChanceToFireGunOnDeath' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, AIBodyArmourSelection) == 0x000180, "Member 'FAIDataLookupTable::AIBodyArmourSelection' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, AIHelmetSelection) == 0x000190, "Member 'FAIDataLookupTable::AIHelmetSelection' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, AIBodyArmourOverride) == 0x0001A0, "Member 'FAIDataLookupTable::AIBodyArmourOverride' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, DefaultLoadout) == 0x0001A8, "Member 'FAIDataLookupTable::DefaultLoadout' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, SpawningTeamType) == 0x000330, "Member 'FAIDataLookupTable::SpawningTeamType' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, CharacterClass) == 0x000338, "Member 'FAIDataLookupTable::CharacterClass' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, RandomCharacterMesh) == 0x000340, "Member 'FAIDataLookupTable::RandomCharacterMesh' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, ControllerClass) == 0x000358, "Member 'FAIDataLookupTable::ControllerClass' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, Tags) == 0x000360, "Member 'FAIDataLookupTable::Tags' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, SurrenderWithItemChance) == 0x000374, "Member 'FAIDataLookupTable::SurrenderWithItemChance' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, SurrenderItems) == 0x000378, "Member 'FAIDataLookupTable::SurrenderItems' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, bCanEverSuicide) == 0x000388, "Member 'FAIDataLookupTable::bCanEverSuicide' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, bOverrideSuicideChance) == 0x000389, "Member 'FAIDataLookupTable::bOverrideSuicideChance' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, SuicideChance) == 0x00038C, "Member 'FAIDataLookupTable::SuicideChance' has a wrong offset!");
static_assert(offsetof(FAIDataLookupTable, bImmuneToGas) == 0x000390, "Member 'FAIDataLookupTable::bImmuneToGas' has a wrong offset!");

// ScriptStruct ReadyOrNot.AIFactionTable
// 0x0018 (0x0020 - 0x0008)
struct FAIFactionTable final  : public FTableRowBase
{
public:
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AAIFactionManager>          Manager;                                           // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIFactionTable) == 0x000008, "Wrong alignment on FAIFactionTable");
static_assert(sizeof(FAIFactionTable) == 0x000020, "Wrong size on FAIFactionTable");
static_assert(offsetof(FAIFactionTable, Name) == 0x000008, "Member 'FAIFactionTable::Name' has a wrong offset!");
static_assert(offsetof(FAIFactionTable, Manager) == 0x000018, "Member 'FAIFactionTable::Manager' has a wrong offset!");

// ScriptStruct ReadyOrNot.SpawnData
// 0x0088 (0x0088 - 0x0000)
struct FSpawnData final 
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    SpawnedAI;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bForceNoWeapon;                                    // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeactivated;                                      // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F7C[0x6];                                     // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseWeapon>                ForceWeaponOverride;                               // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ForceBodyArmourOverride;                           // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SpawnWithTags;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FActivityRouteCollection               ActivityRouteCollection;                           // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ACoverLandmark>          SpawnInLandmark;                                   // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnData) == 0x000008, "Wrong alignment on FSpawnData");
static_assert(sizeof(FSpawnData) == 0x000088, "Wrong size on FSpawnData");
static_assert(offsetof(FSpawnData, Name) == 0x000000, "Member 'FSpawnData::Name' has a wrong offset!");
static_assert(offsetof(FSpawnData, SpawnedAI) == 0x000008, "Member 'FSpawnData::SpawnedAI' has a wrong offset!");
static_assert(offsetof(FSpawnData, bForceNoWeapon) == 0x000018, "Member 'FSpawnData::bForceNoWeapon' has a wrong offset!");
static_assert(offsetof(FSpawnData, bDeactivated) == 0x000019, "Member 'FSpawnData::bDeactivated' has a wrong offset!");
static_assert(offsetof(FSpawnData, ForceWeaponOverride) == 0x000020, "Member 'FSpawnData::ForceWeaponOverride' has a wrong offset!");
static_assert(offsetof(FSpawnData, ForceBodyArmourOverride) == 0x000028, "Member 'FSpawnData::ForceBodyArmourOverride' has a wrong offset!");
static_assert(offsetof(FSpawnData, SpawnWithTags) == 0x000030, "Member 'FSpawnData::SpawnWithTags' has a wrong offset!");
static_assert(offsetof(FSpawnData, ActivityRouteCollection) == 0x000040, "Member 'FSpawnData::ActivityRouteCollection' has a wrong offset!");
static_assert(offsetof(FSpawnData, SpawnInLandmark) == 0x000060, "Member 'FSpawnData::SpawnInLandmark' has a wrong offset!");

// ScriptStruct ReadyOrNot.AnimStanceData
// 0x0020 (0x0020 - 0x0000)
struct FAnimStanceData final 
{
public:
	struct FAnimWeaponData                        StandingAnimData;                                  // 0x0000(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAnimWeaponData                        CrouchedAnimData;                                  // 0x0010(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimStanceData) == 0x000008, "Wrong alignment on FAnimStanceData");
static_assert(sizeof(FAnimStanceData) == 0x000020, "Wrong size on FAnimStanceData");
static_assert(offsetof(FAnimStanceData, StandingAnimData) == 0x000000, "Member 'FAnimStanceData::StandingAnimData' has a wrong offset!");
static_assert(offsetof(FAnimStanceData, CrouchedAnimData) == 0x000010, "Member 'FAnimStanceData::CrouchedAnimData' has a wrong offset!");

// ScriptStruct ReadyOrNot.AnimationDataTable
// 0x00C0 (0x00C8 - 0x0008)
struct FAnimationDataTable final  : public FTableRowBase
{
public:
	TMap<EAnimWeaponType, struct FAnimStanceData> AnimData;                                          // 0x0008(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bRestartIfAlreadyPlaying;                          // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F7D[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRandomDelay;                                    // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cooldown;                                          // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoCanPlayWhileStrafing;                           // 0x0064(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoCanPlayWhileNotStrafing;                        // 0x0065(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanQueue;                                         // 0x0066(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAnimationBeInterupted;                         // 0x0067(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseItem>, class FString> OverrideAnimation;                                 // 0x0068(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FString>                         CanOnlyBeInteruptedBy;                             // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationDataTable) == 0x000008, "Wrong alignment on FAnimationDataTable");
static_assert(sizeof(FAnimationDataTable) == 0x0000C8, "Wrong size on FAnimationDataTable");
static_assert(offsetof(FAnimationDataTable, AnimData) == 0x000008, "Member 'FAnimationDataTable::AnimData' has a wrong offset!");
static_assert(offsetof(FAnimationDataTable, bRestartIfAlreadyPlaying) == 0x000058, "Member 'FAnimationDataTable::bRestartIfAlreadyPlaying' has a wrong offset!");
static_assert(offsetof(FAnimationDataTable, MaxRandomDelay) == 0x00005C, "Member 'FAnimationDataTable::MaxRandomDelay' has a wrong offset!");
static_assert(offsetof(FAnimationDataTable, Cooldown) == 0x000060, "Member 'FAnimationDataTable::Cooldown' has a wrong offset!");
static_assert(offsetof(FAnimationDataTable, bNoCanPlayWhileStrafing) == 0x000064, "Member 'FAnimationDataTable::bNoCanPlayWhileStrafing' has a wrong offset!");
static_assert(offsetof(FAnimationDataTable, bNoCanPlayWhileNotStrafing) == 0x000065, "Member 'FAnimationDataTable::bNoCanPlayWhileNotStrafing' has a wrong offset!");
static_assert(offsetof(FAnimationDataTable, bCanQueue) == 0x000066, "Member 'FAnimationDataTable::bCanQueue' has a wrong offset!");
static_assert(offsetof(FAnimationDataTable, bCanAnimationBeInterupted) == 0x000067, "Member 'FAnimationDataTable::bCanAnimationBeInterupted' has a wrong offset!");
static_assert(offsetof(FAnimationDataTable, OverrideAnimation) == 0x000068, "Member 'FAnimationDataTable::OverrideAnimation' has a wrong offset!");
static_assert(offsetof(FAnimationDataTable, CanOnlyBeInteruptedBy) == 0x0000B8, "Member 'FAnimationDataTable::CanOnlyBeInteruptedBy' has a wrong offset!");

// ScriptStruct ReadyOrNot.AnimSectionData
// 0x0008 (0x0008 - 0x0000)
struct FAnimSectionData final 
{
public:
	float                                         SectionStart;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SectionEnd;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSectionData) == 0x000004, "Wrong alignment on FAnimSectionData");
static_assert(sizeof(FAnimSectionData) == 0x000008, "Wrong size on FAnimSectionData");
static_assert(offsetof(FAnimSectionData, SectionStart) == 0x000000, "Member 'FAnimSectionData::SectionStart' has a wrong offset!");
static_assert(offsetof(FAnimSectionData, SectionEnd) == 0x000004, "Member 'FAnimSectionData::SectionEnd' has a wrong offset!");

// ScriptStruct ReadyOrNot.PredictionResult
// 0x0020 (0x0020 - 0x0000)
struct FPredictionResult final 
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceAbsolute;                                  // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawAngle;                                          // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPredictionResult) == 0x000004, "Wrong alignment on FPredictionResult");
static_assert(sizeof(FPredictionResult) == 0x000020, "Wrong size on FPredictionResult");
static_assert(offsetof(FPredictionResult, Location) == 0x000000, "Member 'FPredictionResult::Location' has a wrong offset!");
static_assert(offsetof(FPredictionResult, Distance) == 0x00000C, "Member 'FPredictionResult::Distance' has a wrong offset!");
static_assert(offsetof(FPredictionResult, DistanceAbsolute) == 0x000010, "Member 'FPredictionResult::DistanceAbsolute' has a wrong offset!");
static_assert(offsetof(FPredictionResult, Time) == 0x000014, "Member 'FPredictionResult::Time' has a wrong offset!");
static_assert(offsetof(FPredictionResult, Speed) == 0x000018, "Member 'FPredictionResult::Speed' has a wrong offset!");
static_assert(offsetof(FPredictionResult, YawAngle) == 0x00001C, "Member 'FPredictionResult::YawAngle' has a wrong offset!");

// ScriptStruct ReadyOrNot.AnimCharacterMovementSnapshot
// 0x0094 (0x0094 - 0x0000)
struct FAnimCharacterMovementSnapshot final 
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastWorldLocation;                                 // 0x000C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldVelocity;                                     // 0x0018(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalVelocity;                                     // 0x0024(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldAcceleration;                                 // 0x0030(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalAcceleration;                                 // 0x003C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalVelocityDirection;                            // 0x0048(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalAccelerationDirection;                        // 0x0054(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimCardinalDirection                        CurrentCardinalDirection;                          // 0x0060(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F7E[0x3];                                     // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VelocityYawAngle;                                  // 0x0064(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationYawAngle;                              // 0x0068(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityYawDeltaNorth;                             // 0x006C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityYawDeltaEast;                              // 0x0070(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityYawDeltaSouth;                             // 0x0074(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityYawDeltaWest;                              // 0x0078(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance2DTraveledSinceLastUpdate;                 // 0x007C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed2D;                                           // 0x0080(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationSize2D;                                // 0x0084(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnGround;                                       // 0x0088(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x0089(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAccelerating;                                   // 0x008A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingAndAccelerating;                          // 0x008B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingOrAccelerating;                           // 0x008C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNotMovingOrAccelerating;                        // 0x008D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNotMoving;                                      // 0x008E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNotAccelerating;                                // 0x008F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNotMovingAndAccelerating;                       // 0x0090(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingAndNotAccelerating;                       // 0x0091(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccelerationOpposesVelocity;                      // 0x0092(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccelerationEqualsVelocity;                       // 0x0093(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimCharacterMovementSnapshot) == 0x000004, "Wrong alignment on FAnimCharacterMovementSnapshot");
static_assert(sizeof(FAnimCharacterMovementSnapshot) == 0x000094, "Wrong size on FAnimCharacterMovementSnapshot");
static_assert(offsetof(FAnimCharacterMovementSnapshot, WorldLocation) == 0x000000, "Member 'FAnimCharacterMovementSnapshot::WorldLocation' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, LastWorldLocation) == 0x00000C, "Member 'FAnimCharacterMovementSnapshot::LastWorldLocation' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, WorldVelocity) == 0x000018, "Member 'FAnimCharacterMovementSnapshot::WorldVelocity' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, LocalVelocity) == 0x000024, "Member 'FAnimCharacterMovementSnapshot::LocalVelocity' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, WorldAcceleration) == 0x000030, "Member 'FAnimCharacterMovementSnapshot::WorldAcceleration' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, LocalAcceleration) == 0x00003C, "Member 'FAnimCharacterMovementSnapshot::LocalAcceleration' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, LocalVelocityDirection) == 0x000048, "Member 'FAnimCharacterMovementSnapshot::LocalVelocityDirection' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, LocalAccelerationDirection) == 0x000054, "Member 'FAnimCharacterMovementSnapshot::LocalAccelerationDirection' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, CurrentCardinalDirection) == 0x000060, "Member 'FAnimCharacterMovementSnapshot::CurrentCardinalDirection' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, VelocityYawAngle) == 0x000064, "Member 'FAnimCharacterMovementSnapshot::VelocityYawAngle' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, AccelerationYawAngle) == 0x000068, "Member 'FAnimCharacterMovementSnapshot::AccelerationYawAngle' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, VelocityYawDeltaNorth) == 0x00006C, "Member 'FAnimCharacterMovementSnapshot::VelocityYawDeltaNorth' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, VelocityYawDeltaEast) == 0x000070, "Member 'FAnimCharacterMovementSnapshot::VelocityYawDeltaEast' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, VelocityYawDeltaSouth) == 0x000074, "Member 'FAnimCharacterMovementSnapshot::VelocityYawDeltaSouth' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, VelocityYawDeltaWest) == 0x000078, "Member 'FAnimCharacterMovementSnapshot::VelocityYawDeltaWest' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, Distance2DTraveledSinceLastUpdate) == 0x00007C, "Member 'FAnimCharacterMovementSnapshot::Distance2DTraveledSinceLastUpdate' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, Speed2D) == 0x000080, "Member 'FAnimCharacterMovementSnapshot::Speed2D' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, AccelerationSize2D) == 0x000084, "Member 'FAnimCharacterMovementSnapshot::AccelerationSize2D' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, bIsOnGround) == 0x000088, "Member 'FAnimCharacterMovementSnapshot::bIsOnGround' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, bIsMoving) == 0x000089, "Member 'FAnimCharacterMovementSnapshot::bIsMoving' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, bIsAccelerating) == 0x00008A, "Member 'FAnimCharacterMovementSnapshot::bIsAccelerating' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, bIsMovingAndAccelerating) == 0x00008B, "Member 'FAnimCharacterMovementSnapshot::bIsMovingAndAccelerating' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, bIsMovingOrAccelerating) == 0x00008C, "Member 'FAnimCharacterMovementSnapshot::bIsMovingOrAccelerating' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, bIsNotMovingOrAccelerating) == 0x00008D, "Member 'FAnimCharacterMovementSnapshot::bIsNotMovingOrAccelerating' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, bIsNotMoving) == 0x00008E, "Member 'FAnimCharacterMovementSnapshot::bIsNotMoving' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, bIsNotAccelerating) == 0x00008F, "Member 'FAnimCharacterMovementSnapshot::bIsNotAccelerating' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, bIsNotMovingAndAccelerating) == 0x000090, "Member 'FAnimCharacterMovementSnapshot::bIsNotMovingAndAccelerating' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, bIsMovingAndNotAccelerating) == 0x000091, "Member 'FAnimCharacterMovementSnapshot::bIsMovingAndNotAccelerating' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, bAccelerationOpposesVelocity) == 0x000092, "Member 'FAnimCharacterMovementSnapshot::bAccelerationOpposesVelocity' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementSnapshot, bAccelerationEqualsVelocity) == 0x000093, "Member 'FAnimCharacterMovementSnapshot::bAccelerationEqualsVelocity' has a wrong offset!");

// ScriptStruct ReadyOrNot.CardinalDirectionSnapshot
// 0x0018 (0x0018 - 0x0000)
struct FCardinalDirectionSnapshot final 
{
public:
	EAnimCardinalDirection                        CardinalDirection;                                 // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F7F[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YawAngle;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawAngleDeltaNorth;                                // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawAngleDeltaEast;                                 // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawAngleDeltaSouth;                                // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawAngleDeltaWest;                                 // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCardinalDirectionSnapshot) == 0x000004, "Wrong alignment on FCardinalDirectionSnapshot");
static_assert(sizeof(FCardinalDirectionSnapshot) == 0x000018, "Wrong size on FCardinalDirectionSnapshot");
static_assert(offsetof(FCardinalDirectionSnapshot, CardinalDirection) == 0x000000, "Member 'FCardinalDirectionSnapshot::CardinalDirection' has a wrong offset!");
static_assert(offsetof(FCardinalDirectionSnapshot, YawAngle) == 0x000004, "Member 'FCardinalDirectionSnapshot::YawAngle' has a wrong offset!");
static_assert(offsetof(FCardinalDirectionSnapshot, YawAngleDeltaNorth) == 0x000008, "Member 'FCardinalDirectionSnapshot::YawAngleDeltaNorth' has a wrong offset!");
static_assert(offsetof(FCardinalDirectionSnapshot, YawAngleDeltaEast) == 0x00000C, "Member 'FCardinalDirectionSnapshot::YawAngleDeltaEast' has a wrong offset!");
static_assert(offsetof(FCardinalDirectionSnapshot, YawAngleDeltaSouth) == 0x000010, "Member 'FCardinalDirectionSnapshot::YawAngleDeltaSouth' has a wrong offset!");
static_assert(offsetof(FCardinalDirectionSnapshot, YawAngleDeltaWest) == 0x000014, "Member 'FCardinalDirectionSnapshot::YawAngleDeltaWest' has a wrong offset!");

// ScriptStruct ReadyOrNot.AnimCharacterMovementPredictionSnapshot
// 0x0020 (0x0020 - 0x0000)
struct FAnimCharacterMovementPredictionSnapshot final 
{
public:
	float                                         GroundFriction;                                    // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingFriction;                                   // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingFrictionFactor;                             // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationWalking;                        // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSeparateBrakingFriction;                       // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F80[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityZ;                                          // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadius;                                     // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHalfHeight;                                 // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimCharacterMovementPredictionSnapshot) == 0x000004, "Wrong alignment on FAnimCharacterMovementPredictionSnapshot");
static_assert(sizeof(FAnimCharacterMovementPredictionSnapshot) == 0x000020, "Wrong size on FAnimCharacterMovementPredictionSnapshot");
static_assert(offsetof(FAnimCharacterMovementPredictionSnapshot, GroundFriction) == 0x000000, "Member 'FAnimCharacterMovementPredictionSnapshot::GroundFriction' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementPredictionSnapshot, BrakingFriction) == 0x000004, "Member 'FAnimCharacterMovementPredictionSnapshot::BrakingFriction' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementPredictionSnapshot, BrakingFrictionFactor) == 0x000008, "Member 'FAnimCharacterMovementPredictionSnapshot::BrakingFrictionFactor' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementPredictionSnapshot, BrakingDecelerationWalking) == 0x00000C, "Member 'FAnimCharacterMovementPredictionSnapshot::BrakingDecelerationWalking' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementPredictionSnapshot, bUseSeparateBrakingFriction) == 0x000010, "Member 'FAnimCharacterMovementPredictionSnapshot::bUseSeparateBrakingFriction' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementPredictionSnapshot, GravityZ) == 0x000014, "Member 'FAnimCharacterMovementPredictionSnapshot::GravityZ' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementPredictionSnapshot, CapsuleRadius) == 0x000018, "Member 'FAnimCharacterMovementPredictionSnapshot::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(FAnimCharacterMovementPredictionSnapshot, CapsuleHalfHeight) == 0x00001C, "Member 'FAnimCharacterMovementPredictionSnapshot::CapsuleHalfHeight' has a wrong offset!");

// ScriptStruct ReadyOrNot.CardinalDirectionBlendSpaceAnimSet
// 0x0020 (0x0020 - 0x0000)
struct FCardinalDirectionBlendSpaceAnimSet final 
{
public:
	class UBlendSpace*                            NorthAnim;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            EastAnim;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            SouthAnim;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            WestAnim;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCardinalDirectionBlendSpaceAnimSet) == 0x000008, "Wrong alignment on FCardinalDirectionBlendSpaceAnimSet");
static_assert(sizeof(FCardinalDirectionBlendSpaceAnimSet) == 0x000020, "Wrong size on FCardinalDirectionBlendSpaceAnimSet");
static_assert(offsetof(FCardinalDirectionBlendSpaceAnimSet, NorthAnim) == 0x000000, "Member 'FCardinalDirectionBlendSpaceAnimSet::NorthAnim' has a wrong offset!");
static_assert(offsetof(FCardinalDirectionBlendSpaceAnimSet, EastAnim) == 0x000008, "Member 'FCardinalDirectionBlendSpaceAnimSet::EastAnim' has a wrong offset!");
static_assert(offsetof(FCardinalDirectionBlendSpaceAnimSet, SouthAnim) == 0x000010, "Member 'FCardinalDirectionBlendSpaceAnimSet::SouthAnim' has a wrong offset!");
static_assert(offsetof(FCardinalDirectionBlendSpaceAnimSet, WestAnim) == 0x000018, "Member 'FCardinalDirectionBlendSpaceAnimSet::WestAnim' has a wrong offset!");

// ScriptStruct ReadyOrNot.CardinalDirectionAnimSet
// 0x0020 (0x0020 - 0x0000)
struct FCardinalDirectionAnimSet final 
{
public:
	class UAnimSequence*                          NorthAnim;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          EastAnim;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SouthAnim;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          WestAnim;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCardinalDirectionAnimSet) == 0x000008, "Wrong alignment on FCardinalDirectionAnimSet");
static_assert(sizeof(FCardinalDirectionAnimSet) == 0x000020, "Wrong size on FCardinalDirectionAnimSet");
static_assert(offsetof(FCardinalDirectionAnimSet, NorthAnim) == 0x000000, "Member 'FCardinalDirectionAnimSet::NorthAnim' has a wrong offset!");
static_assert(offsetof(FCardinalDirectionAnimSet, EastAnim) == 0x000008, "Member 'FCardinalDirectionAnimSet::EastAnim' has a wrong offset!");
static_assert(offsetof(FCardinalDirectionAnimSet, SouthAnim) == 0x000010, "Member 'FCardinalDirectionAnimSet::SouthAnim' has a wrong offset!");
static_assert(offsetof(FCardinalDirectionAnimSet, WestAnim) == 0x000018, "Member 'FCardinalDirectionAnimSet::WestAnim' has a wrong offset!");

// ScriptStruct ReadyOrNot.DistanceMatchCardinalAnimSet
// 0x0080 (0x0080 - 0x0000)
struct FDistanceMatchCardinalAnimSet final 
{
public:
	struct FDistanceMatchAnimation                NorthAnim;                                         // 0x0000(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDistanceMatchAnimation                EastAnim;                                          // 0x0020(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDistanceMatchAnimation                SouthAnim;                                         // 0x0040(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDistanceMatchAnimation                WestAnim;                                          // 0x0060(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDistanceMatchCardinalAnimSet) == 0x000008, "Wrong alignment on FDistanceMatchCardinalAnimSet");
static_assert(sizeof(FDistanceMatchCardinalAnimSet) == 0x000080, "Wrong size on FDistanceMatchCardinalAnimSet");
static_assert(offsetof(FDistanceMatchCardinalAnimSet, NorthAnim) == 0x000000, "Member 'FDistanceMatchCardinalAnimSet::NorthAnim' has a wrong offset!");
static_assert(offsetof(FDistanceMatchCardinalAnimSet, EastAnim) == 0x000020, "Member 'FDistanceMatchCardinalAnimSet::EastAnim' has a wrong offset!");
static_assert(offsetof(FDistanceMatchCardinalAnimSet, SouthAnim) == 0x000040, "Member 'FDistanceMatchCardinalAnimSet::SouthAnim' has a wrong offset!");
static_assert(offsetof(FDistanceMatchCardinalAnimSet, WestAnim) == 0x000060, "Member 'FDistanceMatchCardinalAnimSet::WestAnim' has a wrong offset!");

// ScriptStruct ReadyOrNot.AnimTurnInPlaceState
// 0x0058 (0x0058 - 0x0000)
struct FAnimTurnInPlaceState final 
{
public:
	class UAnimSequence*                          ActiveTurnAnim;                                    // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          TurnRecoveryAnim;                                  // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootYawOffset;                                     // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootYawOffsetInverse;                              // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveTurnAnimTime;                                // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnRecoveryAnimStartTime;                         // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnTransitionRequested;                          // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnRecoveryRequested;                            // 0x0021(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F81[0x2];                                     // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRK4SpringInterpolator            YawOffsetInterpolator;                             // 0x0024(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F82[0x1C];                                    // 0x002C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PendingTurnAnim;                                   // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F83[0x8];                                     // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimTurnInPlaceState) == 0x000008, "Wrong alignment on FAnimTurnInPlaceState");
static_assert(sizeof(FAnimTurnInPlaceState) == 0x000058, "Wrong size on FAnimTurnInPlaceState");
static_assert(offsetof(FAnimTurnInPlaceState, ActiveTurnAnim) == 0x000000, "Member 'FAnimTurnInPlaceState::ActiveTurnAnim' has a wrong offset!");
static_assert(offsetof(FAnimTurnInPlaceState, TurnRecoveryAnim) == 0x000008, "Member 'FAnimTurnInPlaceState::TurnRecoveryAnim' has a wrong offset!");
static_assert(offsetof(FAnimTurnInPlaceState, RootYawOffset) == 0x000010, "Member 'FAnimTurnInPlaceState::RootYawOffset' has a wrong offset!");
static_assert(offsetof(FAnimTurnInPlaceState, RootYawOffsetInverse) == 0x000014, "Member 'FAnimTurnInPlaceState::RootYawOffsetInverse' has a wrong offset!");
static_assert(offsetof(FAnimTurnInPlaceState, ActiveTurnAnimTime) == 0x000018, "Member 'FAnimTurnInPlaceState::ActiveTurnAnimTime' has a wrong offset!");
static_assert(offsetof(FAnimTurnInPlaceState, TurnRecoveryAnimStartTime) == 0x00001C, "Member 'FAnimTurnInPlaceState::TurnRecoveryAnimStartTime' has a wrong offset!");
static_assert(offsetof(FAnimTurnInPlaceState, bTurnTransitionRequested) == 0x000020, "Member 'FAnimTurnInPlaceState::bTurnTransitionRequested' has a wrong offset!");
static_assert(offsetof(FAnimTurnInPlaceState, bTurnRecoveryRequested) == 0x000021, "Member 'FAnimTurnInPlaceState::bTurnRecoveryRequested' has a wrong offset!");
static_assert(offsetof(FAnimTurnInPlaceState, YawOffsetInterpolator) == 0x000024, "Member 'FAnimTurnInPlaceState::YawOffsetInterpolator' has a wrong offset!");
static_assert(offsetof(FAnimTurnInPlaceState, PendingTurnAnim) == 0x000048, "Member 'FAnimTurnInPlaceState::PendingTurnAnim' has a wrong offset!");

// ScriptStruct ReadyOrNot.AnimTurnInPlaceAnimSet
// 0x0018 (0x0018 - 0x0000)
struct FAnimTurnInPlaceAnimSet final 
{
public:
	TArray<struct FAnimTurnTransition>            TurnTransitions;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TurnDeadZoneAngle;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F84[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimTurnInPlaceAnimSet) == 0x000008, "Wrong alignment on FAnimTurnInPlaceAnimSet");
static_assert(sizeof(FAnimTurnInPlaceAnimSet) == 0x000018, "Wrong size on FAnimTurnInPlaceAnimSet");
static_assert(offsetof(FAnimTurnInPlaceAnimSet, TurnTransitions) == 0x000000, "Member 'FAnimTurnInPlaceAnimSet::TurnTransitions' has a wrong offset!");
static_assert(offsetof(FAnimTurnInPlaceAnimSet, TurnDeadZoneAngle) == 0x000010, "Member 'FAnimTurnInPlaceAnimSet::TurnDeadZoneAngle' has a wrong offset!");

// ScriptStruct ReadyOrNot.ItemLookupTable
// 0x0598 (0x05A0 - 0x0008)
struct FItemLookupTable final  : public FTableRowBase
{
public:
	class FText                                   ItemName;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ItemDescription;                                   // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<EGameVersionRestriction>               LockedToDLC;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EItemCategory>                         ItemCategories;                                    // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EItemClass                                    ItemClass;                                         // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemType                                     ItemType;                                          // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F85[0x6];                                     // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   BlueprintClass;                                    // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPistolGrip;                                       // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F86[0x7];                                     // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ItemIcon;                                          // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemWeight;                                        // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HolsterPlayRate;                                   // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawPlayRate;                                      // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLowReady;                                      // 0x00A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F87[0x3];                                     // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PushbackRange;                                     // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowReadyRange;                                     // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowReadyRangeSightsModifier;                       // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowReadyPitchThreshold;                            // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeedMultiplier;                           // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanOffset;                                        // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSZoom;                                           // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSZoomInSpeed;                                    // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSZoomOutSpeed;                                   // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F88[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AImpactEffect>              ImpactEffects;                                     // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AImpactEffect>              RicochetEffects;                                   // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        RicochetParticleSystem;                            // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AImpactEffect>              ExitEffects;                                       // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagazineWeightFull;                                // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagazineWeightEmpty;                               // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bADSCountsAsAbuse;                                 // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F89[0x3];                                     // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HesitationBoostMultiplier;                         // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EFireMode>                             FireModes;                                         // 0x0100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         BurstBulletCount;                                  // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8A[0x4];                                     // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AmmunitionTypes;                                   // 0x0118(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     DamageOverRange;                                   // 0x0128(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x01B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageSeverityMultiplier;                          // 0x01B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageSeverityChance;                              // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BleedoutDamageMultiplier;                          // 0x01BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BleedoutDamageChance;                              // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8B[0x4];                                     // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                DefaultDamageType;                                 // 0x01C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                ArmorPiercingDamageType;                           // 0x01D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagazineCountDefault;                              // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagazineCountMin;                                  // 0x01DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagazineCountMax;                                  // 0x01E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MagazineLabel;                                     // 0x01E4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileMovementSpeed;                           // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationDistance;                               // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8C[0x4];                                     // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABulletProjectile>          FakeBulletProjectile;                              // 0x01F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABulletProjectile>          BulletProjectile;                                  // 0x0200(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABulletProjectile>          ArmorPiercingBulletProjectile;                     // 0x0208(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagazineSize;                                      // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireRate;                                          // 0x0214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Accuracy;                                          // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFireRateAI;                                     // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFireRateAI;                                     // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletsFiredUntilFullyAccurate;                    // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreAmmoTypeSpread;                             // 0x022C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8D[0x3];                                     // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SpreadPattern;                                     // 0x0230(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SpreadReturnRate;                                  // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSSpreadMultiplier;                               // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8E[0x4];                                     // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRotator>                       RecoilPattern;                                     // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         RecoilReturnRate;                                  // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilInterpSpeed;                                 // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSRecoilMultiplier;                               // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockIntegrityMinDamage;                            // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockIntegrityMaxDamage;                            // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletDrag;                                        // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitScan;                                          // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnTracer;                                      // 0x0271(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoSpawnTracerForFiringPlayer;                     // 0x0272(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8F[0x1];                                     // 0x0273(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnProjectileCount;                              // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Wobble;                                            // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialWobbleDelay;                                // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        FireCameraShake;                                   // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstShotRecoil;                                   // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstShotSpread;                                   // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstShotResetTime;                                // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilReturnInterpSpeed;                           // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilReturnPercentage;                            // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocitySpreadMultiplier;                          // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityRecoilMultiplier;                          // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilMultiplierPitch;                             // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilMultiplierYaw;                               // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefireDelay;                                       // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWeaponWheel_ItemStat_Base>> ItemStats;                                         // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         AttachmentPoints;                                  // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptsScopeAttachments;                          // 0x02C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F90[0x3];                                     // 0x02C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UScopedWeaponAttachment>> AvailableScopeAttachments;                         // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bAcceptsMuzzleAttachments;                         // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F91[0x7];                                     // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableMuzzleAttachments;                        // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bAcceptsUnderbarrelAttachments;                    // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F92[0x7];                                     // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableUnderbarrelAttachments;                   // 0x02F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bAcceptsOverbarrelAttachments;                     // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F93[0x7];                                     // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableOverbarrelAttachments;                    // 0x0310(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bAcceptsStockAttachments;                          // 0x0320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F94[0x7];                                     // 0x0321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableStockAttachments;                         // 0x0328(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bAcceptsGripAttachments;                           // 0x0338(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F95[0x7];                                     // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableGripAttachments;                          // 0x0340(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bAcceptsIlluminatorAttachments;                    // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F96[0x7];                                     // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableIlluminatorAttachments;                   // 0x0358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bAcceptsAmmunitionAttachments;                     // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F97[0x7];                                     // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableAmmunitionAttachments;                    // 0x0370(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bCalculateProcRecoil;                              // 0x0380(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F98[0x3];                                     // 0x0381(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoilDampStrength;                                // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilFireTime;                                    // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilFireStrength;                                // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilFireStrengthFirst;                           // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilAngleStrength;                               // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilRandomness;                                  // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilADSModfier;                                  // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilAngleADSModifier;                            // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RecoilRotationBuildup;                             // 0x03A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RecoilPositionBuildup;                             // 0x03B0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilBuildupADSMultiplier;                        // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RecoilHasBuildup;                                  // 0x03C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F99[0x3];                                     // 0x03C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoilBuildupDampStrength;                         // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimLimit;                                      // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimLimitADS;                                   // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LazySpringStrength;                                // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LazySpringStrengthADS;                             // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPADSMotionWeight;                                 // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimInterpSpeed;                                // 0x03DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimInterpADSModifier;                          // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimInterpHipModifier;                          // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimSlowMoveModifier;                           // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimSlowMoveTolerance;                          // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableMeshspaceMovement;                         // 0x03F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9A[0xF];                                     // 0x03F1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MeshspaceTransform_Default;                        // 0x0400(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             MeshspaceTransform_Aiming;                         // 0x0430(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             MeshspaceTransform_Back;                           // 0x0460(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                MovementSpeedScale;                                // 0x0490(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MovementSpeedRotationScalePitchYawRoll;            // 0x049C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MeshSpaceAimInterp;                                // 0x04A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9B[0x4];                                     // 0x04AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MeshspaceTransform_OnDraw;                         // 0x04B0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         OnDrawMeshspaceInterp;                             // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9C[0xC];                                     // 0x04E4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MeshspaceTransform_OnHolster;                      // 0x04F0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         OnHolsterMeshspaceInterp;                          // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaDragAimRotation;                            // 0x0524(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaDragAimLocation;                            // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaDragStrafeRotation;                         // 0x052C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaDragStrafeLocation;                         // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodySocket;                                        // 0x0534(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HandsSocket;                                       // 0x053C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobScaleH;                                   // 0x0544(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobScaleV;                                   // 0x0548(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobSpeedScaleH;                              // 0x054C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobSpeedScaleV;                              // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobAmplitudeBaseSpeed;                       // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobIntensitySprintScale;                     // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobAmplitudeWalkScale;                       // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobAmplitudeSprintScale;                     // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobScaleH;                                   // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobScaleV;                                   // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobScaleInjured;                             // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobSpeedScaleH;                              // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobSpeedScaleV;                              // 0x0574(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobSpeedScaleInjured;                        // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobCrouchModifier;                           // 0x057C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobADSModifier;                              // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotPitchScale;                            // 0x0584(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotRollScale;                             // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotPitchSpeed;                            // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotRollSpeed;                             // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotCrouchModifier;                        // 0x0594(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotADSModifier;                           // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9D[0x4];                                     // 0x059C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemLookupTable) == 0x000010, "Wrong alignment on FItemLookupTable");
static_assert(sizeof(FItemLookupTable) == 0x0005A0, "Wrong size on FItemLookupTable");
static_assert(offsetof(FItemLookupTable, ItemName) == 0x000008, "Member 'FItemLookupTable::ItemName' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ItemDescription) == 0x000020, "Member 'FItemLookupTable::ItemDescription' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, LockedToDLC) == 0x000038, "Member 'FItemLookupTable::LockedToDLC' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ItemCategories) == 0x000048, "Member 'FItemLookupTable::ItemCategories' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ItemClass) == 0x000058, "Member 'FItemLookupTable::ItemClass' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ItemType) == 0x000059, "Member 'FItemLookupTable::ItemType' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, BlueprintClass) == 0x000060, "Member 'FItemLookupTable::BlueprintClass' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bPistolGrip) == 0x000088, "Member 'FItemLookupTable::bPistolGrip' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ItemIcon) == 0x000090, "Member 'FItemLookupTable::ItemIcon' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ItemWeight) == 0x000098, "Member 'FItemLookupTable::ItemWeight' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, HolsterPlayRate) == 0x00009C, "Member 'FItemLookupTable::HolsterPlayRate' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, DrawPlayRate) == 0x0000A0, "Member 'FItemLookupTable::DrawPlayRate' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bUseLowReady) == 0x0000A4, "Member 'FItemLookupTable::bUseLowReady' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, PushbackRange) == 0x0000A8, "Member 'FItemLookupTable::PushbackRange' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, LowReadyRange) == 0x0000AC, "Member 'FItemLookupTable::LowReadyRange' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, LowReadyRangeSightsModifier) == 0x0000B0, "Member 'FItemLookupTable::LowReadyRangeSightsModifier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, LowReadyPitchThreshold) == 0x0000B4, "Member 'FItemLookupTable::LowReadyPitchThreshold' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MovementSpeedMultiplier) == 0x0000B8, "Member 'FItemLookupTable::MovementSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, LeanOffset) == 0x0000BC, "Member 'FItemLookupTable::LeanOffset' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ADSZoom) == 0x0000C0, "Member 'FItemLookupTable::ADSZoom' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ADSZoomInSpeed) == 0x0000C4, "Member 'FItemLookupTable::ADSZoomInSpeed' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ADSZoomOutSpeed) == 0x0000C8, "Member 'FItemLookupTable::ADSZoomOutSpeed' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ImpactEffects) == 0x0000D0, "Member 'FItemLookupTable::ImpactEffects' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RicochetEffects) == 0x0000D8, "Member 'FItemLookupTable::RicochetEffects' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RicochetParticleSystem) == 0x0000E0, "Member 'FItemLookupTable::RicochetParticleSystem' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ExitEffects) == 0x0000E8, "Member 'FItemLookupTable::ExitEffects' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MagazineWeightFull) == 0x0000F0, "Member 'FItemLookupTable::MagazineWeightFull' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MagazineWeightEmpty) == 0x0000F4, "Member 'FItemLookupTable::MagazineWeightEmpty' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bADSCountsAsAbuse) == 0x0000F8, "Member 'FItemLookupTable::bADSCountsAsAbuse' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, HesitationBoostMultiplier) == 0x0000FC, "Member 'FItemLookupTable::HesitationBoostMultiplier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, FireModes) == 0x000100, "Member 'FItemLookupTable::FireModes' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, BurstBulletCount) == 0x000110, "Member 'FItemLookupTable::BurstBulletCount' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, AmmunitionTypes) == 0x000118, "Member 'FItemLookupTable::AmmunitionTypes' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, DamageOverRange) == 0x000128, "Member 'FItemLookupTable::DamageOverRange' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, Damage) == 0x0001B0, "Member 'FItemLookupTable::Damage' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, DamageSeverityMultiplier) == 0x0001B4, "Member 'FItemLookupTable::DamageSeverityMultiplier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, DamageSeverityChance) == 0x0001B8, "Member 'FItemLookupTable::DamageSeverityChance' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, BleedoutDamageMultiplier) == 0x0001BC, "Member 'FItemLookupTable::BleedoutDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, BleedoutDamageChance) == 0x0001C0, "Member 'FItemLookupTable::BleedoutDamageChance' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, DefaultDamageType) == 0x0001C8, "Member 'FItemLookupTable::DefaultDamageType' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ArmorPiercingDamageType) == 0x0001D0, "Member 'FItemLookupTable::ArmorPiercingDamageType' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MagazineCountDefault) == 0x0001D8, "Member 'FItemLookupTable::MagazineCountDefault' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MagazineCountMin) == 0x0001DC, "Member 'FItemLookupTable::MagazineCountMin' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MagazineCountMax) == 0x0001E0, "Member 'FItemLookupTable::MagazineCountMax' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MagazineLabel) == 0x0001E4, "Member 'FItemLookupTable::MagazineLabel' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ProjectileMovementSpeed) == 0x0001EC, "Member 'FItemLookupTable::ProjectileMovementSpeed' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, PenetrationDistance) == 0x0001F0, "Member 'FItemLookupTable::PenetrationDistance' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, FakeBulletProjectile) == 0x0001F8, "Member 'FItemLookupTable::FakeBulletProjectile' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, BulletProjectile) == 0x000200, "Member 'FItemLookupTable::BulletProjectile' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ArmorPiercingBulletProjectile) == 0x000208, "Member 'FItemLookupTable::ArmorPiercingBulletProjectile' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MagazineSize) == 0x000210, "Member 'FItemLookupTable::MagazineSize' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, FireRate) == 0x000214, "Member 'FItemLookupTable::FireRate' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, Range) == 0x000218, "Member 'FItemLookupTable::Range' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, Accuracy) == 0x00021C, "Member 'FItemLookupTable::Accuracy' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MinFireRateAI) == 0x000220, "Member 'FItemLookupTable::MinFireRateAI' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MaxFireRateAI) == 0x000224, "Member 'FItemLookupTable::MaxFireRateAI' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, BulletsFiredUntilFullyAccurate) == 0x000228, "Member 'FItemLookupTable::BulletsFiredUntilFullyAccurate' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bIgnoreAmmoTypeSpread) == 0x00022C, "Member 'FItemLookupTable::bIgnoreAmmoTypeSpread' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, SpreadPattern) == 0x000230, "Member 'FItemLookupTable::SpreadPattern' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, SpreadReturnRate) == 0x00023C, "Member 'FItemLookupTable::SpreadReturnRate' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ADSSpreadMultiplier) == 0x000240, "Member 'FItemLookupTable::ADSSpreadMultiplier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilPattern) == 0x000248, "Member 'FItemLookupTable::RecoilPattern' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilReturnRate) == 0x000258, "Member 'FItemLookupTable::RecoilReturnRate' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilInterpSpeed) == 0x00025C, "Member 'FItemLookupTable::RecoilInterpSpeed' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ADSRecoilMultiplier) == 0x000260, "Member 'FItemLookupTable::ADSRecoilMultiplier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, LockIntegrityMinDamage) == 0x000264, "Member 'FItemLookupTable::LockIntegrityMinDamage' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, LockIntegrityMaxDamage) == 0x000268, "Member 'FItemLookupTable::LockIntegrityMaxDamage' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, BulletDrag) == 0x00026C, "Member 'FItemLookupTable::BulletDrag' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bHitScan) == 0x000270, "Member 'FItemLookupTable::bHitScan' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bSpawnTracer) == 0x000271, "Member 'FItemLookupTable::bSpawnTracer' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bNoSpawnTracerForFiringPlayer) == 0x000272, "Member 'FItemLookupTable::bNoSpawnTracerForFiringPlayer' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, SpawnProjectileCount) == 0x000274, "Member 'FItemLookupTable::SpawnProjectileCount' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, Wobble) == 0x000278, "Member 'FItemLookupTable::Wobble' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, InitialWobbleDelay) == 0x00027C, "Member 'FItemLookupTable::InitialWobbleDelay' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, FireCameraShake) == 0x000280, "Member 'FItemLookupTable::FireCameraShake' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, FirstShotRecoil) == 0x000288, "Member 'FItemLookupTable::FirstShotRecoil' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, FirstShotSpread) == 0x00028C, "Member 'FItemLookupTable::FirstShotSpread' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, FirstShotResetTime) == 0x000290, "Member 'FItemLookupTable::FirstShotResetTime' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilReturnInterpSpeed) == 0x000294, "Member 'FItemLookupTable::RecoilReturnInterpSpeed' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilReturnPercentage) == 0x000298, "Member 'FItemLookupTable::RecoilReturnPercentage' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, VelocitySpreadMultiplier) == 0x00029C, "Member 'FItemLookupTable::VelocitySpreadMultiplier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, VelocityRecoilMultiplier) == 0x0002A0, "Member 'FItemLookupTable::VelocityRecoilMultiplier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilMultiplierPitch) == 0x0002A4, "Member 'FItemLookupTable::RecoilMultiplierPitch' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilMultiplierYaw) == 0x0002A8, "Member 'FItemLookupTable::RecoilMultiplierYaw' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RefireDelay) == 0x0002AC, "Member 'FItemLookupTable::RefireDelay' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, ItemStats) == 0x0002B0, "Member 'FItemLookupTable::ItemStats' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, AttachmentPoints) == 0x0002C0, "Member 'FItemLookupTable::AttachmentPoints' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bAcceptsScopeAttachments) == 0x0002C4, "Member 'FItemLookupTable::bAcceptsScopeAttachments' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, AvailableScopeAttachments) == 0x0002C8, "Member 'FItemLookupTable::AvailableScopeAttachments' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bAcceptsMuzzleAttachments) == 0x0002D8, "Member 'FItemLookupTable::bAcceptsMuzzleAttachments' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, AvailableMuzzleAttachments) == 0x0002E0, "Member 'FItemLookupTable::AvailableMuzzleAttachments' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bAcceptsUnderbarrelAttachments) == 0x0002F0, "Member 'FItemLookupTable::bAcceptsUnderbarrelAttachments' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, AvailableUnderbarrelAttachments) == 0x0002F8, "Member 'FItemLookupTable::AvailableUnderbarrelAttachments' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bAcceptsOverbarrelAttachments) == 0x000308, "Member 'FItemLookupTable::bAcceptsOverbarrelAttachments' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, AvailableOverbarrelAttachments) == 0x000310, "Member 'FItemLookupTable::AvailableOverbarrelAttachments' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bAcceptsStockAttachments) == 0x000320, "Member 'FItemLookupTable::bAcceptsStockAttachments' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, AvailableStockAttachments) == 0x000328, "Member 'FItemLookupTable::AvailableStockAttachments' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bAcceptsGripAttachments) == 0x000338, "Member 'FItemLookupTable::bAcceptsGripAttachments' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, AvailableGripAttachments) == 0x000340, "Member 'FItemLookupTable::AvailableGripAttachments' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bAcceptsIlluminatorAttachments) == 0x000350, "Member 'FItemLookupTable::bAcceptsIlluminatorAttachments' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, AvailableIlluminatorAttachments) == 0x000358, "Member 'FItemLookupTable::AvailableIlluminatorAttachments' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bAcceptsAmmunitionAttachments) == 0x000368, "Member 'FItemLookupTable::bAcceptsAmmunitionAttachments' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, AvailableAmmunitionAttachments) == 0x000370, "Member 'FItemLookupTable::AvailableAmmunitionAttachments' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bCalculateProcRecoil) == 0x000380, "Member 'FItemLookupTable::bCalculateProcRecoil' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilDampStrength) == 0x000384, "Member 'FItemLookupTable::RecoilDampStrength' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilFireTime) == 0x000388, "Member 'FItemLookupTable::RecoilFireTime' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilFireStrength) == 0x00038C, "Member 'FItemLookupTable::RecoilFireStrength' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilFireStrengthFirst) == 0x000390, "Member 'FItemLookupTable::RecoilFireStrengthFirst' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilAngleStrength) == 0x000394, "Member 'FItemLookupTable::RecoilAngleStrength' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilRandomness) == 0x000398, "Member 'FItemLookupTable::RecoilRandomness' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilADSModfier) == 0x00039C, "Member 'FItemLookupTable::RecoilADSModfier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilAngleADSModifier) == 0x0003A0, "Member 'FItemLookupTable::RecoilAngleADSModifier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilRotationBuildup) == 0x0003A4, "Member 'FItemLookupTable::RecoilRotationBuildup' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilPositionBuildup) == 0x0003B0, "Member 'FItemLookupTable::RecoilPositionBuildup' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilBuildupADSMultiplier) == 0x0003BC, "Member 'FItemLookupTable::RecoilBuildupADSMultiplier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilHasBuildup) == 0x0003C0, "Member 'FItemLookupTable::RecoilHasBuildup' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, RecoilBuildupDampStrength) == 0x0003C4, "Member 'FItemLookupTable::RecoilBuildupDampStrength' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, FreeAimLimit) == 0x0003C8, "Member 'FItemLookupTable::FreeAimLimit' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, FreeAimLimitADS) == 0x0003CC, "Member 'FItemLookupTable::FreeAimLimitADS' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, LazySpringStrength) == 0x0003D0, "Member 'FItemLookupTable::LazySpringStrength' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, LazySpringStrengthADS) == 0x0003D4, "Member 'FItemLookupTable::LazySpringStrengthADS' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, FPADSMotionWeight) == 0x0003D8, "Member 'FItemLookupTable::FPADSMotionWeight' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, FreeAimInterpSpeed) == 0x0003DC, "Member 'FItemLookupTable::FreeAimInterpSpeed' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, FreeAimInterpADSModifier) == 0x0003E0, "Member 'FItemLookupTable::FreeAimInterpADSModifier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, FreeAimInterpHipModifier) == 0x0003E4, "Member 'FItemLookupTable::FreeAimInterpHipModifier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, FreeAimSlowMoveModifier) == 0x0003E8, "Member 'FItemLookupTable::FreeAimSlowMoveModifier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, FreeAimSlowMoveTolerance) == 0x0003EC, "Member 'FItemLookupTable::FreeAimSlowMoveTolerance' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, bDisableMeshspaceMovement) == 0x0003F0, "Member 'FItemLookupTable::bDisableMeshspaceMovement' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MeshspaceTransform_Default) == 0x000400, "Member 'FItemLookupTable::MeshspaceTransform_Default' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MeshspaceTransform_Aiming) == 0x000430, "Member 'FItemLookupTable::MeshspaceTransform_Aiming' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MeshspaceTransform_Back) == 0x000460, "Member 'FItemLookupTable::MeshspaceTransform_Back' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MovementSpeedScale) == 0x000490, "Member 'FItemLookupTable::MovementSpeedScale' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MovementSpeedRotationScalePitchYawRoll) == 0x00049C, "Member 'FItemLookupTable::MovementSpeedRotationScalePitchYawRoll' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MeshSpaceAimInterp) == 0x0004A8, "Member 'FItemLookupTable::MeshSpaceAimInterp' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MeshspaceTransform_OnDraw) == 0x0004B0, "Member 'FItemLookupTable::MeshspaceTransform_OnDraw' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, OnDrawMeshspaceInterp) == 0x0004E0, "Member 'FItemLookupTable::OnDrawMeshspaceInterp' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, MeshspaceTransform_OnHolster) == 0x0004F0, "Member 'FItemLookupTable::MeshspaceTransform_OnHolster' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, OnHolsterMeshspaceInterp) == 0x000520, "Member 'FItemLookupTable::OnHolsterMeshspaceInterp' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, InertiaDragAimRotation) == 0x000524, "Member 'FItemLookupTable::InertiaDragAimRotation' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, InertiaDragAimLocation) == 0x000528, "Member 'FItemLookupTable::InertiaDragAimLocation' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, InertiaDragStrafeRotation) == 0x00052C, "Member 'FItemLookupTable::InertiaDragStrafeRotation' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, InertiaDragStrafeLocation) == 0x000530, "Member 'FItemLookupTable::InertiaDragStrafeLocation' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, BodySocket) == 0x000534, "Member 'FItemLookupTable::BodySocket' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, HandsSocket) == 0x00053C, "Member 'FItemLookupTable::HandsSocket' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, CameraBobScaleH) == 0x000544, "Member 'FItemLookupTable::CameraBobScaleH' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, CameraBobScaleV) == 0x000548, "Member 'FItemLookupTable::CameraBobScaleV' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, CameraBobSpeedScaleH) == 0x00054C, "Member 'FItemLookupTable::CameraBobSpeedScaleH' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, CameraBobSpeedScaleV) == 0x000550, "Member 'FItemLookupTable::CameraBobSpeedScaleV' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, CameraBobAmplitudeBaseSpeed) == 0x000554, "Member 'FItemLookupTable::CameraBobAmplitudeBaseSpeed' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, CameraBobIntensitySprintScale) == 0x000558, "Member 'FItemLookupTable::CameraBobIntensitySprintScale' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, CameraBobAmplitudeWalkScale) == 0x00055C, "Member 'FItemLookupTable::CameraBobAmplitudeWalkScale' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, CameraBobAmplitudeSprintScale) == 0x000560, "Member 'FItemLookupTable::CameraBobAmplitudeSprintScale' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, WeaponBobScaleH) == 0x000564, "Member 'FItemLookupTable::WeaponBobScaleH' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, WeaponBobScaleV) == 0x000568, "Member 'FItemLookupTable::WeaponBobScaleV' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, WeaponBobScaleInjured) == 0x00056C, "Member 'FItemLookupTable::WeaponBobScaleInjured' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, WeaponBobSpeedScaleH) == 0x000570, "Member 'FItemLookupTable::WeaponBobSpeedScaleH' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, WeaponBobSpeedScaleV) == 0x000574, "Member 'FItemLookupTable::WeaponBobSpeedScaleV' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, WeaponBobSpeedScaleInjured) == 0x000578, "Member 'FItemLookupTable::WeaponBobSpeedScaleInjured' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, WeaponBobCrouchModifier) == 0x00057C, "Member 'FItemLookupTable::WeaponBobCrouchModifier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, WeaponBobADSModifier) == 0x000580, "Member 'FItemLookupTable::WeaponBobADSModifier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, WeaponBobRotPitchScale) == 0x000584, "Member 'FItemLookupTable::WeaponBobRotPitchScale' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, WeaponBobRotRollScale) == 0x000588, "Member 'FItemLookupTable::WeaponBobRotRollScale' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, WeaponBobRotPitchSpeed) == 0x00058C, "Member 'FItemLookupTable::WeaponBobRotPitchSpeed' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, WeaponBobRotRollSpeed) == 0x000590, "Member 'FItemLookupTable::WeaponBobRotRollSpeed' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, WeaponBobRotCrouchModifier) == 0x000594, "Member 'FItemLookupTable::WeaponBobRotCrouchModifier' has a wrong offset!");
static_assert(offsetof(FItemLookupTable, WeaponBobRotADSModifier) == 0x000598, "Member 'FItemLookupTable::WeaponBobRotADSModifier' has a wrong offset!");

// ScriptStruct ReadyOrNot.RepGearAttach
// 0x0038 (0x0038 - 0x0000)
struct FRepGearAttach final 
{
public:
	bool                                          bEquipped;                                         // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMeshVisibleTo1P;                                  // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMeshVisibleTo3P;                                  // 0x0002(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9E[0x5];                                     // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Attach1P;                                          // 0x0008(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket1P;                                          // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Attach3P;                                          // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket3P;                                          // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ScopeAttach;                                       // 0x0028(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ScopeSocket;                                       // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRepGearAttach) == 0x000008, "Wrong alignment on FRepGearAttach");
static_assert(sizeof(FRepGearAttach) == 0x000038, "Wrong size on FRepGearAttach");
static_assert(offsetof(FRepGearAttach, bEquipped) == 0x000000, "Member 'FRepGearAttach::bEquipped' has a wrong offset!");
static_assert(offsetof(FRepGearAttach, bMeshVisibleTo1P) == 0x000001, "Member 'FRepGearAttach::bMeshVisibleTo1P' has a wrong offset!");
static_assert(offsetof(FRepGearAttach, bMeshVisibleTo3P) == 0x000002, "Member 'FRepGearAttach::bMeshVisibleTo3P' has a wrong offset!");
static_assert(offsetof(FRepGearAttach, Attach1P) == 0x000008, "Member 'FRepGearAttach::Attach1P' has a wrong offset!");
static_assert(offsetof(FRepGearAttach, Socket1P) == 0x000010, "Member 'FRepGearAttach::Socket1P' has a wrong offset!");
static_assert(offsetof(FRepGearAttach, Attach3P) == 0x000018, "Member 'FRepGearAttach::Attach3P' has a wrong offset!");
static_assert(offsetof(FRepGearAttach, Socket3P) == 0x000020, "Member 'FRepGearAttach::Socket3P' has a wrong offset!");
static_assert(offsetof(FRepGearAttach, ScopeAttach) == 0x000028, "Member 'FRepGearAttach::ScopeAttach' has a wrong offset!");
static_assert(offsetof(FRepGearAttach, ScopeSocket) == 0x000030, "Member 'FRepGearAttach::ScopeSocket' has a wrong offset!");

// ScriptStruct ReadyOrNot.HitscanCharacterHit
// 0x0010 (0x0010 - 0x0000)
struct FHitscanCharacterHit final 
{
public:
	TWeakObjectPtr<class UPrimitiveComponent>     Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9F[0x8];                                     // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitscanCharacterHit) == 0x000004, "Wrong alignment on FHitscanCharacterHit");
static_assert(sizeof(FHitscanCharacterHit) == 0x000010, "Wrong size on FHitscanCharacterHit");
static_assert(offsetof(FHitscanCharacterHit, Component) == 0x000000, "Member 'FHitscanCharacterHit::Component' has a wrong offset!");

// ScriptStruct ReadyOrNot.Ricochet
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x04) FRicochet final 
{
public:
	uint8                                         Pad_1FA0[0x28];                                    // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRicochet) == 0x000004, "Wrong alignment on FRicochet");
static_assert(sizeof(FRicochet) == 0x000028, "Wrong size on FRicochet");

// ScriptStruct ReadyOrNot.GibData
// 0x0030 (0x0030 - 0x0000)
struct FGibData final 
{
public:
	class UStaticMesh*                            GibHead;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            GibArms;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            GibLegs;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BoneHead;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BoneArms;                                          // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BoneLegs;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGibData) == 0x000008, "Wrong alignment on FGibData");
static_assert(sizeof(FGibData) == 0x000030, "Wrong size on FGibData");
static_assert(offsetof(FGibData, GibHead) == 0x000000, "Member 'FGibData::GibHead' has a wrong offset!");
static_assert(offsetof(FGibData, GibArms) == 0x000008, "Member 'FGibData::GibArms' has a wrong offset!");
static_assert(offsetof(FGibData, GibLegs) == 0x000010, "Member 'FGibData::GibLegs' has a wrong offset!");
static_assert(offsetof(FGibData, BoneHead) == 0x000018, "Member 'FGibData::BoneHead' has a wrong offset!");
static_assert(offsetof(FGibData, BoneArms) == 0x000020, "Member 'FGibData::BoneArms' has a wrong offset!");
static_assert(offsetof(FGibData, BoneLegs) == 0x000028, "Member 'FGibData::BoneLegs' has a wrong offset!");

// ScriptStruct ReadyOrNot.ArteryData
// 0x0014 (0x0014 - 0x0000)
struct FArteryData final 
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoneSize;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoneOffset;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathTime;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArteryData) == 0x000004, "Wrong alignment on FArteryData");
static_assert(sizeof(FArteryData) == 0x000014, "Wrong size on FArteryData");
static_assert(offsetof(FArteryData, BoneName) == 0x000000, "Member 'FArteryData::BoneName' has a wrong offset!");
static_assert(offsetof(FArteryData, ZoneSize) == 0x000008, "Member 'FArteryData::ZoneSize' has a wrong offset!");
static_assert(offsetof(FArteryData, ZoneOffset) == 0x00000C, "Member 'FArteryData::ZoneOffset' has a wrong offset!");
static_assert(offsetof(FArteryData, DeathTime) == 0x000010, "Member 'FArteryData::DeathTime' has a wrong offset!");

// ScriptStruct ReadyOrNot.SavedTransforms
// 0x0040 (0x0040 - 0x0000)
struct FSavedTransforms final 
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SavedTransform;                                    // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedTransforms) == 0x000010, "Wrong alignment on FSavedTransforms");
static_assert(sizeof(FSavedTransforms) == 0x000040, "Wrong size on FSavedTransforms");
static_assert(offsetof(FSavedTransforms, Name) == 0x000000, "Member 'FSavedTransforms::Name' has a wrong offset!");
static_assert(offsetof(FSavedTransforms, SavedTransform) == 0x000010, "Member 'FSavedTransforms::SavedTransform' has a wrong offset!");

// ScriptStruct ReadyOrNot.ExfiltrationData
// 0x0003 (0x0003 - 0x0000)
struct FExfiltrationData final 
{
public:
	uint8                                         Pad_1FA1[0x3];                                     // 0x0000(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExfiltrationData) == 0x000001, "Wrong alignment on FExfiltrationData");
static_assert(sizeof(FExfiltrationData) == 0x000003, "Wrong size on FExfiltrationData");

// ScriptStruct ReadyOrNot.RosterCharacterSaveData
// 0x0010 (0x0010 - 0x0000)
struct FRosterCharacterSaveData final 
{
public:
	TArray<uint8>                                 ObjectBytes;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRosterCharacterSaveData) == 0x000008, "Wrong alignment on FRosterCharacterSaveData");
static_assert(sizeof(FRosterCharacterSaveData) == 0x000010, "Wrong size on FRosterCharacterSaveData");
static_assert(offsetof(FRosterCharacterSaveData, ObjectBytes) == 0x000000, "Member 'FRosterCharacterSaveData::ObjectBytes' has a wrong offset!");

// ScriptStruct ReadyOrNot.RosterSaveData
// 0x0080 (0x0080 - 0x0000)
struct FRosterSaveData final 
{
public:
	bool                                          bGenerateRoster;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA2[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRosterCharacterSaveData>       Characters;                                        // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRosterCharacterSaveData>       PreviousCharacters;                                // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RosterSeed;                                        // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FiredCount;                                        // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<int32>                                   UsedSerialNumbers;                                 // 0x0030(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRosterSaveData) == 0x000008, "Wrong alignment on FRosterSaveData");
static_assert(sizeof(FRosterSaveData) == 0x000080, "Wrong size on FRosterSaveData");
static_assert(offsetof(FRosterSaveData, bGenerateRoster) == 0x000000, "Member 'FRosterSaveData::bGenerateRoster' has a wrong offset!");
static_assert(offsetof(FRosterSaveData, Characters) == 0x000008, "Member 'FRosterSaveData::Characters' has a wrong offset!");
static_assert(offsetof(FRosterSaveData, PreviousCharacters) == 0x000018, "Member 'FRosterSaveData::PreviousCharacters' has a wrong offset!");
static_assert(offsetof(FRosterSaveData, RosterSeed) == 0x000028, "Member 'FRosterSaveData::RosterSeed' has a wrong offset!");
static_assert(offsetof(FRosterSaveData, FiredCount) == 0x00002C, "Member 'FRosterSaveData::FiredCount' has a wrong offset!");
static_assert(offsetof(FRosterSaveData, UsedSerialNumbers) == 0x000030, "Member 'FRosterSaveData::UsedSerialNumbers' has a wrong offset!");

// ScriptStruct ReadyOrNot.CustomizationMaterialSlot
// 0x0030 (0x0030 - 0x0000)
struct FCustomizationMaterialSlot final 
{
public:
	int32                                         Slot;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA3[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      Material;                                          // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationMaterialSlot) == 0x000008, "Wrong alignment on FCustomizationMaterialSlot");
static_assert(sizeof(FCustomizationMaterialSlot) == 0x000030, "Wrong size on FCustomizationMaterialSlot");
static_assert(offsetof(FCustomizationMaterialSlot, Slot) == 0x000000, "Member 'FCustomizationMaterialSlot::Slot' has a wrong offset!");
static_assert(offsetof(FCustomizationMaterialSlot, Material) == 0x000008, "Member 'FCustomizationMaterialSlot::Material' has a wrong offset!");

// ScriptStruct ReadyOrNot.CompatibleSkinsArray
// 0x0010 (0x0010 - 0x0000)
struct FCompatibleSkinsArray final 
{
public:
	TArray<class ULoadoutCustomization*>          CompatibleSkins;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompatibleSkinsArray) == 0x000008, "Wrong alignment on FCompatibleSkinsArray");
static_assert(sizeof(FCompatibleSkinsArray) == 0x000010, "Wrong size on FCompatibleSkinsArray");
static_assert(offsetof(FCompatibleSkinsArray, CompatibleSkins) == 0x000000, "Member 'FCompatibleSkinsArray::CompatibleSkins' has a wrong offset!");

// ScriptStruct ReadyOrNot.ActorMemory
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FActorMemory final 
{
public:
	uint8                                         Pad_1FA4[0x10];                                    // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorMemory) == 0x000008, "Wrong alignment on FActorMemory");
static_assert(sizeof(FActorMemory) == 0x000010, "Wrong size on FActorMemory");

// ScriptStruct ReadyOrNot.ItemID
// 0x0010 (0x0010 - 0x0000)
struct FItemID final 
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA5[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseItem>                  Item;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemID) == 0x000008, "Wrong alignment on FItemID");
static_assert(sizeof(FItemID) == 0x000010, "Wrong size on FItemID");
static_assert(offsetof(FItemID, ID) == 0x000000, "Member 'FItemID::ID' has a wrong offset!");
static_assert(offsetof(FItemID, Item) == 0x000008, "Member 'FItemID::Item' has a wrong offset!");

// ScriptStruct ReadyOrNot.MapList
// 0x00A0 (0x00A0 - 0x0000)
struct FMapList final 
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameMode;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoadURL;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Author;                                            // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   AuthorContact;                                     // 0x0060(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   RecommendedPlayerCount;                            // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USoundCue*                              LoadingScreenMusic;                                // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsPvP;                                      // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsCoop;                                     // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x009A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA6[0x5];                                     // 0x009B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapList) == 0x000008, "Wrong alignment on FMapList");
static_assert(sizeof(FMapList) == 0x0000A0, "Wrong size on FMapList");
static_assert(offsetof(FMapList, Name) == 0x000000, "Member 'FMapList::Name' has a wrong offset!");
static_assert(offsetof(FMapList, GameMode) == 0x000010, "Member 'FMapList::GameMode' has a wrong offset!");
static_assert(offsetof(FMapList, LoadURL) == 0x000020, "Member 'FMapList::LoadURL' has a wrong offset!");
static_assert(offsetof(FMapList, Description) == 0x000030, "Member 'FMapList::Description' has a wrong offset!");
static_assert(offsetof(FMapList, Author) == 0x000048, "Member 'FMapList::Author' has a wrong offset!");
static_assert(offsetof(FMapList, AuthorContact) == 0x000060, "Member 'FMapList::AuthorContact' has a wrong offset!");
static_assert(offsetof(FMapList, RecommendedPlayerCount) == 0x000078, "Member 'FMapList::RecommendedPlayerCount' has a wrong offset!");
static_assert(offsetof(FMapList, LoadingScreenMusic) == 0x000090, "Member 'FMapList::LoadingScreenMusic' has a wrong offset!");
static_assert(offsetof(FMapList, bSupportsPvP) == 0x000098, "Member 'FMapList::bSupportsPvP' has a wrong offset!");
static_assert(offsetof(FMapList, bSupportsCoop) == 0x000099, "Member 'FMapList::bSupportsCoop' has a wrong offset!");
static_assert(offsetof(FMapList, bVisible) == 0x00009A, "Member 'FMapList::bVisible' has a wrong offset!");

// ScriptStruct ReadyOrNot.OutStackupData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FOutStackupData final 
{
public:
	uint8                                         Pad_1FA7[0x18];                                    // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOutStackupData) == 0x000008, "Wrong alignment on FOutStackupData");
static_assert(sizeof(FOutStackupData) == 0x000018, "Wrong size on FOutStackupData");

// ScriptStruct ReadyOrNot.CoverQueryTest
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x10) FCoverQueryTest final 
{
public:
	ECoverQueryTestPurpose                        TestPurpose;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA8[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScoringFactor;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA9[0x48];                                    // 0x0008(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoverQueryTest) == 0x000010, "Wrong alignment on FCoverQueryTest");
static_assert(sizeof(FCoverQueryTest) == 0x000050, "Wrong size on FCoverQueryTest");
static_assert(offsetof(FCoverQueryTest, TestPurpose) == 0x000000, "Member 'FCoverQueryTest::TestPurpose' has a wrong offset!");
static_assert(offsetof(FCoverQueryTest, ScoringFactor) == 0x000004, "Member 'FCoverQueryTest::ScoringFactor' has a wrong offset!");

// ScriptStruct ReadyOrNot.GraphNode
// 0x0050 (0x0050 - 0x0000)
struct FGraphNode final 
{
public:
	uint8                                         Pad_1FAA[0x28];                                    // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Object;                                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FAB[0x20];                                    // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGraphNode) == 0x000008, "Wrong alignment on FGraphNode");
static_assert(sizeof(FGraphNode) == 0x000050, "Wrong size on FGraphNode");
static_assert(offsetof(FGraphNode, Object) == 0x000028, "Member 'FGraphNode::Object' has a wrong offset!");

// ScriptStruct ReadyOrNot.Hm_Objectives
// 0x0018 (0x0018 - 0x0000)
struct FHm_Objectives final 
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectiveStatus                              ObjectiveStatus;                                   // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FAC[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHm_Objectives) == 0x000008, "Wrong alignment on FHm_Objectives");
static_assert(sizeof(FHm_Objectives) == 0x000018, "Wrong size on FHm_Objectives");
static_assert(offsetof(FHm_Objectives, Name) == 0x000000, "Member 'FHm_Objectives::Name' has a wrong offset!");
static_assert(offsetof(FHm_Objectives, ObjectiveStatus) == 0x000010, "Member 'FHm_Objectives::ObjectiveStatus' has a wrong offset!");

// ScriptStruct ReadyOrNot.Hm_DroppedEvidence
// 0x0040 (0x0040 - 0x0000)
struct FHm_DroppedEvidence final 
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseItem>                  Class;                                             // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FAD[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHm_DroppedEvidence) == 0x000010, "Wrong alignment on FHm_DroppedEvidence");
static_assert(sizeof(FHm_DroppedEvidence) == 0x000040, "Wrong size on FHm_DroppedEvidence");
static_assert(offsetof(FHm_DroppedEvidence, Transform) == 0x000000, "Member 'FHm_DroppedEvidence::Transform' has a wrong offset!");
static_assert(offsetof(FHm_DroppedEvidence, Class) == 0x000030, "Member 'FHm_DroppedEvidence::Class' has a wrong offset!");

// ScriptStruct ReadyOrNot.Hm_BaggedEvidence
// 0x0030 (0x0030 - 0x0000)
struct FHm_BaggedEvidence final 
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHm_BaggedEvidence) == 0x000010, "Wrong alignment on FHm_BaggedEvidence");
static_assert(sizeof(FHm_BaggedEvidence) == 0x000030, "Wrong size on FHm_BaggedEvidence");
static_assert(offsetof(FHm_BaggedEvidence, Transform) == 0x000000, "Member 'FHm_BaggedEvidence::Transform' has a wrong offset!");

// ScriptStruct ReadyOrNot.Hm_BombInformation
// 0x0018 (0x0018 - 0x0000)
struct FHm_BombInformation final 
{
public:
	class FString                                 BombName;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBombState                                    BombState;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FAE[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeRemaining;                                     // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHm_BombInformation) == 0x000008, "Wrong alignment on FHm_BombInformation");
static_assert(sizeof(FHm_BombInformation) == 0x000018, "Wrong size on FHm_BombInformation");
static_assert(offsetof(FHm_BombInformation, BombName) == 0x000000, "Member 'FHm_BombInformation::BombName' has a wrong offset!");
static_assert(offsetof(FHm_BombInformation, BombState) == 0x000010, "Member 'FHm_BombInformation::BombState' has a wrong offset!");
static_assert(offsetof(FHm_BombInformation, TimeRemaining) == 0x000014, "Member 'FHm_BombInformation::TimeRemaining' has a wrong offset!");

// ScriptStruct ReadyOrNot.Hm_DoorChunkInformation
// 0x0040 (0x0040 - 0x0000)
struct FHm_DoorChunkInformation final 
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsSimulating;                                     // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FAF[0xF];                                     // 0x0031(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHm_DoorChunkInformation) == 0x000010, "Wrong alignment on FHm_DoorChunkInformation");
static_assert(sizeof(FHm_DoorChunkInformation) == 0x000040, "Wrong size on FHm_DoorChunkInformation");
static_assert(offsetof(FHm_DoorChunkInformation, Transform) == 0x000000, "Member 'FHm_DoorChunkInformation::Transform' has a wrong offset!");
static_assert(offsetof(FHm_DoorChunkInformation, bIsSimulating) == 0x000030, "Member 'FHm_DoorChunkInformation::bIsSimulating' has a wrong offset!");

// ScriptStruct ReadyOrNot.Hm_DoorInformation
// 0x0070 (0x0070 - 0x0000)
struct FHm_DoorInformation final 
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBroken;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB0[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OpenCloseAmount;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB1[0x8];                                     // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             DoorMeshTransform;                                 // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsSimulatingPhysics;                              // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB2[0x7];                                     // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHm_DoorChunkInformation>       DoorChunkInformations;                             // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   TrapName;                                          // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHm_DoorInformation) == 0x000010, "Wrong alignment on FHm_DoorInformation");
static_assert(sizeof(FHm_DoorInformation) == 0x000070, "Wrong size on FHm_DoorInformation");
static_assert(offsetof(FHm_DoorInformation, Name) == 0x000000, "Member 'FHm_DoorInformation::Name' has a wrong offset!");
static_assert(offsetof(FHm_DoorInformation, bIsBroken) == 0x000010, "Member 'FHm_DoorInformation::bIsBroken' has a wrong offset!");
static_assert(offsetof(FHm_DoorInformation, OpenCloseAmount) == 0x000014, "Member 'FHm_DoorInformation::OpenCloseAmount' has a wrong offset!");
static_assert(offsetof(FHm_DoorInformation, DoorMeshTransform) == 0x000020, "Member 'FHm_DoorInformation::DoorMeshTransform' has a wrong offset!");
static_assert(offsetof(FHm_DoorInformation, bIsSimulatingPhysics) == 0x000050, "Member 'FHm_DoorInformation::bIsSimulatingPhysics' has a wrong offset!");
static_assert(offsetof(FHm_DoorInformation, DoorChunkInformations) == 0x000058, "Member 'FHm_DoorInformation::DoorChunkInformations' has a wrong offset!");
static_assert(offsetof(FHm_DoorInformation, TrapName) == 0x000068, "Member 'FHm_DoorInformation::TrapName' has a wrong offset!");

// ScriptStruct ReadyOrNot.Hm_CyberneticsInformation
// 0x00E0 (0x00E0 - 0x0000)
struct FHm_CyberneticsInformation final 
{
public:
	struct FTransform                             CharacterTransform;                                // 0x0000(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ETeamType                                     TeamType;                                          // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB3[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsArrested;                                       // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSurrendered;                                    // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenReported;                                  // 0x003A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB4[0x5];                                     // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Tags;                                              // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseItem>                  EquippedItemClass;                                 // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterMesh                         CharacterMeshData;                                 // 0x0058(0x0088)(ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHm_CyberneticsInformation) == 0x000010, "Wrong alignment on FHm_CyberneticsInformation");
static_assert(sizeof(FHm_CyberneticsInformation) == 0x0000E0, "Wrong size on FHm_CyberneticsInformation");
static_assert(offsetof(FHm_CyberneticsInformation, CharacterTransform) == 0x000000, "Member 'FHm_CyberneticsInformation::CharacterTransform' has a wrong offset!");
static_assert(offsetof(FHm_CyberneticsInformation, TeamType) == 0x000030, "Member 'FHm_CyberneticsInformation::TeamType' has a wrong offset!");
static_assert(offsetof(FHm_CyberneticsInformation, Health) == 0x000034, "Member 'FHm_CyberneticsInformation::Health' has a wrong offset!");
static_assert(offsetof(FHm_CyberneticsInformation, bIsArrested) == 0x000038, "Member 'FHm_CyberneticsInformation::bIsArrested' has a wrong offset!");
static_assert(offsetof(FHm_CyberneticsInformation, bIsSurrendered) == 0x000039, "Member 'FHm_CyberneticsInformation::bIsSurrendered' has a wrong offset!");
static_assert(offsetof(FHm_CyberneticsInformation, bHasBeenReported) == 0x00003A, "Member 'FHm_CyberneticsInformation::bHasBeenReported' has a wrong offset!");
static_assert(offsetof(FHm_CyberneticsInformation, Tags) == 0x000040, "Member 'FHm_CyberneticsInformation::Tags' has a wrong offset!");
static_assert(offsetof(FHm_CyberneticsInformation, EquippedItemClass) == 0x000050, "Member 'FHm_CyberneticsInformation::EquippedItemClass' has a wrong offset!");
static_assert(offsetof(FHm_CyberneticsInformation, CharacterMeshData) == 0x000058, "Member 'FHm_CyberneticsInformation::CharacterMeshData' has a wrong offset!");

// ScriptStruct ReadyOrNot.Hm_InventoryInformation
// 0x0020 (0x0020 - 0x0000)
struct FHm_InventoryInformation final 
{
public:
	TSubclassOf<class ABaseItem>                  Class;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMagazine>                      Magazines;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MagIndex;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB5[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHm_InventoryInformation) == 0x000008, "Wrong alignment on FHm_InventoryInformation");
static_assert(sizeof(FHm_InventoryInformation) == 0x000020, "Wrong size on FHm_InventoryInformation");
static_assert(offsetof(FHm_InventoryInformation, Class) == 0x000000, "Member 'FHm_InventoryInformation::Class' has a wrong offset!");
static_assert(offsetof(FHm_InventoryInformation, Magazines) == 0x000008, "Member 'FHm_InventoryInformation::Magazines' has a wrong offset!");
static_assert(offsetof(FHm_InventoryInformation, MagIndex) == 0x000018, "Member 'FHm_InventoryInformation::MagIndex' has a wrong offset!");

// ScriptStruct ReadyOrNot.Hm_PlayerInformation
// 0x0090 (0x0090 - 0x0000)
struct FHm_PlayerInformation final 
{
public:
	class FString                                 UniqueId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 SaveData;                                          // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTransform                             CharacterTransform;                                // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ControlRotation;                                   // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseItem>                  EquippedItemClass;                                 // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHm_InventoryInformation>       Inventory;                                         // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TotalGrenades;                                     // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalDevices;                                      // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenReported;                                  // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB6[0xF];                                     // 0x0081(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHm_PlayerInformation) == 0x000010, "Wrong alignment on FHm_PlayerInformation");
static_assert(sizeof(FHm_PlayerInformation) == 0x000090, "Wrong size on FHm_PlayerInformation");
static_assert(offsetof(FHm_PlayerInformation, UniqueId) == 0x000000, "Member 'FHm_PlayerInformation::UniqueId' has a wrong offset!");
static_assert(offsetof(FHm_PlayerInformation, SaveData) == 0x000010, "Member 'FHm_PlayerInformation::SaveData' has a wrong offset!");
static_assert(offsetof(FHm_PlayerInformation, CharacterTransform) == 0x000020, "Member 'FHm_PlayerInformation::CharacterTransform' has a wrong offset!");
static_assert(offsetof(FHm_PlayerInformation, ControlRotation) == 0x000050, "Member 'FHm_PlayerInformation::ControlRotation' has a wrong offset!");
static_assert(offsetof(FHm_PlayerInformation, Health) == 0x00005C, "Member 'FHm_PlayerInformation::Health' has a wrong offset!");
static_assert(offsetof(FHm_PlayerInformation, EquippedItemClass) == 0x000060, "Member 'FHm_PlayerInformation::EquippedItemClass' has a wrong offset!");
static_assert(offsetof(FHm_PlayerInformation, Inventory) == 0x000068, "Member 'FHm_PlayerInformation::Inventory' has a wrong offset!");
static_assert(offsetof(FHm_PlayerInformation, TotalGrenades) == 0x000078, "Member 'FHm_PlayerInformation::TotalGrenades' has a wrong offset!");
static_assert(offsetof(FHm_PlayerInformation, TotalDevices) == 0x00007C, "Member 'FHm_PlayerInformation::TotalDevices' has a wrong offset!");
static_assert(offsetof(FHm_PlayerInformation, bHasBeenReported) == 0x000080, "Member 'FHm_PlayerInformation::bHasBeenReported' has a wrong offset!");

// ScriptStruct ReadyOrNot.SuspectArmourData
// 0x0068 (0x0070 - 0x0008)
struct FSuspectArmourData final  : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   BlueprintClass;                                    // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          Mesh;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHelmet;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ArmourLevel;                                       // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB7[0x2];                                     // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Durability;                                        // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMultiplier;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpallingChance;                                    // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeedMultiplier;                           // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementAccelerationMultiplier;                    // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        HitParticleEffect;                                 // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BlockedSoundEvent;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             PenetratedSoundEvent;                              // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             Footsteps;                                         // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSuspectArmourData) == 0x000008, "Wrong alignment on FSuspectArmourData");
static_assert(sizeof(FSuspectArmourData) == 0x000070, "Wrong size on FSuspectArmourData");
static_assert(offsetof(FSuspectArmourData, BlueprintClass) == 0x000008, "Member 'FSuspectArmourData::BlueprintClass' has a wrong offset!");
static_assert(offsetof(FSuspectArmourData, Mesh) == 0x000030, "Member 'FSuspectArmourData::Mesh' has a wrong offset!");
static_assert(offsetof(FSuspectArmourData, bIsHelmet) == 0x000038, "Member 'FSuspectArmourData::bIsHelmet' has a wrong offset!");
static_assert(offsetof(FSuspectArmourData, ArmourLevel) == 0x000039, "Member 'FSuspectArmourData::ArmourLevel' has a wrong offset!");
static_assert(offsetof(FSuspectArmourData, Durability) == 0x00003C, "Member 'FSuspectArmourData::Durability' has a wrong offset!");
static_assert(offsetof(FSuspectArmourData, DamageMultiplier) == 0x000040, "Member 'FSuspectArmourData::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(FSuspectArmourData, SpallingChance) == 0x000044, "Member 'FSuspectArmourData::SpallingChance' has a wrong offset!");
static_assert(offsetof(FSuspectArmourData, MovementSpeedMultiplier) == 0x000048, "Member 'FSuspectArmourData::MovementSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FSuspectArmourData, MovementAccelerationMultiplier) == 0x00004C, "Member 'FSuspectArmourData::MovementAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(FSuspectArmourData, HitParticleEffect) == 0x000050, "Member 'FSuspectArmourData::HitParticleEffect' has a wrong offset!");
static_assert(offsetof(FSuspectArmourData, BlockedSoundEvent) == 0x000058, "Member 'FSuspectArmourData::BlockedSoundEvent' has a wrong offset!");
static_assert(offsetof(FSuspectArmourData, PenetratedSoundEvent) == 0x000060, "Member 'FSuspectArmourData::PenetratedSoundEvent' has a wrong offset!");
static_assert(offsetof(FSuspectArmourData, Footsteps) == 0x000068, "Member 'FSuspectArmourData::Footsteps' has a wrong offset!");

// ScriptStruct ReadyOrNot.ImpactFx
// 0x0030 (0x0030 - 0x0000)
struct FImpactFx final 
{
public:
	class UParticleSystem*                        ParticleFx;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SoundFx;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Decal;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomFrame;                                   // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB8[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FrameMax;                                          // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     DecalMesh;                                         // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PaintMaterialTexture;                              // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImpactFx) == 0x000008, "Wrong alignment on FImpactFx");
static_assert(sizeof(FImpactFx) == 0x000030, "Wrong size on FImpactFx");
static_assert(offsetof(FImpactFx, ParticleFx) == 0x000000, "Member 'FImpactFx::ParticleFx' has a wrong offset!");
static_assert(offsetof(FImpactFx, SoundFx) == 0x000008, "Member 'FImpactFx::SoundFx' has a wrong offset!");
static_assert(offsetof(FImpactFx, Decal) == 0x000010, "Member 'FImpactFx::Decal' has a wrong offset!");
static_assert(offsetof(FImpactFx, bUseRandomFrame) == 0x000018, "Member 'FImpactFx::bUseRandomFrame' has a wrong offset!");
static_assert(offsetof(FImpactFx, FrameMax) == 0x00001C, "Member 'FImpactFx::FrameMax' has a wrong offset!");
static_assert(offsetof(FImpactFx, DecalMesh) == 0x000020, "Member 'FImpactFx::DecalMesh' has a wrong offset!");
static_assert(offsetof(FImpactFx, PaintMaterialTexture) == 0x000028, "Member 'FImpactFx::PaintMaterialTexture' has a wrong offset!");

// ScriptStruct ReadyOrNot.PlayerActionPromptSlot
// 0x0090 (0x0090 - 0x0000)
struct FPlayerActionPromptSlot final 
{
public:
	class FName                                   InputActionName;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   InputEvent;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB9[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ActionText;                                        // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 ColorLabel;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseCustomActionText : 1;                          // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FBA[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CustomActionPromptText;                            // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         bCheckForDisallowedItems : 1;                      // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseCustomDisallowedActionText : 1;                // 0x0058(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FBB[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisallowedItemActionText;                          // 0x0060(0x0018)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<EItemCategory>                         DisallowedItems;                                   // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         bAnimate : 1;                                      // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLoopAnimation : 1;                                // 0x0088(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCondition : 1;                                    // 0x0088(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FBC[0x7];                                     // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerActionPromptSlot) == 0x000008, "Wrong alignment on FPlayerActionPromptSlot");
static_assert(sizeof(FPlayerActionPromptSlot) == 0x000090, "Wrong size on FPlayerActionPromptSlot");
static_assert(offsetof(FPlayerActionPromptSlot, InputActionName) == 0x000000, "Member 'FPlayerActionPromptSlot::InputActionName' has a wrong offset!");
static_assert(offsetof(FPlayerActionPromptSlot, InputEvent) == 0x000008, "Member 'FPlayerActionPromptSlot::InputEvent' has a wrong offset!");
static_assert(offsetof(FPlayerActionPromptSlot, ActionText) == 0x000010, "Member 'FPlayerActionPromptSlot::ActionText' has a wrong offset!");
static_assert(offsetof(FPlayerActionPromptSlot, ColorLabel) == 0x000028, "Member 'FPlayerActionPromptSlot::ColorLabel' has a wrong offset!");
static_assert(offsetof(FPlayerActionPromptSlot, CustomActionPromptText) == 0x000040, "Member 'FPlayerActionPromptSlot::CustomActionPromptText' has a wrong offset!");
static_assert(offsetof(FPlayerActionPromptSlot, DisallowedItemActionText) == 0x000060, "Member 'FPlayerActionPromptSlot::DisallowedItemActionText' has a wrong offset!");
static_assert(offsetof(FPlayerActionPromptSlot, DisallowedItems) == 0x000078, "Member 'FPlayerActionPromptSlot::DisallowedItems' has a wrong offset!");

// ScriptStruct ReadyOrNot.PairedInteractionTable
// 0x0050 (0x0058 - 0x0008)
struct FPairedInteractionTable final  : public FTableRowBase
{
public:
	TMap<class FName, class UInteractionsData*>   Interactions;                                      // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPairedInteractionTable) == 0x000008, "Wrong alignment on FPairedInteractionTable");
static_assert(sizeof(FPairedInteractionTable) == 0x000058, "Wrong size on FPairedInteractionTable");
static_assert(offsetof(FPairedInteractionTable, Interactions) == 0x000008, "Member 'FPairedInteractionTable::Interactions' has a wrong offset!");

// ScriptStruct ReadyOrNot.InterestPoint
// 0x0108 (0x0108 - 0x0000)
struct FInterestPoint final 
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterestPointType                            Type;                                              // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FBD[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AThreatAwarenessActor>   Threat;                                            // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ADoor>                   Door;                                              // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AAISpawn>                Spawner;                                           // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  CustomActor;                                       // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequiredTimeFocusing;                              // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FBE[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ACyberneticCharacter*, float>      TimeFocusing;                                      // 0x00B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterestPoint) == 0x000008, "Wrong alignment on FInterestPoint");
static_assert(sizeof(FInterestPoint) == 0x000108, "Wrong size on FInterestPoint");
static_assert(offsetof(FInterestPoint, Location) == 0x000000, "Member 'FInterestPoint::Location' has a wrong offset!");
static_assert(offsetof(FInterestPoint, Type) == 0x00000C, "Member 'FInterestPoint::Type' has a wrong offset!");
static_assert(offsetof(FInterestPoint, Threat) == 0x000010, "Member 'FInterestPoint::Threat' has a wrong offset!");
static_assert(offsetof(FInterestPoint, Door) == 0x000038, "Member 'FInterestPoint::Door' has a wrong offset!");
static_assert(offsetof(FInterestPoint, Spawner) == 0x000060, "Member 'FInterestPoint::Spawner' has a wrong offset!");
static_assert(offsetof(FInterestPoint, CustomActor) == 0x000088, "Member 'FInterestPoint::CustomActor' has a wrong offset!");
static_assert(offsetof(FInterestPoint, RequiredTimeFocusing) == 0x0000B0, "Member 'FInterestPoint::RequiredTimeFocusing' has a wrong offset!");
static_assert(offsetof(FInterestPoint, TimeFocusing) == 0x0000B8, "Member 'FInterestPoint::TimeFocusing' has a wrong offset!");

// ScriptStruct ReadyOrNot.DefaultCharacterCustomization
// 0x0018 (0x0018 - 0x0000)
struct FDefaultCharacterCustomization final 
{
public:
	class UCustomizationCharacter*                Character;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationVoice*                    Voice;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationSkin*                     ArmorSkin;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDefaultCharacterCustomization) == 0x000008, "Wrong alignment on FDefaultCharacterCustomization");
static_assert(sizeof(FDefaultCharacterCustomization) == 0x000018, "Wrong size on FDefaultCharacterCustomization");
static_assert(offsetof(FDefaultCharacterCustomization, Character) == 0x000000, "Member 'FDefaultCharacterCustomization::Character' has a wrong offset!");
static_assert(offsetof(FDefaultCharacterCustomization, Voice) == 0x000008, "Member 'FDefaultCharacterCustomization::Voice' has a wrong offset!");
static_assert(offsetof(FDefaultCharacterCustomization, ArmorSkin) == 0x000010, "Member 'FDefaultCharacterCustomization::ArmorSkin' has a wrong offset!");

// ScriptStruct ReadyOrNot.CharacterData
// 0x0090 (0x0090 - 0x0000)
struct FCharacterData final 
{
public:
	class FName                                   Handle;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              CharacterIcon;                                     // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemClass                                    ItemClass;                                         // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FBF[0x7];                                     // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPlayableCharacterData>  Blueprint;                                         // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterData) == 0x000008, "Wrong alignment on FCharacterData");
static_assert(sizeof(FCharacterData) == 0x000090, "Wrong size on FCharacterData");
static_assert(offsetof(FCharacterData, Handle) == 0x000000, "Member 'FCharacterData::Handle' has a wrong offset!");
static_assert(offsetof(FCharacterData, Name) == 0x000008, "Member 'FCharacterData::Name' has a wrong offset!");
static_assert(offsetof(FCharacterData, Title) == 0x000020, "Member 'FCharacterData::Title' has a wrong offset!");
static_assert(offsetof(FCharacterData, CharacterIcon) == 0x000038, "Member 'FCharacterData::CharacterIcon' has a wrong offset!");
static_assert(offsetof(FCharacterData, ItemClass) == 0x000060, "Member 'FCharacterData::ItemClass' has a wrong offset!");
static_assert(offsetof(FCharacterData, Blueprint) == 0x000068, "Member 'FCharacterData::Blueprint' has a wrong offset!");

// ScriptStruct ReadyOrNot.UniformData
// 0x0050 (0x0050 - 0x0000)
struct FUniformData final 
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemClass                                    ItemClass;                                         // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC0[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseItem>                  Blueprint;                                         // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniformData) == 0x000008, "Wrong alignment on FUniformData");
static_assert(sizeof(FUniformData) == 0x000050, "Wrong size on FUniformData");
static_assert(offsetof(FUniformData, Name) == 0x000000, "Member 'FUniformData::Name' has a wrong offset!");
static_assert(offsetof(FUniformData, Image) == 0x000018, "Member 'FUniformData::Image' has a wrong offset!");
static_assert(offsetof(FUniformData, ItemClass) == 0x000040, "Member 'FUniformData::ItemClass' has a wrong offset!");
static_assert(offsetof(FUniformData, Blueprint) == 0x000048, "Member 'FUniformData::Blueprint' has a wrong offset!");

// ScriptStruct ReadyOrNot.ArmourData
// 0x0058 (0x0058 - 0x0000)
struct FArmourData final 
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           ProtectsAgainstText;                               // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemClass                                    ItemClass;                                         // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC1[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseItem>                  Blueprint;                                         // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmourData) == 0x000008, "Wrong alignment on FArmourData");
static_assert(sizeof(FArmourData) == 0x000058, "Wrong size on FArmourData");
static_assert(offsetof(FArmourData, Name) == 0x000000, "Member 'FArmourData::Name' has a wrong offset!");
static_assert(offsetof(FArmourData, ProtectsAgainstText) == 0x000010, "Member 'FArmourData::ProtectsAgainstText' has a wrong offset!");
static_assert(offsetof(FArmourData, Image) == 0x000020, "Member 'FArmourData::Image' has a wrong offset!");
static_assert(offsetof(FArmourData, ItemClass) == 0x000048, "Member 'FArmourData::ItemClass' has a wrong offset!");
static_assert(offsetof(FArmourData, Blueprint) == 0x000050, "Member 'FArmourData::Blueprint' has a wrong offset!");

// ScriptStruct ReadyOrNot.SubtitleParameters
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FSubtitleParameters final 
{
public:
	uint8                                         Pad_1FC2[0x50];                                    // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubtitleParameters) == 0x000008, "Wrong alignment on FSubtitleParameters");
static_assert(sizeof(FSubtitleParameters) == 0x000050, "Wrong size on FSubtitleParameters");

// ScriptStruct ReadyOrNot.DeviceData
// 0x0140 (0x0140 - 0x0000)
struct FDeviceData final 
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              CarouselImage1;                                    // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              CarouselImage2;                                    // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              CarouselImage3;                                    // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EffectiveRange;                                    // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Use;                                               // 0x00C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Effects;                                           // 0x00E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Risk;                                              // 0x00F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ToMitigate;                                        // 0x0110(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EItemClass                                    ItemClass;                                         // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC3[0x3];                                     // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxInInventory;                                    // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemsPerSlot;                                      // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC4[0x4];                                     // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseItem>                  Blueprint;                                         // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeviceData) == 0x000008, "Wrong alignment on FDeviceData");
static_assert(sizeof(FDeviceData) == 0x000140, "Wrong size on FDeviceData");
static_assert(offsetof(FDeviceData, Name) == 0x000000, "Member 'FDeviceData::Name' has a wrong offset!");
static_assert(offsetof(FDeviceData, Image) == 0x000010, "Member 'FDeviceData::Image' has a wrong offset!");
static_assert(offsetof(FDeviceData, CarouselImage1) == 0x000038, "Member 'FDeviceData::CarouselImage1' has a wrong offset!");
static_assert(offsetof(FDeviceData, CarouselImage2) == 0x000060, "Member 'FDeviceData::CarouselImage2' has a wrong offset!");
static_assert(offsetof(FDeviceData, CarouselImage3) == 0x000088, "Member 'FDeviceData::CarouselImage3' has a wrong offset!");
static_assert(offsetof(FDeviceData, EffectiveRange) == 0x0000B0, "Member 'FDeviceData::EffectiveRange' has a wrong offset!");
static_assert(offsetof(FDeviceData, Use) == 0x0000C8, "Member 'FDeviceData::Use' has a wrong offset!");
static_assert(offsetof(FDeviceData, Effects) == 0x0000E0, "Member 'FDeviceData::Effects' has a wrong offset!");
static_assert(offsetof(FDeviceData, Risk) == 0x0000F8, "Member 'FDeviceData::Risk' has a wrong offset!");
static_assert(offsetof(FDeviceData, ToMitigate) == 0x000110, "Member 'FDeviceData::ToMitigate' has a wrong offset!");
static_assert(offsetof(FDeviceData, ItemClass) == 0x000128, "Member 'FDeviceData::ItemClass' has a wrong offset!");
static_assert(offsetof(FDeviceData, MaxInInventory) == 0x00012C, "Member 'FDeviceData::MaxInInventory' has a wrong offset!");
static_assert(offsetof(FDeviceData, ItemsPerSlot) == 0x000130, "Member 'FDeviceData::ItemsPerSlot' has a wrong offset!");
static_assert(offsetof(FDeviceData, Blueprint) == 0x000138, "Member 'FDeviceData::Blueprint' has a wrong offset!");

// ScriptStruct ReadyOrNot.GrenadeData
// 0x0048 (0x0048 - 0x0000)
struct FGrenadeData final 
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemClass                                    ItemClass;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC5[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseGrenade>               Blueprint;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGrenadeData) == 0x000008, "Wrong alignment on FGrenadeData");
static_assert(sizeof(FGrenadeData) == 0x000048, "Wrong size on FGrenadeData");
static_assert(offsetof(FGrenadeData, Name) == 0x000000, "Member 'FGrenadeData::Name' has a wrong offset!");
static_assert(offsetof(FGrenadeData, Image) == 0x000010, "Member 'FGrenadeData::Image' has a wrong offset!");
static_assert(offsetof(FGrenadeData, ItemClass) == 0x000038, "Member 'FGrenadeData::ItemClass' has a wrong offset!");
static_assert(offsetof(FGrenadeData, Blueprint) == 0x000040, "Member 'FGrenadeData::Blueprint' has a wrong offset!");

// ScriptStruct ReadyOrNot.EffectsMultiplierStruct
// 0x0008 (0x0008 - 0x0000)
struct FEffectsMultiplierStruct final 
{
public:
	bool                                          bShouldReverse;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC6[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Multiplier;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectsMultiplierStruct) == 0x000004, "Wrong alignment on FEffectsMultiplierStruct");
static_assert(sizeof(FEffectsMultiplierStruct) == 0x000008, "Wrong size on FEffectsMultiplierStruct");
static_assert(offsetof(FEffectsMultiplierStruct, bShouldReverse) == 0x000000, "Member 'FEffectsMultiplierStruct::bShouldReverse' has a wrong offset!");
static_assert(offsetof(FEffectsMultiplierStruct, Multiplier) == 0x000004, "Member 'FEffectsMultiplierStruct::Multiplier' has a wrong offset!");

// ScriptStruct ReadyOrNot.LoadoutCategory
// 0x0001 (0x0001 - 0x0000)
struct ReadyOrNot::FLoadoutCategory final 
{
public:
	uint8                                         Pad_1FC7[0x1];                                     // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ReadyOrNot::FLoadoutCategory) == 0x000001, "Wrong alignment on ReadyOrNot::FLoadoutCategory");
static_assert(sizeof(ReadyOrNot::FLoadoutCategory) == 0x000001, "Wrong size on ReadyOrNot::FLoadoutCategory");

// ScriptStruct ReadyOrNot.AnalyticsStatus
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FAnalyticsStatus final 
{
public:
	uint8                                         Pad_1FC8[0x70];                                    // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnalyticsStatus) == 0x000008, "Wrong alignment on FAnalyticsStatus");
static_assert(sizeof(FAnalyticsStatus) == 0x000070, "Wrong size on FAnalyticsStatus");

// ScriptStruct ReadyOrNot.AnalyticsSuspectState
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FAnalyticsSuspectState final 
{
public:
	uint8                                         Pad_1FC9[0x50];                                    // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnalyticsSuspectState) == 0x000008, "Wrong alignment on FAnalyticsSuspectState");
static_assert(sizeof(FAnalyticsSuspectState) == 0x000050, "Wrong size on FAnalyticsSuspectState");

// ScriptStruct ReadyOrNot.MessagePromptContent
// 0x0050 (0x0050 - 0x0000)
struct FMessagePromptContent final 
{
public:
	class FName                                   InputActionName;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   InputEvent;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FCA[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ActionText;                                        // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsAxisEvent;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FCB[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KeyIndex;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseCustomActionText : 1;                          // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FCC[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CustomActionPromptText;                            // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMessagePromptContent) == 0x000008, "Wrong alignment on FMessagePromptContent");
static_assert(sizeof(FMessagePromptContent) == 0x000050, "Wrong size on FMessagePromptContent");
static_assert(offsetof(FMessagePromptContent, InputActionName) == 0x000000, "Member 'FMessagePromptContent::InputActionName' has a wrong offset!");
static_assert(offsetof(FMessagePromptContent, InputEvent) == 0x000008, "Member 'FMessagePromptContent::InputEvent' has a wrong offset!");
static_assert(offsetof(FMessagePromptContent, ActionText) == 0x000010, "Member 'FMessagePromptContent::ActionText' has a wrong offset!");
static_assert(offsetof(FMessagePromptContent, bIsAxisEvent) == 0x000028, "Member 'FMessagePromptContent::bIsAxisEvent' has a wrong offset!");
static_assert(offsetof(FMessagePromptContent, KeyIndex) == 0x00002C, "Member 'FMessagePromptContent::KeyIndex' has a wrong offset!");
static_assert(offsetof(FMessagePromptContent, CustomActionPromptText) == 0x000038, "Member 'FMessagePromptContent::CustomActionPromptText' has a wrong offset!");

// ScriptStruct ReadyOrNot.MetaGameProfileTemporaryData
// 0x0068 (0x0068 - 0x0000)
struct FMetaGameProfileTemporaryData final 
{
public:
	TArray<class FString>                         NewCompletedLevels;                                // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<class FName>                             NewProgressionTags;                                // 0x0010(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FExfiltrationData                      ExfilData;                                         // 0x0060(0x0003)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FCD[0x5];                                     // 0x0063(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMetaGameProfileTemporaryData) == 0x000008, "Wrong alignment on FMetaGameProfileTemporaryData");
static_assert(sizeof(FMetaGameProfileTemporaryData) == 0x000068, "Wrong size on FMetaGameProfileTemporaryData");
static_assert(offsetof(FMetaGameProfileTemporaryData, NewCompletedLevels) == 0x000000, "Member 'FMetaGameProfileTemporaryData::NewCompletedLevels' has a wrong offset!");
static_assert(offsetof(FMetaGameProfileTemporaryData, NewProgressionTags) == 0x000010, "Member 'FMetaGameProfileTemporaryData::NewProgressionTags' has a wrong offset!");
static_assert(offsetof(FMetaGameProfileTemporaryData, ExfilData) == 0x000060, "Member 'FMetaGameProfileTemporaryData::ExfilData' has a wrong offset!");

// ScriptStruct ReadyOrNot.PlanningDrawingUpdate
// 0x0010 (0x0010 - 0x0000)
struct FPlanningDrawingUpdate final 
{
public:
	TArray<struct FVector2D>                      NewPoints;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlanningDrawingUpdate) == 0x000008, "Wrong alignment on FPlanningDrawingUpdate");
static_assert(sizeof(FPlanningDrawingUpdate) == 0x000010, "Wrong size on FPlanningDrawingUpdate");
static_assert(offsetof(FPlanningDrawingUpdate, NewPoints) == 0x000000, "Member 'FPlanningDrawingUpdate::NewPoints' has a wrong offset!");

// ScriptStruct ReadyOrNot.PlanningLineArray
// 0x0040 (0x0148 - 0x0108)
struct FPlanningLineArray final  : public FFastArraySerializer
{
public:
	TArray<struct FPlanningLine>                  Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FCE[0x30];                                    // 0x0118(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlanningLineArray) == 0x000008, "Wrong alignment on FPlanningLineArray");
static_assert(sizeof(FPlanningLineArray) == 0x000148, "Wrong size on FPlanningLineArray");
static_assert(offsetof(FPlanningLineArray, Items) == 0x000108, "Member 'FPlanningLineArray::Items' has a wrong offset!");

// ScriptStruct ReadyOrNot.PlanningMarkerArray
// 0x0040 (0x0148 - 0x0108)
struct FPlanningMarkerArray final  : public FFastArraySerializer
{
public:
	TArray<struct FPlanningMarker>                Items;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FCF[0x30];                                    // 0x0118(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlanningMarkerArray) == 0x000008, "Wrong alignment on FPlanningMarkerArray");
static_assert(sizeof(FPlanningMarkerArray) == 0x000148, "Wrong size on FPlanningMarkerArray");
static_assert(offsetof(FPlanningMarkerArray, Items) == 0x000108, "Member 'FPlanningMarkerArray::Items' has a wrong offset!");

// ScriptStruct ReadyOrNot.MoraleChangeInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FMoraleChangeInfo final 
{
public:
	uint8                                         Pad_1FD0[0x8];                                     // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoraleChangeInfo) == 0x000004, "Wrong alignment on FMoraleChangeInfo");
static_assert(sizeof(FMoraleChangeInfo) == 0x000008, "Wrong size on FMoraleChangeInfo");

// ScriptStruct ReadyOrNot.MoraleDamageTraceParameters
// 0x0028 (0x0028 - 0x0000)
struct FMoraleDamageTraceParameters final 
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD1[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         IgnoredActors;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            IgnoredComponents;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoraleDamageTraceParameters) == 0x000008, "Wrong alignment on FMoraleDamageTraceParameters");
static_assert(sizeof(FMoraleDamageTraceParameters) == 0x000028, "Wrong size on FMoraleDamageTraceParameters");
static_assert(offsetof(FMoraleDamageTraceParameters, bEnable) == 0x000000, "Member 'FMoraleDamageTraceParameters::bEnable' has a wrong offset!");
static_assert(offsetof(FMoraleDamageTraceParameters, TraceChannel) == 0x000001, "Member 'FMoraleDamageTraceParameters::TraceChannel' has a wrong offset!");
static_assert(offsetof(FMoraleDamageTraceParameters, IgnoredActors) == 0x000008, "Member 'FMoraleDamageTraceParameters::IgnoredActors' has a wrong offset!");
static_assert(offsetof(FMoraleDamageTraceParameters, IgnoredComponents) == 0x000018, "Member 'FMoraleDamageTraceParameters::IgnoredComponents' has a wrong offset!");

// ScriptStruct ReadyOrNot.MusicTrackFMOD
// 0x0010 (0x0010 - 0x0000)
struct FMusicTrackFMOD final 
{
public:
	class UFMODEvent*                             PreplanningEvent;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             LevelEvent;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMusicTrackFMOD) == 0x000008, "Wrong alignment on FMusicTrackFMOD");
static_assert(sizeof(FMusicTrackFMOD) == 0x000010, "Wrong size on FMusicTrackFMOD");
static_assert(offsetof(FMusicTrackFMOD, PreplanningEvent) == 0x000000, "Member 'FMusicTrackFMOD::PreplanningEvent' has a wrong offset!");
static_assert(offsetof(FMusicTrackFMOD, LevelEvent) == 0x000008, "Member 'FMusicTrackFMOD::LevelEvent' has a wrong offset!");

// ScriptStruct ReadyOrNot.MusicKeyframe
// 0x0018 (0x0018 - 0x0000)
struct FMusicKeyframe final 
{
public:
	float                                         Position;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Label;                                             // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransitionExit;                                   // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD2[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              TransitionPiece;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMusicKeyframe) == 0x000008, "Wrong alignment on FMusicKeyframe");
static_assert(sizeof(FMusicKeyframe) == 0x000018, "Wrong size on FMusicKeyframe");
static_assert(offsetof(FMusicKeyframe, Position) == 0x000000, "Member 'FMusicKeyframe::Position' has a wrong offset!");
static_assert(offsetof(FMusicKeyframe, Label) == 0x000004, "Member 'FMusicKeyframe::Label' has a wrong offset!");
static_assert(offsetof(FMusicKeyframe, bTransitionExit) == 0x00000C, "Member 'FMusicKeyframe::bTransitionExit' has a wrong offset!");
static_assert(offsetof(FMusicKeyframe, TransitionPiece) == 0x000010, "Member 'FMusicKeyframe::TransitionPiece' has a wrong offset!");

// ScriptStruct ReadyOrNot.MusicTrack
// 0x0028 (0x0028 - 0x0000)
struct FMusicTrack final 
{
public:
	class USoundCue*                              MusicPiece;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransitionMusic;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD3[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeTime;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumTime;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD4[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMusicKeyframe>                 Keyframes;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMusicTrack) == 0x000008, "Wrong alignment on FMusicTrack");
static_assert(sizeof(FMusicTrack) == 0x000028, "Wrong size on FMusicTrack");
static_assert(offsetof(FMusicTrack, MusicPiece) == 0x000000, "Member 'FMusicTrack::MusicPiece' has a wrong offset!");
static_assert(offsetof(FMusicTrack, bTransitionMusic) == 0x000008, "Member 'FMusicTrack::bTransitionMusic' has a wrong offset!");
static_assert(offsetof(FMusicTrack, FadeTime) == 0x00000C, "Member 'FMusicTrack::FadeTime' has a wrong offset!");
static_assert(offsetof(FMusicTrack, MinimumTime) == 0x000010, "Member 'FMusicTrack::MinimumTime' has a wrong offset!");
static_assert(offsetof(FMusicTrack, Keyframes) == 0x000018, "Member 'FMusicTrack::Keyframes' has a wrong offset!");

// ScriptStruct ReadyOrNot.ScreenFooterEntry
// 0x0030 (0x0030 - 0x0000)
struct FScreenFooterEntry final 
{
public:
	EInputExclusiveType                           OnlyDisplayWithInput;                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextJustify                                  Alignment;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsButton;                                          // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD5[0x5];                                     // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ButtonLabel;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    InputAction;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenFooterEntry) == 0x000008, "Wrong alignment on FScreenFooterEntry");
static_assert(sizeof(FScreenFooterEntry) == 0x000030, "Wrong size on FScreenFooterEntry");
static_assert(offsetof(FScreenFooterEntry, OnlyDisplayWithInput) == 0x000000, "Member 'FScreenFooterEntry::OnlyDisplayWithInput' has a wrong offset!");
static_assert(offsetof(FScreenFooterEntry, Alignment) == 0x000001, "Member 'FScreenFooterEntry::Alignment' has a wrong offset!");
static_assert(offsetof(FScreenFooterEntry, IsButton) == 0x000002, "Member 'FScreenFooterEntry::IsButton' has a wrong offset!");
static_assert(offsetof(FScreenFooterEntry, ButtonLabel) == 0x000008, "Member 'FScreenFooterEntry::ButtonLabel' has a wrong offset!");
static_assert(offsetof(FScreenFooterEntry, InputAction) == 0x000020, "Member 'FScreenFooterEntry::InputAction' has a wrong offset!");

// ScriptStruct ReadyOrNot.PatrolPoint
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FPatrolPoint final 
{
public:
	uint8                                         Pad_1FD6[0x20];                                    // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPatrolPoint) == 0x000008, "Wrong alignment on FPatrolPoint");
static_assert(sizeof(FPatrolPoint) == 0x000020, "Wrong size on FPatrolPoint");

// ScriptStruct ReadyOrNot.MaterialPenetration
// 0x0018 (0x0018 - 0x0000)
struct FMaterialPenetration final 
{
public:
	bool                                          bIsPenetrable;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD7[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PenetrationDensity;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationMultiplier;                             // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ArmourLevel;                                       // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanRicochet;                                      // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD8[0x2];                                     // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RicochetChanceMultiplier;                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpallingChance;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialPenetration) == 0x000004, "Wrong alignment on FMaterialPenetration");
static_assert(sizeof(FMaterialPenetration) == 0x000018, "Wrong size on FMaterialPenetration");
static_assert(offsetof(FMaterialPenetration, bIsPenetrable) == 0x000000, "Member 'FMaterialPenetration::bIsPenetrable' has a wrong offset!");
static_assert(offsetof(FMaterialPenetration, PenetrationDensity) == 0x000004, "Member 'FMaterialPenetration::PenetrationDensity' has a wrong offset!");
static_assert(offsetof(FMaterialPenetration, PenetrationMultiplier) == 0x000008, "Member 'FMaterialPenetration::PenetrationMultiplier' has a wrong offset!");
static_assert(offsetof(FMaterialPenetration, ArmourLevel) == 0x00000C, "Member 'FMaterialPenetration::ArmourLevel' has a wrong offset!");
static_assert(offsetof(FMaterialPenetration, bCanRicochet) == 0x00000D, "Member 'FMaterialPenetration::bCanRicochet' has a wrong offset!");
static_assert(offsetof(FMaterialPenetration, RicochetChanceMultiplier) == 0x000010, "Member 'FMaterialPenetration::RicochetChanceMultiplier' has a wrong offset!");
static_assert(offsetof(FMaterialPenetration, SpallingChance) == 0x000014, "Member 'FMaterialPenetration::SpallingChance' has a wrong offset!");

// ScriptStruct ReadyOrNot.PingData
// 0x00A8 (0x00A8 - 0x0000)
struct FPingData final 
{
public:
	struct FSlateBrush                            IconBrush;                                         // 0x0000(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   PingText;                                          // 0x0088(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD9[0x4];                                     // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPingData) == 0x000008, "Wrong alignment on FPingData");
static_assert(sizeof(FPingData) == 0x0000A8, "Wrong size on FPingData");
static_assert(offsetof(FPingData, IconBrush) == 0x000000, "Member 'FPingData::IconBrush' has a wrong offset!");
static_assert(offsetof(FPingData, PingText) == 0x000088, "Member 'FPingData::PingText' has a wrong offset!");
static_assert(offsetof(FPingData, Duration) == 0x0000A0, "Member 'FPingData::Duration' has a wrong offset!");

// ScriptStruct ReadyOrNot.WoundData
// 0x00A0 (0x00A0 - 0x0000)
struct FWoundData final 
{
public:
	float                                         WoundSize;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WoundOffset;                                       // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            UpperMesh;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FDA[0x8];                                     // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             UpperMeshTranform;                                 // 0x0020(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UStaticMesh*                            LowerMesh;                                         // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FDB[0x8];                                     // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LowerMeshTranform;                                 // 0x0060(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bBreaksBone;                                       // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FDC[0xF];                                     // 0x0091(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWoundData) == 0x000010, "Wrong alignment on FWoundData");
static_assert(sizeof(FWoundData) == 0x0000A0, "Wrong size on FWoundData");
static_assert(offsetof(FWoundData, WoundSize) == 0x000000, "Member 'FWoundData::WoundSize' has a wrong offset!");
static_assert(offsetof(FWoundData, WoundOffset) == 0x000004, "Member 'FWoundData::WoundOffset' has a wrong offset!");
static_assert(offsetof(FWoundData, UpperMesh) == 0x000010, "Member 'FWoundData::UpperMesh' has a wrong offset!");
static_assert(offsetof(FWoundData, UpperMeshTranform) == 0x000020, "Member 'FWoundData::UpperMeshTranform' has a wrong offset!");
static_assert(offsetof(FWoundData, LowerMesh) == 0x000050, "Member 'FWoundData::LowerMesh' has a wrong offset!");
static_assert(offsetof(FWoundData, LowerMeshTranform) == 0x000060, "Member 'FWoundData::LowerMeshTranform' has a wrong offset!");
static_assert(offsetof(FWoundData, bBreaksBone) == 0x000090, "Member 'FWoundData::bBreaksBone' has a wrong offset!");

// ScriptStruct ReadyOrNot.HealingData
// 0x0020 (0x0020 - 0x0000)
struct FHealingData final 
{
public:
	float                                         CurrentHealth;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHealth;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHealth;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HealerName;                                        // 0x000C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HealeeName;                                        // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMedicalHealScreen                            HealScreen;                                        // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FDD[0x3];                                     // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHealingData) == 0x000004, "Wrong alignment on FHealingData");
static_assert(sizeof(FHealingData) == 0x000020, "Wrong size on FHealingData");
static_assert(offsetof(FHealingData, CurrentHealth) == 0x000000, "Member 'FHealingData::CurrentHealth' has a wrong offset!");
static_assert(offsetof(FHealingData, MinHealth) == 0x000004, "Member 'FHealingData::MinHealth' has a wrong offset!");
static_assert(offsetof(FHealingData, MaxHealth) == 0x000008, "Member 'FHealingData::MaxHealth' has a wrong offset!");
static_assert(offsetof(FHealingData, HealerName) == 0x00000C, "Member 'FHealingData::HealerName' has a wrong offset!");
static_assert(offsetof(FHealingData, HealeeName) == 0x000014, "Member 'FHealingData::HealeeName' has a wrong offset!");
static_assert(offsetof(FHealingData, HealScreen) == 0x00001C, "Member 'FHealingData::HealScreen' has a wrong offset!");

// ScriptStruct ReadyOrNot.FootIKStruct
// 0x0010 (0x0010 - 0x0000)
struct FFootIKStruct final 
{
public:
	float                                         Offset;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FootRotation;                                      // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootIKStruct) == 0x000004, "Wrong alignment on FFootIKStruct");
static_assert(sizeof(FFootIKStruct) == 0x000010, "Wrong size on FFootIKStruct");
static_assert(offsetof(FFootIKStruct, Offset) == 0x000000, "Member 'FFootIKStruct::Offset' has a wrong offset!");
static_assert(offsetof(FFootIKStruct, FootRotation) == 0x000004, "Member 'FFootIKStruct::FootRotation' has a wrong offset!");

// ScriptStruct ReadyOrNot.Injury
// 0x000C (0x000C - 0x0000)
struct FInjury final 
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InjuryCount;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInjury) == 0x000004, "Wrong alignment on FInjury");
static_assert(sizeof(FInjury) == 0x00000C, "Wrong size on FInjury");
static_assert(offsetof(FInjury, BoneName) == 0x000000, "Member 'FInjury::BoneName' has a wrong offset!");
static_assert(offsetof(FInjury, InjuryCount) == 0x000008, "Member 'FInjury::InjuryCount' has a wrong offset!");

// ScriptStruct ReadyOrNot.BoneVelocity
// 0x0018 (0x0018 - 0x0000)
struct FBoneVelocity final 
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastLocation;                                      // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CalculatedSpeed;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoneVelocity) == 0x000004, "Wrong alignment on FBoneVelocity");
static_assert(sizeof(FBoneVelocity) == 0x000018, "Wrong size on FBoneVelocity");
static_assert(offsetof(FBoneVelocity, BoneName) == 0x000000, "Member 'FBoneVelocity::BoneName' has a wrong offset!");
static_assert(offsetof(FBoneVelocity, LastLocation) == 0x000008, "Member 'FBoneVelocity::LastLocation' has a wrong offset!");
static_assert(offsetof(FBoneVelocity, CalculatedSpeed) == 0x000014, "Member 'FBoneVelocity::CalculatedSpeed' has a wrong offset!");

// ScriptStruct ReadyOrNot.SpecificWeaponRecoilMod
// 0x0028 (0x0028 - 0x0000)
struct FSpecificWeaponRecoilMod final 
{
public:
	EItemClass                                    WeaponClass;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FDE[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoilFireStrength;                                // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilFireStrengthFirst;                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilDampStrength;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilAngleStrength;                               // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilRandomness;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilFireADSModifier;                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilBuildupADSModifier;                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilAngleADSModifier;                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilBuildupDampStrength;                         // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecificWeaponRecoilMod) == 0x000004, "Wrong alignment on FSpecificWeaponRecoilMod");
static_assert(sizeof(FSpecificWeaponRecoilMod) == 0x000028, "Wrong size on FSpecificWeaponRecoilMod");
static_assert(offsetof(FSpecificWeaponRecoilMod, WeaponClass) == 0x000000, "Member 'FSpecificWeaponRecoilMod::WeaponClass' has a wrong offset!");
static_assert(offsetof(FSpecificWeaponRecoilMod, RecoilFireStrength) == 0x000004, "Member 'FSpecificWeaponRecoilMod::RecoilFireStrength' has a wrong offset!");
static_assert(offsetof(FSpecificWeaponRecoilMod, RecoilFireStrengthFirst) == 0x000008, "Member 'FSpecificWeaponRecoilMod::RecoilFireStrengthFirst' has a wrong offset!");
static_assert(offsetof(FSpecificWeaponRecoilMod, RecoilDampStrength) == 0x00000C, "Member 'FSpecificWeaponRecoilMod::RecoilDampStrength' has a wrong offset!");
static_assert(offsetof(FSpecificWeaponRecoilMod, RecoilAngleStrength) == 0x000010, "Member 'FSpecificWeaponRecoilMod::RecoilAngleStrength' has a wrong offset!");
static_assert(offsetof(FSpecificWeaponRecoilMod, RecoilRandomness) == 0x000014, "Member 'FSpecificWeaponRecoilMod::RecoilRandomness' has a wrong offset!");
static_assert(offsetof(FSpecificWeaponRecoilMod, RecoilFireADSModifier) == 0x000018, "Member 'FSpecificWeaponRecoilMod::RecoilFireADSModifier' has a wrong offset!");
static_assert(offsetof(FSpecificWeaponRecoilMod, RecoilBuildupADSModifier) == 0x00001C, "Member 'FSpecificWeaponRecoilMod::RecoilBuildupADSModifier' has a wrong offset!");
static_assert(offsetof(FSpecificWeaponRecoilMod, RecoilAngleADSModifier) == 0x000020, "Member 'FSpecificWeaponRecoilMod::RecoilAngleADSModifier' has a wrong offset!");
static_assert(offsetof(FSpecificWeaponRecoilMod, RecoilBuildupDampStrength) == 0x000024, "Member 'FSpecificWeaponRecoilMod::RecoilBuildupDampStrength' has a wrong offset!");

// ScriptStruct ReadyOrNot.PostProcessEffectPlayer
// 0x0038 (0x0038 - 0x0000)
struct FPostProcessEffectPlayer final 
{
public:
	uint8                                         bEnabled : 1;                                      // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebug : 1;                                        // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRestartIfAlreadyPlaying : 1;                      // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWantsFadeOut : 1;                                 // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FDF[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeOutSpeed;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UPostProcessRequirement>> RequirementsClasses;                               // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FName                                   EffectName;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPostProcessEffectData*                 PostProcess_Data;                                  // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               PostProcess_MID;                                   // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bStarted : 1;                                      // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FE0[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPostProcessEffectPlayer) == 0x000008, "Wrong alignment on FPostProcessEffectPlayer");
static_assert(sizeof(FPostProcessEffectPlayer) == 0x000038, "Wrong size on FPostProcessEffectPlayer");
static_assert(offsetof(FPostProcessEffectPlayer, FadeOutSpeed) == 0x000004, "Member 'FPostProcessEffectPlayer::FadeOutSpeed' has a wrong offset!");
static_assert(offsetof(FPostProcessEffectPlayer, RequirementsClasses) == 0x000008, "Member 'FPostProcessEffectPlayer::RequirementsClasses' has a wrong offset!");
static_assert(offsetof(FPostProcessEffectPlayer, EffectName) == 0x000018, "Member 'FPostProcessEffectPlayer::EffectName' has a wrong offset!");
static_assert(offsetof(FPostProcessEffectPlayer, PostProcess_Data) == 0x000020, "Member 'FPostProcessEffectPlayer::PostProcess_Data' has a wrong offset!");
static_assert(offsetof(FPostProcessEffectPlayer, PostProcess_MID) == 0x000028, "Member 'FPostProcessEffectPlayer::PostProcess_MID' has a wrong offset!");

// ScriptStruct ReadyOrNot.PostProcessEffect
// 0x0028 (0x0028 - 0x0000)
struct FPostProcessEffect final 
{
public:
	uint8                                         bEnabled : 1;                                      // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCustomProcess : 1;                                // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebug : 1;                                        // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FE1[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EffectName;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE2[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPostProcessEffectPlayer>       PostProcesses;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bStarted : 1;                                      // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FE3[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPostProcessEffect) == 0x000008, "Wrong alignment on FPostProcessEffect");
static_assert(sizeof(FPostProcessEffect) == 0x000028, "Wrong size on FPostProcessEffect");
static_assert(offsetof(FPostProcessEffect, EffectName) == 0x000004, "Member 'FPostProcessEffect::EffectName' has a wrong offset!");
static_assert(offsetof(FPostProcessEffect, PostProcesses) == 0x000010, "Member 'FPostProcessEffect::PostProcesses' has a wrong offset!");

// ScriptStruct ReadyOrNot.PostProcessSetting_Base
// 0x0080 (0x0080 - 0x0000)
struct FPostProcessSetting_Base
{
public:
	uint8                                         bEnabled : 1;                                      // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FE4[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UPostProcessRequirement>> Requirements;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPostProcessEndOptions                        EffectEndOption;                                   // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE5[0x3];                                     // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartLoopAtCurveKey;                               // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReverseAtAnyTime : 1;                             // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FE6[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UPostProcessRequirement>> ReverseRequirements;                               // 0x0030(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         bUseCurve : 1;                                     // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EEasingFunc                                   EasingMethod;                                      // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPostProcessStartingState                     StartingState;                                     // 0x0042(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE7[0x1];                                     // 0x0043(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpSpeed;                                       // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectLifetime;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartLoopAtTime;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE8[0x30];                                    // 0x0050(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPostProcessSetting_Base) == 0x000008, "Wrong alignment on FPostProcessSetting_Base");
static_assert(sizeof(FPostProcessSetting_Base) == 0x000080, "Wrong size on FPostProcessSetting_Base");
static_assert(offsetof(FPostProcessSetting_Base, Requirements) == 0x000008, "Member 'FPostProcessSetting_Base::Requirements' has a wrong offset!");
static_assert(offsetof(FPostProcessSetting_Base, ParameterName) == 0x000018, "Member 'FPostProcessSetting_Base::ParameterName' has a wrong offset!");
static_assert(offsetof(FPostProcessSetting_Base, EffectEndOption) == 0x000020, "Member 'FPostProcessSetting_Base::EffectEndOption' has a wrong offset!");
static_assert(offsetof(FPostProcessSetting_Base, StartLoopAtCurveKey) == 0x000024, "Member 'FPostProcessSetting_Base::StartLoopAtCurveKey' has a wrong offset!");
static_assert(offsetof(FPostProcessSetting_Base, ReverseRequirements) == 0x000030, "Member 'FPostProcessSetting_Base::ReverseRequirements' has a wrong offset!");
static_assert(offsetof(FPostProcessSetting_Base, EasingMethod) == 0x000041, "Member 'FPostProcessSetting_Base::EasingMethod' has a wrong offset!");
static_assert(offsetof(FPostProcessSetting_Base, StartingState) == 0x000042, "Member 'FPostProcessSetting_Base::StartingState' has a wrong offset!");
static_assert(offsetof(FPostProcessSetting_Base, InterpSpeed) == 0x000044, "Member 'FPostProcessSetting_Base::InterpSpeed' has a wrong offset!");
static_assert(offsetof(FPostProcessSetting_Base, EffectLifetime) == 0x000048, "Member 'FPostProcessSetting_Base::EffectLifetime' has a wrong offset!");
static_assert(offsetof(FPostProcessSetting_Base, StartLoopAtTime) == 0x00004C, "Member 'FPostProcessSetting_Base::StartLoopAtTime' has a wrong offset!");

// ScriptStruct ReadyOrNot.PostProcessSetting_VectorParam
// 0x0220 (0x02A0 - 0x0080)
struct FPostProcessSetting_VectorParam final  : public FPostProcessSetting_Base
{
public:
	struct FVector                                Start;                                             // 0x0080(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x008C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeCurveLinearColor               Curve;                                             // 0x0098(0x0208)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPostProcessSetting_VectorParam) == 0x000008, "Wrong alignment on FPostProcessSetting_VectorParam");
static_assert(sizeof(FPostProcessSetting_VectorParam) == 0x0002A0, "Wrong size on FPostProcessSetting_VectorParam");
static_assert(offsetof(FPostProcessSetting_VectorParam, Start) == 0x000080, "Member 'FPostProcessSetting_VectorParam::Start' has a wrong offset!");
static_assert(offsetof(FPostProcessSetting_VectorParam, End) == 0x00008C, "Member 'FPostProcessSetting_VectorParam::End' has a wrong offset!");
static_assert(offsetof(FPostProcessSetting_VectorParam, Curve) == 0x000098, "Member 'FPostProcessSetting_VectorParam::Curve' has a wrong offset!");

// ScriptStruct ReadyOrNot.PostProcessSetting_FloatParam
// 0x0090 (0x0110 - 0x0080)
struct FPostProcessSetting_FloatParam final  : public FPostProcessSetting_Base
{
public:
	float                                         Start;                                             // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         End;                                               // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0088(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPostProcessSetting_FloatParam) == 0x000008, "Wrong alignment on FPostProcessSetting_FloatParam");
static_assert(sizeof(FPostProcessSetting_FloatParam) == 0x000110, "Wrong size on FPostProcessSetting_FloatParam");
static_assert(offsetof(FPostProcessSetting_FloatParam, Start) == 0x000080, "Member 'FPostProcessSetting_FloatParam::Start' has a wrong offset!");
static_assert(offsetof(FPostProcessSetting_FloatParam, End) == 0x000084, "Member 'FPostProcessSetting_FloatParam::End' has a wrong offset!");
static_assert(offsetof(FPostProcessSetting_FloatParam, Curve) == 0x000088, "Member 'FPostProcessSetting_FloatParam::Curve' has a wrong offset!");

// ScriptStruct ReadyOrNot.PlayHead
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FPlayHead final 
{
public:
	uint8                                         Pad_1FE9[0x1C];                                    // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayHead) == 0x000004, "Wrong alignment on FPlayHead");
static_assert(sizeof(FPlayHead) == 0x00001C, "Wrong size on FPlayHead");

// ScriptStruct ReadyOrNot.BasicLevelStats
// 0x000C (0x000C - 0x0000)
struct FBasicLevelStats final 
{
public:
	float                                         BestRating;                                        // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BestTime;                                          // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimesCompleted;                                    // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBasicLevelStats) == 0x000004, "Wrong alignment on FBasicLevelStats");
static_assert(sizeof(FBasicLevelStats) == 0x00000C, "Wrong size on FBasicLevelStats");
static_assert(offsetof(FBasicLevelStats, BestRating) == 0x000000, "Member 'FBasicLevelStats::BestRating' has a wrong offset!");
static_assert(offsetof(FBasicLevelStats, BestTime) == 0x000004, "Member 'FBasicLevelStats::BestTime' has a wrong offset!");
static_assert(offsetof(FBasicLevelStats, TimesCompleted) == 0x000008, "Member 'FBasicLevelStats::TimesCompleted' has a wrong offset!");

// ScriptStruct ReadyOrNot.CharacterSharedAnim
// 0x0010 (0x0010 - 0x0000)
struct FCharacterSharedAnim final 
{
public:
	class UAnimMontage*                           TP_Anim;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FP_Anim;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSharedAnim) == 0x000008, "Wrong alignment on FCharacterSharedAnim");
static_assert(sizeof(FCharacterSharedAnim) == 0x000010, "Wrong size on FCharacterSharedAnim");
static_assert(offsetof(FCharacterSharedAnim, TP_Anim) == 0x000000, "Member 'FCharacterSharedAnim::TP_Anim' has a wrong offset!");
static_assert(offsetof(FCharacterSharedAnim, FP_Anim) == 0x000008, "Member 'FCharacterSharedAnim::FP_Anim' has a wrong offset!");

// ScriptStruct ReadyOrNot.CharacterFPAnim
// 0x0008 (0x0008 - 0x0000)
struct FCharacterFPAnim final 
{
public:
	class UAnimMontage*                           FP_Anim;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterFPAnim) == 0x000008, "Wrong alignment on FCharacterFPAnim");
static_assert(sizeof(FCharacterFPAnim) == 0x000008, "Wrong size on FCharacterFPAnim");
static_assert(offsetof(FCharacterFPAnim, FP_Anim) == 0x000000, "Member 'FCharacterFPAnim::FP_Anim' has a wrong offset!");

// ScriptStruct ReadyOrNot.CharacterTPAnim
// 0x0008 (0x0008 - 0x0000)
struct FCharacterTPAnim final 
{
public:
	class UAnimMontage*                           TP_Anim;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterTPAnim) == 0x000008, "Wrong alignment on FCharacterTPAnim");
static_assert(sizeof(FCharacterTPAnim) == 0x000008, "Wrong size on FCharacterTPAnim");
static_assert(offsetof(FCharacterTPAnim, TP_Anim) == 0x000000, "Member 'FCharacterTPAnim::TP_Anim' has a wrong offset!");

// ScriptStruct ReadyOrNot.CoverDirectionalTrans
// 0x0030 (0x0030 - 0x0000)
struct FCoverDirectionalTrans final 
{
public:
	class UAnimMontage*                           CoverTrans_0;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DistanceOffsetCover_0;                             // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FEA[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CoverTrans_90;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DistanceOffsetCover_90;                            // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FEB[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoverDirectionalTrans) == 0x000008, "Wrong alignment on FCoverDirectionalTrans");
static_assert(sizeof(FCoverDirectionalTrans) == 0x000030, "Wrong size on FCoverDirectionalTrans");
static_assert(offsetof(FCoverDirectionalTrans, CoverTrans_0) == 0x000000, "Member 'FCoverDirectionalTrans::CoverTrans_0' has a wrong offset!");
static_assert(offsetof(FCoverDirectionalTrans, DistanceOffsetCover_0) == 0x000008, "Member 'FCoverDirectionalTrans::DistanceOffsetCover_0' has a wrong offset!");
static_assert(offsetof(FCoverDirectionalTrans, CoverTrans_90) == 0x000018, "Member 'FCoverDirectionalTrans::CoverTrans_90' has a wrong offset!");
static_assert(offsetof(FCoverDirectionalTrans, DistanceOffsetCover_90) == 0x000020, "Member 'FCoverDirectionalTrans::DistanceOffsetCover_90' has a wrong offset!");

// ScriptStruct ReadyOrNot.CoverTrans
// 0x0010 (0x0010 - 0x0000)
struct FCoverTrans final 
{
public:
	class UAnimMontage*                           CoverEnterTrans;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CoverExitTrans;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverTrans) == 0x000008, "Wrong alignment on FCoverTrans");
static_assert(sizeof(FCoverTrans) == 0x000010, "Wrong size on FCoverTrans");
static_assert(offsetof(FCoverTrans, CoverEnterTrans) == 0x000000, "Member 'FCoverTrans::CoverEnterTrans' has a wrong offset!");
static_assert(offsetof(FCoverTrans, CoverExitTrans) == 0x000008, "Member 'FCoverTrans::CoverExitTrans' has a wrong offset!");

// ScriptStruct ReadyOrNot.CoverDataMain
// 0x00D8 (0x00D8 - 0x0000)
struct FCoverDataMain final 
{
public:
	class UAnimSequence*                          CoverIdlePose;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasVerticalExposure;                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FEC[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoverDirectionalTrans                 CoverEnterTrans;                                   // 0x0010(0x0030)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCoverDirectionalTrans                 CoverExitTrans;                                    // 0x0040(0x0030)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SideSwitchTrans;                                   // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCoverTrans                            AimingHTrans;                                      // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCoverTrans                            BlindFireHTrans;                                   // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BlindFireHIdlePose;                                // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AimingHIdlePose;                                   // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCoverTrans                            AimingVTrans;                                      // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCoverTrans                            BlindFireVTrans;                                   // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BlindFireVIdlePose;                                // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AimingVIdlePose;                                   // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverDataMain) == 0x000008, "Wrong alignment on FCoverDataMain");
static_assert(sizeof(FCoverDataMain) == 0x0000D8, "Wrong size on FCoverDataMain");
static_assert(offsetof(FCoverDataMain, CoverIdlePose) == 0x000000, "Member 'FCoverDataMain::CoverIdlePose' has a wrong offset!");
static_assert(offsetof(FCoverDataMain, bHasVerticalExposure) == 0x000008, "Member 'FCoverDataMain::bHasVerticalExposure' has a wrong offset!");
static_assert(offsetof(FCoverDataMain, CoverEnterTrans) == 0x000010, "Member 'FCoverDataMain::CoverEnterTrans' has a wrong offset!");
static_assert(offsetof(FCoverDataMain, CoverExitTrans) == 0x000040, "Member 'FCoverDataMain::CoverExitTrans' has a wrong offset!");
static_assert(offsetof(FCoverDataMain, SideSwitchTrans) == 0x000070, "Member 'FCoverDataMain::SideSwitchTrans' has a wrong offset!");
static_assert(offsetof(FCoverDataMain, AimingHTrans) == 0x000078, "Member 'FCoverDataMain::AimingHTrans' has a wrong offset!");
static_assert(offsetof(FCoverDataMain, BlindFireHTrans) == 0x000088, "Member 'FCoverDataMain::BlindFireHTrans' has a wrong offset!");
static_assert(offsetof(FCoverDataMain, BlindFireHIdlePose) == 0x000098, "Member 'FCoverDataMain::BlindFireHIdlePose' has a wrong offset!");
static_assert(offsetof(FCoverDataMain, AimingHIdlePose) == 0x0000A0, "Member 'FCoverDataMain::AimingHIdlePose' has a wrong offset!");
static_assert(offsetof(FCoverDataMain, AimingVTrans) == 0x0000A8, "Member 'FCoverDataMain::AimingVTrans' has a wrong offset!");
static_assert(offsetof(FCoverDataMain, BlindFireVTrans) == 0x0000B8, "Member 'FCoverDataMain::BlindFireVTrans' has a wrong offset!");
static_assert(offsetof(FCoverDataMain, BlindFireVIdlePose) == 0x0000C8, "Member 'FCoverDataMain::BlindFireVIdlePose' has a wrong offset!");
static_assert(offsetof(FCoverDataMain, AimingVIdlePose) == 0x0000D0, "Member 'FCoverDataMain::AimingVIdlePose' has a wrong offset!");

// ScriptStruct ReadyOrNot.PMap
// 0x0050 (0x0050 - 0x0000)
struct FPMap final 
{
public:
	TArray<class FString>                         BLPN;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         BLPHZ;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         BLWT;                                              // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         BLDLLHZ;                                           // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         BLDLLN;                                            // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPMap) == 0x000008, "Wrong alignment on FPMap");
static_assert(sizeof(FPMap) == 0x000050, "Wrong size on FPMap");
static_assert(offsetof(FPMap, BLPN) == 0x000000, "Member 'FPMap::BLPN' has a wrong offset!");
static_assert(offsetof(FPMap, BLPHZ) == 0x000010, "Member 'FPMap::BLPHZ' has a wrong offset!");
static_assert(offsetof(FPMap, BLWT) == 0x000020, "Member 'FPMap::BLWT' has a wrong offset!");
static_assert(offsetof(FPMap, BLDLLHZ) == 0x000030, "Member 'FPMap::BLDLLHZ' has a wrong offset!");
static_assert(offsetof(FPMap, BLDLLN) == 0x000040, "Member 'FPMap::BLDLLN' has a wrong offset!");

// ScriptStruct ReadyOrNot.ChannelInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FChannelInfo final 
{
public:
	uint8                                         Pad_1FED[0x18];                                    // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChannelInfo) == 0x000008, "Wrong alignment on FChannelInfo");
static_assert(sizeof(FChannelInfo) == 0x000018, "Wrong size on FChannelInfo");

// ScriptStruct ReadyOrNot.MirrorReflectionSettings
// 0x0008 (0x0008 - 0x0000)
struct FMirrorReflectionSettings final 
{
public:
	float                                         MirrorResolutionScale;                             // 0x0000(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShowAntiAliasing : 1;                             // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowDecals : 1;                                   // 0x0004(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowDynamicShadows : 1;                           // 0x0004(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FEE[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMirrorReflectionSettings) == 0x000004, "Wrong alignment on FMirrorReflectionSettings");
static_assert(sizeof(FMirrorReflectionSettings) == 0x000008, "Wrong size on FMirrorReflectionSettings");
static_assert(offsetof(FMirrorReflectionSettings, MirrorResolutionScale) == 0x000000, "Member 'FMirrorReflectionSettings::MirrorResolutionScale' has a wrong offset!");

// ScriptStruct ReadyOrNot.RelevancyTracker
// 0x0004 (0x0004 - 0x0000)
struct FRelevancyTracker final 
{
public:
	float                                         TimeUntilRecheck;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRelevancyTracker) == 0x000004, "Wrong alignment on FRelevancyTracker");
static_assert(sizeof(FRelevancyTracker) == 0x000004, "Wrong size on FRelevancyTracker");
static_assert(offsetof(FRelevancyTracker, TimeUntilRecheck) == 0x000000, "Member 'FRelevancyTracker::TimeUntilRecheck' has a wrong offset!");

// ScriptStruct ReadyOrNot.ReadyOrNotAnimInstanceProxyTP
// 0x0000 (0x0770 - 0x0770)
struct FReadyOrNotAnimInstanceProxyTP final  : public FAnimInstanceProxy
{
};
static_assert(alignof(FReadyOrNotAnimInstanceProxyTP) == 0x000010, "Wrong alignment on FReadyOrNotAnimInstanceProxyTP");
static_assert(sizeof(FReadyOrNotAnimInstanceProxyTP) == 0x000770, "Wrong size on FReadyOrNotAnimInstanceProxyTP");

// ScriptStruct ReadyOrNot.RoNStyleSlotData
// 0x0250 (0x0250 - 0x0000)
struct FRoNStyleSlotData final 
{
public:
	struct FRoNStyleIdleData                      IdleData;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRoNStyleTurnData                      TurnData;                                          // 0x0010(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRoNGaitTransitionData                 TransitionData;                                    // 0x0058(0x0120)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRoNGaitLocomotionData                 LocomotionData;                                    // 0x0178(0x00C0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleReference;                                     // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StrafeBSData;                                      // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            NonStrafeBSData;                                   // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoNStyleSlotData) == 0x000008, "Wrong alignment on FRoNStyleSlotData");
static_assert(sizeof(FRoNStyleSlotData) == 0x000250, "Wrong size on FRoNStyleSlotData");
static_assert(offsetof(FRoNStyleSlotData, IdleData) == 0x000000, "Member 'FRoNStyleSlotData::IdleData' has a wrong offset!");
static_assert(offsetof(FRoNStyleSlotData, TurnData) == 0x000010, "Member 'FRoNStyleSlotData::TurnData' has a wrong offset!");
static_assert(offsetof(FRoNStyleSlotData, TransitionData) == 0x000058, "Member 'FRoNStyleSlotData::TransitionData' has a wrong offset!");
static_assert(offsetof(FRoNStyleSlotData, LocomotionData) == 0x000178, "Member 'FRoNStyleSlotData::LocomotionData' has a wrong offset!");
static_assert(offsetof(FRoNStyleSlotData, IdleReference) == 0x000238, "Member 'FRoNStyleSlotData::IdleReference' has a wrong offset!");
static_assert(offsetof(FRoNStyleSlotData, StrafeBSData) == 0x000240, "Member 'FRoNStyleSlotData::StrafeBSData' has a wrong offset!");
static_assert(offsetof(FRoNStyleSlotData, NonStrafeBSData) == 0x000248, "Member 'FRoNStyleSlotData::NonStrafeBSData' has a wrong offset!");

// ScriptStruct ReadyOrNot.RoNMoveStyleTable
// 0x0010 (0x0018 - 0x0008)
struct FRoNMoveStyleTable final  : public FTableRowBase
{
public:
	TArray<struct FRoNMovementStyle>              MoveStyles;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoNMoveStyleTable) == 0x000008, "Wrong alignment on FRoNMoveStyleTable");
static_assert(sizeof(FRoNMoveStyleTable) == 0x000018, "Wrong size on FRoNMoveStyleTable");
static_assert(offsetof(FRoNMoveStyleTable, MoveStyles) == 0x000008, "Member 'FRoNMoveStyleTable::MoveStyles' has a wrong offset!");

// ScriptStruct ReadyOrNot.RosterTraitEntry
// 0x0038 (0x0038 - 0x0000)
struct FRosterTraitEntry final 
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FEF[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class URosterTrait>            Trait;                                             // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRosterTraitEntry) == 0x000008, "Wrong alignment on FRosterTraitEntry");
static_assert(sizeof(FRosterTraitEntry) == 0x000038, "Wrong size on FRosterTraitEntry");
static_assert(offsetof(FRosterTraitEntry, Name) == 0x000000, "Member 'FRosterTraitEntry::Name' has a wrong offset!");
static_assert(offsetof(FRosterTraitEntry, bEnabled) == 0x000008, "Member 'FRosterTraitEntry::bEnabled' has a wrong offset!");
static_assert(offsetof(FRosterTraitEntry, Trait) == 0x000010, "Member 'FRosterTraitEntry::Trait' has a wrong offset!");

// ScriptStruct ReadyOrNot.RosterActiveTraitInfo
// 0x0010 (0x0010 - 0x0000)
struct FRosterActiveTraitInfo final 
{
public:
	class URosterTrait*                           Trait;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRosterActiveTraitInfo) == 0x000008, "Wrong alignment on FRosterActiveTraitInfo");
static_assert(sizeof(FRosterActiveTraitInfo) == 0x000010, "Wrong size on FRosterActiveTraitInfo");
static_assert(offsetof(FRosterActiveTraitInfo, Trait) == 0x000000, "Member 'FRosterActiveTraitInfo::Trait' has a wrong offset!");
static_assert(offsetof(FRosterActiveTraitInfo, Count) == 0x000008, "Member 'FRosterActiveTraitInfo::Count' has a wrong offset!");
static_assert(offsetof(FRosterActiveTraitInfo, Value) == 0x00000C, "Member 'FRosterActiveTraitInfo::Value' has a wrong offset!");

// ScriptStruct ReadyOrNot.ScopeModifications
// 0x0048 (0x0048 - 0x0000)
struct FScopeModifications final 
{
public:
	class UClass*                                 WeaponClass;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalOffset;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalOffset;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceOffset;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FF0[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          CustomWeaponMesh;                                  // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HideBone;                                          // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsSecondarySights;                          // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FF1[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MeshSpace_ADS_SecondaryPos;                        // 0x002C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MeshSpace_ADS_SecondaryRot;                        // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FF2[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScopeModifications) == 0x000008, "Wrong alignment on FScopeModifications");
static_assert(sizeof(FScopeModifications) == 0x000048, "Wrong size on FScopeModifications");
static_assert(offsetof(FScopeModifications, WeaponClass) == 0x000000, "Member 'FScopeModifications::WeaponClass' has a wrong offset!");
static_assert(offsetof(FScopeModifications, VerticalOffset) == 0x000008, "Member 'FScopeModifications::VerticalOffset' has a wrong offset!");
static_assert(offsetof(FScopeModifications, HorizontalOffset) == 0x00000C, "Member 'FScopeModifications::HorizontalOffset' has a wrong offset!");
static_assert(offsetof(FScopeModifications, DistanceOffset) == 0x000010, "Member 'FScopeModifications::DistanceOffset' has a wrong offset!");
static_assert(offsetof(FScopeModifications, CustomWeaponMesh) == 0x000018, "Member 'FScopeModifications::CustomWeaponMesh' has a wrong offset!");
static_assert(offsetof(FScopeModifications, HideBone) == 0x000020, "Member 'FScopeModifications::HideBone' has a wrong offset!");
static_assert(offsetof(FScopeModifications, bSupportsSecondarySights) == 0x000028, "Member 'FScopeModifications::bSupportsSecondarySights' has a wrong offset!");
static_assert(offsetof(FScopeModifications, MeshSpace_ADS_SecondaryPos) == 0x00002C, "Member 'FScopeModifications::MeshSpace_ADS_SecondaryPos' has a wrong offset!");
static_assert(offsetof(FScopeModifications, MeshSpace_ADS_SecondaryRot) == 0x000038, "Member 'FScopeModifications::MeshSpace_ADS_SecondaryRot' has a wrong offset!");

// ScriptStruct ReadyOrNot.ScoreBonus
// 0x0040 (0x0040 - 0x0000)
struct FScoreBonus final 
{
public:
	uint8                                         bEnabled : 1;                                      // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FF3[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ScoreName;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRequired : 1;                                     // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGiven : 1;                                        // 0x0024(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWasDisplayedOnHUD : 1;                            // 0x0024(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FF4[0x3];                                     // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ScoreTextOnHUD;                                    // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreBonus) == 0x000008, "Wrong alignment on FScoreBonus");
static_assert(sizeof(FScoreBonus) == 0x000040, "Wrong size on FScoreBonus");
static_assert(offsetof(FScoreBonus, ScoreName) == 0x000008, "Member 'FScoreBonus::ScoreName' has a wrong offset!");
static_assert(offsetof(FScoreBonus, Score) == 0x000020, "Member 'FScoreBonus::Score' has a wrong offset!");
static_assert(offsetof(FScoreBonus, ScoreTextOnHUD) == 0x000028, "Member 'FScoreBonus::ScoreTextOnHUD' has a wrong offset!");

// ScriptStruct ReadyOrNot.ScorePenalty
// 0x0040 (0x0040 - 0x0000)
struct FScorePenalty final 
{
public:
	uint8                                         bEnabled : 1;                                      // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FF5[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ScoreName;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGiven : 1;                                        // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWasDisplayedOnHUD : 1;                            // 0x0024(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FF6[0x3];                                     // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ScoreTextOnHUD;                                    // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScorePenalty) == 0x000008, "Wrong alignment on FScorePenalty");
static_assert(sizeof(FScorePenalty) == 0x000040, "Wrong size on FScorePenalty");
static_assert(offsetof(FScorePenalty, ScoreName) == 0x000008, "Member 'FScorePenalty::ScoreName' has a wrong offset!");
static_assert(offsetof(FScorePenalty, Score) == 0x000020, "Member 'FScorePenalty::Score' has a wrong offset!");
static_assert(offsetof(FScorePenalty, ScoreTextOnHUD) == 0x000028, "Member 'FScorePenalty::ScoreTextOnHUD' has a wrong offset!");

// ScriptStruct ReadyOrNot.ScoringDataTable
// 0x0048 (0x0050 - 0x0008)
struct FScoringDataTable final  : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EObjectiveLevel                               ObjectiveLevel;                                    // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FF7[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FScoreBonus>                    Bonuses;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FScorePenalty>                  Penalties;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bRequiredToClearMission : 1;                       // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRequiredToSoftClearMission : 1;                   // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FF8[0x3];                                     // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrderPriority;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoringDataTable) == 0x000008, "Wrong alignment on FScoringDataTable");
static_assert(sizeof(FScoringDataTable) == 0x000050, "Wrong size on FScoringDataTable");
static_assert(offsetof(FScoringDataTable, Name) == 0x000008, "Member 'FScoringDataTable::Name' has a wrong offset!");
static_assert(offsetof(FScoringDataTable, ObjectiveLevel) == 0x000020, "Member 'FScoringDataTable::ObjectiveLevel' has a wrong offset!");
static_assert(offsetof(FScoringDataTable, Bonuses) == 0x000028, "Member 'FScoringDataTable::Bonuses' has a wrong offset!");
static_assert(offsetof(FScoringDataTable, Penalties) == 0x000038, "Member 'FScoringDataTable::Penalties' has a wrong offset!");
static_assert(offsetof(FScoringDataTable, OrderPriority) == 0x00004C, "Member 'FScoringDataTable::OrderPriority' has a wrong offset!");

// ScriptStruct ReadyOrNot.ScoreData
// 0x0030 (0x0030 - 0x0000)
struct FScoreData final 
{
public:
	TArray<struct FScoreBonus>                    Bonuses;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FScorePenalty>                  Penalties;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bHiddenScore : 1;                                  // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FF9[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UScoringComponent*                      FromScoringComponent;                              // 0x0028(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreData) == 0x000008, "Wrong alignment on FScoreData");
static_assert(sizeof(FScoreData) == 0x000030, "Wrong size on FScoreData");
static_assert(offsetof(FScoreData, Bonuses) == 0x000000, "Member 'FScoreData::Bonuses' has a wrong offset!");
static_assert(offsetof(FScoreData, Penalties) == 0x000010, "Member 'FScoreData::Penalties' has a wrong offset!");
static_assert(offsetof(FScoreData, FromScoringComponent) == 0x000028, "Member 'FScoreData::FromScoringComponent' has a wrong offset!");

// ScriptStruct ReadyOrNot.ScoreGroup
// 0x0030 (0x0030 - 0x0000)
struct FScoreGroup final 
{
public:
	class FName                                   GroupName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectiveLevel                               ObjectiveLevel;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRequiredToClearMission : 1;                       // 0x0009(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRequiredToSoftClearMission : 1;                   // 0x0009(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FFA[0x2];                                     // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrderPriority;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FScoreData>                     Scores;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FScoreData>                     InactiveScores;                                    // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreGroup) == 0x000008, "Wrong alignment on FScoreGroup");
static_assert(sizeof(FScoreGroup) == 0x000030, "Wrong size on FScoreGroup");
static_assert(offsetof(FScoreGroup, GroupName) == 0x000000, "Member 'FScoreGroup::GroupName' has a wrong offset!");
static_assert(offsetof(FScoreGroup, ObjectiveLevel) == 0x000008, "Member 'FScoreGroup::ObjectiveLevel' has a wrong offset!");
static_assert(offsetof(FScoreGroup, OrderPriority) == 0x00000C, "Member 'FScoreGroup::OrderPriority' has a wrong offset!");
static_assert(offsetof(FScoreGroup, Scores) == 0x000010, "Member 'FScoreGroup::Scores' has a wrong offset!");
static_assert(offsetof(FScoreGroup, InactiveScores) == 0x000020, "Member 'FScoreGroup::InactiveScores' has a wrong offset!");

// ScriptStruct ReadyOrNot.ScorePenaltyData
// 0x0020 (0x0020 - 0x0000)
struct FScorePenaltyData final 
{
public:
	class FText                                   GroupName;                                         // 0x0000(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PenaltyCount;                                      // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScorePenaltyData) == 0x000008, "Wrong alignment on FScorePenaltyData");
static_assert(sizeof(FScorePenaltyData) == 0x000020, "Wrong size on FScorePenaltyData");
static_assert(offsetof(FScorePenaltyData, GroupName) == 0x000000, "Member 'FScorePenaltyData::GroupName' has a wrong offset!");
static_assert(offsetof(FScorePenaltyData, Score) == 0x000018, "Member 'FScorePenaltyData::Score' has a wrong offset!");
static_assert(offsetof(FScorePenaltyData, PenaltyCount) == 0x00001C, "Member 'FScorePenaltyData::PenaltyCount' has a wrong offset!");

// ScriptStruct ReadyOrNot.ShotgunVisuals
// 0x0010 (0x0010 - 0x0000)
struct FShotgunVisuals final 
{
public:
	TArray<class UStaticMesh*>                    ShellVisuals;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShotgunVisuals) == 0x000008, "Wrong alignment on FShotgunVisuals");
static_assert(sizeof(FShotgunVisuals) == 0x000010, "Wrong size on FShotgunVisuals");
static_assert(offsetof(FShotgunVisuals, ShellVisuals) == 0x000000, "Member 'FShotgunVisuals::ShellVisuals' has a wrong offset!");

// ScriptStruct ReadyOrNot.NodePath
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FNodePath final 
{
public:
	uint8                                         Pad_1FFB[0x10];                                    // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNodePath) == 0x000008, "Wrong alignment on FNodePath");
static_assert(sizeof(FNodePath) == 0x000010, "Wrong size on FNodePath");

// ScriptStruct ReadyOrNot.PathAwarenessInfo
// 0x0028 (0x0028 - 0x0000)
struct FPathAwarenessInfo final 
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SensedFrom;                                        // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Age;                                               // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FFC[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPathAwarenessInfo) == 0x000008, "Wrong alignment on FPathAwarenessInfo");
static_assert(sizeof(FPathAwarenessInfo) == 0x000028, "Wrong size on FPathAwarenessInfo");
static_assert(offsetof(FPathAwarenessInfo, Actor) == 0x000000, "Member 'FPathAwarenessInfo::Actor' has a wrong offset!");
static_assert(offsetof(FPathAwarenessInfo, Location) == 0x000008, "Member 'FPathAwarenessInfo::Location' has a wrong offset!");
static_assert(offsetof(FPathAwarenessInfo, SensedFrom) == 0x000014, "Member 'FPathAwarenessInfo::SensedFrom' has a wrong offset!");
static_assert(offsetof(FPathAwarenessInfo, Age) == 0x000020, "Member 'FPathAwarenessInfo::Age' has a wrong offset!");

// ScriptStruct ReadyOrNot.SharedStackUpData
// 0x0064 (0x0090 - 0x002C)
struct FSharedStackUpData : public FSharedTeamData
{
public:
	uint8                                         Pad_1FFD[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  StackUpDoor;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   DoorChecker;                                       // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASWATCharacter*>                 StackUpSortedSwat;                                 // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class ADoor*                                  DoorToClose;                                       // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FFE[0x38];                                    // 0x0058(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSharedStackUpData) == 0x000008, "Wrong alignment on FSharedStackUpData");
static_assert(sizeof(FSharedStackUpData) == 0x000090, "Wrong size on FSharedStackUpData");
static_assert(offsetof(FSharedStackUpData, StackUpDoor) == 0x000030, "Member 'FSharedStackUpData::StackUpDoor' has a wrong offset!");
static_assert(offsetof(FSharedStackUpData, DoorChecker) == 0x000038, "Member 'FSharedStackUpData::DoorChecker' has a wrong offset!");
static_assert(offsetof(FSharedStackUpData, StackUpSortedSwat) == 0x000040, "Member 'FSharedStackUpData::StackUpSortedSwat' has a wrong offset!");
static_assert(offsetof(FSharedStackUpData, DoorToClose) == 0x000050, "Member 'FSharedStackUpData::DoorToClose' has a wrong offset!");

// ScriptStruct ReadyOrNot.SharedBreachData
// 0x0078 (0x0108 - 0x0090)
struct FSharedBreachData final  : public FSharedStackUpData
{
public:
	class ACyberneticCharacter*                   DoorUser;                                          // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   DoorBreacher;                                      // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   DoorScanner;                                       // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   ShieldUser;                                        // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   BreachCaller;                                      // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseItem>                  DoorBreachItemClass;                               // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseItem>                  DoorUseItemClass;                                  // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDoorBreachActivity*                    DoorUseActivity;                                   // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDoorBreachActivity*                    DoorBreachActivity;                                // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScanDoorActivity*                      DoorScanActivity;                                  // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASWATCharacter*>                 ClearingSortedSwat;                                // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FFF[0x18];                                    // 0x00F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSharedBreachData) == 0x000008, "Wrong alignment on FSharedBreachData");
static_assert(sizeof(FSharedBreachData) == 0x000108, "Wrong size on FSharedBreachData");
static_assert(offsetof(FSharedBreachData, DoorUser) == 0x000090, "Member 'FSharedBreachData::DoorUser' has a wrong offset!");
static_assert(offsetof(FSharedBreachData, DoorBreacher) == 0x000098, "Member 'FSharedBreachData::DoorBreacher' has a wrong offset!");
static_assert(offsetof(FSharedBreachData, DoorScanner) == 0x0000A0, "Member 'FSharedBreachData::DoorScanner' has a wrong offset!");
static_assert(offsetof(FSharedBreachData, ShieldUser) == 0x0000A8, "Member 'FSharedBreachData::ShieldUser' has a wrong offset!");
static_assert(offsetof(FSharedBreachData, BreachCaller) == 0x0000B0, "Member 'FSharedBreachData::BreachCaller' has a wrong offset!");
static_assert(offsetof(FSharedBreachData, DoorBreachItemClass) == 0x0000B8, "Member 'FSharedBreachData::DoorBreachItemClass' has a wrong offset!");
static_assert(offsetof(FSharedBreachData, DoorUseItemClass) == 0x0000C0, "Member 'FSharedBreachData::DoorUseItemClass' has a wrong offset!");
static_assert(offsetof(FSharedBreachData, DoorUseActivity) == 0x0000C8, "Member 'FSharedBreachData::DoorUseActivity' has a wrong offset!");
static_assert(offsetof(FSharedBreachData, DoorBreachActivity) == 0x0000D0, "Member 'FSharedBreachData::DoorBreachActivity' has a wrong offset!");
static_assert(offsetof(FSharedBreachData, DoorScanActivity) == 0x0000D8, "Member 'FSharedBreachData::DoorScanActivity' has a wrong offset!");
static_assert(offsetof(FSharedBreachData, ClearingSortedSwat) == 0x0000E0, "Member 'FSharedBreachData::ClearingSortedSwat' has a wrong offset!");

// ScriptStruct ReadyOrNot.Room
// 0x0058 (0x0058 - 0x0000)
struct FRoom final 
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             Location;                                          // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2000[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  RootDoor;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AThreatAwarenessActor*>          Threats;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          AdditionalRootDoors;                               // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TArray<class FName>                           ConnectingRooms;                                   // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	bool                                          bClearedBySwat;                                    // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearedByTrailers;                                // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2001[0x6];                                     // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRoom) == 0x000008, "Wrong alignment on FRoom");
static_assert(sizeof(FRoom) == 0x000058, "Wrong size on FRoom");
static_assert(offsetof(FRoom, Name) == 0x000000, "Member 'FRoom::Name' has a wrong offset!");
static_assert(offsetof(FRoom, Location) == 0x000008, "Member 'FRoom::Location' has a wrong offset!");
static_assert(offsetof(FRoom, RootDoor) == 0x000018, "Member 'FRoom::RootDoor' has a wrong offset!");
static_assert(offsetof(FRoom, Threats) == 0x000020, "Member 'FRoom::Threats' has a wrong offset!");
static_assert(offsetof(FRoom, AdditionalRootDoors) == 0x000030, "Member 'FRoom::AdditionalRootDoors' has a wrong offset!");
static_assert(offsetof(FRoom, ConnectingRooms) == 0x000040, "Member 'FRoom::ConnectingRooms' has a wrong offset!");
static_assert(offsetof(FRoom, bClearedBySwat) == 0x000050, "Member 'FRoom::bClearedBySwat' has a wrong offset!");
static_assert(offsetof(FRoom, bClearedByTrailers) == 0x000051, "Member 'FRoom::bClearedByTrailers' has a wrong offset!");

// ScriptStruct ReadyOrNot.RoomGenData
// 0x0020 (0x0020 - 0x0000)
struct FRoomGenData final 
{
public:
	TArray<struct FRoom>                          Rooms;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_2002[0x10];                                    // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRoomGenData) == 0x000008, "Wrong alignment on FRoomGenData");
static_assert(sizeof(FRoomGenData) == 0x000020, "Wrong size on FRoomGenData");
static_assert(offsetof(FRoomGenData, Rooms) == 0x000000, "Member 'FRoomGenData::Rooms' has a wrong offset!");

// ScriptStruct ReadyOrNot.RonKey
// 0x00A8 (0x00A8 - 0x0000)
struct FRonKey final 
{
public:
	class FString                                 InputName;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AlternativeInputName;                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            IconBrush;                                         // 0x0020(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRonKey) == 0x000008, "Wrong alignment on FRonKey");
static_assert(sizeof(FRonKey) == 0x0000A8, "Wrong size on FRonKey");
static_assert(offsetof(FRonKey, InputName) == 0x000000, "Member 'FRonKey::InputName' has a wrong offset!");
static_assert(offsetof(FRonKey, AlternativeInputName) == 0x000010, "Member 'FRonKey::AlternativeInputName' has a wrong offset!");
static_assert(offsetof(FRonKey, IconBrush) == 0x000020, "Member 'FRonKey::IconBrush' has a wrong offset!");

// ScriptStruct ReadyOrNot.RonInputKeyTable
// 0x00A8 (0x00B0 - 0x0008)
struct FRonInputKeyTable final  : public FTableRowBase
{
public:
	struct FRonKey                                Key;                                               // 0x0008(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRonInputKeyTable) == 0x000008, "Wrong alignment on FRonInputKeyTable");
static_assert(sizeof(FRonInputKeyTable) == 0x0000B0, "Wrong size on FRonInputKeyTable");
static_assert(offsetof(FRonInputKeyTable, Key) == 0x000008, "Member 'FRonInputKeyTable::Key' has a wrong offset!");

// ScriptStruct ReadyOrNot.SpeedRange
// 0x0010 (0x0010 - 0x0000)
struct FSpeedRange final 
{
public:
	float                                         Speed;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRandomSpeed : 1;                                  // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2003[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSpeed;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpeedRange) == 0x000004, "Wrong alignment on FSpeedRange");
static_assert(sizeof(FSpeedRange) == 0x000010, "Wrong size on FSpeedRange");
static_assert(offsetof(FSpeedRange, Speed) == 0x000000, "Member 'FSpeedRange::Speed' has a wrong offset!");
static_assert(offsetof(FSpeedRange, MinSpeed) == 0x000008, "Member 'FSpeedRange::MinSpeed' has a wrong offset!");
static_assert(offsetof(FSpeedRange, MaxSpeed) == 0x00000C, "Member 'FSpeedRange::MaxSpeed' has a wrong offset!");

// ScriptStruct ReadyOrNot.SubtitleData
// 0x0030 (0x0030 - 0x0000)
struct FSubtitleData final 
{
public:
	class FString                                 Speaker;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpeakerTag;                                        // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialogue;                                          // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2004[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubtitleData) == 0x000008, "Wrong alignment on FSubtitleData");
static_assert(sizeof(FSubtitleData) == 0x000030, "Wrong size on FSubtitleData");
static_assert(offsetof(FSubtitleData, Speaker) == 0x000000, "Member 'FSubtitleData::Speaker' has a wrong offset!");
static_assert(offsetof(FSubtitleData, SpeakerTag) == 0x000010, "Member 'FSubtitleData::SpeakerTag' has a wrong offset!");
static_assert(offsetof(FSubtitleData, Dialogue) == 0x000018, "Member 'FSubtitleData::Dialogue' has a wrong offset!");
static_assert(offsetof(FSubtitleData, Length) == 0x000028, "Member 'FSubtitleData::Length' has a wrong offset!");

// ScriptStruct ReadyOrNot.ClearQueueInfo
// 0x0060 (0x0060 - 0x0000)
struct FClearQueueInfo final 
{
public:
	TMap<class ADoor*, class AThreatAwarenessActor*> Data;                                              // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_2005[0x10];                                    // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClearQueueInfo) == 0x000008, "Wrong alignment on FClearQueueInfo");
static_assert(sizeof(FClearQueueInfo) == 0x000060, "Wrong size on FClearQueueInfo");
static_assert(offsetof(FClearQueueInfo, Data) == 0x000000, "Member 'FClearQueueInfo::Data' has a wrong offset!");

// ScriptStruct ReadyOrNot.TableTennisGame
// 0x0034 (0x0034 - 0x0000)
struct FTableTennisGame final 
{
public:
	float                                         TimeToStart;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameOverPauseTime;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftPaddlePosition;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightPaddlePosition;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BallPosition;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BallVelocity;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeftScore;                                         // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RightScore;                                        // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2006[0xC];                                     // 0x0028(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTableTennisGame) == 0x000004, "Wrong alignment on FTableTennisGame");
static_assert(sizeof(FTableTennisGame) == 0x000034, "Wrong size on FTableTennisGame");
static_assert(offsetof(FTableTennisGame, TimeToStart) == 0x000000, "Member 'FTableTennisGame::TimeToStart' has a wrong offset!");
static_assert(offsetof(FTableTennisGame, GameOverPauseTime) == 0x000004, "Member 'FTableTennisGame::GameOverPauseTime' has a wrong offset!");
static_assert(offsetof(FTableTennisGame, LeftPaddlePosition) == 0x000008, "Member 'FTableTennisGame::LeftPaddlePosition' has a wrong offset!");
static_assert(offsetof(FTableTennisGame, RightPaddlePosition) == 0x00000C, "Member 'FTableTennisGame::RightPaddlePosition' has a wrong offset!");
static_assert(offsetof(FTableTennisGame, BallPosition) == 0x000010, "Member 'FTableTennisGame::BallPosition' has a wrong offset!");
static_assert(offsetof(FTableTennisGame, BallVelocity) == 0x000018, "Member 'FTableTennisGame::BallVelocity' has a wrong offset!");
static_assert(offsetof(FTableTennisGame, LeftScore) == 0x000020, "Member 'FTableTennisGame::LeftScore' has a wrong offset!");
static_assert(offsetof(FTableTennisGame, RightScore) == 0x000024, "Member 'FTableTennisGame::RightScore' has a wrong offset!");

// ScriptStruct ReadyOrNot.TOCData
// 0x0018 (0x0018 - 0x0000)
struct FTOCData final 
{
public:
	class FString                                 TOCLine;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETOCPriority                                  QueuePriority;                                     // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsNetworked : 1;                                  // 0x0011(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2007[0x6];                                     // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTOCData) == 0x000008, "Wrong alignment on FTOCData");
static_assert(sizeof(FTOCData) == 0x000018, "Wrong size on FTOCData");
static_assert(offsetof(FTOCData, TOCLine) == 0x000000, "Member 'FTOCData::TOCLine' has a wrong offset!");
static_assert(offsetof(FTOCData, QueuePriority) == 0x000010, "Member 'FTOCData::QueuePriority' has a wrong offset!");

// ScriptStruct ReadyOrNot.TutorialMissionData
// 0x01A0 (0x01A0 - 0x0000)
struct FTutorialMissionData final 
{
public:
	ETutorialMissionType                          MissionType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnSWATTeam;                                    // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2008[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedLoadout                          Loadout;                                           // 0x0008(0x0188)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 SpawnTag;                                          // 0x0190(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialMissionData) == 0x000008, "Wrong alignment on FTutorialMissionData");
static_assert(sizeof(FTutorialMissionData) == 0x0001A0, "Wrong size on FTutorialMissionData");
static_assert(offsetof(FTutorialMissionData, MissionType) == 0x000000, "Member 'FTutorialMissionData::MissionType' has a wrong offset!");
static_assert(offsetof(FTutorialMissionData, bSpawnSWATTeam) == 0x000001, "Member 'FTutorialMissionData::bSpawnSWATTeam' has a wrong offset!");
static_assert(offsetof(FTutorialMissionData, Loadout) == 0x000008, "Member 'FTutorialMissionData::Loadout' has a wrong offset!");
static_assert(offsetof(FTutorialMissionData, SpawnTag) == 0x000190, "Member 'FTutorialMissionData::SpawnTag' has a wrong offset!");

// ScriptStruct ReadyOrNot.TutorialActionPromptSlot
// 0x0050 (0x0050 - 0x0000)
struct FTutorialActionPromptSlot final 
{
public:
	class FName                                   InputActionName;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   InputEvent;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2009[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ActionText;                                        // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsAxisEvent;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_200A[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KeyIndex;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseCustomActionText : 1;                          // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_200B[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CustomActionPromptText;                            // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialActionPromptSlot) == 0x000008, "Wrong alignment on FTutorialActionPromptSlot");
static_assert(sizeof(FTutorialActionPromptSlot) == 0x000050, "Wrong size on FTutorialActionPromptSlot");
static_assert(offsetof(FTutorialActionPromptSlot, InputActionName) == 0x000000, "Member 'FTutorialActionPromptSlot::InputActionName' has a wrong offset!");
static_assert(offsetof(FTutorialActionPromptSlot, InputEvent) == 0x000008, "Member 'FTutorialActionPromptSlot::InputEvent' has a wrong offset!");
static_assert(offsetof(FTutorialActionPromptSlot, ActionText) == 0x000010, "Member 'FTutorialActionPromptSlot::ActionText' has a wrong offset!");
static_assert(offsetof(FTutorialActionPromptSlot, bIsAxisEvent) == 0x000028, "Member 'FTutorialActionPromptSlot::bIsAxisEvent' has a wrong offset!");
static_assert(offsetof(FTutorialActionPromptSlot, KeyIndex) == 0x00002C, "Member 'FTutorialActionPromptSlot::KeyIndex' has a wrong offset!");
static_assert(offsetof(FTutorialActionPromptSlot, CustomActionPromptText) == 0x000038, "Member 'FTutorialActionPromptSlot::CustomActionPromptText' has a wrong offset!");

// ScriptStruct ReadyOrNot.PromptInfo
// 0x0040 (0x0040 - 0x0000)
struct FPromptInfo final 
{
public:
	ETutorialMessageContext                       PromptContext;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_200C[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   ActionKey;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   InputType;                                         // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_200D[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ActionText;                                        // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPromptInfo) == 0x000008, "Wrong alignment on FPromptInfo");
static_assert(sizeof(FPromptInfo) == 0x000040, "Wrong size on FPromptInfo");
static_assert(offsetof(FPromptInfo, PromptContext) == 0x000000, "Member 'FPromptInfo::PromptContext' has a wrong offset!");
static_assert(offsetof(FPromptInfo, ActionKey) == 0x000008, "Member 'FPromptInfo::ActionKey' has a wrong offset!");
static_assert(offsetof(FPromptInfo, InputType) == 0x000020, "Member 'FPromptInfo::InputType' has a wrong offset!");
static_assert(offsetof(FPromptInfo, ActionText) == 0x000028, "Member 'FPromptInfo::ActionText' has a wrong offset!");

// ScriptStruct ReadyOrNot.AttachmentUIElements
// 0x0078 (0x0078 - 0x0000)
struct FAttachmentUIElements final 
{
public:
	TSoftObjectPtr<class UTexture2D>              ImageOfScope;                                      // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              SightPicture;                                      // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              AttachmentIcon;                                    // 0x0050(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttachmentUIElements) == 0x000008, "Wrong alignment on FAttachmentUIElements");
static_assert(sizeof(FAttachmentUIElements) == 0x000078, "Wrong size on FAttachmentUIElements");
static_assert(offsetof(FAttachmentUIElements, ImageOfScope) == 0x000000, "Member 'FAttachmentUIElements::ImageOfScope' has a wrong offset!");
static_assert(offsetof(FAttachmentUIElements, SightPicture) == 0x000028, "Member 'FAttachmentUIElements::SightPicture' has a wrong offset!");
static_assert(offsetof(FAttachmentUIElements, AttachmentIcon) == 0x000050, "Member 'FAttachmentUIElements::AttachmentIcon' has a wrong offset!");

// ScriptStruct ReadyOrNot.WidgetLookupData
// 0x0028 (0x0030 - 0x0008)
struct FWidgetLookupData final  : public FTableRowBase
{
public:
	TSubclassOf<class UUserWidget>                WidgetClass;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMouseCursor;                                  // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMouseUIOnly;                                      // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToWidgetStack;                                 // 0x0022(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCloseOnRespawn;                                   // 0x0023(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              VisibilityUponCreation;                            // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_200E[0x3];                                     // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ZOrder;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_200F[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWidgetLookupData) == 0x000008, "Wrong alignment on FWidgetLookupData");
static_assert(sizeof(FWidgetLookupData) == 0x000030, "Wrong size on FWidgetLookupData");
static_assert(offsetof(FWidgetLookupData, WidgetClass) == 0x000008, "Member 'FWidgetLookupData::WidgetClass' has a wrong offset!");
static_assert(offsetof(FWidgetLookupData, Description) == 0x000010, "Member 'FWidgetLookupData::Description' has a wrong offset!");
static_assert(offsetof(FWidgetLookupData, bShowMouseCursor) == 0x000020, "Member 'FWidgetLookupData::bShowMouseCursor' has a wrong offset!");
static_assert(offsetof(FWidgetLookupData, bMouseUIOnly) == 0x000021, "Member 'FWidgetLookupData::bMouseUIOnly' has a wrong offset!");
static_assert(offsetof(FWidgetLookupData, bAddToWidgetStack) == 0x000022, "Member 'FWidgetLookupData::bAddToWidgetStack' has a wrong offset!");
static_assert(offsetof(FWidgetLookupData, bCloseOnRespawn) == 0x000023, "Member 'FWidgetLookupData::bCloseOnRespawn' has a wrong offset!");
static_assert(offsetof(FWidgetLookupData, VisibilityUponCreation) == 0x000024, "Member 'FWidgetLookupData::VisibilityUponCreation' has a wrong offset!");
static_assert(offsetof(FWidgetLookupData, ZOrder) == 0x000028, "Member 'FWidgetLookupData::ZOrder' has a wrong offset!");

// ScriptStruct ReadyOrNot.SavedRoomData
// 0x0050 (0x0050 - 0x0000)
struct FSavedRoomData final 
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             Location;                                          // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RootDoorID;                                        // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Threats;                                           // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        AdditionalRootDoors;                               // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ConnectingRooms;                                   // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedRoomData) == 0x000008, "Wrong alignment on FSavedRoomData");
static_assert(sizeof(FSavedRoomData) == 0x000050, "Wrong size on FSavedRoomData");
static_assert(offsetof(FSavedRoomData, Name) == 0x000000, "Member 'FSavedRoomData::Name' has a wrong offset!");
static_assert(offsetof(FSavedRoomData, Location) == 0x000008, "Member 'FSavedRoomData::Location' has a wrong offset!");
static_assert(offsetof(FSavedRoomData, RootDoorID) == 0x000014, "Member 'FSavedRoomData::RootDoorID' has a wrong offset!");
static_assert(offsetof(FSavedRoomData, Threats) == 0x000020, "Member 'FSavedRoomData::Threats' has a wrong offset!");
static_assert(offsetof(FSavedRoomData, AdditionalRootDoors) == 0x000030, "Member 'FSavedRoomData::AdditionalRootDoors' has a wrong offset!");
static_assert(offsetof(FSavedRoomData, ConnectingRooms) == 0x000040, "Member 'FSavedRoomData::ConnectingRooms' has a wrong offset!");

// ScriptStruct ReadyOrNot.SavedCoverActor
// 0x00D0 (0x00D0 - 0x0000)
struct FSavedCoverActor final 
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 CoverObjectName;                                   // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCoverRail                             CoverRail;                                         // 0x0050(0x0038)(NativeAccessSpecifierPublic)
	EStandCoverType                               StandCoverType;                                    // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrouchCoverType                              CrouchCoverType;                                   // 0x0089(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2010[0x2];                                     // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoverDirection                        StandCoverDirection;                               // 0x008C(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCoverDirection                        CrouchCoverDirection;                              // 0x00A4(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCrouchOnlyCover;                                // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCoverType;                                // 0x00C1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2011[0xE];                                     // 0x00C2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSavedCoverActor) == 0x000010, "Wrong alignment on FSavedCoverActor");
static_assert(sizeof(FSavedCoverActor) == 0x0000D0, "Wrong size on FSavedCoverActor");
static_assert(offsetof(FSavedCoverActor, Name) == 0x000000, "Member 'FSavedCoverActor::Name' has a wrong offset!");
static_assert(offsetof(FSavedCoverActor, Transform) == 0x000010, "Member 'FSavedCoverActor::Transform' has a wrong offset!");
static_assert(offsetof(FSavedCoverActor, CoverObjectName) == 0x000040, "Member 'FSavedCoverActor::CoverObjectName' has a wrong offset!");
static_assert(offsetof(FSavedCoverActor, CoverRail) == 0x000050, "Member 'FSavedCoverActor::CoverRail' has a wrong offset!");
static_assert(offsetof(FSavedCoverActor, StandCoverType) == 0x000088, "Member 'FSavedCoverActor::StandCoverType' has a wrong offset!");
static_assert(offsetof(FSavedCoverActor, CrouchCoverType) == 0x000089, "Member 'FSavedCoverActor::CrouchCoverType' has a wrong offset!");
static_assert(offsetof(FSavedCoverActor, StandCoverDirection) == 0x00008C, "Member 'FSavedCoverActor::StandCoverDirection' has a wrong offset!");
static_assert(offsetof(FSavedCoverActor, CrouchCoverDirection) == 0x0000A4, "Member 'FSavedCoverActor::CrouchCoverDirection' has a wrong offset!");
static_assert(offsetof(FSavedCoverActor, Index) == 0x0000BC, "Member 'FSavedCoverActor::Index' has a wrong offset!");
static_assert(offsetof(FSavedCoverActor, bIsCrouchOnlyCover) == 0x0000C0, "Member 'FSavedCoverActor::bIsCrouchOnlyCover' has a wrong offset!");
static_assert(offsetof(FSavedCoverActor, bOverrideCoverType) == 0x0000C1, "Member 'FSavedCoverActor::bOverrideCoverType' has a wrong offset!");

}

